(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all3) => {
    for (var name2 in all3)
      __defProp(target, name2, { get: all3[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/he/he.js
  var require_he = __commonJS({
    "node_modules/he/he.js"(exports3, module) {
      (function(root2) {
        var freeExports = typeof exports3 == "object" && exports3;
        var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
        var freeGlobal = typeof globalThis == "object" && globalThis;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
          root2 = freeGlobal;
        }
        var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var regexAsciiWhitelist = /[\x01-\x7F]/g;
        var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
        var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
        var encodeMap = { "\xAD": "shy", "\u200C": "zwnj", "\u200D": "zwj", "\u200E": "lrm", "\u2063": "ic", "\u2062": "it", "\u2061": "af", "\u200F": "rlm", "\u200B": "ZeroWidthSpace", "\u2060": "NoBreak", "\u0311": "DownBreve", "\u20DB": "tdot", "\u20DC": "DotDot", "	": "Tab", "\n": "NewLine", "\u2008": "puncsp", "\u205F": "MediumSpace", "\u2009": "thinsp", "\u200A": "hairsp", "\u2004": "emsp13", "\u2002": "ensp", "\u2005": "emsp14", "\u2003": "emsp", "\u2007": "numsp", "\xA0": "nbsp", "\u205F\u200A": "ThickSpace", "\u203E": "oline", "_": "lowbar", "\u2010": "dash", "\u2013": "ndash", "\u2014": "mdash", "\u2015": "horbar", ",": "comma", ";": "semi", "\u204F": "bsemi", ":": "colon", "\u2A74": "Colone", "!": "excl", "\xA1": "iexcl", "?": "quest", "\xBF": "iquest", ".": "period", "\u2025": "nldr", "\u2026": "mldr", "\xB7": "middot", "'": "apos", "\u2018": "lsquo", "\u2019": "rsquo", "\u201A": "sbquo", "\u2039": "lsaquo", "\u203A": "rsaquo", '"': "quot", "\u201C": "ldquo", "\u201D": "rdquo", "\u201E": "bdquo", "\xAB": "laquo", "\xBB": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "\u2308": "lceil", "\u2309": "rceil", "\u230A": "lfloor", "\u230B": "rfloor", "\u2985": "lopar", "\u2986": "ropar", "\u298B": "lbrke", "\u298C": "rbrke", "\u298D": "lbrkslu", "\u298E": "rbrksld", "\u298F": "lbrksld", "\u2990": "rbrkslu", "\u2991": "langd", "\u2992": "rangd", "\u2993": "lparlt", "\u2994": "rpargt", "\u2995": "gtlPar", "\u2996": "ltrPar", "\u27E6": "lobrk", "\u27E7": "robrk", "\u27E8": "lang", "\u27E9": "rang", "\u27EA": "Lang", "\u27EB": "Rang", "\u27EC": "loang", "\u27ED": "roang", "\u2772": "lbbrk", "\u2773": "rbbrk", "\u2016": "Vert", "\xA7": "sect", "\xB6": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "\u2030": "permil", "\u2031": "pertenk", "\u2020": "dagger", "\u2021": "Dagger", "\u2022": "bull", "\u2043": "hybull", "\u2032": "prime", "\u2033": "Prime", "\u2034": "tprime", "\u2057": "qprime", "\u2035": "bprime", "\u2041": "caret", "`": "grave", "\xB4": "acute", "\u02DC": "tilde", "^": "Hat", "\xAF": "macr", "\u02D8": "breve", "\u02D9": "dot", "\xA8": "die", "\u02DA": "ring", "\u02DD": "dblac", "\xB8": "cedil", "\u02DB": "ogon", "\u02C6": "circ", "\u02C7": "caron", "\xB0": "deg", "\xA9": "copy", "\xAE": "reg", "\u2117": "copysr", "\u2118": "wp", "\u211E": "rx", "\u2127": "mho", "\u2129": "iiota", "\u2190": "larr", "\u219A": "nlarr", "\u2192": "rarr", "\u219B": "nrarr", "\u2191": "uarr", "\u2193": "darr", "\u2194": "harr", "\u21AE": "nharr", "\u2195": "varr", "\u2196": "nwarr", "\u2197": "nearr", "\u2198": "searr", "\u2199": "swarr", "\u219D": "rarrw", "\u219D\u0338": "nrarrw", "\u219E": "Larr", "\u219F": "Uarr", "\u21A0": "Rarr", "\u21A1": "Darr", "\u21A2": "larrtl", "\u21A3": "rarrtl", "\u21A4": "mapstoleft", "\u21A5": "mapstoup", "\u21A6": "map", "\u21A7": "mapstodown", "\u21A9": "larrhk", "\u21AA": "rarrhk", "\u21AB": "larrlp", "\u21AC": "rarrlp", "\u21AD": "harrw", "\u21B0": "lsh", "\u21B1": "rsh", "\u21B2": "ldsh", "\u21B3": "rdsh", "\u21B5": "crarr", "\u21B6": "cularr", "\u21B7": "curarr", "\u21BA": "olarr", "\u21BB": "orarr", "\u21BC": "lharu", "\u21BD": "lhard", "\u21BE": "uharr", "\u21BF": "uharl", "\u21C0": "rharu", "\u21C1": "rhard", "\u21C2": "dharr", "\u21C3": "dharl", "\u21C4": "rlarr", "\u21C5": "udarr", "\u21C6": "lrarr", "\u21C7": "llarr", "\u21C8": "uuarr", "\u21C9": "rrarr", "\u21CA": "ddarr", "\u21CB": "lrhar", "\u21CC": "rlhar", "\u21D0": "lArr", "\u21CD": "nlArr", "\u21D1": "uArr", "\u21D2": "rArr", "\u21CF": "nrArr", "\u21D3": "dArr", "\u21D4": "iff", "\u21CE": "nhArr", "\u21D5": "vArr", "\u21D6": "nwArr", "\u21D7": "neArr", "\u21D8": "seArr", "\u21D9": "swArr", "\u21DA": "lAarr", "\u21DB": "rAarr", "\u21DD": "zigrarr", "\u21E4": "larrb", "\u21E5": "rarrb", "\u21F5": "duarr", "\u21FD": "loarr", "\u21FE": "roarr", "\u21FF": "hoarr", "\u2200": "forall", "\u2201": "comp", "\u2202": "part", "\u2202\u0338": "npart", "\u2203": "exist", "\u2204": "nexist", "\u2205": "empty", "\u2207": "Del", "\u2208": "in", "\u2209": "notin", "\u220B": "ni", "\u220C": "notni", "\u03F6": "bepsi", "\u220F": "prod", "\u2210": "coprod", "\u2211": "sum", "+": "plus", "\xB1": "pm", "\xF7": "div", "\xD7": "times", "<": "lt", "\u226E": "nlt", "<\u20D2": "nvlt", "=": "equals", "\u2260": "ne", "=\u20E5": "bne", "\u2A75": "Equal", ">": "gt", "\u226F": "ngt", ">\u20D2": "nvgt", "\xAC": "not", "|": "vert", "\xA6": "brvbar", "\u2212": "minus", "\u2213": "mp", "\u2214": "plusdo", "\u2044": "frasl", "\u2216": "setmn", "\u2217": "lowast", "\u2218": "compfn", "\u221A": "Sqrt", "\u221D": "prop", "\u221E": "infin", "\u221F": "angrt", "\u2220": "ang", "\u2220\u20D2": "nang", "\u2221": "angmsd", "\u2222": "angsph", "\u2223": "mid", "\u2224": "nmid", "\u2225": "par", "\u2226": "npar", "\u2227": "and", "\u2228": "or", "\u2229": "cap", "\u2229\uFE00": "caps", "\u222A": "cup", "\u222A\uFE00": "cups", "\u222B": "int", "\u222C": "Int", "\u222D": "tint", "\u2A0C": "qint", "\u222E": "oint", "\u222F": "Conint", "\u2230": "Cconint", "\u2231": "cwint", "\u2232": "cwconint", "\u2233": "awconint", "\u2234": "there4", "\u2235": "becaus", "\u2236": "ratio", "\u2237": "Colon", "\u2238": "minusd", "\u223A": "mDDot", "\u223B": "homtht", "\u223C": "sim", "\u2241": "nsim", "\u223C\u20D2": "nvsim", "\u223D": "bsim", "\u223D\u0331": "race", "\u223E": "ac", "\u223E\u0333": "acE", "\u223F": "acd", "\u2240": "wr", "\u2242": "esim", "\u2242\u0338": "nesim", "\u2243": "sime", "\u2244": "nsime", "\u2245": "cong", "\u2247": "ncong", "\u2246": "simne", "\u2248": "ap", "\u2249": "nap", "\u224A": "ape", "\u224B": "apid", "\u224B\u0338": "napid", "\u224C": "bcong", "\u224D": "CupCap", "\u226D": "NotCupCap", "\u224D\u20D2": "nvap", "\u224E": "bump", "\u224E\u0338": "nbump", "\u224F": "bumpe", "\u224F\u0338": "nbumpe", "\u2250": "doteq", "\u2250\u0338": "nedot", "\u2251": "eDot", "\u2252": "efDot", "\u2253": "erDot", "\u2254": "colone", "\u2255": "ecolon", "\u2256": "ecir", "\u2257": "cire", "\u2259": "wedgeq", "\u225A": "veeeq", "\u225C": "trie", "\u225F": "equest", "\u2261": "equiv", "\u2262": "nequiv", "\u2261\u20E5": "bnequiv", "\u2264": "le", "\u2270": "nle", "\u2264\u20D2": "nvle", "\u2265": "ge", "\u2271": "nge", "\u2265\u20D2": "nvge", "\u2266": "lE", "\u2266\u0338": "nlE", "\u2267": "gE", "\u2267\u0338": "ngE", "\u2268\uFE00": "lvnE", "\u2268": "lnE", "\u2269": "gnE", "\u2269\uFE00": "gvnE", "\u226A": "ll", "\u226A\u0338": "nLtv", "\u226A\u20D2": "nLt", "\u226B": "gg", "\u226B\u0338": "nGtv", "\u226B\u20D2": "nGt", "\u226C": "twixt", "\u2272": "lsim", "\u2274": "nlsim", "\u2273": "gsim", "\u2275": "ngsim", "\u2276": "lg", "\u2278": "ntlg", "\u2277": "gl", "\u2279": "ntgl", "\u227A": "pr", "\u2280": "npr", "\u227B": "sc", "\u2281": "nsc", "\u227C": "prcue", "\u22E0": "nprcue", "\u227D": "sccue", "\u22E1": "nsccue", "\u227E": "prsim", "\u227F": "scsim", "\u227F\u0338": "NotSucceedsTilde", "\u2282": "sub", "\u2284": "nsub", "\u2282\u20D2": "vnsub", "\u2283": "sup", "\u2285": "nsup", "\u2283\u20D2": "vnsup", "\u2286": "sube", "\u2288": "nsube", "\u2287": "supe", "\u2289": "nsupe", "\u228A\uFE00": "vsubne", "\u228A": "subne", "\u228B\uFE00": "vsupne", "\u228B": "supne", "\u228D": "cupdot", "\u228E": "uplus", "\u228F": "sqsub", "\u228F\u0338": "NotSquareSubset", "\u2290": "sqsup", "\u2290\u0338": "NotSquareSuperset", "\u2291": "sqsube", "\u22E2": "nsqsube", "\u2292": "sqsupe", "\u22E3": "nsqsupe", "\u2293": "sqcap", "\u2293\uFE00": "sqcaps", "\u2294": "sqcup", "\u2294\uFE00": "sqcups", "\u2295": "oplus", "\u2296": "ominus", "\u2297": "otimes", "\u2298": "osol", "\u2299": "odot", "\u229A": "ocir", "\u229B": "oast", "\u229D": "odash", "\u229E": "plusb", "\u229F": "minusb", "\u22A0": "timesb", "\u22A1": "sdotb", "\u22A2": "vdash", "\u22AC": "nvdash", "\u22A3": "dashv", "\u22A4": "top", "\u22A5": "bot", "\u22A7": "models", "\u22A8": "vDash", "\u22AD": "nvDash", "\u22A9": "Vdash", "\u22AE": "nVdash", "\u22AA": "Vvdash", "\u22AB": "VDash", "\u22AF": "nVDash", "\u22B0": "prurel", "\u22B2": "vltri", "\u22EA": "nltri", "\u22B3": "vrtri", "\u22EB": "nrtri", "\u22B4": "ltrie", "\u22EC": "nltrie", "\u22B4\u20D2": "nvltrie", "\u22B5": "rtrie", "\u22ED": "nrtrie", "\u22B5\u20D2": "nvrtrie", "\u22B6": "origof", "\u22B7": "imof", "\u22B8": "mumap", "\u22B9": "hercon", "\u22BA": "intcal", "\u22BB": "veebar", "\u22BD": "barvee", "\u22BE": "angrtvb", "\u22BF": "lrtri", "\u22C0": "Wedge", "\u22C1": "Vee", "\u22C2": "xcap", "\u22C3": "xcup", "\u22C4": "diam", "\u22C5": "sdot", "\u22C6": "Star", "\u22C7": "divonx", "\u22C8": "bowtie", "\u22C9": "ltimes", "\u22CA": "rtimes", "\u22CB": "lthree", "\u22CC": "rthree", "\u22CD": "bsime", "\u22CE": "cuvee", "\u22CF": "cuwed", "\u22D0": "Sub", "\u22D1": "Sup", "\u22D2": "Cap", "\u22D3": "Cup", "\u22D4": "fork", "\u22D5": "epar", "\u22D6": "ltdot", "\u22D7": "gtdot", "\u22D8": "Ll", "\u22D8\u0338": "nLl", "\u22D9": "Gg", "\u22D9\u0338": "nGg", "\u22DA\uFE00": "lesg", "\u22DA": "leg", "\u22DB": "gel", "\u22DB\uFE00": "gesl", "\u22DE": "cuepr", "\u22DF": "cuesc", "\u22E6": "lnsim", "\u22E7": "gnsim", "\u22E8": "prnsim", "\u22E9": "scnsim", "\u22EE": "vellip", "\u22EF": "ctdot", "\u22F0": "utdot", "\u22F1": "dtdot", "\u22F2": "disin", "\u22F3": "isinsv", "\u22F4": "isins", "\u22F5": "isindot", "\u22F5\u0338": "notindot", "\u22F6": "notinvc", "\u22F7": "notinvb", "\u22F9": "isinE", "\u22F9\u0338": "notinE", "\u22FA": "nisd", "\u22FB": "xnis", "\u22FC": "nis", "\u22FD": "notnivc", "\u22FE": "notnivb", "\u2305": "barwed", "\u2306": "Barwed", "\u230C": "drcrop", "\u230D": "dlcrop", "\u230E": "urcrop", "\u230F": "ulcrop", "\u2310": "bnot", "\u2312": "profline", "\u2313": "profsurf", "\u2315": "telrec", "\u2316": "target", "\u231C": "ulcorn", "\u231D": "urcorn", "\u231E": "dlcorn", "\u231F": "drcorn", "\u2322": "frown", "\u2323": "smile", "\u232D": "cylcty", "\u232E": "profalar", "\u2336": "topbot", "\u233D": "ovbar", "\u233F": "solbar", "\u237C": "angzarr", "\u23B0": "lmoust", "\u23B1": "rmoust", "\u23B4": "tbrk", "\u23B5": "bbrk", "\u23B6": "bbrktbrk", "\u23DC": "OverParenthesis", "\u23DD": "UnderParenthesis", "\u23DE": "OverBrace", "\u23DF": "UnderBrace", "\u23E2": "trpezium", "\u23E7": "elinters", "\u2423": "blank", "\u2500": "boxh", "\u2502": "boxv", "\u250C": "boxdr", "\u2510": "boxdl", "\u2514": "boxur", "\u2518": "boxul", "\u251C": "boxvr", "\u2524": "boxvl", "\u252C": "boxhd", "\u2534": "boxhu", "\u253C": "boxvh", "\u2550": "boxH", "\u2551": "boxV", "\u2552": "boxdR", "\u2553": "boxDr", "\u2554": "boxDR", "\u2555": "boxdL", "\u2556": "boxDl", "\u2557": "boxDL", "\u2558": "boxuR", "\u2559": "boxUr", "\u255A": "boxUR", "\u255B": "boxuL", "\u255C": "boxUl", "\u255D": "boxUL", "\u255E": "boxvR", "\u255F": "boxVr", "\u2560": "boxVR", "\u2561": "boxvL", "\u2562": "boxVl", "\u2563": "boxVL", "\u2564": "boxHd", "\u2565": "boxhD", "\u2566": "boxHD", "\u2567": "boxHu", "\u2568": "boxhU", "\u2569": "boxHU", "\u256A": "boxvH", "\u256B": "boxVh", "\u256C": "boxVH", "\u2580": "uhblk", "\u2584": "lhblk", "\u2588": "block", "\u2591": "blk14", "\u2592": "blk12", "\u2593": "blk34", "\u25A1": "squ", "\u25AA": "squf", "\u25AB": "EmptyVerySmallSquare", "\u25AD": "rect", "\u25AE": "marker", "\u25B1": "fltns", "\u25B3": "xutri", "\u25B4": "utrif", "\u25B5": "utri", "\u25B8": "rtrif", "\u25B9": "rtri", "\u25BD": "xdtri", "\u25BE": "dtrif", "\u25BF": "dtri", "\u25C2": "ltrif", "\u25C3": "ltri", "\u25CA": "loz", "\u25CB": "cir", "\u25EC": "tridot", "\u25EF": "xcirc", "\u25F8": "ultri", "\u25F9": "urtri", "\u25FA": "lltri", "\u25FB": "EmptySmallSquare", "\u25FC": "FilledSmallSquare", "\u2605": "starf", "\u2606": "star", "\u260E": "phone", "\u2640": "female", "\u2642": "male", "\u2660": "spades", "\u2663": "clubs", "\u2665": "hearts", "\u2666": "diams", "\u266A": "sung", "\u2713": "check", "\u2717": "cross", "\u2720": "malt", "\u2736": "sext", "\u2758": "VerticalSeparator", "\u27C8": "bsolhsub", "\u27C9": "suphsol", "\u27F5": "xlarr", "\u27F6": "xrarr", "\u27F7": "xharr", "\u27F8": "xlArr", "\u27F9": "xrArr", "\u27FA": "xhArr", "\u27FC": "xmap", "\u27FF": "dzigrarr", "\u2902": "nvlArr", "\u2903": "nvrArr", "\u2904": "nvHarr", "\u2905": "Map", "\u290C": "lbarr", "\u290D": "rbarr", "\u290E": "lBarr", "\u290F": "rBarr", "\u2910": "RBarr", "\u2911": "DDotrahd", "\u2912": "UpArrowBar", "\u2913": "DownArrowBar", "\u2916": "Rarrtl", "\u2919": "latail", "\u291A": "ratail", "\u291B": "lAtail", "\u291C": "rAtail", "\u291D": "larrfs", "\u291E": "rarrfs", "\u291F": "larrbfs", "\u2920": "rarrbfs", "\u2923": "nwarhk", "\u2924": "nearhk", "\u2925": "searhk", "\u2926": "swarhk", "\u2927": "nwnear", "\u2928": "toea", "\u2929": "tosa", "\u292A": "swnwar", "\u2933": "rarrc", "\u2933\u0338": "nrarrc", "\u2935": "cudarrr", "\u2936": "ldca", "\u2937": "rdca", "\u2938": "cudarrl", "\u2939": "larrpl", "\u293C": "curarrm", "\u293D": "cularrp", "\u2945": "rarrpl", "\u2948": "harrcir", "\u2949": "Uarrocir", "\u294A": "lurdshar", "\u294B": "ldrushar", "\u294E": "LeftRightVector", "\u294F": "RightUpDownVector", "\u2950": "DownLeftRightVector", "\u2951": "LeftUpDownVector", "\u2952": "LeftVectorBar", "\u2953": "RightVectorBar", "\u2954": "RightUpVectorBar", "\u2955": "RightDownVectorBar", "\u2956": "DownLeftVectorBar", "\u2957": "DownRightVectorBar", "\u2958": "LeftUpVectorBar", "\u2959": "LeftDownVectorBar", "\u295A": "LeftTeeVector", "\u295B": "RightTeeVector", "\u295C": "RightUpTeeVector", "\u295D": "RightDownTeeVector", "\u295E": "DownLeftTeeVector", "\u295F": "DownRightTeeVector", "\u2960": "LeftUpTeeVector", "\u2961": "LeftDownTeeVector", "\u2962": "lHar", "\u2963": "uHar", "\u2964": "rHar", "\u2965": "dHar", "\u2966": "luruhar", "\u2967": "ldrdhar", "\u2968": "ruluhar", "\u2969": "rdldhar", "\u296A": "lharul", "\u296B": "llhard", "\u296C": "rharul", "\u296D": "lrhard", "\u296E": "udhar", "\u296F": "duhar", "\u2970": "RoundImplies", "\u2971": "erarr", "\u2972": "simrarr", "\u2973": "larrsim", "\u2974": "rarrsim", "\u2975": "rarrap", "\u2976": "ltlarr", "\u2978": "gtrarr", "\u2979": "subrarr", "\u297B": "suplarr", "\u297C": "lfisht", "\u297D": "rfisht", "\u297E": "ufisht", "\u297F": "dfisht", "\u299A": "vzigzag", "\u299C": "vangrt", "\u299D": "angrtvbd", "\u29A4": "ange", "\u29A5": "range", "\u29A6": "dwangle", "\u29A7": "uwangle", "\u29A8": "angmsdaa", "\u29A9": "angmsdab", "\u29AA": "angmsdac", "\u29AB": "angmsdad", "\u29AC": "angmsdae", "\u29AD": "angmsdaf", "\u29AE": "angmsdag", "\u29AF": "angmsdah", "\u29B0": "bemptyv", "\u29B1": "demptyv", "\u29B2": "cemptyv", "\u29B3": "raemptyv", "\u29B4": "laemptyv", "\u29B5": "ohbar", "\u29B6": "omid", "\u29B7": "opar", "\u29B9": "operp", "\u29BB": "olcross", "\u29BC": "odsold", "\u29BE": "olcir", "\u29BF": "ofcir", "\u29C0": "olt", "\u29C1": "ogt", "\u29C2": "cirscir", "\u29C3": "cirE", "\u29C4": "solb", "\u29C5": "bsolb", "\u29C9": "boxbox", "\u29CD": "trisb", "\u29CE": "rtriltri", "\u29CF": "LeftTriangleBar", "\u29CF\u0338": "NotLeftTriangleBar", "\u29D0": "RightTriangleBar", "\u29D0\u0338": "NotRightTriangleBar", "\u29DC": "iinfin", "\u29DD": "infintie", "\u29DE": "nvinfin", "\u29E3": "eparsl", "\u29E4": "smeparsl", "\u29E5": "eqvparsl", "\u29EB": "lozf", "\u29F4": "RuleDelayed", "\u29F6": "dsol", "\u2A00": "xodot", "\u2A01": "xoplus", "\u2A02": "xotime", "\u2A04": "xuplus", "\u2A06": "xsqcup", "\u2A0D": "fpartint", "\u2A10": "cirfnint", "\u2A11": "awint", "\u2A12": "rppolint", "\u2A13": "scpolint", "\u2A14": "npolint", "\u2A15": "pointint", "\u2A16": "quatint", "\u2A17": "intlarhk", "\u2A22": "pluscir", "\u2A23": "plusacir", "\u2A24": "simplus", "\u2A25": "plusdu", "\u2A26": "plussim", "\u2A27": "plustwo", "\u2A29": "mcomma", "\u2A2A": "minusdu", "\u2A2D": "loplus", "\u2A2E": "roplus", "\u2A2F": "Cross", "\u2A30": "timesd", "\u2A31": "timesbar", "\u2A33": "smashp", "\u2A34": "lotimes", "\u2A35": "rotimes", "\u2A36": "otimesas", "\u2A37": "Otimes", "\u2A38": "odiv", "\u2A39": "triplus", "\u2A3A": "triminus", "\u2A3B": "tritime", "\u2A3C": "iprod", "\u2A3F": "amalg", "\u2A40": "capdot", "\u2A42": "ncup", "\u2A43": "ncap", "\u2A44": "capand", "\u2A45": "cupor", "\u2A46": "cupcap", "\u2A47": "capcup", "\u2A48": "cupbrcap", "\u2A49": "capbrcup", "\u2A4A": "cupcup", "\u2A4B": "capcap", "\u2A4C": "ccups", "\u2A4D": "ccaps", "\u2A50": "ccupssm", "\u2A53": "And", "\u2A54": "Or", "\u2A55": "andand", "\u2A56": "oror", "\u2A57": "orslope", "\u2A58": "andslope", "\u2A5A": "andv", "\u2A5B": "orv", "\u2A5C": "andd", "\u2A5D": "ord", "\u2A5F": "wedbar", "\u2A66": "sdote", "\u2A6A": "simdot", "\u2A6D": "congdot", "\u2A6D\u0338": "ncongdot", "\u2A6E": "easter", "\u2A6F": "apacir", "\u2A70": "apE", "\u2A70\u0338": "napE", "\u2A71": "eplus", "\u2A72": "pluse", "\u2A73": "Esim", "\u2A77": "eDDot", "\u2A78": "equivDD", "\u2A79": "ltcir", "\u2A7A": "gtcir", "\u2A7B": "ltquest", "\u2A7C": "gtquest", "\u2A7D": "les", "\u2A7D\u0338": "nles", "\u2A7E": "ges", "\u2A7E\u0338": "nges", "\u2A7F": "lesdot", "\u2A80": "gesdot", "\u2A81": "lesdoto", "\u2A82": "gesdoto", "\u2A83": "lesdotor", "\u2A84": "gesdotol", "\u2A85": "lap", "\u2A86": "gap", "\u2A87": "lne", "\u2A88": "gne", "\u2A89": "lnap", "\u2A8A": "gnap", "\u2A8B": "lEg", "\u2A8C": "gEl", "\u2A8D": "lsime", "\u2A8E": "gsime", "\u2A8F": "lsimg", "\u2A90": "gsiml", "\u2A91": "lgE", "\u2A92": "glE", "\u2A93": "lesges", "\u2A94": "gesles", "\u2A95": "els", "\u2A96": "egs", "\u2A97": "elsdot", "\u2A98": "egsdot", "\u2A99": "el", "\u2A9A": "eg", "\u2A9D": "siml", "\u2A9E": "simg", "\u2A9F": "simlE", "\u2AA0": "simgE", "\u2AA1": "LessLess", "\u2AA1\u0338": "NotNestedLessLess", "\u2AA2": "GreaterGreater", "\u2AA2\u0338": "NotNestedGreaterGreater", "\u2AA4": "glj", "\u2AA5": "gla", "\u2AA6": "ltcc", "\u2AA7": "gtcc", "\u2AA8": "lescc", "\u2AA9": "gescc", "\u2AAA": "smt", "\u2AAB": "lat", "\u2AAC": "smte", "\u2AAC\uFE00": "smtes", "\u2AAD": "late", "\u2AAD\uFE00": "lates", "\u2AAE": "bumpE", "\u2AAF": "pre", "\u2AAF\u0338": "npre", "\u2AB0": "sce", "\u2AB0\u0338": "nsce", "\u2AB3": "prE", "\u2AB4": "scE", "\u2AB5": "prnE", "\u2AB6": "scnE", "\u2AB7": "prap", "\u2AB8": "scap", "\u2AB9": "prnap", "\u2ABA": "scnap", "\u2ABB": "Pr", "\u2ABC": "Sc", "\u2ABD": "subdot", "\u2ABE": "supdot", "\u2ABF": "subplus", "\u2AC0": "supplus", "\u2AC1": "submult", "\u2AC2": "supmult", "\u2AC3": "subedot", "\u2AC4": "supedot", "\u2AC5": "subE", "\u2AC5\u0338": "nsubE", "\u2AC6": "supE", "\u2AC6\u0338": "nsupE", "\u2AC7": "subsim", "\u2AC8": "supsim", "\u2ACB\uFE00": "vsubnE", "\u2ACB": "subnE", "\u2ACC\uFE00": "vsupnE", "\u2ACC": "supnE", "\u2ACF": "csub", "\u2AD0": "csup", "\u2AD1": "csube", "\u2AD2": "csupe", "\u2AD3": "subsup", "\u2AD4": "supsub", "\u2AD5": "subsub", "\u2AD6": "supsup", "\u2AD7": "suphsub", "\u2AD8": "supdsub", "\u2AD9": "forkv", "\u2ADA": "topfork", "\u2ADB": "mlcp", "\u2AE4": "Dashv", "\u2AE6": "Vdashl", "\u2AE7": "Barv", "\u2AE8": "vBar", "\u2AE9": "vBarv", "\u2AEB": "Vbar", "\u2AEC": "Not", "\u2AED": "bNot", "\u2AEE": "rnmid", "\u2AEF": "cirmid", "\u2AF0": "midcir", "\u2AF1": "topcir", "\u2AF2": "nhpar", "\u2AF3": "parsim", "\u2AFD": "parsl", "\u2AFD\u20E5": "nparsl", "\u266D": "flat", "\u266E": "natur", "\u266F": "sharp", "\xA4": "curren", "\xA2": "cent", "$": "dollar", "\xA3": "pound", "\xA5": "yen", "\u20AC": "euro", "\xB9": "sup1", "\xBD": "half", "\u2153": "frac13", "\xBC": "frac14", "\u2155": "frac15", "\u2159": "frac16", "\u215B": "frac18", "\xB2": "sup2", "\u2154": "frac23", "\u2156": "frac25", "\xB3": "sup3", "\xBE": "frac34", "\u2157": "frac35", "\u215C": "frac38", "\u2158": "frac45", "\u215A": "frac56", "\u215D": "frac58", "\u215E": "frac78", "\u{1D4B6}": "ascr", "\u{1D552}": "aopf", "\u{1D51E}": "afr", "\u{1D538}": "Aopf", "\u{1D504}": "Afr", "\u{1D49C}": "Ascr", "\xAA": "ordf", "\xE1": "aacute", "\xC1": "Aacute", "\xE0": "agrave", "\xC0": "Agrave", "\u0103": "abreve", "\u0102": "Abreve", "\xE2": "acirc", "\xC2": "Acirc", "\xE5": "aring", "\xC5": "angst", "\xE4": "auml", "\xC4": "Auml", "\xE3": "atilde", "\xC3": "Atilde", "\u0105": "aogon", "\u0104": "Aogon", "\u0101": "amacr", "\u0100": "Amacr", "\xE6": "aelig", "\xC6": "AElig", "\u{1D4B7}": "bscr", "\u{1D553}": "bopf", "\u{1D51F}": "bfr", "\u{1D539}": "Bopf", "\u212C": "Bscr", "\u{1D505}": "Bfr", "\u{1D520}": "cfr", "\u{1D4B8}": "cscr", "\u{1D554}": "copf", "\u212D": "Cfr", "\u{1D49E}": "Cscr", "\u2102": "Copf", "\u0107": "cacute", "\u0106": "Cacute", "\u0109": "ccirc", "\u0108": "Ccirc", "\u010D": "ccaron", "\u010C": "Ccaron", "\u010B": "cdot", "\u010A": "Cdot", "\xE7": "ccedil", "\xC7": "Ccedil", "\u2105": "incare", "\u{1D521}": "dfr", "\u2146": "dd", "\u{1D555}": "dopf", "\u{1D4B9}": "dscr", "\u{1D49F}": "Dscr", "\u{1D507}": "Dfr", "\u2145": "DD", "\u{1D53B}": "Dopf", "\u010F": "dcaron", "\u010E": "Dcaron", "\u0111": "dstrok", "\u0110": "Dstrok", "\xF0": "eth", "\xD0": "ETH", "\u2147": "ee", "\u212F": "escr", "\u{1D522}": "efr", "\u{1D556}": "eopf", "\u2130": "Escr", "\u{1D508}": "Efr", "\u{1D53C}": "Eopf", "\xE9": "eacute", "\xC9": "Eacute", "\xE8": "egrave", "\xC8": "Egrave", "\xEA": "ecirc", "\xCA": "Ecirc", "\u011B": "ecaron", "\u011A": "Ecaron", "\xEB": "euml", "\xCB": "Euml", "\u0117": "edot", "\u0116": "Edot", "\u0119": "eogon", "\u0118": "Eogon", "\u0113": "emacr", "\u0112": "Emacr", "\u{1D523}": "ffr", "\u{1D557}": "fopf", "\u{1D4BB}": "fscr", "\u{1D509}": "Ffr", "\u{1D53D}": "Fopf", "\u2131": "Fscr", "\uFB00": "fflig", "\uFB03": "ffilig", "\uFB04": "ffllig", "\uFB01": "filig", "fj": "fjlig", "\uFB02": "fllig", "\u0192": "fnof", "\u210A": "gscr", "\u{1D558}": "gopf", "\u{1D524}": "gfr", "\u{1D4A2}": "Gscr", "\u{1D53E}": "Gopf", "\u{1D50A}": "Gfr", "\u01F5": "gacute", "\u011F": "gbreve", "\u011E": "Gbreve", "\u011D": "gcirc", "\u011C": "Gcirc", "\u0121": "gdot", "\u0120": "Gdot", "\u0122": "Gcedil", "\u{1D525}": "hfr", "\u210E": "planckh", "\u{1D4BD}": "hscr", "\u{1D559}": "hopf", "\u210B": "Hscr", "\u210C": "Hfr", "\u210D": "Hopf", "\u0125": "hcirc", "\u0124": "Hcirc", "\u210F": "hbar", "\u0127": "hstrok", "\u0126": "Hstrok", "\u{1D55A}": "iopf", "\u{1D526}": "ifr", "\u{1D4BE}": "iscr", "\u2148": "ii", "\u{1D540}": "Iopf", "\u2110": "Iscr", "\u2111": "Im", "\xED": "iacute", "\xCD": "Iacute", "\xEC": "igrave", "\xCC": "Igrave", "\xEE": "icirc", "\xCE": "Icirc", "\xEF": "iuml", "\xCF": "Iuml", "\u0129": "itilde", "\u0128": "Itilde", "\u0130": "Idot", "\u012F": "iogon", "\u012E": "Iogon", "\u012B": "imacr", "\u012A": "Imacr", "\u0133": "ijlig", "\u0132": "IJlig", "\u0131": "imath", "\u{1D4BF}": "jscr", "\u{1D55B}": "jopf", "\u{1D527}": "jfr", "\u{1D4A5}": "Jscr", "\u{1D50D}": "Jfr", "\u{1D541}": "Jopf", "\u0135": "jcirc", "\u0134": "Jcirc", "\u0237": "jmath", "\u{1D55C}": "kopf", "\u{1D4C0}": "kscr", "\u{1D528}": "kfr", "\u{1D4A6}": "Kscr", "\u{1D542}": "Kopf", "\u{1D50E}": "Kfr", "\u0137": "kcedil", "\u0136": "Kcedil", "\u{1D529}": "lfr", "\u{1D4C1}": "lscr", "\u2113": "ell", "\u{1D55D}": "lopf", "\u2112": "Lscr", "\u{1D50F}": "Lfr", "\u{1D543}": "Lopf", "\u013A": "lacute", "\u0139": "Lacute", "\u013E": "lcaron", "\u013D": "Lcaron", "\u013C": "lcedil", "\u013B": "Lcedil", "\u0142": "lstrok", "\u0141": "Lstrok", "\u0140": "lmidot", "\u013F": "Lmidot", "\u{1D52A}": "mfr", "\u{1D55E}": "mopf", "\u{1D4C2}": "mscr", "\u{1D510}": "Mfr", "\u{1D544}": "Mopf", "\u2133": "Mscr", "\u{1D52B}": "nfr", "\u{1D55F}": "nopf", "\u{1D4C3}": "nscr", "\u2115": "Nopf", "\u{1D4A9}": "Nscr", "\u{1D511}": "Nfr", "\u0144": "nacute", "\u0143": "Nacute", "\u0148": "ncaron", "\u0147": "Ncaron", "\xF1": "ntilde", "\xD1": "Ntilde", "\u0146": "ncedil", "\u0145": "Ncedil", "\u2116": "numero", "\u014B": "eng", "\u014A": "ENG", "\u{1D560}": "oopf", "\u{1D52C}": "ofr", "\u2134": "oscr", "\u{1D4AA}": "Oscr", "\u{1D512}": "Ofr", "\u{1D546}": "Oopf", "\xBA": "ordm", "\xF3": "oacute", "\xD3": "Oacute", "\xF2": "ograve", "\xD2": "Ograve", "\xF4": "ocirc", "\xD4": "Ocirc", "\xF6": "ouml", "\xD6": "Ouml", "\u0151": "odblac", "\u0150": "Odblac", "\xF5": "otilde", "\xD5": "Otilde", "\xF8": "oslash", "\xD8": "Oslash", "\u014D": "omacr", "\u014C": "Omacr", "\u0153": "oelig", "\u0152": "OElig", "\u{1D52D}": "pfr", "\u{1D4C5}": "pscr", "\u{1D561}": "popf", "\u2119": "Popf", "\u{1D513}": "Pfr", "\u{1D4AB}": "Pscr", "\u{1D562}": "qopf", "\u{1D52E}": "qfr", "\u{1D4C6}": "qscr", "\u{1D4AC}": "Qscr", "\u{1D514}": "Qfr", "\u211A": "Qopf", "\u0138": "kgreen", "\u{1D52F}": "rfr", "\u{1D563}": "ropf", "\u{1D4C7}": "rscr", "\u211B": "Rscr", "\u211C": "Re", "\u211D": "Ropf", "\u0155": "racute", "\u0154": "Racute", "\u0159": "rcaron", "\u0158": "Rcaron", "\u0157": "rcedil", "\u0156": "Rcedil", "\u{1D564}": "sopf", "\u{1D4C8}": "sscr", "\u{1D530}": "sfr", "\u{1D54A}": "Sopf", "\u{1D516}": "Sfr", "\u{1D4AE}": "Sscr", "\u24C8": "oS", "\u015B": "sacute", "\u015A": "Sacute", "\u015D": "scirc", "\u015C": "Scirc", "\u0161": "scaron", "\u0160": "Scaron", "\u015F": "scedil", "\u015E": "Scedil", "\xDF": "szlig", "\u{1D531}": "tfr", "\u{1D4C9}": "tscr", "\u{1D565}": "topf", "\u{1D4AF}": "Tscr", "\u{1D517}": "Tfr", "\u{1D54B}": "Topf", "\u0165": "tcaron", "\u0164": "Tcaron", "\u0163": "tcedil", "\u0162": "Tcedil", "\u2122": "trade", "\u0167": "tstrok", "\u0166": "Tstrok", "\u{1D4CA}": "uscr", "\u{1D566}": "uopf", "\u{1D532}": "ufr", "\u{1D54C}": "Uopf", "\u{1D518}": "Ufr", "\u{1D4B0}": "Uscr", "\xFA": "uacute", "\xDA": "Uacute", "\xF9": "ugrave", "\xD9": "Ugrave", "\u016D": "ubreve", "\u016C": "Ubreve", "\xFB": "ucirc", "\xDB": "Ucirc", "\u016F": "uring", "\u016E": "Uring", "\xFC": "uuml", "\xDC": "Uuml", "\u0171": "udblac", "\u0170": "Udblac", "\u0169": "utilde", "\u0168": "Utilde", "\u0173": "uogon", "\u0172": "Uogon", "\u016B": "umacr", "\u016A": "Umacr", "\u{1D533}": "vfr", "\u{1D567}": "vopf", "\u{1D4CB}": "vscr", "\u{1D519}": "Vfr", "\u{1D54D}": "Vopf", "\u{1D4B1}": "Vscr", "\u{1D568}": "wopf", "\u{1D4CC}": "wscr", "\u{1D534}": "wfr", "\u{1D4B2}": "Wscr", "\u{1D54E}": "Wopf", "\u{1D51A}": "Wfr", "\u0175": "wcirc", "\u0174": "Wcirc", "\u{1D535}": "xfr", "\u{1D4CD}": "xscr", "\u{1D569}": "xopf", "\u{1D54F}": "Xopf", "\u{1D51B}": "Xfr", "\u{1D4B3}": "Xscr", "\u{1D536}": "yfr", "\u{1D4CE}": "yscr", "\u{1D56A}": "yopf", "\u{1D4B4}": "Yscr", "\u{1D51C}": "Yfr", "\u{1D550}": "Yopf", "\xFD": "yacute", "\xDD": "Yacute", "\u0177": "ycirc", "\u0176": "Ycirc", "\xFF": "yuml", "\u0178": "Yuml", "\u{1D4CF}": "zscr", "\u{1D537}": "zfr", "\u{1D56B}": "zopf", "\u2128": "Zfr", "\u2124": "Zopf", "\u{1D4B5}": "Zscr", "\u017A": "zacute", "\u0179": "Zacute", "\u017E": "zcaron", "\u017D": "Zcaron", "\u017C": "zdot", "\u017B": "Zdot", "\u01B5": "imped", "\xFE": "thorn", "\xDE": "THORN", "\u0149": "napos", "\u03B1": "alpha", "\u0391": "Alpha", "\u03B2": "beta", "\u0392": "Beta", "\u03B3": "gamma", "\u0393": "Gamma", "\u03B4": "delta", "\u0394": "Delta", "\u03B5": "epsi", "\u03F5": "epsiv", "\u0395": "Epsilon", "\u03DD": "gammad", "\u03DC": "Gammad", "\u03B6": "zeta", "\u0396": "Zeta", "\u03B7": "eta", "\u0397": "Eta", "\u03B8": "theta", "\u03D1": "thetav", "\u0398": "Theta", "\u03B9": "iota", "\u0399": "Iota", "\u03BA": "kappa", "\u03F0": "kappav", "\u039A": "Kappa", "\u03BB": "lambda", "\u039B": "Lambda", "\u03BC": "mu", "\xB5": "micro", "\u039C": "Mu", "\u03BD": "nu", "\u039D": "Nu", "\u03BE": "xi", "\u039E": "Xi", "\u03BF": "omicron", "\u039F": "Omicron", "\u03C0": "pi", "\u03D6": "piv", "\u03A0": "Pi", "\u03C1": "rho", "\u03F1": "rhov", "\u03A1": "Rho", "\u03C3": "sigma", "\u03A3": "Sigma", "\u03C2": "sigmaf", "\u03C4": "tau", "\u03A4": "Tau", "\u03C5": "upsi", "\u03A5": "Upsilon", "\u03D2": "Upsi", "\u03C6": "phi", "\u03D5": "phiv", "\u03A6": "Phi", "\u03C7": "chi", "\u03A7": "Chi", "\u03C8": "psi", "\u03A8": "Psi", "\u03C9": "omega", "\u03A9": "ohm", "\u0430": "acy", "\u0410": "Acy", "\u0431": "bcy", "\u0411": "Bcy", "\u0432": "vcy", "\u0412": "Vcy", "\u0433": "gcy", "\u0413": "Gcy", "\u0453": "gjcy", "\u0403": "GJcy", "\u0434": "dcy", "\u0414": "Dcy", "\u0452": "djcy", "\u0402": "DJcy", "\u0435": "iecy", "\u0415": "IEcy", "\u0451": "iocy", "\u0401": "IOcy", "\u0454": "jukcy", "\u0404": "Jukcy", "\u0436": "zhcy", "\u0416": "ZHcy", "\u0437": "zcy", "\u0417": "Zcy", "\u0455": "dscy", "\u0405": "DScy", "\u0438": "icy", "\u0418": "Icy", "\u0456": "iukcy", "\u0406": "Iukcy", "\u0457": "yicy", "\u0407": "YIcy", "\u0439": "jcy", "\u0419": "Jcy", "\u0458": "jsercy", "\u0408": "Jsercy", "\u043A": "kcy", "\u041A": "Kcy", "\u045C": "kjcy", "\u040C": "KJcy", "\u043B": "lcy", "\u041B": "Lcy", "\u0459": "ljcy", "\u0409": "LJcy", "\u043C": "mcy", "\u041C": "Mcy", "\u043D": "ncy", "\u041D": "Ncy", "\u045A": "njcy", "\u040A": "NJcy", "\u043E": "ocy", "\u041E": "Ocy", "\u043F": "pcy", "\u041F": "Pcy", "\u0440": "rcy", "\u0420": "Rcy", "\u0441": "scy", "\u0421": "Scy", "\u0442": "tcy", "\u0422": "Tcy", "\u045B": "tshcy", "\u040B": "TSHcy", "\u0443": "ucy", "\u0423": "Ucy", "\u045E": "ubrcy", "\u040E": "Ubrcy", "\u0444": "fcy", "\u0424": "Fcy", "\u0445": "khcy", "\u0425": "KHcy", "\u0446": "tscy", "\u0426": "TScy", "\u0447": "chcy", "\u0427": "CHcy", "\u045F": "dzcy", "\u040F": "DZcy", "\u0448": "shcy", "\u0428": "SHcy", "\u0449": "shchcy", "\u0429": "SHCHcy", "\u044A": "hardcy", "\u042A": "HARDcy", "\u044B": "ycy", "\u042B": "Ycy", "\u044C": "softcy", "\u042C": "SOFTcy", "\u044D": "ecy", "\u042D": "Ecy", "\u044E": "yucy", "\u042E": "YUcy", "\u044F": "yacy", "\u042F": "YAcy", "\u2135": "aleph", "\u2136": "beth", "\u2137": "gimel", "\u2138": "daleth" };
        var regexEscape = /["&'<>`]/g;
        var escapeMap = {
          '"': "&quot;",
          "&": "&amp;",
          "'": "&#x27;",
          "<": "&lt;",
          // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
          // following is not strictly necessary unless it’s part of a tag or an
          // unquoted attribute value. We’re only escaping it to support those
          // situations, and for XML support.
          ">": "&gt;",
          // In Internet Explorer ≤ 8, the backtick character can be used
          // to break out of (un)quoted attribute values or HTML comments.
          // See http://html5sec.org/#102, http://html5sec.org/#108, and
          // http://html5sec.org/#133.
          "`": "&#x60;"
        };
        var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
        var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
        var decodeMap = { "aacute": "\xE1", "Aacute": "\xC1", "abreve": "\u0103", "Abreve": "\u0102", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "acy": "\u0430", "Acy": "\u0410", "aelig": "\xE6", "AElig": "\xC6", "af": "\u2061", "afr": "\u{1D51E}", "Afr": "\u{1D504}", "agrave": "\xE0", "Agrave": "\xC0", "alefsym": "\u2135", "aleph": "\u2135", "alpha": "\u03B1", "Alpha": "\u0391", "amacr": "\u0101", "Amacr": "\u0100", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "and": "\u2227", "And": "\u2A53", "andand": "\u2A55", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsd": "\u2221", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\xC5", "angzarr": "\u237C", "aogon": "\u0105", "Aogon": "\u0104", "aopf": "\u{1D552}", "Aopf": "\u{1D538}", "ap": "\u2248", "apacir": "\u2A6F", "ape": "\u224A", "apE": "\u2A70", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "aring": "\xE5", "Aring": "\xC5", "ascr": "\u{1D4B6}", "Ascr": "\u{1D49C}", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "bcy": "\u0431", "Bcy": "\u0411", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "beta": "\u03B2", "Beta": "\u0392", "beth": "\u2136", "between": "\u226C", "bfr": "\u{1D51F}", "Bfr": "\u{1D505}", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bnot": "\u2310", "bNot": "\u2AED", "bopf": "\u{1D553}", "Bopf": "\u{1D539}", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxhD": "\u2565", "boxHd": "\u2564", "boxHD": "\u2566", "boxhu": "\u2534", "boxhU": "\u2568", "boxHu": "\u2567", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\xA6", "bscr": "\u{1D4B7}", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsol": "\\", "bsolb": "\u29C5", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpe": "\u224F", "bumpE": "\u2AAE", "bumpeq": "\u224F", "Bumpeq": "\u224E", "cacute": "\u0107", "Cacute": "\u0106", "cap": "\u2229", "Cap": "\u22D2", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "ccaron": "\u010D", "Ccaron": "\u010C", "ccedil": "\xE7", "Ccedil": "\xC7", "ccirc": "\u0109", "Ccirc": "\u0108", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "cdot": "\u010B", "Cdot": "\u010A", "cedil": "\xB8", "Cedilla": "\xB8", "cemptyv": "\u29B2", "cent": "\xA2", "centerdot": "\xB7", "CenterDot": "\xB7", "cfr": "\u{1D520}", "Cfr": "\u212D", "chcy": "\u0447", "CHcy": "\u0427", "check": "\u2713", "checkmark": "\u2713", "chi": "\u03C7", "Chi": "\u03A7", "cir": "\u25CB", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\xAE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cire": "\u2257", "cirE": "\u29C3", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "colone": "\u2254", "Colone": "\u2A74", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\u{1D554}", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\xA9", "COPY": "\xA9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "cscr": "\u{1D4B8}", "Cscr": "\u{1D49E}", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cup": "\u222A", "Cup": "\u22D3", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\xA4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "dArr": "\u21D3", "Darr": "\u21A1", "dash": "\u2010", "dashv": "\u22A3", "Dashv": "\u2AE4", "dbkarow": "\u290F", "dblac": "\u02DD", "dcaron": "\u010F", "Dcaron": "\u010E", "dcy": "\u0434", "Dcy": "\u0414", "dd": "\u2146", "DD": "\u2145", "ddagger": "\u2021", "ddarr": "\u21CA", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\xB0", "Del": "\u2207", "delta": "\u03B4", "Delta": "\u0394", "demptyv": "\u29B1", "dfisht": "\u297F", "dfr": "\u{1D521}", "Dfr": "\u{1D507}", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\xB4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\xA8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\xF7", "divide": "\xF7", "divideontimes": "\u22C7", "divonx": "\u22C7", "djcy": "\u0452", "DJcy": "\u0402", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "dopf": "\u{1D555}", "Dopf": "\u{1D53B}", "dot": "\u02D9", "Dot": "\xA8", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\xA8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "downarrow": "\u2193", "Downarrow": "\u21D3", "DownArrow": "\u2193", "DownArrowBar": "\u2913", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVector": "\u21BD", "DownLeftVectorBar": "\u2956", "DownRightTeeVector": "\u295F", "DownRightVector": "\u21C1", "DownRightVectorBar": "\u2957", "DownTee": "\u22A4", "DownTeeArrow": "\u21A7", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "dscr": "\u{1D4B9}", "Dscr": "\u{1D49F}", "dscy": "\u0455", "DScy": "\u0405", "dsol": "\u29F6", "dstrok": "\u0111", "Dstrok": "\u0110", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "dzcy": "\u045F", "DZcy": "\u040F", "dzigrarr": "\u27FF", "eacute": "\xE9", "Eacute": "\xC9", "easter": "\u2A6E", "ecaron": "\u011B", "Ecaron": "\u011A", "ecir": "\u2256", "ecirc": "\xEA", "Ecirc": "\xCA", "ecolon": "\u2255", "ecy": "\u044D", "Ecy": "\u042D", "eDDot": "\u2A77", "edot": "\u0117", "eDot": "\u2251", "Edot": "\u0116", "ee": "\u2147", "efDot": "\u2252", "efr": "\u{1D522}", "Efr": "\u{1D508}", "eg": "\u2A9A", "egrave": "\xE8", "Egrave": "\xC8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "emacr": "\u0113", "Emacr": "\u0112", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp": "\u2003", "emsp13": "\u2004", "emsp14": "\u2005", "eng": "\u014B", "ENG": "\u014A", "ensp": "\u2002", "eogon": "\u0119", "Eogon": "\u0118", "eopf": "\u{1D556}", "Eopf": "\u{1D53C}", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "epsilon": "\u03B5", "Epsilon": "\u0395", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "esim": "\u2242", "Esim": "\u2A73", "eta": "\u03B7", "Eta": "\u0397", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "fcy": "\u0444", "Fcy": "\u0424", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "ffr": "\u{1D523}", "Ffr": "\u{1D509}", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "fopf": "\u{1D557}", "Fopf": "\u{1D53D}", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\xBD", "frac13": "\u2153", "frac14": "\xBC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\xBE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\u{1D4BB}", "Fscr": "\u2131", "gacute": "\u01F5", "gamma": "\u03B3", "Gamma": "\u0393", "gammad": "\u03DD", "Gammad": "\u03DC", "gap": "\u2A86", "gbreve": "\u011F", "Gbreve": "\u011E", "Gcedil": "\u0122", "gcirc": "\u011D", "Gcirc": "\u011C", "gcy": "\u0433", "Gcy": "\u0413", "gdot": "\u0121", "Gdot": "\u0120", "ge": "\u2265", "gE": "\u2267", "gel": "\u22DB", "gEl": "\u2A8C", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "ges": "\u2A7E", "gescc": "\u2AA9", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "gfr": "\u{1D524}", "Gfr": "\u{1D50A}", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "gjcy": "\u0453", "GJcy": "\u0403", "gl": "\u2277", "gla": "\u2AA5", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "gopf": "\u{1D558}", "Gopf": "\u{1D53E}", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "gscr": "\u210A", "Gscr": "\u{1D4A2}", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gt": ">", "Gt": "\u226B", "GT": ">", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\xBD", "hamilt": "\u210B", "hardcy": "\u044A", "HARDcy": "\u042A", "harr": "\u2194", "hArr": "\u21D4", "harrcir": "\u2948", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "hcirc": "\u0125", "Hcirc": "\u0124", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\u{1D525}", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\u{1D559}", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\u{1D4BD}", "Hscr": "\u210B", "hslash": "\u210F", "hstrok": "\u0127", "Hstrok": "\u0126", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "iacute": "\xED", "Iacute": "\xCD", "ic": "\u2063", "icirc": "\xEE", "Icirc": "\xCE", "icy": "\u0438", "Icy": "\u0418", "Idot": "\u0130", "iecy": "\u0435", "IEcy": "\u0415", "iexcl": "\xA1", "iff": "\u21D4", "ifr": "\u{1D526}", "Ifr": "\u2111", "igrave": "\xEC", "Igrave": "\xCC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "ijlig": "\u0133", "IJlig": "\u0132", "Im": "\u2111", "imacr": "\u012B", "Imacr": "\u012A", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "in": "\u2208", "incare": "\u2105", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "int": "\u222B", "Int": "\u222C", "intcal": "\u22BA", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "iocy": "\u0451", "IOcy": "\u0401", "iogon": "\u012F", "Iogon": "\u012E", "iopf": "\u{1D55A}", "Iopf": "\u{1D540}", "iota": "\u03B9", "Iota": "\u0399", "iprod": "\u2A3C", "iquest": "\xBF", "iscr": "\u{1D4BE}", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "itilde": "\u0129", "Itilde": "\u0128", "iukcy": "\u0456", "Iukcy": "\u0406", "iuml": "\xEF", "Iuml": "\xCF", "jcirc": "\u0135", "Jcirc": "\u0134", "jcy": "\u0439", "Jcy": "\u0419", "jfr": "\u{1D527}", "Jfr": "\u{1D50D}", "jmath": "\u0237", "jopf": "\u{1D55B}", "Jopf": "\u{1D541}", "jscr": "\u{1D4BF}", "Jscr": "\u{1D4A5}", "jsercy": "\u0458", "Jsercy": "\u0408", "jukcy": "\u0454", "Jukcy": "\u0404", "kappa": "\u03BA", "Kappa": "\u039A", "kappav": "\u03F0", "kcedil": "\u0137", "Kcedil": "\u0136", "kcy": "\u043A", "Kcy": "\u041A", "kfr": "\u{1D528}", "Kfr": "\u{1D50E}", "kgreen": "\u0138", "khcy": "\u0445", "KHcy": "\u0425", "kjcy": "\u045C", "KJcy": "\u040C", "kopf": "\u{1D55C}", "Kopf": "\u{1D542}", "kscr": "\u{1D4C0}", "Kscr": "\u{1D4A6}", "lAarr": "\u21DA", "lacute": "\u013A", "Lacute": "\u0139", "laemptyv": "\u29B4", "lagran": "\u2112", "lambda": "\u03BB", "Lambda": "\u039B", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\xAB", "larr": "\u2190", "lArr": "\u21D0", "Larr": "\u219E", "larrb": "\u21E4", "larrbfs": "\u291F", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "lat": "\u2AAB", "latail": "\u2919", "lAtail": "\u291B", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "lcaron": "\u013E", "Lcaron": "\u013D", "lcedil": "\u013C", "Lcedil": "\u013B", "lceil": "\u2308", "lcub": "{", "lcy": "\u043B", "Lcy": "\u041B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "leftarrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrow": "\u2190", "LeftArrowBar": "\u21E4", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVector": "\u21C3", "LeftDownVectorBar": "\u2959", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "Leftrightarrow": "\u21D4", "LeftRightArrow": "\u2194", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTee": "\u22A3", "LeftTeeArrow": "\u21A4", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangle": "\u22B2", "LeftTriangleBar": "\u29CF", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVector": "\u21BF", "LeftUpVectorBar": "\u2958", "LeftVector": "\u21BC", "LeftVectorBar": "\u2952", "leg": "\u22DA", "lEg": "\u2A8B", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "les": "\u2A7D", "lescc": "\u2AA8", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "lfr": "\u{1D529}", "Lfr": "\u{1D50F}", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "ljcy": "\u0459", "LJcy": "\u0409", "ll": "\u226A", "Ll": "\u22D8", "llarr": "\u21C7", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "lmidot": "\u0140", "Lmidot": "\u013F", "lmoust": "\u23B0", "lmoustache": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "Longleftarrow": "\u27F8", "LongLeftArrow": "\u27F5", "longleftrightarrow": "\u27F7", "Longleftrightarrow": "\u27FA", "LongLeftRightArrow": "\u27F7", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "Longrightarrow": "\u27F9", "LongRightArrow": "\u27F6", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "lopf": "\u{1D55D}", "Lopf": "\u{1D543}", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\u{1D4C1}", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "lstrok": "\u0142", "Lstrok": "\u0141", "lt": "<", "Lt": "\u226A", "LT": "<", "ltcc": "\u2AA6", "ltcir": "\u2A79", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\xAF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "map": "\u21A6", "Map": "\u2905", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "mcy": "\u043C", "Mcy": "\u041C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "mfr": "\u{1D52A}", "Mfr": "\u{1D510}", "mho": "\u2127", "micro": "\xB5", "mid": "\u2223", "midast": "*", "midcir": "\u2AF0", "middot": "\xB7", "minus": "\u2212", "minusb": "\u229F", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "mopf": "\u{1D55E}", "Mopf": "\u{1D544}", "mp": "\u2213", "mscr": "\u{1D4C2}", "Mscr": "\u2133", "mstpos": "\u223E", "mu": "\u03BC", "Mu": "\u039C", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "nacute": "\u0144", "Nacute": "\u0143", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natur": "\u266E", "natural": "\u266E", "naturals": "\u2115", "nbsp": "\xA0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "ncaron": "\u0148", "Ncaron": "\u0147", "ncedil": "\u0146", "Ncedil": "\u0145", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "ncy": "\u043D", "Ncy": "\u041D", "ndash": "\u2013", "ne": "\u2260", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "nfr": "\u{1D52B}", "Nfr": "\u{1D511}", "nge": "\u2271", "ngE": "\u2267\u0338", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "ngt": "\u226F", "nGt": "\u226B\u20D2", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "njcy": "\u045A", "NJcy": "\u040A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nle": "\u2270", "nlE": "\u2266\u0338", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nlt": "\u226E", "nLt": "\u226A\u20D2", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\xA0", "nopf": "\u{1D55F}", "Nopf": "\u2115", "not": "\xAC", "Not": "\u2AEC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangle": "\u22EA", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangle": "\u22EB", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "npar": "\u2226", "nparallel": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "npre": "\u2AAF\u0338", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrc": "\u2933\u0338", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "nscr": "\u{1D4C3}", "Nscr": "\u{1D4A9}", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsube": "\u2288", "nsubE": "\u2AC5\u0338", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupe": "\u2289", "nsupE": "\u2AC6\u0338", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "ntilde": "\xF1", "Ntilde": "\xD1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "nu": "\u03BD", "Nu": "\u039D", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "oacute": "\xF3", "Oacute": "\xD3", "oast": "\u229B", "ocir": "\u229A", "ocirc": "\xF4", "Ocirc": "\xD4", "ocy": "\u043E", "Ocy": "\u041E", "odash": "\u229D", "odblac": "\u0151", "Odblac": "\u0150", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "oelig": "\u0153", "OElig": "\u0152", "ofcir": "\u29BF", "ofr": "\u{1D52C}", "Ofr": "\u{1D512}", "ogon": "\u02DB", "ograve": "\xF2", "Ograve": "\xD2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "omacr": "\u014D", "Omacr": "\u014C", "omega": "\u03C9", "Omega": "\u03A9", "omicron": "\u03BF", "Omicron": "\u039F", "omid": "\u29B6", "ominus": "\u2296", "oopf": "\u{1D560}", "Oopf": "\u{1D546}", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "or": "\u2228", "Or": "\u2A54", "orarr": "\u21BB", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\xAA", "ordm": "\xBA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "oscr": "\u2134", "Oscr": "\u{1D4AA}", "oslash": "\xF8", "Oslash": "\xD8", "osol": "\u2298", "otilde": "\xF5", "Otilde": "\xD5", "otimes": "\u2297", "Otimes": "\u2A37", "otimesas": "\u2A36", "ouml": "\xF6", "Ouml": "\xD6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "par": "\u2225", "para": "\xB6", "parallel": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "pcy": "\u043F", "Pcy": "\u041F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "pfr": "\u{1D52D}", "Pfr": "\u{1D513}", "phi": "\u03C6", "Phi": "\u03A6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "pi": "\u03C0", "Pi": "\u03A0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plus": "+", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\xB1", "plusmn": "\xB1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\xB1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\u{1D561}", "Popf": "\u2119", "pound": "\xA3", "pr": "\u227A", "Pr": "\u2ABB", "prap": "\u2AB7", "prcue": "\u227C", "pre": "\u2AAF", "prE": "\u2AB3", "prec": "\u227A", "precapprox": "\u2AB7", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportion": "\u2237", "Proportional": "\u221D", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "pscr": "\u{1D4C5}", "Pscr": "\u{1D4AB}", "psi": "\u03C8", "Psi": "\u03A8", "puncsp": "\u2008", "qfr": "\u{1D52E}", "Qfr": "\u{1D514}", "qint": "\u2A0C", "qopf": "\u{1D562}", "Qopf": "\u211A", "qprime": "\u2057", "qscr": "\u{1D4C6}", "Qscr": "\u{1D4AC}", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": '"', "QUOT": '"', "rAarr": "\u21DB", "race": "\u223D\u0331", "racute": "\u0155", "Racute": "\u0154", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\xBB", "rarr": "\u2192", "rArr": "\u21D2", "Rarr": "\u21A0", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "rarrtl": "\u21A3", "Rarrtl": "\u2916", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "rcaron": "\u0159", "Rcaron": "\u0158", "rcedil": "\u0157", "Rcedil": "\u0156", "rceil": "\u2309", "rcub": "}", "rcy": "\u0440", "Rcy": "\u0420", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "Re": "\u211C", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "rect": "\u25AD", "reg": "\xAE", "REG": "\xAE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\u{1D52F}", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "rho": "\u03C1", "Rho": "\u03A1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "rightarrow": "\u2192", "Rightarrow": "\u21D2", "RightArrow": "\u2192", "RightArrowBar": "\u21E5", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVector": "\u21C2", "RightDownVectorBar": "\u2955", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTee": "\u22A2", "RightTeeArrow": "\u21A6", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangle": "\u22B3", "RightTriangleBar": "\u29D0", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVector": "\u21BE", "RightUpVectorBar": "\u2954", "RightVector": "\u21C0", "RightVectorBar": "\u2953", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoust": "\u23B1", "rmoustache": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\u{1D563}", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\u{1D4C7}", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "sacute": "\u015B", "Sacute": "\u015A", "sbquo": "\u201A", "sc": "\u227B", "Sc": "\u2ABC", "scap": "\u2AB8", "scaron": "\u0161", "Scaron": "\u0160", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "scedil": "\u015F", "Scedil": "\u015E", "scirc": "\u015D", "Scirc": "\u015C", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "scy": "\u0441", "Scy": "\u0421", "sdot": "\u22C5", "sdotb": "\u22A1", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\xA7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "sfr": "\u{1D530}", "Sfr": "\u{1D516}", "sfrown": "\u2322", "sharp": "\u266F", "shchcy": "\u0449", "SHCHcy": "\u0429", "shcy": "\u0448", "SHcy": "\u0428", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\xAD", "sigma": "\u03C3", "Sigma": "\u03A3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "softcy": "\u044C", "SOFTcy": "\u042C", "sol": "/", "solb": "\u29C4", "solbar": "\u233F", "sopf": "\u{1D564}", "Sopf": "\u{1D54A}", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "squ": "\u25A1", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squf": "\u25AA", "srarr": "\u2192", "sscr": "\u{1D4C8}", "Sscr": "\u{1D4AE}", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "star": "\u2606", "Star": "\u22C6", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\xAF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "sube": "\u2286", "subE": "\u2AC5", "subedot": "\u2AC3", "submult": "\u2AC1", "subne": "\u228A", "subnE": "\u2ACB", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succ": "\u227B", "succapprox": "\u2AB8", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup": "\u2283", "Sup": "\u22D1", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supe": "\u2287", "supE": "\u2AC6", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supne": "\u228B", "supnE": "\u2ACC", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\xDF", "Tab": "	", "target": "\u2316", "tau": "\u03C4", "Tau": "\u03A4", "tbrk": "\u23B4", "tcaron": "\u0165", "Tcaron": "\u0164", "tcedil": "\u0163", "Tcedil": "\u0162", "tcy": "\u0442", "Tcy": "\u0422", "tdot": "\u20DB", "telrec": "\u2315", "tfr": "\u{1D531}", "Tfr": "\u{1D517}", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "theta": "\u03B8", "Theta": "\u0398", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "thinsp": "\u2009", "ThinSpace": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "thorn": "\xFE", "THORN": "\xDE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "times": "\xD7", "timesb": "\u22A0", "timesbar": "\u2A31", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "top": "\u22A4", "topbot": "\u2336", "topcir": "\u2AF1", "topf": "\u{1D565}", "Topf": "\u{1D54B}", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "tscr": "\u{1D4C9}", "Tscr": "\u{1D4AF}", "tscy": "\u0446", "TScy": "\u0426", "tshcy": "\u045B", "TSHcy": "\u040B", "tstrok": "\u0167", "Tstrok": "\u0166", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "uacute": "\xFA", "Uacute": "\xDA", "uarr": "\u2191", "uArr": "\u21D1", "Uarr": "\u219F", "Uarrocir": "\u2949", "ubrcy": "\u045E", "Ubrcy": "\u040E", "ubreve": "\u016D", "Ubreve": "\u016C", "ucirc": "\xFB", "Ucirc": "\xDB", "ucy": "\u0443", "Ucy": "\u0423", "udarr": "\u21C5", "udblac": "\u0171", "Udblac": "\u0170", "udhar": "\u296E", "ufisht": "\u297E", "ufr": "\u{1D532}", "Ufr": "\u{1D518}", "ugrave": "\xF9", "Ugrave": "\xD9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "umacr": "\u016B", "Umacr": "\u016A", "uml": "\xA8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "uogon": "\u0173", "Uogon": "\u0172", "uopf": "\u{1D566}", "Uopf": "\u{1D54C}", "uparrow": "\u2191", "Uparrow": "\u21D1", "UpArrow": "\u2191", "UpArrowBar": "\u2912", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "Updownarrow": "\u21D5", "UpDownArrow": "\u2195", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "upsilon": "\u03C5", "Upsilon": "\u03A5", "UpTee": "\u22A5", "UpTeeArrow": "\u21A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "uring": "\u016F", "Uring": "\u016E", "urtri": "\u25F9", "uscr": "\u{1D4CA}", "Uscr": "\u{1D4B0}", "utdot": "\u22F0", "utilde": "\u0169", "Utilde": "\u0168", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "uuml": "\xFC", "Uuml": "\xDC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "vcy": "\u0432", "Vcy": "\u0412", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "vee": "\u2228", "Vee": "\u22C1", "veebar": "\u22BB", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "vfr": "\u{1D533}", "Vfr": "\u{1D519}", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "vopf": "\u{1D567}", "Vopf": "\u{1D54D}", "vprop": "\u221D", "vrtri": "\u22B3", "vscr": "\u{1D4CB}", "Vscr": "\u{1D4B1}", "vsubne": "\u228A\uFE00", "vsubnE": "\u2ACB\uFE00", "vsupne": "\u228B\uFE00", "vsupnE": "\u2ACC\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "wcirc": "\u0175", "Wcirc": "\u0174", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "wfr": "\u{1D534}", "Wfr": "\u{1D51A}", "wopf": "\u{1D568}", "Wopf": "\u{1D54E}", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "wscr": "\u{1D4CC}", "Wscr": "\u{1D4B2}", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "xfr": "\u{1D535}", "Xfr": "\u{1D51B}", "xharr": "\u27F7", "xhArr": "\u27FA", "xi": "\u03BE", "Xi": "\u039E", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "xopf": "\u{1D569}", "Xopf": "\u{1D54F}", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "xscr": "\u{1D4CD}", "Xscr": "\u{1D4B3}", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "yacute": "\xFD", "Yacute": "\xDD", "yacy": "\u044F", "YAcy": "\u042F", "ycirc": "\u0177", "Ycirc": "\u0176", "ycy": "\u044B", "Ycy": "\u042B", "yen": "\xA5", "yfr": "\u{1D536}", "Yfr": "\u{1D51C}", "yicy": "\u0457", "YIcy": "\u0407", "yopf": "\u{1D56A}", "Yopf": "\u{1D550}", "yscr": "\u{1D4CE}", "Yscr": "\u{1D4B4}", "yucy": "\u044E", "YUcy": "\u042E", "yuml": "\xFF", "Yuml": "\u0178", "zacute": "\u017A", "Zacute": "\u0179", "zcaron": "\u017E", "Zcaron": "\u017D", "zcy": "\u0437", "Zcy": "\u0417", "zdot": "\u017C", "Zdot": "\u017B", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "zeta": "\u03B6", "Zeta": "\u0396", "zfr": "\u{1D537}", "Zfr": "\u2128", "zhcy": "\u0436", "ZHcy": "\u0416", "zigrarr": "\u21DD", "zopf": "\u{1D56B}", "Zopf": "\u2124", "zscr": "\u{1D4CF}", "Zscr": "\u{1D4B5}", "zwj": "\u200D", "zwnj": "\u200C" };
        var decodeMapLegacy = { "aacute": "\xE1", "Aacute": "\xC1", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "aelig": "\xE6", "AElig": "\xC6", "agrave": "\xE0", "Agrave": "\xC0", "amp": "&", "AMP": "&", "aring": "\xE5", "Aring": "\xC5", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "brvbar": "\xA6", "ccedil": "\xE7", "Ccedil": "\xC7", "cedil": "\xB8", "cent": "\xA2", "copy": "\xA9", "COPY": "\xA9", "curren": "\xA4", "deg": "\xB0", "divide": "\xF7", "eacute": "\xE9", "Eacute": "\xC9", "ecirc": "\xEA", "Ecirc": "\xCA", "egrave": "\xE8", "Egrave": "\xC8", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "frac12": "\xBD", "frac14": "\xBC", "frac34": "\xBE", "gt": ">", "GT": ">", "iacute": "\xED", "Iacute": "\xCD", "icirc": "\xEE", "Icirc": "\xCE", "iexcl": "\xA1", "igrave": "\xEC", "Igrave": "\xCC", "iquest": "\xBF", "iuml": "\xEF", "Iuml": "\xCF", "laquo": "\xAB", "lt": "<", "LT": "<", "macr": "\xAF", "micro": "\xB5", "middot": "\xB7", "nbsp": "\xA0", "not": "\xAC", "ntilde": "\xF1", "Ntilde": "\xD1", "oacute": "\xF3", "Oacute": "\xD3", "ocirc": "\xF4", "Ocirc": "\xD4", "ograve": "\xF2", "Ograve": "\xD2", "ordf": "\xAA", "ordm": "\xBA", "oslash": "\xF8", "Oslash": "\xD8", "otilde": "\xF5", "Otilde": "\xD5", "ouml": "\xF6", "Ouml": "\xD6", "para": "\xB6", "plusmn": "\xB1", "pound": "\xA3", "quot": '"', "QUOT": '"', "raquo": "\xBB", "reg": "\xAE", "REG": "\xAE", "sect": "\xA7", "shy": "\xAD", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "szlig": "\xDF", "thorn": "\xFE", "THORN": "\xDE", "times": "\xD7", "uacute": "\xFA", "Uacute": "\xDA", "ucirc": "\xFB", "Ucirc": "\xDB", "ugrave": "\xF9", "Ugrave": "\xD9", "uml": "\xA8", "uuml": "\xFC", "Uuml": "\xDC", "yacute": "\xFD", "Yacute": "\xDD", "yen": "\xA5", "yuml": "\xFF" };
        var decodeMapNumeric = { "0": "\uFFFD", "128": "\u20AC", "130": "\u201A", "131": "\u0192", "132": "\u201E", "133": "\u2026", "134": "\u2020", "135": "\u2021", "136": "\u02C6", "137": "\u2030", "138": "\u0160", "139": "\u2039", "140": "\u0152", "142": "\u017D", "145": "\u2018", "146": "\u2019", "147": "\u201C", "148": "\u201D", "149": "\u2022", "150": "\u2013", "151": "\u2014", "152": "\u02DC", "153": "\u2122", "154": "\u0161", "155": "\u203A", "156": "\u0153", "158": "\u017E", "159": "\u0178" };
        var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
        var stringFromCharCode = String.fromCharCode;
        var object = {};
        var hasOwnProperty4 = object.hasOwnProperty;
        var has = function(object2, propertyName) {
          return hasOwnProperty4.call(object2, propertyName);
        };
        var contains = function(array, value) {
          var index4 = -1;
          var length = array.length;
          while (++index4 < length) {
            if (array[index4] == value) {
              return true;
            }
          }
          return false;
        };
        var merge = function(options, defaults) {
          if (!options) {
            return defaults;
          }
          var result = {};
          var key2;
          for (key2 in defaults) {
            result[key2] = has(options, key2) ? options[key2] : defaults[key2];
          }
          return result;
        };
        var codePointToSymbol = function(codePoint, strict) {
          var output = "";
          if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
            if (strict) {
              parseError("character reference outside the permissible Unicode range");
            }
            return "\uFFFD";
          }
          if (has(decodeMapNumeric, codePoint)) {
            if (strict) {
              parseError("disallowed character reference");
            }
            return decodeMapNumeric[codePoint];
          }
          if (strict && contains(invalidReferenceCodePoints, codePoint)) {
            parseError("disallowed character reference");
          }
          if (codePoint > 65535) {
            codePoint -= 65536;
            output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          output += stringFromCharCode(codePoint);
          return output;
        };
        var hexEscape = function(codePoint) {
          return "&#x" + codePoint.toString(16).toUpperCase() + ";";
        };
        var decEscape = function(codePoint) {
          return "&#" + codePoint + ";";
        };
        var parseError = function(message) {
          throw Error("Parse error: " + message);
        };
        var encode = function(string3, options) {
          options = merge(options, encode.options);
          var strict = options.strict;
          if (strict && regexInvalidRawCodePoint.test(string3)) {
            parseError("forbidden code point");
          }
          var encodeEverything = options.encodeEverything;
          var useNamedReferences = options.useNamedReferences;
          var allowUnsafeSymbols = options.allowUnsafeSymbols;
          var escapeCodePoint = options.decimal ? decEscape : hexEscape;
          var escapeBmpSymbol = function(symbol) {
            return escapeCodePoint(symbol.charCodeAt(0));
          };
          if (encodeEverything) {
            string3 = string3.replace(regexAsciiWhitelist, function(symbol) {
              if (useNamedReferences && has(encodeMap, symbol)) {
                return "&" + encodeMap[symbol] + ";";
              }
              return escapeBmpSymbol(symbol);
            });
            if (useNamedReferences) {
              string3 = string3.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
            }
            if (useNamedReferences) {
              string3 = string3.replace(regexEncodeNonAscii, function(string4) {
                return "&" + encodeMap[string4] + ";";
              });
            }
          } else if (useNamedReferences) {
            if (!allowUnsafeSymbols) {
              string3 = string3.replace(regexEscape, function(string4) {
                return "&" + encodeMap[string4] + ";";
              });
            }
            string3 = string3.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
            string3 = string3.replace(regexEncodeNonAscii, function(string4) {
              return "&" + encodeMap[string4] + ";";
            });
          } else if (!allowUnsafeSymbols) {
            string3 = string3.replace(regexEscape, escapeBmpSymbol);
          }
          return string3.replace(regexAstralSymbols, function($0) {
            var high = $0.charCodeAt(0);
            var low = $0.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return escapeCodePoint(codePoint);
          }).replace(regexBmpWhitelist, escapeBmpSymbol);
        };
        encode.options = {
          "allowUnsafeSymbols": false,
          "encodeEverything": false,
          "strict": false,
          "useNamedReferences": false,
          "decimal": false
        };
        var decode4 = function(html2, options) {
          options = merge(options, decode4.options);
          var strict = options.strict;
          if (strict && regexInvalidEntity.test(html2)) {
            parseError("malformed character reference");
          }
          return html2.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
            var codePoint;
            var semicolon;
            var decDigits;
            var hexDigits;
            var reference;
            var next;
            if ($1) {
              reference = $1;
              return decodeMap[reference];
            }
            if ($2) {
              reference = $2;
              next = $3;
              if (next && options.isAttributeValue) {
                if (strict && next == "=") {
                  parseError("`&` did not start a character reference");
                }
                return $0;
              } else {
                if (strict) {
                  parseError(
                    "named character reference was not terminated by a semicolon"
                  );
                }
                return decodeMapLegacy[reference] + (next || "");
              }
            }
            if ($4) {
              decDigits = $4;
              semicolon = $5;
              if (strict && !semicolon) {
                parseError("character reference was not terminated by a semicolon");
              }
              codePoint = parseInt(decDigits, 10);
              return codePointToSymbol(codePoint, strict);
            }
            if ($6) {
              hexDigits = $6;
              semicolon = $7;
              if (strict && !semicolon) {
                parseError("character reference was not terminated by a semicolon");
              }
              codePoint = parseInt(hexDigits, 16);
              return codePointToSymbol(codePoint, strict);
            }
            if (strict) {
              parseError(
                "named character reference was not terminated by a semicolon"
              );
            }
            return $0;
          });
        };
        decode4.options = {
          "isAttributeValue": false,
          "strict": false
        };
        var escape = function(string3) {
          return string3.replace(regexEscape, function($0) {
            return escapeMap[$0];
          });
        };
        var he = {
          "version": "1.2.0",
          "encode": encode,
          "decode": decode4,
          "escape": escape,
          "unescape": decode4
        };
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          define(function() {
            return he;
          });
        } else if (freeExports && !freeExports.nodeType) {
          if (freeModule) {
            freeModule.exports = he;
          } else {
            for (var key in he) {
              has(he, key) && (freeExports[key] = he[key]);
            }
          }
        } else {
          root2.he = he;
        }
      })(exports3);
    }
  });

  // node_modules/@volar/source-map/lib/binarySearch.js
  var require_binarySearch = __commonJS({
    "node_modules/@volar/source-map/lib/binarySearch.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.binarySearch = binarySearch;
      function binarySearch(values, searchValue) {
        let low = 0;
        let high = values.length - 1;
        let match;
        while (low <= high) {
          const mid = Math.floor((low + high) / 2);
          const midValue = values[mid];
          if (midValue < searchValue) {
            low = mid + 1;
          } else if (midValue > searchValue) {
            high = mid - 1;
          } else {
            low = mid;
            high = mid;
            match = mid;
            break;
          }
        }
        const finalLow = Math.max(Math.min(low, high, values.length - 1), 0);
        const finalHigh = Math.min(Math.max(low, high, 0), values.length - 1);
        return { low: finalLow, high: finalHigh, match };
      }
    }
  });

  // node_modules/@volar/source-map/lib/translateOffset.js
  var require_translateOffset = __commonJS({
    "node_modules/@volar/source-map/lib/translateOffset.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.translateOffset = translateOffset;
      var warned = false;
      function translateOffset(start2, fromOffsets, toOffsets, fromLengths, toLengths = fromLengths) {
        const isSorted = fromOffsets.every((value, index4) => index4 === 0 || fromOffsets[index4 - 1] <= value);
        if (!isSorted) {
          for (let i = 0; i < fromOffsets.length; i++) {
            const fromOffset = fromOffsets[i];
            const fromLength = fromLengths[i];
            if (start2 >= fromOffset && start2 <= fromOffset + fromLength) {
              const toLength = toLengths[i];
              const toOffset = toOffsets[i];
              let rangeOffset = Math.min(start2 - fromOffset, toLength);
              return toOffset + rangeOffset;
            }
          }
          if (!warned) {
            warned = true;
            console.warn("fromOffsets should be sorted in ascending order");
          }
        }
        let low = 0;
        let high = fromOffsets.length - 1;
        while (low <= high) {
          const mid = Math.floor((low + high) / 2);
          const fromOffset = fromOffsets[mid];
          const fromLength = fromLengths[mid];
          if (start2 >= fromOffset && start2 <= fromOffset + fromLength) {
            const toLength = toLengths[mid];
            const toOffset = toOffsets[mid];
            let rangeOffset = Math.min(start2 - fromOffset, toLength);
            return toOffset + rangeOffset;
          } else if (start2 < fromOffset) {
            high = mid - 1;
          } else {
            low = mid + 1;
          }
        }
      }
    }
  });

  // node_modules/@volar/source-map/lib/sourceMap.js
  var require_sourceMap = __commonJS({
    "node_modules/@volar/source-map/lib/sourceMap.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.SourceMap = void 0;
      var binarySearch_1 = require_binarySearch();
      var translateOffset_1 = require_translateOffset();
      var SourceMap = class {
        constructor(mappings) {
          this.mappings = mappings;
        }
        toSourceRange(generatedStart, generatedEnd, fallbackToAnyMatch, filter) {
          return this.findMatchingStartEnd(generatedStart, generatedEnd, fallbackToAnyMatch, "generatedOffsets", filter);
        }
        toGeneratedRange(sourceStart, sourceEnd, fallbackToAnyMatch, filter) {
          return this.findMatchingStartEnd(sourceStart, sourceEnd, fallbackToAnyMatch, "sourceOffsets", filter);
        }
        toSourceLocation(generatedOffset, filter) {
          return this.findMatchingOffsets(generatedOffset, "generatedOffsets", filter);
        }
        toGeneratedLocation(sourceOffset, filter) {
          return this.findMatchingOffsets(sourceOffset, "sourceOffsets", filter);
        }
        *findMatchingOffsets(offset2, fromRange, filter) {
          const memo = this.getMemoBasedOnRange(fromRange);
          if (memo.offsets.length === 0) {
            return;
          }
          const { low: start2, high: end } = (0, binarySearch_1.binarySearch)(memo.offsets, offset2);
          const skip = /* @__PURE__ */ new Set();
          const toRange = fromRange == "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
          for (let i = start2; i <= end; i++) {
            for (const mapping of memo.mappings[i]) {
              if (skip.has(mapping)) {
                continue;
              }
              skip.add(mapping);
              if (filter && !filter(mapping.data)) {
                continue;
              }
              const mapped = (0, translateOffset_1.translateOffset)(offset2, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
              if (mapped !== void 0) {
                yield [mapped, mapping];
              }
            }
          }
        }
        *findMatchingStartEnd(start2, end, fallbackToAnyMatch, fromRange, filter) {
          const toRange = fromRange == "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
          const mappedStarts = [];
          let hadMatch = false;
          for (const [mappedStart, mapping] of this.findMatchingOffsets(start2, fromRange)) {
            if (filter && !filter(mapping.data)) {
              continue;
            }
            mappedStarts.push([mappedStart, mapping]);
            const mappedEnd = (0, translateOffset_1.translateOffset)(end, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
            if (mappedEnd !== void 0) {
              hadMatch = true;
              yield [mappedStart, mappedEnd, mapping, mapping];
            }
          }
          if (!hadMatch && fallbackToAnyMatch) {
            for (const [mappedStart, mappingStart] of mappedStarts) {
              for (const [mappedEnd, mappingEnd] of this.findMatchingOffsets(end, fromRange)) {
                if (filter && !filter(mappingEnd.data) || mappedEnd < mappedStart) {
                  continue;
                }
                yield [mappedStart, mappedEnd, mappingStart, mappingEnd];
                break;
              }
              ;
            }
          }
        }
        getMemoBasedOnRange(fromRange) {
          return fromRange === "sourceOffsets" ? this.sourceCodeOffsetsMemo ??= this.createMemo("sourceOffsets") : this.generatedCodeOffsetsMemo ??= this.createMemo("generatedOffsets");
        }
        createMemo(key) {
          const offsetsSet = /* @__PURE__ */ new Set();
          for (const mapping of this.mappings) {
            for (let i = 0; i < mapping[key].length; i++) {
              offsetsSet.add(mapping[key][i]);
              offsetsSet.add(mapping[key][i] + getLengths(mapping, key)[i]);
            }
          }
          const offsets = [...offsetsSet].sort((a, b) => a - b);
          const mappings = offsets.map(() => /* @__PURE__ */ new Set());
          for (const mapping of this.mappings) {
            for (let i = 0; i < mapping[key].length; i++) {
              const startIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i]).match;
              const endIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i] + getLengths(mapping, key)[i]).match;
              for (let i2 = startIndex; i2 <= endIndex; i2++) {
                mappings[i2].add(mapping);
              }
            }
          }
          return { offsets, mappings };
        }
      };
      exports3.SourceMap = SourceMap;
      function getLengths(mapping, key) {
        return key == "sourceOffsets" ? mapping.lengths : mapping.generatedLengths ?? mapping.lengths;
      }
    }
  });

  // node_modules/@volar/source-map/index.js
  var require_source_map = __commonJS({
    "node_modules/@volar/source-map/index.js"(exports3) {
      "use strict";
      var __createBinding = exports3 && exports3.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports3 && exports3.__exportStar || function(m, exports4) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p))
            __createBinding(exports4, m, p);
      };
      Object.defineProperty(exports3, "__esModule", { value: true });
      __exportStar(require_sourceMap(), exports3);
      __exportStar(require_translateOffset(), exports3);
    }
  });

  // node_modules/@volar/language-core/lib/editorFeatures.js
  var require_editorFeatures = __commonJS({
    "node_modules/@volar/language-core/lib/editorFeatures.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.isHoverEnabled = isHoverEnabled;
      exports3.isInlayHintsEnabled = isInlayHintsEnabled;
      exports3.isCodeLensEnabled = isCodeLensEnabled;
      exports3.isSemanticTokensEnabled = isSemanticTokensEnabled;
      exports3.isCallHierarchyEnabled = isCallHierarchyEnabled;
      exports3.isRenameEnabled = isRenameEnabled;
      exports3.isDefinitionEnabled = isDefinitionEnabled;
      exports3.isTypeDefinitionEnabled = isTypeDefinitionEnabled;
      exports3.isReferencesEnabled = isReferencesEnabled;
      exports3.isImplementationEnabled = isImplementationEnabled;
      exports3.isHighlightEnabled = isHighlightEnabled;
      exports3.isSymbolsEnabled = isSymbolsEnabled;
      exports3.isFoldingRangesEnabled = isFoldingRangesEnabled;
      exports3.isSelectionRangesEnabled = isSelectionRangesEnabled;
      exports3.isLinkedEditingEnabled = isLinkedEditingEnabled;
      exports3.isColorEnabled = isColorEnabled;
      exports3.isDocumentLinkEnabled = isDocumentLinkEnabled;
      exports3.isDiagnosticsEnabled = isDiagnosticsEnabled;
      exports3.isCodeActionsEnabled = isCodeActionsEnabled;
      exports3.isFormattingEnabled = isFormattingEnabled;
      exports3.isCompletionEnabled = isCompletionEnabled;
      exports3.isAutoInsertEnabled = isAutoInsertEnabled;
      exports3.isSignatureHelpEnabled = isSignatureHelpEnabled;
      exports3.shouldReportDiagnostics = shouldReportDiagnostics;
      exports3.resolveRenameNewName = resolveRenameNewName;
      exports3.resolveRenameEditText = resolveRenameEditText;
      function isHoverEnabled(info) {
        return !!info.semantic;
      }
      function isInlayHintsEnabled(info) {
        return !!info.semantic;
      }
      function isCodeLensEnabled(info) {
        return !!info.semantic;
      }
      function isSemanticTokensEnabled(info) {
        return typeof info.semantic === "object" ? info.semantic.shouldHighlight?.() ?? true : !!info.semantic;
      }
      function isCallHierarchyEnabled(info) {
        return !!info.navigation;
      }
      function isRenameEnabled(info) {
        return typeof info.navigation === "object" ? info.navigation.shouldRename?.() ?? true : !!info.navigation;
      }
      function isDefinitionEnabled(info) {
        return !!info.navigation;
      }
      function isTypeDefinitionEnabled(info) {
        return !!info.navigation;
      }
      function isReferencesEnabled(info) {
        return !!info.navigation;
      }
      function isImplementationEnabled(info) {
        return !!info.navigation;
      }
      function isHighlightEnabled(info) {
        return !!info.navigation;
      }
      function isSymbolsEnabled(info) {
        return !!info.structure;
      }
      function isFoldingRangesEnabled(info) {
        return !!info.structure;
      }
      function isSelectionRangesEnabled(info) {
        return !!info.structure;
      }
      function isLinkedEditingEnabled(info) {
        return !!info.structure;
      }
      function isColorEnabled(info) {
        return !!info.structure;
      }
      function isDocumentLinkEnabled(info) {
        return !!info.structure;
      }
      function isDiagnosticsEnabled(info) {
        return !!info.verification;
      }
      function isCodeActionsEnabled(info) {
        return !!info.verification;
      }
      function isFormattingEnabled(info) {
        return !!info.format;
      }
      function isCompletionEnabled(info) {
        return !!info.completion;
      }
      function isAutoInsertEnabled(info) {
        return !!info.completion;
      }
      function isSignatureHelpEnabled(info) {
        return !!info.completion;
      }
      function shouldReportDiagnostics(info) {
        return typeof info.verification === "object" ? info.verification.shouldReport?.() ?? true : !!info.verification;
      }
      function resolveRenameNewName(newName, info) {
        return typeof info.navigation === "object" ? info.navigation.resolveRenameNewName?.(newName) ?? newName : newName;
      }
      function resolveRenameEditText(text4, info) {
        return typeof info.navigation === "object" ? info.navigation.resolveRenameEditText?.(text4) ?? text4 : text4;
      }
    }
  });

  // node_modules/@volar/language-core/lib/linkedCodeMap.js
  var require_linkedCodeMap = __commonJS({
    "node_modules/@volar/language-core/lib/linkedCodeMap.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.LinkedCodeMap = void 0;
      var source_map_1 = require_source_map();
      var LinkedCodeMap = class extends source_map_1.SourceMap {
        *getLinkedOffsets(start2) {
          for (const mapped of this.toGeneratedLocation(start2)) {
            yield mapped[0];
          }
          for (const mapped of this.toSourceLocation(start2)) {
            yield mapped[0];
          }
        }
      };
      exports3.LinkedCodeMap = LinkedCodeMap;
    }
  });

  // node_modules/@volar/language-core/lib/types.js
  var require_types = __commonJS({
    "node_modules/@volar/language-core/lib/types.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
    }
  });

  // node_modules/@volar/language-core/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/@volar/language-core/lib/utils.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.FileMap = void 0;
      var FileMap = class extends Map {
        constructor(caseSensitive) {
          super();
          this.caseSensitive = caseSensitive;
          this.originalFileNames = /* @__PURE__ */ new Map();
        }
        keys() {
          return this.originalFileNames.values();
        }
        get(key) {
          return super.get(this.normalizeId(key));
        }
        has(key) {
          return super.has(this.normalizeId(key));
        }
        set(key, value) {
          this.originalFileNames.set(this.normalizeId(key), key);
          return super.set(this.normalizeId(key), value);
        }
        delete(key) {
          this.originalFileNames.delete(this.normalizeId(key));
          return super.delete(this.normalizeId(key));
        }
        clear() {
          this.originalFileNames.clear();
          return super.clear();
        }
        normalizeId(id) {
          return this.caseSensitive ? id : id.toLowerCase();
        }
      };
      exports3.FileMap = FileMap;
    }
  });

  // node_modules/@volar/language-core/index.js
  var require_language_core = __commonJS({
    "node_modules/@volar/language-core/index.js"(exports3) {
      "use strict";
      var __createBinding = exports3 && exports3.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports3 && exports3.__exportStar || function(m, exports4) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p))
            __createBinding(exports4, m, p);
      };
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.defaultMapperFactory = exports3.SourceMap = void 0;
      exports3.createLanguage = createLanguage2;
      exports3.forEachEmbeddedCode = forEachEmbeddedCode;
      var source_map_1 = require_source_map();
      Object.defineProperty(exports3, "SourceMap", { enumerable: true, get: function() {
        return source_map_1.SourceMap;
      } });
      __exportStar(require_editorFeatures(), exports3);
      __exportStar(require_linkedCodeMap(), exports3);
      __exportStar(require_types(), exports3);
      __exportStar(require_utils(), exports3);
      var source_map_2 = require_source_map();
      var linkedCodeMap_1 = require_linkedCodeMap();
      var defaultMapperFactory = (mappings) => new source_map_2.SourceMap(mappings);
      exports3.defaultMapperFactory = defaultMapperFactory;
      function createLanguage2(plugins, scriptRegistry, sync) {
        const virtualCodeToSourceScriptMap = /* @__PURE__ */ new WeakMap();
        const virtualCodeToSourceMap = /* @__PURE__ */ new WeakMap();
        const virtualCodeToLinkedCodeMap = /* @__PURE__ */ new WeakMap();
        const language = {
          mapperFactory: exports3.defaultMapperFactory,
          plugins,
          scripts: {
            fromVirtualCode(virtualCode) {
              return virtualCodeToSourceScriptMap.get(virtualCode);
            },
            get(id) {
              sync(id);
              const result = scriptRegistry.get(id);
              if (result?.isAssociationDirty) {
                this.set(id, result.snapshot, result.languageId);
              }
              return scriptRegistry.get(id);
            },
            set(id, snapshot, languageId, _plugins = plugins) {
              if (!languageId) {
                for (const plugin of plugins) {
                  languageId = plugin.getLanguageId?.(id);
                  if (languageId) {
                    break;
                  }
                }
              }
              if (!languageId) {
                console.warn(`languageId not found for ${id}`);
                return;
              }
              let associatedOnly = false;
              for (const plugin of plugins) {
                if (plugin.isAssociatedFileOnly?.(id, languageId)) {
                  associatedOnly = true;
                  break;
                }
              }
              if (scriptRegistry.has(id)) {
                const sourceScript = scriptRegistry.get(id);
                if (sourceScript.languageId !== languageId || sourceScript.associatedOnly !== associatedOnly) {
                  this.delete(id);
                  return this.set(id, snapshot, languageId);
                } else if (associatedOnly) {
                  sourceScript.snapshot = snapshot;
                } else if (sourceScript.isAssociationDirty || sourceScript.snapshot !== snapshot) {
                  sourceScript.snapshot = snapshot;
                  const codegenCtx = prepareCreateVirtualCode(sourceScript);
                  if (sourceScript.generated) {
                    const { updateVirtualCode, createVirtualCode } = sourceScript.generated.languagePlugin;
                    const newVirtualCode = updateVirtualCode ? updateVirtualCode(id, sourceScript.generated.root, snapshot, codegenCtx) : createVirtualCode?.(id, languageId, snapshot, codegenCtx);
                    if (newVirtualCode) {
                      sourceScript.generated.root = newVirtualCode;
                      sourceScript.generated.embeddedCodes.clear();
                      for (const code2 of forEachEmbeddedCode(sourceScript.generated.root)) {
                        virtualCodeToSourceScriptMap.set(code2, sourceScript);
                        sourceScript.generated.embeddedCodes.set(code2.id, code2);
                      }
                      return sourceScript;
                    } else {
                      this.delete(id);
                      return;
                    }
                  }
                  triggerTargetsDirty(sourceScript);
                } else {
                  return sourceScript;
                }
              } else {
                const sourceScript = {
                  id,
                  languageId,
                  snapshot,
                  associatedIds: /* @__PURE__ */ new Set(),
                  targetIds: /* @__PURE__ */ new Set(),
                  associatedOnly
                };
                scriptRegistry.set(id, sourceScript);
                if (associatedOnly) {
                  return sourceScript;
                }
                for (const languagePlugin of _plugins) {
                  const virtualCode = languagePlugin.createVirtualCode?.(id, languageId, snapshot, prepareCreateVirtualCode(sourceScript));
                  if (virtualCode) {
                    sourceScript.generated = {
                      root: virtualCode,
                      languagePlugin,
                      embeddedCodes: /* @__PURE__ */ new Map()
                    };
                    for (const code2 of forEachEmbeddedCode(virtualCode)) {
                      virtualCodeToSourceScriptMap.set(code2, sourceScript);
                      sourceScript.generated.embeddedCodes.set(code2.id, code2);
                    }
                    break;
                  }
                }
                return sourceScript;
              }
            },
            delete(id) {
              const sourceScript = scriptRegistry.get(id);
              if (sourceScript) {
                sourceScript.generated?.languagePlugin.disposeVirtualCode?.(id, sourceScript.generated.root);
                scriptRegistry.delete(id);
                triggerTargetsDirty(sourceScript);
              }
            }
          },
          maps: {
            get(virtualCode, sourceScript) {
              let mapCache = virtualCodeToSourceMap.get(virtualCode.snapshot);
              if (!mapCache) {
                virtualCodeToSourceMap.set(virtualCode.snapshot, mapCache = /* @__PURE__ */ new WeakMap());
              }
              if (!mapCache.has(sourceScript.snapshot)) {
                const mappings = virtualCode.associatedScriptMappings?.get(sourceScript.id) ?? virtualCode.mappings;
                mapCache.set(sourceScript.snapshot, language.mapperFactory(mappings));
              }
              return mapCache.get(sourceScript.snapshot);
            },
            *forEach(virtualCode) {
              const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
              yield [
                sourceScript,
                this.get(virtualCode, sourceScript)
              ];
              if (virtualCode.associatedScriptMappings) {
                for (const [relatedScriptId] of virtualCode.associatedScriptMappings) {
                  const relatedSourceScript = scriptRegistry.get(relatedScriptId);
                  if (relatedSourceScript) {
                    yield [
                      relatedSourceScript,
                      this.get(virtualCode, relatedSourceScript)
                    ];
                  }
                }
              }
            }
          },
          linkedCodeMaps: {
            get(virtualCode) {
              const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
              let mapCache = virtualCodeToLinkedCodeMap.get(virtualCode.snapshot);
              if (mapCache?.[0] !== sourceScript.snapshot) {
                virtualCodeToLinkedCodeMap.set(virtualCode.snapshot, mapCache = [
                  sourceScript.snapshot,
                  virtualCode.linkedCodeMappings ? new linkedCodeMap_1.LinkedCodeMap(virtualCode.linkedCodeMappings) : void 0
                ]);
              }
              return mapCache[1];
            }
          }
        };
        return language;
        function triggerTargetsDirty(sourceScript) {
          sourceScript.targetIds.forEach((id) => {
            const sourceScript2 = scriptRegistry.get(id);
            if (sourceScript2) {
              sourceScript2.isAssociationDirty = true;
            }
          });
        }
        function prepareCreateVirtualCode(sourceScript) {
          for (const id of sourceScript.associatedIds) {
            scriptRegistry.get(id)?.targetIds.delete(sourceScript.id);
          }
          sourceScript.associatedIds.clear();
          sourceScript.isAssociationDirty = false;
          return {
            getAssociatedScript(id) {
              sync(id);
              const relatedSourceScript = scriptRegistry.get(id);
              if (relatedSourceScript) {
                relatedSourceScript.targetIds.add(sourceScript.id);
                sourceScript.associatedIds.add(relatedSourceScript.id);
              }
              return relatedSourceScript;
            }
          };
        }
      }
      function* forEachEmbeddedCode(virtualCode) {
        yield virtualCode;
        if (virtualCode.embeddedCodes) {
          for (const embeddedCode of virtualCode.embeddedCodes) {
            yield* forEachEmbeddedCode(embeddedCode);
          }
        }
      }
    }
  });

  // node_modules/vscode-languageserver-textdocument/lib/esm/main.js
  var main_exports = {};
  __export(main_exports, {
    TextDocument: () => TextDocument
  });
  function mergeSort(data2, compare) {
    if (data2.length <= 1) {
      return data2;
    }
    const p = data2.length / 2 | 0;
    const left = data2.slice(0, p);
    const right = data2.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      let ret = compare(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data2[i++] = left[leftIdx++];
      } else {
        data2[i++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data2[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data2[i++] = right[rightIdx++];
    }
    return data2;
  }
  function computeLineOffsets(text4, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [textOffset] : [];
    for (let i = 0; i < text4.length; i++) {
      let ch = text4.charCodeAt(i);
      if (ch === 13 || ch === 10) {
        if (ch === 13 && i + 1 < text4.length && text4.charCodeAt(i + 1) === 10) {
          i++;
        }
        result.push(textOffset + i + 1);
      }
    }
    return result;
  }
  function getWellformedRange(range) {
    const start2 = range.start;
    const end = range.end;
    if (start2.line > end.line || start2.line === end.line && start2.character > end.character) {
      return { start: end, end: start2 };
    }
    return range;
  }
  function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
      return { newText: textEdit.newText, range };
    }
    return textEdit;
  }
  var FullTextDocument, TextDocument;
  var init_main = __esm({
    "node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
      "use strict";
      FullTextDocument = class {
        constructor(uri, languageId, version2, content3) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version2;
          this._content = content3;
          this._lineOffsets = void 0;
        }
        get uri() {
          return this._uri;
        }
        get languageId() {
          return this._languageId;
        }
        get version() {
          return this._version;
        }
        getText(range) {
          if (range) {
            const start2 = this.offsetAt(range.start);
            const end = this.offsetAt(range.end);
            return this._content.substring(start2, end);
          }
          return this._content;
        }
        update(changes, version2) {
          for (let change of changes) {
            if (FullTextDocument.isIncremental(change)) {
              const range = getWellformedRange(change.range);
              const startOffset = this.offsetAt(range.start);
              const endOffset = this.offsetAt(range.end);
              this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
              const startLine = Math.max(range.start.line, 0);
              const endLine = Math.max(range.end.line, 0);
              let lineOffsets = this._lineOffsets;
              const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
              if (endLine - startLine === addedLineOffsets.length) {
                for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                  lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                }
              } else {
                if (addedLineOffsets.length < 1e4) {
                  lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                } else {
                  this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                }
              }
              const diff = change.text.length - (endOffset - startOffset);
              if (diff !== 0) {
                for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                  lineOffsets[i] = lineOffsets[i] + diff;
                }
              }
            } else if (FullTextDocument.isFull(change)) {
              this._content = change.text;
              this._lineOffsets = void 0;
            } else {
              throw new Error("Unknown change event received");
            }
          }
          this._version = version2;
        }
        getLineOffsets() {
          if (this._lineOffsets === void 0) {
            this._lineOffsets = computeLineOffsets(this._content, true);
          }
          return this._lineOffsets;
        }
        positionAt(offset2) {
          offset2 = Math.max(Math.min(offset2, this._content.length), 0);
          let lineOffsets = this.getLineOffsets();
          let low = 0, high = lineOffsets.length;
          if (high === 0) {
            return { line: 0, character: offset2 };
          }
          while (low < high) {
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset2) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          let line = low - 1;
          return { line, character: offset2 - lineOffsets[line] };
        }
        offsetAt(position4) {
          let lineOffsets = this.getLineOffsets();
          if (position4.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position4.line < 0) {
            return 0;
          }
          let lineOffset = lineOffsets[position4.line];
          let nextLineOffset = position4.line + 1 < lineOffsets.length ? lineOffsets[position4.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position4.character, nextLineOffset), lineOffset);
        }
        get lineCount() {
          return this.getLineOffsets().length;
        }
        static isIncremental(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
        }
        static isFull(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
        }
      };
      (function(TextDocument2) {
        function create(uri, languageId, version2, content3) {
          return new FullTextDocument(uri, languageId, version2, content3);
        }
        TextDocument2.create = create;
        function update(document5, changes, version2) {
          if (document5 instanceof FullTextDocument) {
            document5.update(changes, version2);
            return document5;
          } else {
            throw new Error("TextDocument.update: document must be created by TextDocument.create");
          }
        }
        TextDocument2.update = update;
        function applyEdits(document5, edits) {
          let text4 = document5.getText();
          let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
            let diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          let lastModifiedOffset = 0;
          const spans = [];
          for (const e of sortedEdits) {
            let startOffset = document5.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
              throw new Error("Overlapping edit");
            } else if (startOffset > lastModifiedOffset) {
              spans.push(text4.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
              spans.push(e.newText);
            }
            lastModifiedOffset = document5.offsetAt(e.range.end);
          }
          spans.push(text4.substr(lastModifiedOffset));
          return spans.join("");
        }
        TextDocument2.applyEdits = applyEdits;
      })(TextDocument || (TextDocument = {}));
    }
  });

  // node_modules/vscode-uri/lib/umd/index.js
  var require_umd = __commonJS({
    "node_modules/vscode-uri/lib/umd/index.js"(exports3, module) {
      !function(t, e) {
        if ("object" == typeof exports3 && "object" == typeof module)
          module.exports = e();
        else if ("function" == typeof define && define.amd)
          define([], e);
        else {
          var r = e();
          for (var n in r)
            ("object" == typeof exports3 ? exports3 : t)[n] = r[n];
        }
      }(exports3, () => (() => {
        "use strict";
        var t = { 470: (t2) => {
          function e2(t3) {
            if ("string" != typeof t3)
              throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
          }
          function r2(t3, e3) {
            for (var r3, n3 = "", i = 0, o = -1, s = 0, a = 0; a <= t3.length; ++a) {
              if (a < t3.length)
                r3 = t3.charCodeAt(a);
              else {
                if (47 === r3)
                  break;
                r3 = 47;
              }
              if (47 === r3) {
                if (o === a - 1 || 1 === s)
                  ;
                else if (o !== a - 1 && 2 === s) {
                  if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                    if (n3.length > 2) {
                      var h = n3.lastIndexOf("/");
                      if (h !== n3.length - 1) {
                        -1 === h ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, h)).length - 1 - n3.lastIndexOf("/"), o = a, s = 0;
                        continue;
                      }
                    } else if (2 === n3.length || 1 === n3.length) {
                      n3 = "", i = 0, o = a, s = 0;
                      continue;
                    }
                  }
                  e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
                } else
                  n3.length > 0 ? n3 += "/" + t3.slice(o + 1, a) : n3 = t3.slice(o + 1, a), i = a - o - 1;
                o = a, s = 0;
              } else
                46 === r3 && -1 !== s ? ++s : s = -1;
            }
            return n3;
          }
          var n2 = { resolve: function() {
            for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
              var s;
              o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
            }
            return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
          }, normalize: function(t3) {
            if (e2(t3), 0 === t3.length)
              return ".";
            var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
            return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
          }, isAbsolute: function(t3) {
            return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
          }, join: function() {
            if (0 === arguments.length)
              return ".";
            for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
              var i = arguments[r3];
              e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
            }
            return void 0 === t3 ? "." : n2.normalize(t3);
          }, relative: function(t3, r3) {
            if (e2(t3), e2(r3), t3 === r3)
              return "";
            if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
              return "";
            for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i)
              ;
            for (var o = t3.length, s = o - i, a = 1; a < r3.length && 47 === r3.charCodeAt(a); ++a)
              ;
            for (var h = r3.length - a, c = s < h ? s : h, f = -1, u = 0; u <= c; ++u) {
              if (u === c) {
                if (h > c) {
                  if (47 === r3.charCodeAt(a + u))
                    return r3.slice(a + u + 1);
                  if (0 === u)
                    return r3.slice(a + u);
                } else
                  s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
                break;
              }
              var l = t3.charCodeAt(i + u);
              if (l !== r3.charCodeAt(a + u))
                break;
              47 === l && (f = u);
            }
            var d = "";
            for (u = i + f + 1; u <= o; ++u)
              u !== o && 47 !== t3.charCodeAt(u) || (0 === d.length ? d += ".." : d += "/..");
            return d.length > 0 ? d + r3.slice(a + f) : (a += f, 47 === r3.charCodeAt(a) && ++a, r3.slice(a));
          }, _makeLong: function(t3) {
            return t3;
          }, dirname: function(t3) {
            if (e2(t3), 0 === t3.length)
              return ".";
            for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s)
              if (47 === (r3 = t3.charCodeAt(s))) {
                if (!o) {
                  i = s;
                  break;
                }
              } else
                o = false;
            return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
          }, basename: function(t3, r3) {
            if (void 0 !== r3 && "string" != typeof r3)
              throw new TypeError('"ext" argument must be a string');
            e2(t3);
            var n3, i = 0, o = -1, s = true;
            if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
              if (r3.length === t3.length && r3 === t3)
                return "";
              var a = r3.length - 1, h = -1;
              for (n3 = t3.length - 1; n3 >= 0; --n3) {
                var c = t3.charCodeAt(n3);
                if (47 === c) {
                  if (!s) {
                    i = n3 + 1;
                    break;
                  }
                } else
                  -1 === h && (s = false, h = n3 + 1), a >= 0 && (c === r3.charCodeAt(a) ? -1 == --a && (o = n3) : (a = -1, o = h));
              }
              return i === o ? o = h : -1 === o && (o = t3.length), t3.slice(i, o);
            }
            for (n3 = t3.length - 1; n3 >= 0; --n3)
              if (47 === t3.charCodeAt(n3)) {
                if (!s) {
                  i = n3 + 1;
                  break;
                }
              } else
                -1 === o && (s = false, o = n3 + 1);
            return -1 === o ? "" : t3.slice(i, o);
          }, extname: function(t3) {
            e2(t3);
            for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, a = t3.length - 1; a >= 0; --a) {
              var h = t3.charCodeAt(a);
              if (47 !== h)
                -1 === i && (o = false, i = a + 1), 46 === h ? -1 === r3 ? r3 = a : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
              else if (!o) {
                n3 = a + 1;
                break;
              }
            }
            return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
          }, format: function(t3) {
            if (null === t3 || "object" != typeof t3)
              throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
            return function(t4, e3) {
              var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
              return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
            }(0, t3);
          }, parse: function(t3) {
            e2(t3);
            var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
            if (0 === t3.length)
              return r3;
            var n3, i = t3.charCodeAt(0), o = 47 === i;
            o ? (r3.root = "/", n3 = 1) : n3 = 0;
            for (var s = -1, a = 0, h = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
              if (47 !== (i = t3.charCodeAt(f)))
                -1 === h && (c = false, h = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
              else if (!c) {
                a = f + 1;
                break;
              }
            return -1 === s || -1 === h || 0 === u || 1 === u && s === h - 1 && s === a + 1 ? -1 !== h && (r3.base = r3.name = 0 === a && o ? t3.slice(1, h) : t3.slice(a, h)) : (0 === a && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, h)) : (r3.name = t3.slice(a, s), r3.base = t3.slice(a, h)), r3.ext = t3.slice(s, h)), a > 0 ? r3.dir = t3.slice(0, a - 1) : o && (r3.dir = "/"), r3;
          }, sep: "/", delimiter: ":", win32: null, posix: null };
          n2.posix = n2, t2.exports = n2;
        }, 674: (t2, e2) => {
          if (Object.defineProperty(e2, "__esModule", { value: true }), e2.isWindows = void 0, "object" == typeof process)
            e2.isWindows = "win32" === process.platform;
          else if ("object" == typeof navigator) {
            let t3 = navigator.userAgent;
            e2.isWindows = t3.indexOf("Windows") >= 0;
          }
        }, 796: (t2, e2, r2) => {
          Object.defineProperty(e2, "__esModule", { value: true }), e2.uriToFsPath = e2.URI = void 0;
          const n2 = r2(674), i = /^\w[\w\d+.-]*$/, o = /^\//, s = /^\/\//;
          function a(t3, e3) {
            if (!t3.scheme && e3)
              throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
            if (t3.scheme && !i.test(t3.scheme))
              throw new Error("[UriError]: Scheme contains illegal characters.");
            if (t3.path) {
              if (t3.authority) {
                if (!o.test(t3.path))
                  throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
              } else if (s.test(t3.path))
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
          }
          const h = "", c = "/", f = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
          class u {
            static isUri(t3) {
              return t3 instanceof u || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
            }
            scheme;
            authority;
            path;
            query;
            fragment;
            constructor(t3, e3, r3, n3, i2, o2 = false) {
              "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = function(t4, e4) {
                return t4 || e4 ? t4 : "file";
              }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {
                switch (t4) {
                  case "https":
                  case "http":
                  case "file":
                    e4 ? e4[0] !== c && (e4 = c + e4) : e4 = c;
                }
                return e4;
              }(this.scheme, r3 || h), this.query = n3 || h, this.fragment = i2 || h, a(this, o2));
            }
            get fsPath() {
              return v(this, false);
            }
            with(t3) {
              if (!t3)
                return this;
              let { scheme: e3, authority: r3, path: n3, query: i2, fragment: o2 } = t3;
              return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r3 ? r3 = this.authority : null === r3 && (r3 = h), void 0 === n3 ? n3 = this.path : null === n3 && (n3 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r3 === this.authority && n3 === this.path && i2 === this.query && o2 === this.fragment ? this : new d(e3, r3, n3, i2, o2);
            }
            static parse(t3, e3 = false) {
              const r3 = f.exec(t3);
              return r3 ? new d(r3[2] || h, w(r3[4] || h), w(r3[5] || h), w(r3[7] || h), w(r3[9] || h), e3) : new d(h, h, h, h, h);
            }
            static file(t3) {
              let e3 = h;
              if (n2.isWindows && (t3 = t3.replace(/\\/g, c)), t3[0] === c && t3[1] === c) {
                const r3 = t3.indexOf(c, 2);
                -1 === r3 ? (e3 = t3.substring(2), t3 = c) : (e3 = t3.substring(2, r3), t3 = t3.substring(r3) || c);
              }
              return new d("file", e3, t3, h, h);
            }
            static from(t3) {
              const e3 = new d(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
              return a(e3, true), e3;
            }
            toString(t3 = false) {
              return y(this, t3);
            }
            toJSON() {
              return this;
            }
            static revive(t3) {
              if (t3) {
                if (t3 instanceof u)
                  return t3;
                {
                  const e3 = new d(t3);
                  return e3._formatted = t3.external, e3._fsPath = t3._sep === l ? t3.fsPath : null, e3;
                }
              }
              return t3;
            }
          }
          e2.URI = u;
          const l = n2.isWindows ? 1 : void 0;
          class d extends u {
            _formatted = null;
            _fsPath = null;
            get fsPath() {
              return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
            }
            toString(t3 = false) {
              return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
            }
            toJSON() {
              const t3 = { $mid: 1 };
              return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = l), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
            }
          }
          const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
          function g(t3, e3, r3) {
            let n3, i2 = -1;
            for (let o2 = 0; o2 < t3.length; o2++) {
              const s2 = t3.charCodeAt(o2);
              if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r3 && 91 === s2 || r3 && 93 === s2 || r3 && 58 === s2)
                -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n3 && (n3 += t3.charAt(o2));
              else {
                void 0 === n3 && (n3 = t3.substr(0, o2));
                const e4 = p[s2];
                void 0 !== e4 ? (-1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n3 += e4) : -1 === i2 && (i2 = o2);
              }
            }
            return -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2))), void 0 !== n3 ? n3 : t3;
          }
          function m(t3) {
            let e3;
            for (let r3 = 0; r3 < t3.length; r3++) {
              const n3 = t3.charCodeAt(r3);
              35 === n3 || 63 === n3 ? (void 0 === e3 && (e3 = t3.substr(0, r3)), e3 += p[n3]) : void 0 !== e3 && (e3 += t3[r3]);
            }
            return void 0 !== e3 ? e3 : t3;
          }
          function v(t3, e3) {
            let r3;
            return r3 = t3.authority && t3.path.length > 1 && "file" === t3.scheme ? `//${t3.authority}${t3.path}` : 47 === t3.path.charCodeAt(0) && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n2.isWindows && (r3 = r3.replace(/\//g, "\\")), r3;
          }
          function y(t3, e3) {
            const r3 = e3 ? m : g;
            let n3 = "", { scheme: i2, authority: o2, path: s2, query: a2, fragment: h2 } = t3;
            if (i2 && (n3 += i2, n3 += ":"), (o2 || "file" === i2) && (n3 += c, n3 += c), o2) {
              let t4 = o2.indexOf("@");
              if (-1 !== t4) {
                const e4 = o2.substr(0, t4);
                o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n3 += r3(e4, false, false) : (n3 += r3(e4.substr(0, t4), false, false), n3 += ":", n3 += r3(e4.substr(t4 + 1), false, true)), n3 += "@";
              }
              o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n3 += r3(o2, false, true) : (n3 += r3(o2.substr(0, t4), false, true), n3 += o2.substr(t4));
            }
            if (s2) {
              if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
                const t4 = s2.charCodeAt(1);
                t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
              } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
                const t4 = s2.charCodeAt(0);
                t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
              }
              n3 += r3(s2, true, false);
            }
            return a2 && (n3 += "?", n3 += r3(a2, false, false)), h2 && (n3 += "#", n3 += e3 ? h2 : g(h2, false, false)), n3;
          }
          function b(t3) {
            try {
              return decodeURIComponent(t3);
            } catch {
              return t3.length > 3 ? t3.substr(0, 3) + b(t3.substr(3)) : t3;
            }
          }
          e2.uriToFsPath = v;
          const C = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
          function w(t3) {
            return t3.match(C) ? t3.replace(C, (t4) => b(t4)) : t3;
          }
        }, 679: function(t2, e2, r2) {
          var n2 = this && this.__createBinding || (Object.create ? function(t3, e3, r3, n3) {
            void 0 === n3 && (n3 = r3);
            var i2 = Object.getOwnPropertyDescriptor(e3, r3);
            i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e3[r3];
            } }), Object.defineProperty(t3, n3, i2);
          } : function(t3, e3, r3, n3) {
            void 0 === n3 && (n3 = r3), t3[n3] = e3[r3];
          }), i = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
            Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
          } : function(t3, e3) {
            t3.default = e3;
          }), o = this && this.__importStar || function(t3) {
            if (t3 && t3.__esModule)
              return t3;
            var e3 = {};
            if (null != t3)
              for (var r3 in t3)
                "default" !== r3 && Object.prototype.hasOwnProperty.call(t3, r3) && n2(e3, t3, r3);
            return i(e3, t3), e3;
          };
          Object.defineProperty(e2, "__esModule", { value: true }), e2.Utils = void 0;
          const s = o(r2(470)), a = s.posix || s, h = "/";
          var c;
          !function(t3) {
            t3.joinPath = function(t4, ...e3) {
              return t4.with({ path: a.join(t4.path, ...e3) });
            }, t3.resolvePath = function(t4, ...e3) {
              let r3 = t4.path, n3 = false;
              r3[0] !== h && (r3 = h + r3, n3 = true);
              let i2 = a.resolve(r3, ...e3);
              return n3 && i2[0] === h && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
            }, t3.dirname = function(t4) {
              if (0 === t4.path.length || t4.path === h)
                return t4;
              let e3 = a.dirname(t4.path);
              return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
            }, t3.basename = function(t4) {
              return a.basename(t4.path);
            }, t3.extname = function(t4) {
              return a.extname(t4.path);
            };
          }(c || (e2.Utils = c = {}));
        } }, e = {};
        function r(n2) {
          var i = e[n2];
          if (void 0 !== i)
            return i.exports;
          var o = e[n2] = { exports: {} };
          return t[n2].call(o.exports, o, o.exports, r), o.exports;
        }
        var n = {};
        return (() => {
          var t2 = n;
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Utils = t2.URI = void 0;
          const e2 = r(796);
          Object.defineProperty(t2, "URI", { enumerable: true, get: function() {
            return e2.URI;
          } });
          const i = r(679);
          Object.defineProperty(t2, "Utils", { enumerable: true, get: function() {
            return i.Utils;
          } });
        })(), n;
      })());
    }
  });

  // node_modules/@volar/language-service/lib/utils/cancellation.js
  var require_cancellation = __commonJS({
    "node_modules/@volar/language-service/lib/utils/cancellation.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.NoneCancellationToken = void 0;
      exports3.NoneCancellationToken = {
        isCancellationRequested: false,
        onCancellationRequested: () => ({ dispose: () => {
        } })
      };
    }
  });

  // node_modules/@volar/language-service/lib/utils/featureWorkers.js
  var require_featureWorkers = __commonJS({
    "node_modules/@volar/language-service/lib/utils/featureWorkers.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.documentFeatureWorker = documentFeatureWorker;
      exports3.languageFeatureWorker = languageFeatureWorker;
      exports3.safeCall = safeCall;
      exports3.forEachEmbeddedDocument = forEachEmbeddedDocument;
      exports3.getSourceRange = getSourceRange;
      exports3.getGeneratedRange = getGeneratedRange;
      exports3.getSourceRanges = getSourceRanges;
      exports3.getGeneratedRanges = getGeneratedRanges;
      exports3.getSourcePositions = getSourcePositions;
      exports3.getGeneratedPositions = getGeneratedPositions;
      exports3.getLinkedCodePositions = getLinkedCodePositions;
      function documentFeatureWorker(context, uri, valid, worker, transformResult, combineResult) {
        return languageFeatureWorker(context, uri, () => void 0, function* (map4) {
          if (valid(map4)) {
            yield;
          }
        }, worker, transformResult, combineResult);
      }
      async function languageFeatureWorker(context, uri, getRealDocParams, eachVirtualDocParams, worker, transformResult, combineResult) {
        let sourceScript;
        const decoded = context.decodeEmbeddedDocumentUri(uri);
        if (decoded) {
          sourceScript = context.language.scripts.get(decoded[0]);
        } else {
          sourceScript = context.language.scripts.get(uri);
        }
        if (!sourceScript) {
          return;
        }
        let results = [];
        if (decoded) {
          const virtualCode = sourceScript.generated?.embeddedCodes.get(decoded[1]);
          if (virtualCode) {
            const docs = [
              context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot),
              context.documents.get(uri, virtualCode.languageId, virtualCode.snapshot),
              context.language.maps.get(virtualCode, sourceScript)
            ];
            await docsWorker(docs, false);
          }
        } else if (sourceScript.generated) {
          for (const docs of forEachEmbeddedDocument(context, sourceScript, sourceScript.generated.root)) {
            if (results.length && !combineResult) {
              continue;
            }
            await docsWorker(docs, true);
          }
        } else {
          const document5 = context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
          const params = getRealDocParams();
          for (const [pluginIndex, plugin] of Object.entries(context.plugins)) {
            if (context.disabledServicePlugins.has(plugin[1])) {
              continue;
            }
            const embeddedResult = await safeCall(() => worker(plugin, document5, params, void 0), `Language service plugin "${plugin[0].name}" (${pluginIndex}) failed to provide document feature for ${document5.uri}.`);
            if (!embeddedResult) {
              continue;
            }
            const result = transformResult(embeddedResult, void 0);
            if (!result) {
              continue;
            }
            results.push(result);
            if (!combineResult) {
              break;
            }
          }
        }
        if (combineResult && results.length > 0) {
          const combined = combineResult(results);
          return combined;
        } else if (results.length > 0) {
          return results[0];
        }
        async function docsWorker(docs, transform) {
          for (const mappedArg of eachVirtualDocParams(docs)) {
            if (results.length && !combineResult) {
              continue;
            }
            for (const [pluginIndex, plugin] of Object.entries(context.plugins)) {
              if (context.disabledServicePlugins.has(plugin[1])) {
                continue;
              }
              if (results.length && !combineResult) {
                continue;
              }
              const embeddedResult = await safeCall(() => worker(plugin, docs[1], mappedArg, docs), `Language service plugin "${plugin[0].name}" (${pluginIndex}) failed to provide document feature for ${docs[1].uri}.`);
              if (!embeddedResult) {
                continue;
              }
              if (transform) {
                const mappedResult = transformResult(embeddedResult, docs);
                if (mappedResult) {
                  results.push(mappedResult);
                }
              } else {
                results.push(embeddedResult);
              }
            }
          }
        }
      }
      async function safeCall(cb, errorMsg) {
        try {
          return await cb();
        } catch (err) {
          console.warn(errorMsg, err);
        }
      }
      function* forEachEmbeddedDocument(context, sourceScript, current2) {
        if (current2.embeddedCodes) {
          for (const embeddedCode of current2.embeddedCodes) {
            yield* forEachEmbeddedDocument(context, sourceScript, embeddedCode);
          }
        }
        const embeddedDocumentUri = context.encodeEmbeddedDocumentUri(sourceScript.id, current2.id);
        if (!context.disabledEmbeddedDocumentUris.get(embeddedDocumentUri)) {
          yield [
            context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot),
            context.documents.get(embeddedDocumentUri, current2.languageId, current2.snapshot),
            context.language.maps.get(current2, sourceScript)
          ];
        }
      }
      function getSourceRange(docs, range, filter) {
        for (const result of getSourceRanges(docs, range, filter)) {
          return result;
        }
      }
      function getGeneratedRange(docs, range, filter) {
        for (const result of getGeneratedRanges(docs, range, filter)) {
          return result;
        }
      }
      function* getSourceRanges([sourceDocument, embeddedDocument, map4], range, filter) {
        for (const [mappedStart, mappedEnd] of map4.toSourceRange(embeddedDocument.offsetAt(range.start), embeddedDocument.offsetAt(range.end), true, filter)) {
          yield { start: sourceDocument.positionAt(mappedStart), end: sourceDocument.positionAt(mappedEnd) };
        }
      }
      function* getGeneratedRanges([sourceDocument, embeddedDocument, map4], range, filter) {
        for (const [mappedStart, mappedEnd] of map4.toGeneratedRange(sourceDocument.offsetAt(range.start), sourceDocument.offsetAt(range.end), true, filter)) {
          yield { start: embeddedDocument.positionAt(mappedStart), end: embeddedDocument.positionAt(mappedEnd) };
        }
      }
      function* getSourcePositions([sourceDocument, embeddedDocument, map4], position4, filter = () => true) {
        for (const mapped of map4.toSourceLocation(embeddedDocument.offsetAt(position4), filter)) {
          yield sourceDocument.positionAt(mapped[0]);
        }
      }
      function* getGeneratedPositions([sourceDocument, embeddedDocument, map4], position4, filter = () => true) {
        for (const mapped of map4.toGeneratedLocation(sourceDocument.offsetAt(position4), filter)) {
          yield embeddedDocument.positionAt(mapped[0]);
        }
      }
      function* getLinkedCodePositions(document5, linkedMap, posotion) {
        for (const linkedPosition of linkedMap.getLinkedOffsets(document5.offsetAt(posotion))) {
          yield document5.positionAt(linkedPosition);
        }
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideAutoInsertSnippet.js
  var require_provideAutoInsertSnippet = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideAutoInsertSnippet.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return (uri, selection, change, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => ({ selection, change }), function* (docs) {
            for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, selection, language_core_1.isAutoInsertEnabled)) {
              for (const mapped of docs[2].toGeneratedLocation(change.rangeOffset)) {
                yield {
                  selection: mappedPosition,
                  change: {
                    text: change.text,
                    rangeOffset: mapped[0],
                    rangeLength: change.rangeLength
                  }
                };
                break;
              }
            }
          }, (plugin, document5, args) => {
            if (token.isCancellationRequested) {
              return;
            }
            return plugin[1].provideAutoInsertSnippet?.(document5, args.selection, args.change, token);
          }, (snippet) => snippet);
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/utils/dedupe.js
  var require_dedupe = __commonJS({
    "node_modules/@volar/language-service/lib/utils/dedupe.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createLocationSet = createLocationSet;
      exports3.withCodeAction = withCodeAction;
      exports3.withTextEdits = withTextEdits;
      exports3.withDocumentChanges = withDocumentChanges;
      exports3.withDiagnostics = withDiagnostics;
      exports3.withLocations = withLocations;
      exports3.withLocationLinks = withLocationLinks;
      exports3.withCallHierarchyIncomingCalls = withCallHierarchyIncomingCalls;
      exports3.withCallHierarchyOutgoingCalls = withCallHierarchyOutgoingCalls;
      exports3.withRanges = withRanges;
      function createLocationSet() {
        const set = /* @__PURE__ */ new Set();
        return {
          add,
          has
        };
        function add(item) {
          if (has(item)) {
            return false;
          }
          set.add(getKey(item));
          return true;
        }
        function has(item) {
          return set.has(getKey(item));
        }
        function getKey(item) {
          return [
            item.uri,
            item.range.start.line,
            item.range.start.character,
            item.range.end.line,
            item.range.end.character
          ].join(":");
        }
      }
      function withCodeAction(items) {
        return dedupe(items, (item) => [
          item.title
        ].join(":"));
      }
      function withTextEdits(items) {
        return dedupe(items, (item) => [
          item.range.start.line,
          item.range.start.character,
          item.range.end.line,
          item.range.end.character,
          item.newText
        ].join(":"));
      }
      function withDocumentChanges(items) {
        return dedupe(items, (item) => JSON.stringify(item));
      }
      function withDiagnostics(items) {
        return dedupe(items, (item) => [
          item.range.start.line,
          item.range.start.character,
          item.range.end.line,
          item.range.end.character,
          item.source,
          item.code,
          item.severity,
          item.message
        ].join(":"));
      }
      function withLocations(items) {
        return dedupe(items, (item) => [
          item.uri,
          item.range.start.line,
          item.range.start.character,
          item.range.end.line,
          item.range.end.character
        ].join(":"));
      }
      function withLocationLinks(items) {
        return dedupe(items, (item) => [
          item.targetUri,
          item.targetSelectionRange.start.line,
          item.targetSelectionRange.start.character,
          item.targetSelectionRange.end.line,
          item.targetSelectionRange.end.character
          // ignore difference targetRange
        ].join(":"));
      }
      function withCallHierarchyIncomingCalls(items) {
        return dedupe(items, (item) => [
          item.from.uri,
          item.from.range.start.line,
          item.from.range.start.character,
          item.from.range.end.line,
          item.from.range.end.character
        ].join(":"));
      }
      function withCallHierarchyOutgoingCalls(items) {
        return dedupe(items, (item) => [
          item.to.uri,
          item.to.range.start.line,
          item.to.range.start.character,
          item.to.range.end.line,
          item.to.range.end.character
        ].join(":"));
      }
      function withRanges(items) {
        return dedupe(items, (item) => [
          item.start.line,
          item.start.character,
          item.end.line,
          item.end.character
        ].join(":"));
      }
      function dedupe(items, getKey) {
        const map4 = /* @__PURE__ */ new Map();
        for (const item of items.reverse()) {
          map4.set(getKey(item), item);
        }
        return [...map4.values()];
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideCallHierarchyItems.js
  var require_provideCallHierarchyItems = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideCallHierarchyItems.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var dedupe = require_dedupe();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return {
          getCallHierarchyItems(uri, position4, token = cancellation_1.NoneCancellationToken) {
            return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position4, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position4, language_core_1.isCallHierarchyEnabled), async (plugin, document5, position5, map4) => {
              if (token.isCancellationRequested) {
                return;
              }
              const items = await plugin[1].provideCallHierarchyItems?.(document5, position5, token);
              items?.forEach((item) => {
                item.data = {
                  uri: uri.toString(),
                  original: {
                    data: item.data
                  },
                  pluginIndex: context.plugins.indexOf(plugin),
                  embeddedDocumentUri: map4?.[1].uri
                };
              });
              return items;
            }, (data2, map4) => {
              if (!map4) {
                return data2;
              }
              return data2.map((item) => transformCallHierarchyItem(item, [])?.[0]).filter((item) => !!item);
            }, (arr) => dedupe.withLocations(arr.flat()));
          },
          async getCallHierarchyIncomingCalls(item, token) {
            const data2 = item.data;
            let incomingItems = [];
            if (data2) {
              const plugin = context.plugins[data2.pluginIndex];
              if (!plugin[1].provideCallHierarchyIncomingCalls) {
                return incomingItems;
              }
              Object.assign(item, data2.original);
              if (data2.embeddedDocumentUri) {
                const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data2.embeddedDocumentUri));
                if (isEmbeddedContent) {
                  const _calls = await plugin[1].provideCallHierarchyIncomingCalls(item, token);
                  for (const _call of _calls) {
                    const calls = transformCallHierarchyItem(_call.from, _call.fromRanges);
                    if (!calls) {
                      continue;
                    }
                    incomingItems.push({
                      from: calls[0],
                      fromRanges: calls[1]
                    });
                  }
                }
              } else {
                const _calls = await plugin[1].provideCallHierarchyIncomingCalls(item, token);
                for (const _call of _calls) {
                  const calls = transformCallHierarchyItem(_call.from, _call.fromRanges);
                  if (!calls) {
                    continue;
                  }
                  incomingItems.push({
                    from: calls[0],
                    fromRanges: calls[1]
                  });
                }
              }
            }
            return dedupe.withCallHierarchyIncomingCalls(incomingItems);
          },
          async getCallHierarchyOutgoingCalls(item, token) {
            const data2 = item.data;
            let items = [];
            if (data2) {
              const plugin = context.plugins[data2.pluginIndex];
              if (!plugin[1].provideCallHierarchyOutgoingCalls) {
                return items;
              }
              Object.assign(item, data2.original);
              if (data2.embeddedDocumentUri) {
                const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data2.embeddedDocumentUri));
                if (isEmbeddedContent) {
                  const _calls = await plugin[1].provideCallHierarchyOutgoingCalls(item, token);
                  for (const call of _calls) {
                    const calls = transformCallHierarchyItem(call.to, call.fromRanges);
                    if (!calls) {
                      continue;
                    }
                    items.push({
                      to: calls[0],
                      fromRanges: calls[1]
                    });
                  }
                }
              } else {
                const _calls = await plugin[1].provideCallHierarchyOutgoingCalls(item, token);
                for (const call of _calls) {
                  const calls = transformCallHierarchyItem(call.to, call.fromRanges);
                  if (!calls) {
                    continue;
                  }
                  items.push({
                    to: calls[0],
                    fromRanges: calls[1]
                  });
                }
              }
            }
            return dedupe.withCallHierarchyOutgoingCalls(items);
          }
        };
        function transformCallHierarchyItem(tsItem, tsRanges) {
          const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsItem.uri));
          const sourceScript = decoded && context.language.scripts.get(decoded[0]);
          const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
          if (!sourceScript || !virtualCode) {
            return [tsItem, tsRanges];
          }
          const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
          for (const [sourceScript2, map4] of context.language.maps.forEach(virtualCode)) {
            const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
            const docs = [sourceDocument, embeddedDocument, map4];
            let range = (0, featureWorkers_1.getSourceRange)(docs, tsItem.range);
            if (!range) {
              range = {
                start: sourceDocument.positionAt(0),
                end: sourceDocument.positionAt(sourceDocument.getText().length)
              };
            }
            const selectionRange = (0, featureWorkers_1.getSourceRange)(docs, tsItem.selectionRange);
            if (!selectionRange) {
              continue;
            }
            const vueRanges = tsRanges.map((tsRange) => (0, featureWorkers_1.getSourceRange)(docs, tsRange)).filter((range2) => !!range2);
            const vueItem = {
              ...tsItem,
              name: tsItem.name === embeddedDocument.uri.substring(embeddedDocument.uri.lastIndexOf("/") + 1) ? sourceDocument.uri.substring(sourceDocument.uri.lastIndexOf("/") + 1) : tsItem.name,
              uri: sourceDocument.uri,
              // TS Bug: `range: range` not works
              range: {
                start: range.start,
                end: range.end
              },
              selectionRange: {
                start: selectionRange.start,
                end: selectionRange.end
              }
            };
            return [vueItem, vueRanges];
          }
        }
      }
    }
  });

  // node_modules/@volar/language-service/lib/utils/common.js
  var require_common = __commonJS({
    "node_modules/@volar/language-service/lib/utils/common.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.findOverlapCodeRange = findOverlapCodeRange;
      exports3.isInsideRange = isInsideRange;
      exports3.isEqualRange = isEqualRange;
      exports3.stringToSnapshot = stringToSnapshot;
      exports3.sleep = sleep;
      function findOverlapCodeRange(start2, end, map4, filter) {
        let mappedStart;
        let mappedEnd;
        for (const [mapped, mapping] of map4.toGeneratedLocation(start2)) {
          if (filter(mapping.data)) {
            mappedStart = mapped;
            break;
          }
        }
        for (const [mapped, mapping] of map4.toGeneratedLocation(end)) {
          if (filter(mapping.data)) {
            mappedEnd = mapped;
            break;
          }
        }
        if (mappedStart === void 0 || mappedEnd === void 0) {
          for (const mapping of map4.mappings) {
            if (filter(mapping.data)) {
              const mappingStart = mapping.sourceOffsets[0];
              const mappingEnd = mapping.sourceOffsets[mapping.sourceOffsets.length - 1] + mapping.lengths[mapping.lengths.length - 1];
              const overlap = getOverlapRange(start2, end, mappingStart, mappingEnd);
              if (overlap) {
                const curMappedStart = overlap.start - mappingStart + mapping.generatedOffsets[0];
                mappedStart = mappedStart === void 0 ? curMappedStart : Math.min(mappedStart, curMappedStart);
                const lastGeneratedLength = (mapping.generatedLengths ?? mapping.lengths)[mapping.generatedOffsets.length - 1];
                const curMappedEndOffset = Math.min(overlap.end - mapping.sourceOffsets[mapping.sourceOffsets.length - 1], lastGeneratedLength);
                const curMappedEnd = mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + curMappedEndOffset;
                mappedEnd = mappedEnd === void 0 ? curMappedEnd : Math.max(mappedEnd, curMappedEnd);
              }
            }
          }
        }
        if (mappedStart !== void 0 && mappedEnd !== void 0) {
          return {
            start: mappedStart,
            end: mappedEnd
          };
        }
      }
      function getOverlapRange(range1Start, range1End, range2Start, range2End) {
        const start2 = Math.max(range1Start, range2Start);
        const end = Math.min(range1End, range2End);
        if (start2 > end) {
          return void 0;
        }
        return {
          start: start2,
          end
        };
      }
      function isInsideRange(parent, child) {
        if (child.start.line < parent.start.line) {
          return false;
        }
        if (child.end.line > parent.end.line) {
          return false;
        }
        if (child.start.line === parent.start.line && child.start.character < parent.start.character) {
          return false;
        }
        if (child.end.line === parent.end.line && child.end.character > parent.end.character) {
          return false;
        }
        return true;
      }
      function isEqualRange(a, b) {
        return a.start.line === b.start.line && a.start.character === b.start.character && a.end.line === b.end.line && a.end.character === b.end.character;
      }
      function stringToSnapshot(str) {
        return {
          getText: (start2, end) => str.substring(start2, end),
          getLength: () => str.length,
          getChangeRange: () => void 0
        };
      }
      function sleep(ms) {
        return new Promise((resolve3) => setTimeout(resolve3, ms));
      }
    }
  });

  // node_modules/@volar/language-service/lib/utils/transform.js
  var require_transform = __commonJS({
    "node_modules/@volar/language-service/lib/utils/transform.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.transformDocumentLinkTarget = transformDocumentLinkTarget;
      exports3.transformMarkdown = transformMarkdown;
      exports3.transformCompletionItem = transformCompletionItem;
      exports3.transformCompletionList = transformCompletionList;
      exports3.transformDocumentSymbol = transformDocumentSymbol;
      exports3.transformFoldingRanges = transformFoldingRanges;
      exports3.transformHover = transformHover;
      exports3.transformLocation = transformLocation;
      exports3.transformLocations = transformLocations;
      exports3.transformSelectionRange = transformSelectionRange;
      exports3.transformSelectionRanges = transformSelectionRanges;
      exports3.transformTextEdit = transformTextEdit;
      exports3.transformWorkspaceSymbol = transformWorkspaceSymbol;
      exports3.transformWorkspaceEdit = transformWorkspaceEdit;
      exports3.pushEditToDocumentChanges = pushEditToDocumentChanges;
      var language_core_1 = require_language_core();
      var vscode_uri_1 = require_umd();
      var featureWorkers_1 = require_featureWorkers();
      function transformDocumentLinkTarget(_target, context) {
        let target = vscode_uri_1.URI.parse(_target);
        const decoded = context.decodeEmbeddedDocumentUri(target);
        if (!decoded) {
          return target;
        }
        const embeddedRange = target.fragment.match(/^L(\d+)(,(\d+))?(-L(\d+)(,(\d+))?)?$/);
        const sourceScript = context.language.scripts.get(decoded[0]);
        const virtualCode = sourceScript?.generated?.embeddedCodes.get(decoded[1]);
        target = decoded[0];
        if (embeddedRange && sourceScript && virtualCode) {
          const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
          for (const [sourceScript2, map4] of context.language.maps.forEach(virtualCode)) {
            if (!map4.mappings.some((mapping) => (0, language_core_1.isDocumentLinkEnabled)(mapping.data))) {
              continue;
            }
            const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
            const docs = [sourceDocument, embeddedDocument, map4];
            const startLine = Number(embeddedRange[1]) - 1;
            const startCharacter = Number(embeddedRange[3] ?? 1) - 1;
            if (embeddedRange[5] !== void 0) {
              const endLine = Number(embeddedRange[5]) - 1;
              const endCharacter = Number(embeddedRange[7] ?? 1) - 1;
              const sourceRange = (0, featureWorkers_1.getSourceRange)(docs, {
                start: { line: startLine, character: startCharacter },
                end: { line: endLine, character: endCharacter }
              });
              if (sourceRange) {
                target = target.with({
                  fragment: "L" + (sourceRange.start.line + 1) + "," + (sourceRange.start.character + 1) + "-L" + (sourceRange.end.line + 1) + "," + (sourceRange.end.character + 1)
                });
                break;
              }
            } else {
              let mapped = false;
              for (const sourcePos of (0, featureWorkers_1.getSourcePositions)(docs, { line: startLine, character: startCharacter })) {
                mapped = true;
                target = target.with({
                  fragment: "L" + (sourcePos.line + 1) + "," + (sourcePos.character + 1)
                });
                break;
              }
              if (mapped) {
                break;
              }
            }
          }
        }
        return target;
      }
      function transformMarkdown(content3, context) {
        return content3.replace(/(?!\()volar-embedded-content:\/\/\w+\/[^)]+/g, (match) => {
          const segments = match.split("|");
          segments[0] = transformDocumentLinkTarget(segments[0], context).toString();
          return segments.join("|");
        });
      }
      function transformCompletionItem(item, getOtherRange, document5, context) {
        return {
          ...item,
          additionalTextEdits: item.additionalTextEdits?.map((edit) => transformTextEdit(edit, getOtherRange, document5)).filter((edit) => !!edit),
          textEdit: item.textEdit ? transformTextEdit(item.textEdit, getOtherRange, document5) : void 0,
          documentation: item.documentation ? typeof item.documentation === "string" ? transformMarkdown(item.documentation, context) : item.documentation.kind === "markdown" ? { kind: "markdown", value: transformMarkdown(item.documentation.value, context) } : item.documentation : void 0
        };
      }
      function transformCompletionList(completionList, getOtherRange, document5, context) {
        return {
          isIncomplete: completionList.isIncomplete,
          itemDefaults: completionList.itemDefaults ? {
            ...completionList.itemDefaults,
            editRange: completionList.itemDefaults.editRange ? "replace" in completionList.itemDefaults.editRange ? {
              insert: getOtherRange(completionList.itemDefaults.editRange.insert),
              replace: getOtherRange(completionList.itemDefaults.editRange.replace)
            } : getOtherRange(completionList.itemDefaults.editRange) : void 0
          } : void 0,
          items: completionList.items.map((item) => transformCompletionItem(item, getOtherRange, document5, context))
        };
      }
      function transformDocumentSymbol(symbol, getOtherRange) {
        const range = getOtherRange(symbol.range);
        if (!range) {
          return;
        }
        const selectionRange = getOtherRange(symbol.selectionRange);
        if (!selectionRange) {
          return;
        }
        return {
          ...symbol,
          range,
          selectionRange,
          children: symbol.children?.map((child) => transformDocumentSymbol(child, getOtherRange)).filter((child) => !!child)
        };
      }
      function transformFoldingRanges(ranges, getOtherRange) {
        const result = [];
        for (const range of ranges) {
          const otherRange = getOtherRange({
            start: { line: range.startLine, character: range.startCharacter ?? 0 },
            end: { line: range.endLine, character: range.endCharacter ?? 0 }
          });
          if (otherRange) {
            range.startLine = otherRange.start.line;
            range.endLine = otherRange.end.line;
            if (range.startCharacter !== void 0) {
              range.startCharacter = otherRange.start.character;
            }
            if (range.endCharacter !== void 0) {
              range.endCharacter = otherRange.end.character;
            }
            result.push(range);
          }
        }
        return result;
      }
      function transformHover(hover, getOtherRange) {
        if (!hover?.range) {
          return hover;
        }
        const range = getOtherRange(hover.range);
        if (!range) {
          return;
        }
        return {
          ...hover,
          range
        };
      }
      function transformLocation(location, getOtherRange) {
        const range = getOtherRange(location.range);
        if (!range) {
          return;
        }
        return {
          ...location,
          range
        };
      }
      function transformLocations(locations, getOtherRange) {
        return locations.map((location) => transformLocation(location, getOtherRange)).filter((location) => !!location);
      }
      function transformSelectionRange(location, getOtherRange) {
        const range = getOtherRange(location.range);
        if (!range) {
          return;
        }
        const parent = location.parent ? transformSelectionRange(location.parent, getOtherRange) : void 0;
        return {
          range,
          parent
        };
      }
      function transformSelectionRanges(locations, getOtherRange) {
        return locations.map((location) => transformSelectionRange(location, getOtherRange)).filter((location) => !!location);
      }
      function transformTextEdit(textEdit, getOtherRange, document5) {
        if ("range" in textEdit) {
          let range = getOtherRange(textEdit.range);
          if (range) {
            return {
              ...textEdit,
              range
            };
          }
          ;
          const cover = tryRecoverTextEdit(getOtherRange, textEdit.range, textEdit.newText, document5);
          if (cover) {
            return {
              ...textEdit,
              range: cover.range,
              newText: cover.newText
            };
          }
        } else if ("replace" in textEdit && "insert" in textEdit) {
          const insert = getOtherRange(textEdit.insert);
          const replace = insert ? getOtherRange(textEdit.replace) : void 0;
          if (insert && replace) {
            return {
              ...textEdit,
              insert,
              replace
            };
          }
          const recoverInsert = tryRecoverTextEdit(getOtherRange, textEdit.insert, textEdit.newText, document5);
          const recoverReplace = recoverInsert ? tryRecoverTextEdit(getOtherRange, textEdit.replace, textEdit.newText, document5) : void 0;
          if (recoverInsert && recoverReplace && recoverInsert.newText === recoverReplace.newText) {
            return {
              ...textEdit,
              insert: recoverInsert.range,
              replace: recoverReplace.range,
              newText: recoverInsert.newText
            };
          }
        }
      }
      function tryRecoverTextEdit(getOtherRange, replaceRange, newText, document5) {
        if (replaceRange.start.line === replaceRange.end.line && replaceRange.end.character > replaceRange.start.character) {
          let character = replaceRange.start.character;
          while (newText.length && replaceRange.end.character > character) {
            const newStart = { line: replaceRange.start.line, character: replaceRange.start.character + 1 };
            if (document5.getText({ start: replaceRange.start, end: newStart }) === newText[0]) {
              newText = newText.slice(1);
              character++;
              const otherRange = getOtherRange({ start: newStart, end: replaceRange.end });
              if (otherRange) {
                return {
                  newText,
                  range: otherRange
                };
              }
            } else {
              break;
            }
          }
        }
      }
      function transformWorkspaceSymbol(symbol, getOtherLocation) {
        if (!("range" in symbol.location)) {
          return symbol;
        }
        const loc = getOtherLocation(symbol.location);
        if (!loc) {
          return;
        }
        return {
          ...symbol,
          location: loc
        };
      }
      function transformWorkspaceEdit(edit, context, mode, versions = {}) {
        const sourceResult = {};
        let hasResult = false;
        for (const tsUri in edit.changeAnnotations) {
          sourceResult.changeAnnotations ??= {};
          const tsAnno = edit.changeAnnotations[tsUri];
          const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsUri));
          const sourceScript = decoded && context.language.scripts.get(decoded[0]);
          const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
          if (sourceScript && virtualCode) {
            for (const [sourceScript2] of context.language.maps.forEach(virtualCode)) {
              const uri = sourceScript2.id.toString();
              sourceResult.changeAnnotations[uri] = tsAnno;
              break;
            }
          } else {
            sourceResult.changeAnnotations[tsUri] = tsAnno;
          }
        }
        for (const tsUri in edit.changes) {
          sourceResult.changes ??= {};
          const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsUri));
          const sourceScript = decoded && context.language.scripts.get(decoded[0]);
          const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
          if (sourceScript && virtualCode) {
            const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
            for (const [sourceScript2, map4] of context.language.maps.forEach(virtualCode)) {
              const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
              const docs = [sourceDocument, embeddedDocument, map4];
              const tsEdits = edit.changes[tsUri];
              for (const tsEdit of tsEdits) {
                if (mode === "rename" || mode === "fileName" || mode === "codeAction") {
                  let _data;
                  const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range, (data2) => {
                    _data = data2;
                    return (0, language_core_1.isRenameEnabled)(data2);
                  });
                  if (range) {
                    sourceResult.changes[sourceDocument.uri] ??= [];
                    sourceResult.changes[sourceDocument.uri].push({
                      newText: (0, language_core_1.resolveRenameEditText)(tsEdit.newText, _data),
                      range
                    });
                    hasResult = true;
                  }
                } else {
                  const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range);
                  if (range) {
                    sourceResult.changes[sourceDocument.uri] ??= [];
                    sourceResult.changes[sourceDocument.uri].push({ newText: tsEdit.newText, range });
                    hasResult = true;
                  }
                }
              }
            }
          } else {
            sourceResult.changes[tsUri] = edit.changes[tsUri];
            hasResult = true;
          }
        }
        if (edit.documentChanges) {
          for (const tsDocEdit of edit.documentChanges) {
            sourceResult.documentChanges ??= [];
            let sourceEdit;
            if ("textDocument" in tsDocEdit) {
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsDocEdit.textDocument.uri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              if (sourceScript && virtualCode) {
                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                for (const [sourceScript2, map4] of context.language.maps.forEach(virtualCode)) {
                  const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
                  const docs = [sourceDocument, embeddedDocument, map4];
                  sourceEdit = {
                    textDocument: {
                      uri: sourceDocument.uri,
                      version: versions[sourceDocument.uri] ?? null
                    },
                    edits: []
                  };
                  for (const tsEdit of tsDocEdit.edits) {
                    if (mode === "rename" || mode === "fileName" || mode === "codeAction") {
                      let _data;
                      const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range, (data2) => {
                        _data = data2;
                        return (0, language_core_1.isRenameEnabled)(data2);
                      });
                      if (range) {
                        sourceEdit.edits.push({
                          annotationId: "annotationId" in tsEdit ? tsEdit.annotationId : void 0,
                          newText: (0, language_core_1.resolveRenameEditText)(tsEdit.newText, _data),
                          range
                        });
                      }
                    } else {
                      const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range);
                      if (range) {
                        sourceEdit.edits.push({
                          annotationId: "annotationId" in tsEdit ? tsEdit.annotationId : void 0,
                          newText: tsEdit.newText,
                          range
                        });
                      }
                    }
                  }
                  if (!sourceEdit.edits.length) {
                    sourceEdit = void 0;
                  }
                }
              } else {
                sourceEdit = tsDocEdit;
              }
            } else if (tsDocEdit.kind === "create") {
              sourceEdit = tsDocEdit;
            } else if (tsDocEdit.kind === "rename") {
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsDocEdit.oldUri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              if (virtualCode) {
                for (const [sourceScript2] of context.language.maps.forEach(virtualCode)) {
                  sourceEdit = {
                    kind: "rename",
                    oldUri: sourceScript2.id.toString(),
                    newUri: tsDocEdit.newUri,
                    options: tsDocEdit.options,
                    annotationId: tsDocEdit.annotationId
                  };
                }
              } else {
                sourceEdit = tsDocEdit;
              }
            } else if (tsDocEdit.kind === "delete") {
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsDocEdit.uri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              if (virtualCode) {
                for (const [sourceScript2] of context.language.maps.forEach(virtualCode)) {
                  sourceEdit = {
                    kind: "delete",
                    uri: sourceScript2.id.toString(),
                    options: tsDocEdit.options,
                    annotationId: tsDocEdit.annotationId
                  };
                }
              } else {
                sourceEdit = tsDocEdit;
              }
            }
            if (sourceEdit) {
              pushEditToDocumentChanges(sourceResult.documentChanges, sourceEdit);
              hasResult = true;
            }
          }
        }
        if (hasResult) {
          return sourceResult;
        }
      }
      function pushEditToDocumentChanges(arr, item) {
        const current2 = arr.find((edit) => "textDocument" in edit && "textDocument" in item && edit.textDocument.uri === item.textDocument.uri);
        if (current2) {
          current2.edits.push(...item.edits);
        } else {
          arr.push(item);
        }
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideCodeActions.js
  var require_provideCodeActions = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideCodeActions.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var common_1 = require_common();
      var dedupe = require_dedupe();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return async (uri, range, codeActionContext, token = cancellation_1.NoneCancellationToken) => {
          const sourceScript = context.language.scripts.get(uri);
          if (!sourceScript) {
            return;
          }
          const transformedCodeActions = /* @__PURE__ */ new WeakSet();
          return await (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => ({ range, codeActionContext }), function* (docs) {
            const _codeActionContext = {
              diagnostics: (0, transform_1.transformLocations)(codeActionContext.diagnostics, (range2) => (0, featureWorkers_1.getGeneratedRange)(docs, range2)),
              only: codeActionContext.only
            };
            const mapped = (0, common_1.findOverlapCodeRange)(docs[0].offsetAt(range.start), docs[0].offsetAt(range.end), docs[2], language_core_1.isCodeActionsEnabled);
            if (mapped) {
              yield {
                range: {
                  start: docs[1].positionAt(mapped.start),
                  end: docs[1].positionAt(mapped.end)
                },
                codeActionContext: _codeActionContext
              };
            }
          }, async (plugin, document5, { range: range2, codeActionContext: codeActionContext2 }) => {
            if (token.isCancellationRequested) {
              return;
            }
            const pluginIndex = context.plugins.indexOf(plugin);
            const diagnostics = codeActionContext2.diagnostics.filter((diagnostic) => {
              const data2 = diagnostic.data;
              if (data2 && data2.version !== document5.version) {
                return false;
              }
              return data2?.pluginIndex === pluginIndex;
            }).map((diagnostic) => {
              const data2 = diagnostic.data;
              return {
                ...diagnostic,
                ...data2.original
              };
            });
            const codeActions = await plugin[1].provideCodeActions?.(document5, range2, {
              ...codeActionContext2,
              diagnostics
            }, token);
            codeActions?.forEach((codeAction) => {
              codeAction.data = {
                uri: uri.toString(),
                version: document5.version,
                original: {
                  data: codeAction.data,
                  edit: codeAction.edit
                },
                pluginIndex: context.plugins.indexOf(plugin)
              };
            });
            if (codeActions && plugin[1].transformCodeAction) {
              for (let i = 0; i < codeActions.length; i++) {
                const transformed = plugin[1].transformCodeAction(codeActions[i]);
                if (transformed) {
                  codeActions[i] = transformed;
                  transformedCodeActions.add(transformed);
                }
              }
            }
            return codeActions;
          }, (actions) => actions.map((action) => {
            if (transformedCodeActions.has(action)) {
              return action;
            }
            if (action.edit) {
              const edit = (0, transform_1.transformWorkspaceEdit)(action.edit, context, "codeAction");
              if (!edit) {
                return;
              }
              action.edit = edit;
            }
            return action;
          }).filter((action) => !!action), (arr) => dedupe.withCodeAction(arr.flat()));
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideCodeLenses.js
  var require_provideCodeLenses = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideCodeLenses.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return async (uri, token = cancellation_1.NoneCancellationToken) => {
          return await (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isCodeLensEnabled)(mapping.data)), async (plugin, document5) => {
            if (token.isCancellationRequested) {
              return;
            }
            let codeLens = await plugin[1].provideCodeLenses?.(document5, token);
            const pluginIndex = context.plugins.indexOf(plugin);
            codeLens?.forEach((codeLens2) => {
              codeLens2.data = {
                kind: "normal",
                uri: uri.toString(),
                original: {
                  data: codeLens2.data
                },
                pluginIndex
              };
            });
            const ranges = await plugin[1].provideReferencesCodeLensRanges?.(document5, token);
            const referencesCodeLens = ranges?.map((range) => ({
              range,
              data: {
                kind: "references",
                sourceFileUri: uri.toString(),
                workerFileUri: document5.uri,
                workerFileRange: range,
                pluginIndex
              }
            }));
            codeLens = [
              ...codeLens ?? [],
              ...referencesCodeLens ?? []
            ];
            return codeLens;
          }, (data2, docs) => {
            if (!docs) {
              return data2;
            }
            return data2.map((codeLens) => {
              const range = (0, featureWorkers_1.getSourceRange)(docs, codeLens.range, language_core_1.isCodeLensEnabled);
              if (range) {
                return {
                  ...codeLens,
                  range
                };
              }
            }).filter((codeLens) => !!codeLens);
          }, (arr) => arr.flat()) ?? [];
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideColorPresentations.js
  var require_provideColorPresentations = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideColorPresentations.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return (uri, color3, range, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, function* (docs) {
            for (const mappedRange of (0, featureWorkers_1.getGeneratedRanges)(docs, range, language_core_1.isColorEnabled)) {
              yield mappedRange;
            }
          }, (plugin, document5, range2) => {
            if (token.isCancellationRequested) {
              return;
            }
            return plugin[1].provideColorPresentations?.(document5, color3, range2, token);
          }, (data2, docs) => {
            if (!docs) {
              return data2;
            }
            return data2.map((colorPresentation) => {
              if (colorPresentation.textEdit) {
                const range2 = (0, featureWorkers_1.getSourceRange)(docs, colorPresentation.textEdit.range);
                if (!range2) {
                  return void 0;
                }
                colorPresentation.textEdit.range = range2;
              }
              if (colorPresentation.additionalTextEdits) {
                for (const textEdit of colorPresentation.additionalTextEdits) {
                  const range2 = (0, featureWorkers_1.getSourceRange)(docs, textEdit.range);
                  if (!range2) {
                    return void 0;
                  }
                  textEdit.range = range2;
                }
              }
              return colorPresentation;
            }).filter((colorPresentation) => !!colorPresentation);
          });
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideCompletionItems.js
  var require_provideCompletionItems = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideCompletionItems.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        let lastResult;
        return async (uri, position4, completionContext = { triggerKind: 1 }, token = cancellation_1.NoneCancellationToken) => {
          let langaugeIdAndSnapshot;
          let sourceScript;
          const decoded = context.decodeEmbeddedDocumentUri(uri);
          if (decoded) {
            langaugeIdAndSnapshot = context.language.scripts.get(decoded[0])?.generated?.embeddedCodes.get(decoded[1]);
          } else {
            sourceScript = context.language.scripts.get(uri);
            langaugeIdAndSnapshot = sourceScript;
          }
          if (!langaugeIdAndSnapshot) {
            return {
              isIncomplete: false,
              items: []
            };
          }
          if (completionContext?.triggerKind === 3 && lastResult?.uri.toString() === uri.toString()) {
            for (const cacheData of lastResult.results) {
              if (!cacheData.list?.isIncomplete) {
                continue;
              }
              const pluginIndex = context.plugins.findIndex((plugin) => plugin[1] === cacheData.plugin);
              if (cacheData.embeddedDocumentUri) {
                const decoded2 = context.decodeEmbeddedDocumentUri(cacheData.embeddedDocumentUri);
                const sourceScript2 = decoded2 && context.language.scripts.get(decoded2[0]);
                const virtualCode = decoded2 && sourceScript2?.generated?.embeddedCodes.get(decoded2[1]);
                if (!sourceScript2 || !virtualCode) {
                  continue;
                }
                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript2.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                for (const [sourceScript3, map4] of context.language.maps.forEach(virtualCode)) {
                  const sourceDocument = context.documents.get(sourceScript3.id, sourceScript3.languageId, sourceScript3.snapshot);
                  const docs = [sourceDocument, embeddedDocument, map4];
                  for (const mapped of (0, featureWorkers_1.getGeneratedPositions)(docs, position4, (data2) => (0, language_core_1.isCompletionEnabled)(data2))) {
                    if (!cacheData.plugin.provideCompletionItems) {
                      continue;
                    }
                    cacheData.list = await cacheData.plugin.provideCompletionItems(embeddedDocument, mapped, completionContext, token);
                    if (!cacheData.list) {
                      continue;
                    }
                    for (const item of cacheData.list.items) {
                      item.data = {
                        uri: uri.toString(),
                        original: {
                          additionalTextEdits: item.additionalTextEdits,
                          textEdit: item.textEdit,
                          data: item.data
                        },
                        pluginIndex,
                        embeddedDocumentUri: embeddedDocument.uri
                      };
                    }
                    cacheData.list = (0, transform_1.transformCompletionList)(cacheData.list, (range) => (0, featureWorkers_1.getSourceRange)(docs, range), embeddedDocument, context);
                  }
                }
              } else {
                if (!cacheData.plugin.provideCompletionItems) {
                  continue;
                }
                const document5 = context.documents.get(uri, langaugeIdAndSnapshot.languageId, langaugeIdAndSnapshot.snapshot);
                cacheData.list = await cacheData.plugin.provideCompletionItems(document5, position4, completionContext, token);
                if (!cacheData.list) {
                  continue;
                }
                for (const item of cacheData.list.items) {
                  item.data = {
                    uri: uri.toString(),
                    original: {
                      additionalTextEdits: item.additionalTextEdits,
                      textEdit: item.textEdit,
                      data: item.data
                    },
                    pluginIndex,
                    embeddedDocumentUri: void 0
                  };
                }
              }
            }
          } else {
            lastResult = {
              uri,
              results: []
            };
            let isFirstMapping = true;
            let mainCompletionUri;
            const sortedPlugins = [...context.plugins].filter((plugin) => !context.disabledServicePlugins.has(plugin[1])).sort((a, b) => sortServices(a[1], b[1]));
            const worker = async (document5, position5, docs, codeInfo) => {
              for (const plugin of sortedPlugins) {
                if (token.isCancellationRequested) {
                  break;
                }
                if (!plugin[1].provideCompletionItems) {
                  continue;
                }
                if (plugin[1].isAdditionalCompletion && !isFirstMapping) {
                  continue;
                }
                if (completionContext?.triggerCharacter && !plugin[0].capabilities.completionProvider?.triggerCharacters?.includes(completionContext.triggerCharacter)) {
                  continue;
                }
                const isAdditional = codeInfo && typeof codeInfo.completion === "object" && codeInfo.completion.isAdditional || plugin[1].isAdditionalCompletion;
                if (mainCompletionUri && (!isAdditional || mainCompletionUri !== document5.uri)) {
                  continue;
                }
                if (plugin[1].isAdditionalCompletion && lastResult?.results.some((data2) => data2.plugin === plugin[1])) {
                  continue;
                }
                let completionList = await plugin[1].provideCompletionItems(document5, position5, completionContext, token);
                if (!completionList || !completionList.items.length) {
                  continue;
                }
                if (typeof codeInfo?.completion === "object" && codeInfo.completion.onlyImport) {
                  completionList.items = completionList.items.filter((item) => !!item.labelDetails);
                }
                if (!isAdditional) {
                  mainCompletionUri = document5.uri;
                }
                const pluginIndex = context.plugins.indexOf(plugin);
                for (const item of completionList.items) {
                  item.data = {
                    uri: uri.toString(),
                    original: {
                      additionalTextEdits: item.additionalTextEdits,
                      textEdit: item.textEdit,
                      data: item.data
                    },
                    pluginIndex,
                    embeddedDocumentUri: docs ? document5.uri : void 0
                  };
                }
                if (docs) {
                  completionList = (0, transform_1.transformCompletionList)(completionList, (range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isCompletionEnabled), document5, context);
                }
                lastResult?.results.push({
                  embeddedDocumentUri: docs ? vscode_uri_1.URI.parse(document5.uri) : void 0,
                  plugin: plugin[1],
                  list: completionList
                });
              }
              isFirstMapping = false;
            };
            if (sourceScript?.generated) {
              for (const docs of (0, featureWorkers_1.forEachEmbeddedDocument)(context, sourceScript, sourceScript.generated.root)) {
                let _data;
                for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position4, (data2) => {
                  _data = data2;
                  return (0, language_core_1.isCompletionEnabled)(data2);
                })) {
                  await worker(docs[1], mappedPosition, docs, _data);
                }
              }
            } else {
              const document5 = context.documents.get(uri, langaugeIdAndSnapshot.languageId, langaugeIdAndSnapshot.snapshot);
              await worker(document5, position4);
            }
          }
          return combineCompletionList(lastResult.results.map((cacheData) => cacheData.list));
          function sortServices(a, b) {
            return (b.isAdditionalCompletion ? -1 : 1) - (a.isAdditionalCompletion ? -1 : 1);
          }
          function combineCompletionList(lists) {
            return {
              isIncomplete: lists.some((list4) => list4?.isIncomplete),
              itemDefaults: lists.find((list4) => list4?.itemDefaults)?.itemDefaults,
              items: lists.map((list4) => list4?.items ?? []).flat()
            };
          }
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideDefinition.js
  var require_provideDefinition = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideDefinition.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var dedupe = require_dedupe();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context, apiName, isValidPosition) {
        return (uri, position4, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position4, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position4, isValidPosition), async (plugin, document5, position5) => {
            if (token.isCancellationRequested) {
              return;
            }
            const recursiveChecker = dedupe.createLocationSet();
            const result = [];
            await withLinkedCode(document5, position5, void 0);
            return result;
            async function withLinkedCode(document6, position6, originDefinition) {
              const api = plugin[1][apiName];
              if (!api) {
                return;
              }
              if (recursiveChecker.has({ uri: document6.uri, range: { start: position6, end: position6 } })) {
                return;
              }
              recursiveChecker.add({ uri: document6.uri, range: { start: position6, end: position6 } });
              const definitions = await api?.(document6, position6, token) ?? [];
              for (const definition3 of definitions) {
                let foundMirrorPosition = false;
                recursiveChecker.add({ uri: definition3.targetUri, range: { start: definition3.targetRange.start, end: definition3.targetRange.start } });
                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(definition3.targetUri));
                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                const linkedCodeMap = virtualCode && sourceScript ? context.language.linkedCodeMaps.get(virtualCode) : void 0;
                if (sourceScript && virtualCode && linkedCodeMap) {
                  const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                  for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, definition3.targetSelectionRange.start)) {
                    if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
                      continue;
                    }
                    foundMirrorPosition = true;
                    await withLinkedCode(embeddedDocument, linkedPos, originDefinition ?? definition3);
                  }
                }
                if (!foundMirrorPosition) {
                  if (originDefinition) {
                    result.push({
                      ...definition3,
                      originSelectionRange: originDefinition.originSelectionRange
                    });
                  } else {
                    result.push(definition3);
                  }
                }
              }
            }
          }, (data2, map4) => data2.map((link2) => {
            if (link2.originSelectionRange && map4) {
              const originSelectionRange = toSourcePositionPreferSurroundedPosition(map4, link2.originSelectionRange, position4);
              if (!originSelectionRange) {
                return;
              }
              link2.originSelectionRange = originSelectionRange;
            }
            let foundTargetSelectionRange = false;
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(link2.targetUri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const targetVirtualFile = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (sourceScript && targetVirtualFile) {
              const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, targetVirtualFile.id), targetVirtualFile.languageId, targetVirtualFile.snapshot);
              for (const [targetScript, targetSourceMap] of context.language.maps.forEach(targetVirtualFile)) {
                const sourceDocument = context.documents.get(targetScript.id, targetScript.languageId, targetScript.snapshot);
                const docs = [sourceDocument, embeddedDocument, targetSourceMap];
                const targetSelectionRange = (0, featureWorkers_1.getSourceRange)(docs, link2.targetSelectionRange);
                if (!targetSelectionRange) {
                  continue;
                }
                foundTargetSelectionRange = true;
                let targetRange = (0, featureWorkers_1.getSourceRange)(docs, link2.targetRange);
                link2.targetUri = sourceDocument.uri;
                link2.targetRange = targetRange ?? targetSelectionRange;
                link2.targetSelectionRange = targetSelectionRange;
              }
              if (apiName === "provideDefinition" && !foundTargetSelectionRange) {
                for (const [targetScript] of context.language.maps.forEach(targetVirtualFile)) {
                  if (targetScript.id.toString() !== uri.toString()) {
                    return {
                      ...link2,
                      targetUri: targetScript.id.toString(),
                      targetRange: {
                        start: { line: 0, character: 0 },
                        end: { line: 0, character: 0 }
                      },
                      targetSelectionRange: {
                        start: { line: 0, character: 0 },
                        end: { line: 0, character: 0 }
                      }
                    };
                  }
                }
                return;
              }
            }
            return link2;
          }).filter((link2) => !!link2), (arr) => dedupe.withLocationLinks(arr.flat()));
        };
      }
      function toSourcePositionPreferSurroundedPosition(docs, mappedRange, position4) {
        let result;
        for (const range of (0, featureWorkers_1.getSourceRanges)(docs, mappedRange)) {
          if (!result) {
            result = range;
          }
          if ((range.start.line < position4.line || range.start.line === position4.line && range.start.character <= position4.character) && (range.end.line > position4.line || range.end.line === position4.line && range.end.character >= position4.character)) {
            return range;
          }
        }
        return result;
      }
    }
  });

  // node_modules/@volar/language-service/lib/utils/uriMap.js
  var require_uriMap = __commonJS({
    "node_modules/@volar/language-service/lib/utils/uriMap.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createUriMap = createUriMap2;
      function createUriMap2(caseSensitive = false) {
        const map4 = /* @__PURE__ */ new Map();
        const rawUriToNormalizedUri = /* @__PURE__ */ new Map();
        const normalizedUriToRawUri = /* @__PURE__ */ new Map();
        return {
          get size() {
            return map4.size;
          },
          get [Symbol.toStringTag]() {
            return "UriMap";
          },
          [Symbol.iterator]() {
            return this.entries();
          },
          clear() {
            rawUriToNormalizedUri.clear();
            normalizedUriToRawUri.clear();
            return map4.clear();
          },
          values() {
            return map4.values();
          },
          *keys() {
            for (const normalizedUri of map4.keys()) {
              yield normalizedUriToRawUri.get(normalizedUri);
            }
          },
          *entries() {
            for (const [normalizedUri, item] of map4.entries()) {
              yield [normalizedUriToRawUri.get(normalizedUri), item];
            }
          },
          forEach(callbackfn, thisArg) {
            for (const [uri, item] of this.entries()) {
              callbackfn.call(thisArg, item, uri, this);
            }
          },
          delete(uri) {
            return map4.delete(toKey(uri));
          },
          get(uri) {
            return map4.get(toKey(uri));
          },
          has(uri) {
            return map4.has(toKey(uri));
          },
          set(uri, item) {
            map4.set(toKey(uri), item);
            return this;
          }
        };
        function toKey(uri) {
          const rawUri = uri.toString();
          if (!rawUriToNormalizedUri.has(rawUri)) {
            let normalizedUri = uri.toString();
            if (!caseSensitive) {
              normalizedUri = normalizedUri.toLowerCase();
            }
            rawUriToNormalizedUri.set(rawUri, normalizedUri);
            normalizedUriToRawUri.set(normalizedUri, uri);
          }
          return rawUriToNormalizedUri.get(rawUri);
        }
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideDiagnostics.js
  var require_provideDiagnostics = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideDiagnostics.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.errorMarkups = void 0;
      exports3.updateRange = updateRange;
      exports3.register = register2;
      exports3.transformDiagnostic = transformDiagnostic;
      var language_core_1 = require_language_core();
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var common_1 = require_common();
      var dedupe = require_dedupe();
      var featureWorkers_1 = require_featureWorkers();
      var uriMap_1 = require_uriMap();
      function updateRange(range, change) {
        if (!updatePosition(range.start, change, false)) {
          return;
        }
        if (!updatePosition(range.end, change, true)) {
          return;
        }
        if (range.end.line === range.start.line && range.end.character <= range.start.character) {
          range.end.character++;
        }
        return range;
      }
      function updatePosition(position4, change, isEnd) {
        if (change.range.end.line > position4.line) {
          if (change.newEnd.line > position4.line) {
            return true;
          } else if (change.newEnd.line === position4.line) {
            position4.character = Math.min(position4.character, change.newEnd.character);
            return true;
          } else if (change.newEnd.line < position4.line) {
            position4.line = change.newEnd.line;
            position4.character = change.newEnd.character;
            return true;
          }
        } else if (change.range.end.line === position4.line) {
          const characterDiff = change.newEnd.character - change.range.end.character;
          if (position4.character >= change.range.end.character) {
            if (change.newEnd.line !== change.range.end.line) {
              position4.line = change.newEnd.line;
              position4.character = change.newEnd.character + position4.character - change.range.end.character;
            } else {
              if (isEnd ? change.range.end.character < position4.character : change.range.end.character <= position4.character) {
                position4.character += characterDiff;
              } else {
                const offset2 = change.range.end.character - position4.character;
                if (-characterDiff > offset2) {
                  position4.character += characterDiff + offset2;
                }
              }
            }
            return true;
          } else {
            if (change.newEnd.line === change.range.end.line) {
              const offset2 = change.range.end.character - position4.character;
              if (-characterDiff > offset2) {
                position4.character += characterDiff + offset2;
              }
            } else if (change.newEnd.line < change.range.end.line) {
              position4.line = change.newEnd.line;
              position4.character = change.newEnd.character;
            } else {
            }
            return true;
          }
        } else if (change.range.end.line < position4.line) {
          position4.line += change.newEnd.line - change.range.end.line;
          return true;
        }
        return false;
      }
      exports3.errorMarkups = (0, uriMap_1.createUriMap)();
      function register2(context) {
        const lastResponses = (0, uriMap_1.createUriMap)();
        const cacheMaps = {
          semantic: /* @__PURE__ */ new Map(),
          syntactic: /* @__PURE__ */ new Map()
        };
        context.env.onDidChangeConfiguration?.(() => {
          lastResponses.clear();
          cacheMaps.semantic.clear();
          cacheMaps.syntactic.clear();
        });
        return async (uri, response, token = cancellation_1.NoneCancellationToken) => {
          let langaugeIdAndSnapshot;
          const decoded = context.decodeEmbeddedDocumentUri(uri);
          if (decoded) {
            langaugeIdAndSnapshot = context.language.scripts.get(decoded[0])?.generated?.embeddedCodes.get(decoded[1]);
          } else {
            langaugeIdAndSnapshot = context.language.scripts.get(uri);
          }
          if (!langaugeIdAndSnapshot) {
            return [];
          }
          const document5 = context.documents.get(uri, langaugeIdAndSnapshot.languageId, langaugeIdAndSnapshot.snapshot);
          const lastResponse = lastResponses.get(uri) ?? lastResponses.set(uri, {
            semantic: { errors: [] },
            syntactic: { errors: [] }
          }).get(uri);
          let updateCacheRangeFailed = false;
          let errorsUpdated = false;
          let lastCheckCancelAt = 0;
          for (const cache of Object.values(lastResponse)) {
            const oldSnapshot = cache.snapshot;
            const oldDocument = cache.document;
            const change = oldSnapshot ? langaugeIdAndSnapshot.snapshot.getChangeRange(oldSnapshot) : void 0;
            cache.snapshot = langaugeIdAndSnapshot.snapshot;
            cache.document = document5;
            if (!updateCacheRangeFailed && oldDocument && change) {
              const changeRange = {
                range: {
                  start: oldDocument.positionAt(change.span.start),
                  end: oldDocument.positionAt(change.span.start + change.span.length)
                },
                newEnd: document5.positionAt(change.span.start + change.newLength)
              };
              for (const error of cache.errors) {
                if (!updateRange(error.range, changeRange)) {
                  updateCacheRangeFailed = true;
                  break;
                }
              }
            }
          }
          await worker("provideDiagnostics", cacheMaps.syntactic, lastResponse.syntactic);
          await doResponse();
          await worker("provideSemanticDiagnostics", cacheMaps.semantic, lastResponse.semantic);
          return collectErrors();
          function doResponse() {
            if (errorsUpdated && !updateCacheRangeFailed) {
              response?.(collectErrors());
              errorsUpdated = false;
            }
          }
          function collectErrors() {
            return Object.values(lastResponse).flatMap(({ errors }) => errors);
          }
          async function worker(api, cacheMap, cache) {
            const result = await (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isDiagnosticsEnabled)(mapping.data)), async (plugin, document6) => {
              if (Date.now() - lastCheckCancelAt >= 10) {
                await (0, common_1.sleep)(10);
                lastCheckCancelAt = Date.now();
              }
              if (token.isCancellationRequested) {
                return;
              }
              const pluginIndex = context.plugins.indexOf(plugin);
              const pluginCache = cacheMap.get(pluginIndex) ?? cacheMap.set(pluginIndex, /* @__PURE__ */ new Map()).get(pluginIndex);
              const cache2 = pluginCache.get(document6.uri);
              if (api !== "provideSemanticDiagnostics" && cache2 && cache2.documentVersion === document6.version) {
                return cache2.errors;
              }
              const errors = await plugin[1][api]?.(document6, token) || [];
              errors.forEach((error) => {
                error.data = {
                  uri: uri.toString(),
                  version: document6.version,
                  pluginIndex,
                  isFormat: false,
                  original: {
                    data: error.data
                  },
                  documentUri: document6.uri
                };
              });
              errorsUpdated = true;
              pluginCache.set(document6.uri, {
                documentVersion: document6.version,
                errors
              });
              return errors;
            }, (errors, map4) => {
              return errors.map((error) => transformDiagnostic(context, error, map4, language_core_1.shouldReportDiagnostics)).filter((error) => !!error);
            }, (arr) => dedupe.withDiagnostics(arr.flat()));
            if (result) {
              cache.errors = result;
              cache.snapshot = langaugeIdAndSnapshot?.snapshot;
            }
          }
        };
      }
      function transformDiagnostic(context, error, docs, filter) {
        let _error = { ...error };
        if (docs) {
          const range = (0, featureWorkers_1.getSourceRange)(docs, error.range, filter);
          if (!range) {
            return;
          }
          _error.range = range;
        }
        if (_error.relatedInformation) {
          const relatedInfos = [];
          for (const info of _error.relatedInformation) {
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(info.location.uri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (sourceScript && virtualCode) {
              const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
              for (const [sourceScript2, map4] of context.language.maps.forEach(virtualCode)) {
                const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
                const docs2 = [sourceDocument, embeddedDocument, map4];
                const range = (0, featureWorkers_1.getSourceRange)(docs2, info.location.range, filter);
                if (range) {
                  relatedInfos.push({
                    location: {
                      uri: sourceDocument.uri,
                      range
                    },
                    message: info.message
                  });
                }
              }
            } else {
              relatedInfos.push(info);
            }
          }
          _error.relatedInformation = relatedInfos;
        }
        return _error;
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideDocumentColors.js
  var require_provideDocumentColors = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideDocumentColors.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return (uri, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isColorEnabled)(mapping.data)), (plugin, document5) => {
            if (token.isCancellationRequested) {
              return;
            }
            return plugin[1].provideDocumentColors?.(document5, token);
          }, (data2, docs) => {
            if (!docs) {
              return data2;
            }
            return data2.map((color3) => {
              const range = (0, featureWorkers_1.getSourceRange)(docs, color3.range, language_core_1.isColorEnabled);
              if (range) {
                return {
                  range,
                  color: color3.color
                };
              }
            }).filter((color3) => !!color3);
          }, (arr) => arr.flat());
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideDocumentDropEdits.js
  var require_provideDocumentDropEdits = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideDocumentDropEdits.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return (uri, position4, dataTransfer, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position4, function* (docs) {
            for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position4)) {
              yield mappedPosition;
            }
          }, (plugin, document5, arg) => {
            if (token.isCancellationRequested) {
              return;
            }
            return plugin[1].provideDocumentDropEdits?.(document5, arg, dataTransfer, token);
          }, (edit) => {
            if (edit.additionalEdit) {
              edit.additionalEdit = (0, transform_1.transformWorkspaceEdit)(edit.additionalEdit, context, void 0);
            }
            return edit;
          });
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideDocumentFormattingEdits.js
  var require_provideDocumentFormattingEdits = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideDocumentFormattingEdits.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var common_1 = require_common();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return async (uri, options, range, onTypeParams, token = cancellation_1.NoneCancellationToken) => {
          const sourceScript = context.language.scripts.get(uri);
          if (!sourceScript) {
            return;
          }
          let document5 = context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
          range ??= {
            start: document5.positionAt(0),
            end: document5.positionAt(document5.getText().length)
          };
          if (!sourceScript.generated) {
            return onTypeParams ? (await tryFormat(document5, document5, sourceScript, void 0, 0, onTypeParams.position, onTypeParams.ch))?.edits : (await tryFormat(document5, document5, sourceScript, void 0, 0, range, void 0))?.edits;
          }
          const embeddedRanges = /* @__PURE__ */ new Map();
          const startOffset = document5.offsetAt(range.start);
          const endOffset = document5.offsetAt(range.end);
          for (const code2 of (0, language_core_1.forEachEmbeddedCode)(sourceScript.generated.root)) {
            const map4 = context.language.maps.get(code2, sourceScript);
            if (map4) {
              const embeddedRange = (0, common_1.findOverlapCodeRange)(startOffset, endOffset, map4, language_core_1.isFormattingEnabled);
              if (embeddedRange) {
                if (embeddedRange.start === map4.mappings[0].generatedOffsets[0]) {
                  embeddedRange.start = 0;
                }
                const lastMapping = map4.mappings[map4.mappings.length - 1];
                if (embeddedRange.end === lastMapping.generatedOffsets[lastMapping.generatedOffsets.length - 1] + (lastMapping.generatedLengths ?? lastMapping.lengths)[lastMapping.lengths.length - 1]) {
                  embeddedRange.end = code2.snapshot.getLength();
                }
                embeddedRanges.set(code2.id, embeddedRange);
              }
            }
          }
          try {
            const originalDocument = document5;
            let tempSourceSnapshot = sourceScript.snapshot;
            let tempVirtualFile = context.language.scripts.set(vscode_uri_1.URI.parse(sourceScript.id.toString() + ".tmp"), sourceScript.snapshot, sourceScript.languageId, [sourceScript.generated.languagePlugin])?.generated?.root;
            if (!tempVirtualFile) {
              return;
            }
            let currentCodes = [];
            for (let depth = 0; (currentCodes = getNestedEmbeddedFiles(context, sourceScript.id, tempVirtualFile, depth)).length > 0; depth++) {
              let edits = [];
              for (const code2 of currentCodes) {
                if (!code2.mappings.some((mapping) => (0, language_core_1.isFormattingEnabled)(mapping.data))) {
                  continue;
                }
                const currentRange = embeddedRanges.get(code2.id);
                if (!currentRange) {
                  continue;
                }
                const isChildRange = [...(0, language_core_1.forEachEmbeddedCode)(code2)].some((child) => {
                  if (child === code2) {
                    return false;
                  }
                  const childRange = embeddedRanges.get(child.id);
                  return childRange && childRange.end - childRange.start >= currentRange.end - currentRange.start;
                });
                if (isChildRange) {
                  continue;
                }
                const docs = [
                  context.documents.get(uri, sourceScript.languageId, tempSourceSnapshot),
                  context.documents.get(context.encodeEmbeddedDocumentUri(uri, code2.id), code2.languageId, code2.snapshot),
                  context.language.mapperFactory(code2.mappings)
                ];
                let embeddedResult;
                if (onTypeParams) {
                  for (const embeddedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, onTypeParams.position)) {
                    embeddedResult = await tryFormat(docs[0], docs[1], sourceScript, code2, depth, embeddedPosition, onTypeParams.ch);
                    break;
                  }
                } else if (currentRange) {
                  embeddedResult = await tryFormat(docs[0], docs[1], sourceScript, code2, depth, {
                    start: docs[1].positionAt(currentRange.start),
                    end: docs[1].positionAt(currentRange.end)
                  });
                }
                if (!embeddedResult) {
                  continue;
                }
                for (const textEdit2 of embeddedResult.edits) {
                  const range2 = (0, featureWorkers_1.getSourceRange)(docs, textEdit2.range);
                  if (range2) {
                    edits.push({
                      newText: textEdit2.newText,
                      range: range2
                    });
                  }
                }
              }
              if (edits.length > 0) {
                const newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document5, edits);
                document5 = vscode_languageserver_textdocument_1.TextDocument.create(document5.uri, document5.languageId, document5.version + 1, newText);
                tempSourceSnapshot = (0, common_1.stringToSnapshot)(newText);
                tempVirtualFile = context.language.scripts.set(vscode_uri_1.URI.parse(sourceScript.id.toString() + ".tmp"), tempSourceSnapshot, sourceScript.languageId, [sourceScript.generated.languagePlugin])?.generated?.root;
                if (!tempVirtualFile) {
                  break;
                }
              }
            }
            if (document5.getText() === originalDocument.getText()) {
              return;
            }
            const editRange = {
              start: originalDocument.positionAt(0),
              end: originalDocument.positionAt(originalDocument.getText().length)
            };
            const textEdit = {
              range: editRange,
              newText: document5.getText()
            };
            return [textEdit];
          } finally {
            context.language.scripts.delete(vscode_uri_1.URI.parse(sourceScript.id.toString() + ".tmp"));
          }
          async function tryFormat(sourceDocument, document6, sourceScript2, virtualCode, embeddedLevel, rangeOrPosition, ch) {
            if (context.disabledEmbeddedDocumentUris.get(vscode_uri_1.URI.parse(document6.uri))) {
              return;
            }
            let codeOptions;
            rangeOrPosition ??= {
              start: document6.positionAt(0),
              end: document6.positionAt(document6.getText().length)
            };
            if (virtualCode) {
              codeOptions = {
                level: embeddedLevel,
                initialIndentLevel: 0
              };
              if (virtualCode.mappings.length) {
                const firstMapping = virtualCode.mappings[0];
                const startOffset2 = firstMapping.sourceOffsets[0];
                const startPosition = sourceDocument.positionAt(startOffset2);
                codeOptions.initialIndentLevel = computeInitialIndent(sourceDocument.getText(), sourceDocument.offsetAt({ line: startPosition.line, character: 0 }), options);
              }
              for (const plugin of context.plugins) {
                if (context.disabledServicePlugins.has(plugin[1])) {
                  continue;
                }
                codeOptions = await plugin[1].resolveEmbeddedCodeFormattingOptions?.(sourceScript2, virtualCode, codeOptions, token) ?? codeOptions;
              }
            }
            for (const plugin of context.plugins) {
              if (context.disabledServicePlugins.has(plugin[1])) {
                continue;
              }
              if (token.isCancellationRequested) {
                break;
              }
              let edits;
              try {
                if (ch !== void 0 && rangeOrPosition && "line" in rangeOrPosition && "character" in rangeOrPosition) {
                  if (plugin[0].capabilities.documentOnTypeFormattingProvider?.triggerCharacters?.includes(ch)) {
                    edits = await plugin[1].provideOnTypeFormattingEdits?.(document6, rangeOrPosition, ch, options, codeOptions, token);
                  }
                } else if (ch === void 0 && rangeOrPosition && "start" in rangeOrPosition && "end" in rangeOrPosition) {
                  edits = await plugin[1].provideDocumentFormattingEdits?.(document6, rangeOrPosition, options, codeOptions, token);
                }
              } catch (err) {
                console.warn(err);
              }
              if (!edits) {
                continue;
              }
              return {
                plugin,
                edits
              };
            }
          }
        };
      }
      function getNestedEmbeddedFiles(context, uri, rootCode, depth) {
        const nestedCodesByLevel = [[rootCode]];
        while (true) {
          if (nestedCodesByLevel.length > depth) {
            return nestedCodesByLevel[depth];
          }
          const nestedCodes = [];
          for (const code2 of nestedCodesByLevel[nestedCodesByLevel.length - 1]) {
            if (code2.embeddedCodes) {
              for (const embedded of code2.embeddedCodes) {
                if (!context.disabledEmbeddedDocumentUris.get(context.encodeEmbeddedDocumentUri(uri, embedded.id))) {
                  nestedCodes.push(embedded);
                }
              }
            }
          }
          nestedCodesByLevel.push(nestedCodes);
        }
      }
      function computeInitialIndent(content3, i, options) {
        let nChars = 0;
        const tabSize = options.tabSize || 4;
        while (i < content3.length) {
          const ch = content3.charAt(i);
          if (ch === " ") {
            nChars++;
          } else if (ch === "	") {
            nChars += tabSize;
          } else {
            break;
          }
          i++;
        }
        return Math.floor(nChars / tabSize);
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideDocumentHighlights.js
  var require_provideDocumentHighlights = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideDocumentHighlights.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var dedupe = require_dedupe();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return (uri, position4, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position4, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position4, language_core_1.isHighlightEnabled), async (plugin, document5, position5) => {
            if (token.isCancellationRequested) {
              return;
            }
            const recursiveChecker = dedupe.createLocationSet();
            const result = [];
            await withLinkedCode(document5, position5);
            return result;
            async function withLinkedCode(document6, position6) {
              if (!plugin[1].provideDocumentHighlights) {
                return;
              }
              if (recursiveChecker.has({ uri: document6.uri, range: { start: position6, end: position6 } })) {
                return;
              }
              recursiveChecker.add({ uri: document6.uri, range: { start: position6, end: position6 } });
              const references = await plugin[1].provideDocumentHighlights(document6, position6, token) ?? [];
              for (const reference of references) {
                let foundMirrorPosition = false;
                recursiveChecker.add({ uri: document6.uri, range: { start: reference.range.start, end: reference.range.start } });
                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(document6.uri));
                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                const linkedCodeMap = virtualCode && sourceScript ? context.language.linkedCodeMaps.get(virtualCode) : void 0;
                if (sourceScript && virtualCode && linkedCodeMap) {
                  const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                  for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, reference.range.start)) {
                    if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
                      continue;
                    }
                    foundMirrorPosition = true;
                    await withLinkedCode(embeddedDocument, linkedPos);
                  }
                }
                if (!foundMirrorPosition) {
                  result.push(reference);
                }
              }
            }
          }, (data2, docs) => data2.map((highlight) => {
            if (!docs) {
              return highlight;
            }
            const range = (0, featureWorkers_1.getSourceRange)(docs, highlight.range, language_core_1.isHighlightEnabled);
            if (range) {
              return {
                ...highlight,
                range
              };
            }
          }).filter((highlight) => !!highlight), (arr) => arr.flat());
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideDocumentLinks.js
  var require_provideDocumentLinks = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideDocumentLinks.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return async (uri, token = cancellation_1.NoneCancellationToken) => {
          return await (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isDocumentLinkEnabled)(mapping.data)), async (plugin, document5) => {
            if (token.isCancellationRequested) {
              return;
            }
            const links = await plugin[1].provideDocumentLinks?.(document5, token);
            for (const link2 of links ?? []) {
              link2.data = {
                uri: uri.toString(),
                original: {
                  data: link2.data
                },
                pluginIndex: context.plugins.indexOf(plugin)
              };
            }
            return links;
          }, (links, docs) => {
            if (!docs) {
              return links;
            }
            return links.map((link2) => {
              const range = (0, featureWorkers_1.getSourceRange)(docs, link2.range, language_core_1.isDocumentLinkEnabled);
              if (!range) {
                return;
              }
              link2 = {
                ...link2,
                range
              };
              if (link2.target) {
                link2.target = (0, transform_1.transformDocumentLinkTarget)(link2.target, context).toString();
              }
              return link2;
            }).filter((link2) => !!link2);
          }, (arr) => arr.flat()) ?? [];
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/utils/SemanticTokensBuilder.js
  var require_SemanticTokensBuilder = __commonJS({
    "node_modules/@volar/language-service/lib/utils/SemanticTokensBuilder.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.SemanticTokensBuilder = void 0;
      var SemanticTokensBuilder = class {
        constructor() {
          this.initialize();
        }
        initialize() {
          this._id = Date.now();
          this._prevLine = 0;
          this._prevChar = 0;
          this._data = [];
          this._dataLen = 0;
        }
        push(line, char, length, tokenType, tokenModifiers) {
          let pushLine = line;
          let pushChar = char;
          if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
              pushChar -= this._prevChar;
            }
          }
          this._data[this._dataLen++] = pushLine;
          this._data[this._dataLen++] = pushChar;
          this._data[this._dataLen++] = length;
          this._data[this._dataLen++] = tokenType;
          this._data[this._dataLen++] = tokenModifiers;
          this._prevLine = line;
          this._prevChar = char;
        }
        get id() {
          return this._id.toString();
        }
        build() {
          return {
            resultId: this.id,
            data: this._data
          };
        }
      };
      exports3.SemanticTokensBuilder = SemanticTokensBuilder;
    }
  });

  // node_modules/@volar/language-service/lib/features/provideDocumentSemanticTokens.js
  var require_provideDocumentSemanticTokens = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideDocumentSemanticTokens.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var SemanticTokensBuilder_1 = require_SemanticTokensBuilder();
      var cancellation_1 = require_cancellation();
      var common_1 = require_common();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return async (uri, range, legend, _reportProgress, token = cancellation_1.NoneCancellationToken) => {
          const sourceScript = context.language.scripts.get(uri);
          if (!sourceScript) {
            return;
          }
          const document5 = context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
          if (!range) {
            range = {
              start: { line: 0, character: 0 },
              end: { line: document5.lineCount - 1, character: document5.getText().length }
            };
          }
          const tokens = await (0, featureWorkers_1.languageFeatureWorker)(
            context,
            uri,
            () => range,
            function* (docs) {
              const mapped = (0, common_1.findOverlapCodeRange)(docs[0].offsetAt(range.start), docs[0].offsetAt(range.end), docs[2], language_core_1.isSemanticTokensEnabled);
              if (mapped) {
                yield {
                  start: docs[1].positionAt(mapped.start),
                  end: docs[1].positionAt(mapped.end)
                };
              }
            },
            (plugin, document6, range2) => {
              if (token?.isCancellationRequested) {
                return;
              }
              return plugin[1].provideDocumentSemanticTokens?.(document6, range2, legend, token);
            },
            (tokens2, docs) => {
              if (!docs) {
                return tokens2;
              }
              return tokens2.map((_token) => {
                const range2 = (0, featureWorkers_1.getSourceRange)(docs, {
                  start: { line: _token[0], character: _token[1] },
                  end: { line: _token[0], character: _token[1] + _token[2] }
                }, language_core_1.isSemanticTokensEnabled);
                if (range2) {
                  return [range2.start.line, range2.start.character, range2.end.character - range2.start.character, _token[3], _token[4]];
                }
              }).filter((token2) => !!token2);
            },
            (tokens2) => tokens2.flat()
            // tokens => reportProgress?.(buildTokens(tokens)), // TODO: this has no effect with LSP
          );
          if (tokens) {
            return buildTokens(tokens);
          }
        };
      }
      function buildTokens(tokens) {
        const builder = new SemanticTokensBuilder_1.SemanticTokensBuilder();
        const sortedTokens = tokens.sort((a, b) => a[0] - b[0] === 0 ? a[1] - b[1] : a[0] - b[0]);
        for (const token of sortedTokens) {
          builder.push(...token);
        }
        return builder.build();
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideDocumentSymbols.js
  var require_provideDocumentSymbols = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideDocumentSymbols.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var common_1 = require_common();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return (uri, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isSymbolsEnabled)(mapping.data)), (plugin, document5) => {
            if (token.isCancellationRequested) {
              return;
            }
            return plugin[1].provideDocumentSymbols?.(document5, token);
          }, (data2, docs) => {
            if (!docs) {
              return data2;
            }
            return data2.map((symbol) => (0, transform_1.transformDocumentSymbol)(symbol, (range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isSymbolsEnabled))).filter((symbol) => !!symbol);
          }, (results) => {
            for (let i = 0; i < results.length; i++) {
              for (let j = 0; j < results.length; j++) {
                if (i === j) {
                  continue;
                }
                results[i] = results[i].filter((child) => {
                  for (const parent of forEachSymbol(results[j])) {
                    if ((0, common_1.isInsideRange)(parent.range, child.range)) {
                      parent.children ??= [];
                      parent.children.push(child);
                      return false;
                    }
                  }
                  return true;
                });
              }
            }
            return results.flat();
          });
        };
      }
      function* forEachSymbol(symbols) {
        for (const symbol of symbols) {
          if (symbol.children) {
            yield* forEachSymbol(symbol.children);
          }
          yield symbol;
        }
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideFileReferences.js
  var require_provideFileReferences = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideFileReferences.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var dedupe = require_dedupe();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return (uri, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.documentFeatureWorker)(context, uri, () => true, async (plugin, document5) => {
            if (token.isCancellationRequested) {
              return;
            }
            return await plugin[1].provideFileReferences?.(document5, token) ?? [];
          }, (data2) => data2.map((reference) => {
            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(reference.uri));
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (!sourceScript || !virtualCode) {
              return reference;
            }
            const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
            for (const [sourceScript2, map4] of context.language.maps.forEach(virtualCode)) {
              const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
              const docs = [sourceDocument, embeddedDocument, map4];
              const range = (0, featureWorkers_1.getSourceRange)(docs, reference.range, language_core_1.isReferencesEnabled);
              if (range) {
                reference.uri = sourceDocument.uri;
                reference.range = range;
                return reference;
              }
            }
          }).filter((reference) => !!reference), (arr) => dedupe.withLocations(arr.flat()));
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideFileRenameEdits.js
  var require_provideFileRenameEdits = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideFileRenameEdits.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var cancellation_1 = require_cancellation();
      var dedupe = require_dedupe();
      var transform_1 = require_transform();
      function register2(context) {
        return async (oldUri, newUri, token = cancellation_1.NoneCancellationToken) => {
          for (const plugin of context.plugins) {
            if (context.disabledServicePlugins.has(plugin[1])) {
              continue;
            }
            if (token.isCancellationRequested) {
              break;
            }
            if (!plugin[1].provideFileRenameEdits) {
              continue;
            }
            const workspaceEdit = await plugin[1].provideFileRenameEdits(oldUri, newUri, token);
            if (workspaceEdit) {
              const result = (0, transform_1.transformWorkspaceEdit)(workspaceEdit, context, "fileName");
              if (result?.documentChanges) {
                result.documentChanges = dedupe.withDocumentChanges(result.documentChanges);
              }
              return result;
            }
          }
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideFoldingRanges.js
  var require_provideFoldingRanges = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideFoldingRanges.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return (uri, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.documentFeatureWorker)(context, uri, (docs) => docs[2].mappings.some((mapping) => (0, language_core_1.isFoldingRangesEnabled)(mapping.data)), (plugin, document5) => {
            if (token.isCancellationRequested) {
              return;
            }
            return plugin[1].provideFoldingRanges?.(document5, token);
          }, (data2, docs) => {
            if (!docs) {
              return data2;
            }
            return (0, transform_1.transformFoldingRanges)(data2, (range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isFoldingRangesEnabled));
          }, (arr) => arr.flat());
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideHover.js
  var require_provideHover = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideHover.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var common_1 = require_common();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      var provideDiagnostics_1 = require_provideDiagnostics();
      function register2(context) {
        return async (uri, position4, token = cancellation_1.NoneCancellationToken) => {
          let hover = await (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position4, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position4, language_core_1.isHoverEnabled), (plugin, document5, position5) => {
            if (token.isCancellationRequested) {
              return;
            }
            return plugin[1].provideHover?.(document5, position5, token);
          }, (item, docs) => {
            if (!docs || !item.range) {
              return item;
            }
            item.range = (0, featureWorkers_1.getSourceRange)(docs, item.range, language_core_1.isHoverEnabled);
            return item;
          }, (hovers) => ({
            contents: {
              kind: "markdown",
              value: hovers.map(getHoverTexts).flat().join("\n\n---\n\n")
            },
            range: hovers.find((hover2) => hover2.range && (0, common_1.isInsideRange)(hover2.range, { start: position4, end: position4 }))?.range ?? hovers[0].range
          }));
          const markups = provideDiagnostics_1.errorMarkups.get(uri);
          if (markups) {
            for (const errorAndMarkup of markups) {
              if ((0, common_1.isInsideRange)(errorAndMarkup.error.range, { start: position4, end: position4 })) {
                hover ??= {
                  contents: {
                    kind: "markdown",
                    value: ""
                  }
                };
                hover.range = errorAndMarkup.error.range;
                if (typeof hover.contents !== "object" || typeof hover.contents !== "string") {
                  hover.contents = {
                    kind: "markdown",
                    value: hover.contents
                  };
                }
                if (hover.contents.value) {
                  hover.contents.value += "\n\n---\n\n";
                }
                hover.contents.value += errorAndMarkup.markup.value;
              }
            }
          }
          return hover;
        };
        function getHoverTexts(hover) {
          if (typeof hover.contents === "string") {
            return [(0, transform_1.transformMarkdown)(hover.contents, context)];
          }
          if (Array.isArray(hover.contents)) {
            return hover.contents.map((content3) => {
              if (typeof content3 === "string") {
                return (0, transform_1.transformMarkdown)(content3, context);
              }
              if (content3.language === "md") {
                return `\`\`\`${content3.language}
${(0, transform_1.transformMarkdown)(content3.value, context)}
\`\`\``;
              } else {
                return `\`\`\`${content3.language}
${content3.value}
\`\`\``;
              }
            });
          }
          if ("kind" in hover.contents) {
            if (hover.contents.kind === "markdown") {
              return [(0, transform_1.transformMarkdown)(hover.contents.value, context)];
            } else {
              return [hover.contents.value];
            }
          }
          if (hover.contents.language === "md") {
            return [`\`\`\`${hover.contents.language}
${(0, transform_1.transformMarkdown)(hover.contents.value, context)}
\`\`\``];
          } else {
            return [`\`\`\`${hover.contents.language}
${hover.contents.value}
\`\`\``];
          }
        }
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideInlayHints.js
  var require_provideInlayHints = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideInlayHints.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var common_1 = require_common();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return async (uri, range, token = cancellation_1.NoneCancellationToken) => {
          const sourceScript = context.language.scripts.get(uri);
          if (!sourceScript) {
            return;
          }
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, function* (docs) {
            const mapped = (0, common_1.findOverlapCodeRange)(docs[0].offsetAt(range.start), docs[0].offsetAt(range.end), docs[2], language_core_1.isInlayHintsEnabled);
            if (mapped) {
              yield {
                start: docs[1].positionAt(mapped.start),
                end: docs[1].positionAt(mapped.end)
              };
            }
          }, async (plugin, document5, arg) => {
            if (token.isCancellationRequested) {
              return;
            }
            const hints = await plugin[1].provideInlayHints?.(document5, arg, token);
            hints?.forEach((link2) => {
              link2.data = {
                uri: uri.toString(),
                original: {
                  data: link2.data
                },
                pluginIndex: context.plugins.indexOf(plugin)
              };
            });
            return hints;
          }, (inlayHints, docs) => {
            if (!docs) {
              return inlayHints;
            }
            return inlayHints.map((_inlayHint) => {
              const edits = _inlayHint.textEdits?.map((textEdit) => (0, transform_1.transformTextEdit)(textEdit, (range2) => (0, featureWorkers_1.getSourceRange)(docs, range2), docs[1])).filter((textEdit) => !!textEdit);
              for (const position4 of (0, featureWorkers_1.getSourcePositions)(docs, _inlayHint.position, language_core_1.isInlayHintsEnabled)) {
                return {
                  ..._inlayHint,
                  position: position4,
                  textEdits: edits
                };
              }
            }).filter((hint) => !!hint);
          }, (arr) => arr.flat());
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideLinkedEditingRanges.js
  var require_provideLinkedEditingRanges = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideLinkedEditingRanges.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return (uri, position4, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position4, function* (docs) {
            for (const pos of (0, featureWorkers_1.getGeneratedPositions)(docs, position4, language_core_1.isLinkedEditingEnabled)) {
              yield pos;
            }
          }, (plugin, document5, position5) => {
            if (token.isCancellationRequested) {
              return;
            }
            return plugin[1].provideLinkedEditingRanges?.(document5, position5, token);
          }, (ranges, docs) => {
            if (!docs) {
              return ranges;
            }
            return {
              wordPattern: ranges.wordPattern,
              ranges: ranges.ranges.map((range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isLinkedEditingEnabled)).filter((range) => !!range)
            };
          });
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideReferences.js
  var require_provideReferences = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideReferences.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var dedupe = require_dedupe();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return (uri, position4, referenceContext, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position4, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position4, language_core_1.isReferencesEnabled), async (plugin, document5, position5) => {
            if (token.isCancellationRequested) {
              return;
            }
            const recursiveChecker = dedupe.createLocationSet();
            const result = [];
            await withLinkedCode(document5, position5);
            return result;
            async function withLinkedCode(document6, position6) {
              if (!plugin[1].provideReferences) {
                return;
              }
              if (recursiveChecker.has({ uri: document6.uri, range: { start: position6, end: position6 } })) {
                return;
              }
              recursiveChecker.add({ uri: document6.uri, range: { start: position6, end: position6 } });
              const references = await plugin[1].provideReferences(document6, position6, referenceContext, token) ?? [];
              for (const reference of references) {
                let foundMirrorPosition = false;
                recursiveChecker.add({ uri: reference.uri, range: { start: reference.range.start, end: reference.range.start } });
                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(reference.uri));
                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                const linkedCodeMap = virtualCode && sourceScript ? context.language.linkedCodeMaps.get(virtualCode) : void 0;
                if (sourceScript && virtualCode && linkedCodeMap) {
                  const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                  for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, reference.range.start)) {
                    if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
                      continue;
                    }
                    foundMirrorPosition = true;
                    await withLinkedCode(embeddedDocument, linkedPos);
                  }
                }
                if (!foundMirrorPosition) {
                  result.push(reference);
                }
              }
            }
          }, (data2) => {
            const results = [];
            for (const reference of data2) {
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(reference.uri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              if (sourceScript && virtualCode) {
                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                for (const [sourceScript2, map4] of context.language.maps.forEach(virtualCode)) {
                  const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
                  const docs = [sourceDocument, embeddedDocument, map4];
                  const range = (0, featureWorkers_1.getSourceRange)(docs, reference.range, language_core_1.isReferencesEnabled);
                  if (range) {
                    results.push({
                      uri: sourceDocument.uri,
                      range
                    });
                  }
                }
              } else {
                results.push(reference);
              }
            }
            return results;
          }, (arr) => dedupe.withLocations(arr.flat()));
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideRenameEdits.js
  var require_provideRenameEdits = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideRenameEdits.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      exports3.mergeWorkspaceEdits = mergeWorkspaceEdits;
      var language_core_1 = require_language_core();
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var dedupe = require_dedupe();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return (uri, position4, newName, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => ({ position: position4, newName }), function* (docs) {
            let _data;
            for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position4, (data2) => {
              _data = data2;
              return (0, language_core_1.isRenameEnabled)(data2);
            })) {
              yield {
                position: mappedPosition,
                newName: (0, language_core_1.resolveRenameNewName)(newName, _data)
              };
            }
            ;
          }, async (plugin, document5, params) => {
            if (token.isCancellationRequested) {
              return;
            }
            const recursiveChecker = dedupe.createLocationSet();
            let result;
            await withLinkedCode(document5, params.position, params.newName);
            return result;
            async function withLinkedCode(document6, position5, newName2) {
              if (!plugin[1].provideRenameEdits) {
                return;
              }
              if (recursiveChecker.has({ uri: document6.uri, range: { start: position5, end: position5 } })) {
                return;
              }
              recursiveChecker.add({ uri: document6.uri, range: { start: position5, end: position5 } });
              const workspaceEdit = await plugin[1].provideRenameEdits(document6, position5, newName2, token);
              if (!workspaceEdit) {
                return;
              }
              if (!result) {
                result = {};
              }
              if (workspaceEdit.changes) {
                for (const editUri in workspaceEdit.changes) {
                  const textEdits = workspaceEdit.changes[editUri];
                  for (const textEdit of textEdits) {
                    let foundMirrorPosition = false;
                    recursiveChecker.add({ uri: editUri, range: { start: textEdit.range.start, end: textEdit.range.start } });
                    const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(editUri));
                    const sourceScript = decoded && context.language.scripts.get(decoded[0]);
                    const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                    const linkedCodeMap = virtualCode && sourceScript ? context.language.linkedCodeMaps.get(virtualCode) : void 0;
                    if (sourceScript && virtualCode && linkedCodeMap) {
                      const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                      for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, textEdit.range.start)) {
                        if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
                          continue;
                        }
                        foundMirrorPosition = true;
                        await withLinkedCode(embeddedDocument, linkedPos, newName2);
                      }
                    }
                    if (!foundMirrorPosition) {
                      if (!result.changes) {
                        result.changes = {};
                      }
                      if (!result.changes[editUri]) {
                        result.changes[editUri] = [];
                      }
                      result.changes[editUri].push(textEdit);
                    }
                  }
                }
              }
              if (workspaceEdit.changeAnnotations) {
                for (const uri2 in workspaceEdit.changeAnnotations) {
                  if (!result.changeAnnotations) {
                    result.changeAnnotations = {};
                  }
                  result.changeAnnotations[uri2] = workspaceEdit.changeAnnotations[uri2];
                }
              }
              if (workspaceEdit.documentChanges) {
                if (!result.documentChanges) {
                  result.documentChanges = [];
                }
                result.documentChanges = result.documentChanges.concat(workspaceEdit.documentChanges);
              }
            }
          }, (data2) => {
            return (0, transform_1.transformWorkspaceEdit)(data2, context, "rename");
          }, (workspaceEdits) => {
            const mainEdit = workspaceEdits[0];
            const otherEdits = workspaceEdits.slice(1);
            mergeWorkspaceEdits(mainEdit, ...otherEdits);
            if (mainEdit.changes) {
              for (const uri2 in mainEdit.changes) {
                mainEdit.changes[uri2] = dedupe.withTextEdits(mainEdit.changes[uri2]);
              }
            }
            return workspaceEdits[0];
          });
        };
      }
      function mergeWorkspaceEdits(original, ...others) {
        for (const other of others) {
          for (const uri in other.changeAnnotations) {
            if (!original.changeAnnotations) {
              original.changeAnnotations = {};
            }
            original.changeAnnotations[uri] = other.changeAnnotations[uri];
          }
          for (const uri in other.changes) {
            if (!original.changes) {
              original.changes = {};
            }
            if (!original.changes[uri]) {
              original.changes[uri] = [];
            }
            const edits = other.changes[uri];
            original.changes[uri] = original.changes[uri].concat(edits);
          }
          if (other.documentChanges) {
            if (!original.documentChanges) {
              original.documentChanges = [];
            }
            for (const docChange of other.documentChanges) {
              (0, transform_1.pushEditToDocumentChanges)(original.documentChanges, docChange);
            }
          }
        }
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideRenameRange.js
  var require_provideRenameRange = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideRenameRange.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return (uri, position4, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position4, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position4, language_core_1.isRenameEnabled), (plugin, document5, position5) => {
            if (token.isCancellationRequested) {
              return;
            }
            return plugin[1].provideRenameRange?.(document5, position5, token);
          }, (item, docs) => {
            if (!docs) {
              return item;
            }
            if ("start" in item && "end" in item) {
              return (0, featureWorkers_1.getSourceRange)(docs, item);
            }
            return item;
          }, (prepares) => {
            for (const prepare of prepares) {
              if ("start" in prepare && "end" in prepare) {
                return prepare;
              }
            }
            return prepares[0];
          });
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideSelectionRanges.js
  var require_provideSelectionRanges = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideSelectionRanges.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var common_1 = require_common();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return (uri, positions, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => positions, function* (docs) {
            const result = positions.map((position4) => {
              for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position4, language_core_1.isSelectionRangesEnabled)) {
                return mappedPosition;
              }
            }).filter((position4) => !!position4);
            if (result.length) {
              yield result;
            }
          }, async (plugin, document5, positions2) => {
            if (token.isCancellationRequested) {
              return;
            }
            const selectionRanges = await plugin[1].provideSelectionRanges?.(document5, positions2, token);
            if (selectionRanges && selectionRanges.length !== positions2.length) {
              console.error("Selection ranges count should be equal to positions count:", plugin[0].name, selectionRanges.length, positions2.length);
              return;
            }
            return selectionRanges;
          }, (data2, docs) => {
            if (!docs) {
              return data2;
            }
            return (0, transform_1.transformSelectionRanges)(data2, (range) => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isSelectionRangesEnabled));
          }, (results) => {
            const result = [];
            for (let i = 0; i < positions.length; i++) {
              let pluginResults = [];
              for (const ranges of results) {
                pluginResults.push(ranges[i]);
              }
              pluginResults = pluginResults.sort((a, b) => {
                if ((0, common_1.isInsideRange)(a.range, b.range)) {
                  return 1;
                }
                if ((0, common_1.isInsideRange)(b.range, a.range)) {
                  return -1;
                }
                return 0;
              });
              for (let j = 1; j < pluginResults.length; j++) {
                let top = pluginResults[j - 1];
                const parent = pluginResults[j];
                while (top.parent && (0, common_1.isInsideRange)(parent.range, top.parent.range) && !(0, common_1.isEqualRange)(parent.range, top.parent.range)) {
                  top = top.parent;
                }
                if (top) {
                  top.parent = parent;
                }
              }
              result.push(pluginResults[0]);
            }
            return result;
          });
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideSignatureHelp.js
  var require_provideSignatureHelp = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideSignatureHelp.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      function register2(context) {
        return (uri, position4, signatureHelpContext = {
          triggerKind: 1,
          isRetrigger: false
        }, token = cancellation_1.NoneCancellationToken) => {
          return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position4, (docs) => (0, featureWorkers_1.getGeneratedPositions)(docs, position4, language_core_1.isSignatureHelpEnabled), (plugin, document5, position5) => {
            if (token.isCancellationRequested) {
              return;
            }
            if (signatureHelpContext?.triggerKind === 2 && signatureHelpContext.triggerCharacter && !(signatureHelpContext.isRetrigger ? plugin[0].capabilities.signatureHelpProvider?.retriggerCharacters : plugin[0].capabilities.signatureHelpProvider?.triggerCharacters)?.includes(signatureHelpContext.triggerCharacter)) {
              return;
            }
            return plugin[1].provideSignatureHelp?.(document5, position5, signatureHelpContext, token);
          }, (data2) => data2);
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideWorkspaceDiagnostics.js
  var require_provideWorkspaceDiagnostics = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideWorkspaceDiagnostics.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var language_core_1 = require_language_core();
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var provideDiagnostics_1 = require_provideDiagnostics();
      function register2(context) {
        return async (token = cancellation_1.NoneCancellationToken) => {
          const allItems = [];
          for (const plugin of context.plugins) {
            if (context.disabledServicePlugins.has(plugin[1])) {
              continue;
            }
            if (token.isCancellationRequested) {
              break;
            }
            if (!plugin[1].provideWorkspaceDiagnostics) {
              continue;
            }
            const report = await plugin[1].provideWorkspaceDiagnostics(token);
            if (!report) {
              continue;
            }
            const items = report.map((item) => {
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(item.uri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              if (virtualCode && sourceScript) {
                if (item.kind === "unchanged") {
                  return {
                    ...item,
                    uri: sourceScript.id.toString()
                  };
                } else {
                  const map4 = context.language.maps.get(virtualCode, sourceScript);
                  const docs = [
                    context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot),
                    context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot),
                    map4
                  ];
                  return {
                    ...item,
                    items: item.items.map((error) => (0, provideDiagnostics_1.transformDiagnostic)(context, error, docs, language_core_1.shouldReportDiagnostics)).filter((error) => !!error)
                  };
                }
              } else {
                if (item.kind === "unchanged") {
                  return item;
                }
                return {
                  ...item,
                  items: item.items.map((error) => (0, provideDiagnostics_1.transformDiagnostic)(context, error, void 0, language_core_1.shouldReportDiagnostics)).filter((error) => !!error)
                };
              }
            });
            allItems.push(...items);
          }
          return allItems;
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/provideWorkspaceSymbols.js
  var require_provideWorkspaceSymbols = __commonJS({
    "node_modules/@volar/language-service/lib/features/provideWorkspaceSymbols.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return async (query, token = cancellation_1.NoneCancellationToken) => {
          const symbolsList = [];
          for (const plugin of context.plugins) {
            if (context.disabledServicePlugins.has(plugin[1])) {
              continue;
            }
            if (token.isCancellationRequested) {
              break;
            }
            if (!plugin[1].provideWorkspaceSymbols) {
              continue;
            }
            const embeddedSymbols = await plugin[1].provideWorkspaceSymbols(query, token);
            if (!embeddedSymbols) {
              continue;
            }
            const symbols = embeddedSymbols.map((symbol) => (0, transform_1.transformWorkspaceSymbol)(symbol, (loc) => {
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(loc.uri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              if (sourceScript && virtualCode) {
                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                for (const [sourceScript2, map4] of context.language.maps.forEach(virtualCode)) {
                  const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
                  const docs = [sourceDocument, embeddedDocument, map4];
                  const range = (0, featureWorkers_1.getSourceRange)(docs, loc.range);
                  if (range) {
                    return { uri: sourceDocument.uri, range };
                  }
                }
              } else {
                return loc;
              }
            })).filter((symbol) => !!symbol);
            symbols?.forEach((symbol) => {
              symbol.data = {
                original: {
                  data: symbol.data
                },
                pluginIndex: context.plugins.indexOf(plugin)
              };
            });
            symbolsList.push(symbols);
          }
          return symbolsList.flat();
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/resolveCodeAction.js
  var require_resolveCodeAction = __commonJS({
    "node_modules/@volar/language-service/lib/features/resolveCodeAction.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var cancellation_1 = require_cancellation();
      var transform_1 = require_transform();
      function register2(context) {
        return async (item, token = cancellation_1.NoneCancellationToken) => {
          const data2 = item.data;
          if (data2) {
            const plugin = context.plugins[data2.pluginIndex];
            if (!plugin[1].resolveCodeAction) {
              return item;
            }
            Object.assign(item, data2.original);
            item = await plugin[1].resolveCodeAction(item, token);
            item = plugin[1].transformCodeAction?.(item) ?? (item.edit ? {
              ...item,
              edit: (0, transform_1.transformWorkspaceEdit)(item.edit, context, "codeAction", { [data2.uri]: data2.version })
            } : item);
          }
          return item;
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/resolveCodeLens.js
  var require_resolveCodeLens = __commonJS({
    "node_modules/@volar/language-service/lib/features/resolveCodeLens.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var references = require_provideReferences();
      function register2(context) {
        const findReferences = references.register(context);
        return async (item, token = cancellation_1.NoneCancellationToken) => {
          const data2 = item.data;
          if (data2?.kind === "normal") {
            const plugin = context.plugins[data2.pluginIndex];
            if (!plugin[1].resolveCodeLens) {
              return item;
            }
            Object.assign(item, data2.original);
            item = await plugin[1].resolveCodeLens(item, token);
          }
          if (data2?.kind === "references") {
            const references2 = await findReferences(vscode_uri_1.URI.parse(data2.sourceFileUri), item.range.start, { includeDeclaration: false }, token) ?? [];
            item.command = context.commands.showReferences.create(data2.sourceFileUri, item.range.start, references2);
          }
          return item;
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/resolveCompletionItem.js
  var require_resolveCompletionItem = __commonJS({
    "node_modules/@volar/language-service/lib/features/resolveCompletionItem.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var vscode_uri_1 = require_umd();
      var cancellation_1 = require_cancellation();
      var featureWorkers_1 = require_featureWorkers();
      var transform_1 = require_transform();
      function register2(context) {
        return async (item, token = cancellation_1.NoneCancellationToken) => {
          const data2 = item.data;
          if (data2) {
            const plugin = context.plugins[data2.pluginIndex];
            if (!plugin[1].resolveCompletionItem) {
              return item;
            }
            item = Object.assign(item, data2.original);
            if (data2.embeddedDocumentUri) {
              const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data2.embeddedDocumentUri));
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              if (sourceScript && virtualCode) {
                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
                for (const [sourceScript2, map4] of context.language.maps.forEach(virtualCode)) {
                  const sourceDocument = context.documents.get(sourceScript2.id, sourceScript2.languageId, sourceScript2.snapshot);
                  const docs = [sourceDocument, embeddedDocument, map4];
                  item = await plugin[1].resolveCompletionItem(item, token);
                  item = plugin[1].transformCompletionItem?.(item) ?? (0, transform_1.transformCompletionItem)(item, (embeddedRange) => (0, featureWorkers_1.getSourceRange)(docs, embeddedRange), embeddedDocument, context);
                }
              }
            } else {
              item = await plugin[1].resolveCompletionItem(item, token);
            }
          }
          if (item.detail !== item.detail + ".ts") {
            item.detail = item.detail;
          }
          return item;
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/resolveDocumentLink.js
  var require_resolveDocumentLink = __commonJS({
    "node_modules/@volar/language-service/lib/features/resolveDocumentLink.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var cancellation_1 = require_cancellation();
      var transform_1 = require_transform();
      function register2(context) {
        return async (item, token = cancellation_1.NoneCancellationToken) => {
          const data2 = item.data;
          if (data2) {
            const plugin = context.plugins[data2.pluginIndex];
            if (!plugin[1].resolveDocumentLink) {
              return item;
            }
            Object.assign(item, data2.original);
            item = await plugin[1].resolveDocumentLink(item, token);
            if (item.target) {
              item.target = (0, transform_1.transformDocumentLinkTarget)(item.target, context).toString();
            }
          }
          return item;
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/resolveInlayHint.js
  var require_resolveInlayHint = __commonJS({
    "node_modules/@volar/language-service/lib/features/resolveInlayHint.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var cancellation_1 = require_cancellation();
      function register2(context) {
        return async (item, token = cancellation_1.NoneCancellationToken) => {
          const data2 = item.data;
          if (data2) {
            const plugin = context.plugins[data2.pluginIndex];
            if (!plugin[1].resolveInlayHint) {
              return item;
            }
            Object.assign(item, data2.original);
            item = await plugin[1].resolveInlayHint(item, token);
          }
          return item;
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/features/resolveWorkspaceSymbol.js
  var require_resolveWorkspaceSymbol = __commonJS({
    "node_modules/@volar/language-service/lib/features/resolveWorkspaceSymbol.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var cancellation_1 = require_cancellation();
      function register2(context) {
        return async (symbol, token = cancellation_1.NoneCancellationToken) => {
          const data2 = symbol.data;
          if (data2) {
            const plugin = context.plugins[data2.pluginIndex];
            if (!plugin[1].resolveWorkspaceSymbol) {
              return symbol;
            }
            Object.assign(symbol, data2.original);
            symbol = await plugin[1].resolveWorkspaceSymbol(symbol, token);
          }
          return symbol;
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/languageService.js
  var require_languageService = __commonJS({
    "node_modules/@volar/language-service/lib/languageService.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.embeddedContentScheme = void 0;
      exports3.createLanguageService = createLanguageService2;
      exports3.decodeEmbeddedDocumentUri = decodeEmbeddedDocumentUri;
      exports3.encodeEmbeddedDocumentUri = encodeEmbeddedDocumentUri;
      var language_core_1 = require_language_core();
      var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
      var vscode_uri_1 = require_umd();
      var autoInsert = require_provideAutoInsertSnippet();
      var callHierarchy = require_provideCallHierarchyItems();
      var codeActions = require_provideCodeActions();
      var codeLens = require_provideCodeLenses();
      var colorPresentations = require_provideColorPresentations();
      var completions = require_provideCompletionItems();
      var definition3 = require_provideDefinition();
      var diagnostics = require_provideDiagnostics();
      var documentColors = require_provideDocumentColors();
      var documentDrop = require_provideDocumentDropEdits();
      var format2 = require_provideDocumentFormattingEdits();
      var documentHighlight = require_provideDocumentHighlights();
      var documentLink = require_provideDocumentLinks();
      var semanticTokens = require_provideDocumentSemanticTokens();
      var documentSymbols = require_provideDocumentSymbols();
      var fileReferences = require_provideFileReferences();
      var fileRename = require_provideFileRenameEdits();
      var foldingRanges = require_provideFoldingRanges();
      var hover = require_provideHover();
      var inlayHints = require_provideInlayHints();
      var linkedEditing = require_provideLinkedEditingRanges();
      var references = require_provideReferences();
      var rename = require_provideRenameEdits();
      var renamePrepare = require_provideRenameRange();
      var selectionRanges = require_provideSelectionRanges();
      var signatureHelp = require_provideSignatureHelp();
      var workspaceDiagnostics = require_provideWorkspaceDiagnostics();
      var workspaceSymbol = require_provideWorkspaceSymbols();
      var codeActionResolve = require_resolveCodeAction();
      var codeLensResolve = require_resolveCodeLens();
      var completionResolve = require_resolveCompletionItem();
      var documentLinkResolve = require_resolveDocumentLink();
      var inlayHintResolve = require_resolveInlayHint();
      var workspaceSymbolResolve = require_resolveWorkspaceSymbol();
      var cancellation_1 = require_cancellation();
      var uriMap_1 = require_uriMap();
      exports3.embeddedContentScheme = "volar-embedded-content";
      function createLanguageService2(language, plugins, env2, project) {
        const documentVersions = (0, uriMap_1.createUriMap)();
        const snapshot2Doc = /* @__PURE__ */ new WeakMap();
        const context = {
          language,
          project,
          getLanguageService: () => langaugeService,
          documents: {
            get(uri, languageId, snapshot) {
              if (!snapshot2Doc.has(snapshot)) {
                snapshot2Doc.set(snapshot, (0, uriMap_1.createUriMap)());
              }
              const map4 = snapshot2Doc.get(snapshot);
              if (!map4.has(uri)) {
                const version2 = documentVersions.get(uri) ?? 0;
                documentVersions.set(uri, version2 + 1);
                map4.set(uri, vscode_languageserver_textdocument_1.TextDocument.create(uri.toString(), languageId, version2, snapshot.getText(0, snapshot.getLength())));
              }
              return map4.get(uri);
            }
          },
          env: env2,
          inject: (key, ...args) => {
            for (const plugin of context.plugins) {
              if (context.disabledServicePlugins.has(plugin[1])) {
                continue;
              }
              const provide = plugin[1].provide?.[key];
              if (provide) {
                return provide(...args);
              }
            }
          },
          plugins: [],
          commands: {
            rename: {
              create(uri, position4) {
                return {
                  title: "",
                  command: "editor.action.rename",
                  arguments: [
                    uri,
                    position4
                  ]
                };
              },
              is(command) {
                return command.command === "editor.action.rename";
              }
            },
            showReferences: {
              create(uri, position4, locations) {
                return {
                  title: locations.length === 1 ? "1 reference" : `${locations.length} references`,
                  command: "editor.action.showReferences",
                  arguments: [
                    uri,
                    position4,
                    locations
                  ]
                };
              },
              is(command) {
                return command.command === "editor.action.showReferences";
              }
            },
            setSelection: {
              create(position4) {
                return {
                  title: "",
                  command: "setSelection",
                  arguments: [{
                    selection: {
                      selectionStartLineNumber: position4.line + 1,
                      positionLineNumber: position4.line + 1,
                      selectionStartColumn: position4.character + 1,
                      positionColumn: position4.character + 1
                    }
                  }]
                };
              },
              is(command) {
                return command.command === "setSelection";
              }
            }
          },
          disabledEmbeddedDocumentUris: (0, uriMap_1.createUriMap)(),
          disabledServicePlugins: /* @__PURE__ */ new WeakSet(),
          decodeEmbeddedDocumentUri,
          encodeEmbeddedDocumentUri
        };
        for (const plugin of plugins) {
          context.plugins.push([plugin, plugin.create(context)]);
        }
        const langaugeService = createLanguageServiceBase(plugins, context);
        return langaugeService;
      }
      function decodeEmbeddedDocumentUri(maybeEmbeddedContentUri) {
        if (maybeEmbeddedContentUri.scheme === exports3.embeddedContentScheme) {
          const embeddedCodeId = decodeURIComponent(maybeEmbeddedContentUri.authority);
          const documentUri = decodeURIComponent(maybeEmbeddedContentUri.path.substring(1));
          return [
            vscode_uri_1.URI.parse(documentUri),
            embeddedCodeId
          ];
        }
      }
      function encodeEmbeddedDocumentUri(documentUri, embeddedContentId) {
        if (embeddedContentId !== embeddedContentId.toLowerCase()) {
          console.error(`embeddedContentId must be lowercase: ${embeddedContentId}`);
        }
        return vscode_uri_1.URI.from({
          scheme: exports3.embeddedContentScheme,
          authority: encodeURIComponent(embeddedContentId),
          path: "/" + encodeURIComponent(documentUri.toString())
        });
      }
      function createLanguageServiceBase(plugins, context) {
        const tokenModifiers = plugins.map((plugin) => plugin.capabilities.semanticTokensProvider?.legend?.tokenModifiers ?? []).flat();
        const tokenTypes = plugins.map((plugin) => plugin.capabilities.semanticTokensProvider?.legend?.tokenTypes ?? []).flat();
        return {
          semanticTokenLegend: {
            tokenModifiers: [...new Set(tokenModifiers)],
            tokenTypes: [...new Set(tokenTypes)]
          },
          commands: plugins.map((plugin) => plugin.capabilities.executeCommandProvider?.commands ?? []).flat(),
          triggerCharacters: plugins.map((plugin) => plugin.capabilities.completionProvider?.triggerCharacters ?? []).flat(),
          autoFormatTriggerCharacters: plugins.map((plugin) => plugin.capabilities.documentOnTypeFormattingProvider?.triggerCharacters ?? []).flat(),
          signatureHelpTriggerCharacters: plugins.map((plugin) => plugin.capabilities.signatureHelpProvider?.triggerCharacters ?? []).flat(),
          signatureHelpRetriggerCharacters: plugins.map((plugin) => plugin.capabilities.signatureHelpProvider?.retriggerCharacters ?? []).flat(),
          executeCommand(command, args, token = cancellation_1.NoneCancellationToken) {
            for (const plugin of context.plugins) {
              if (context.disabledServicePlugins.has(plugin[1])) {
                continue;
              }
              if (!plugin[1].executeCommand || !plugin[0].capabilities.executeCommandProvider?.commands.includes(command)) {
                continue;
              }
              return plugin[1].executeCommand(command, args, token);
            }
          },
          getDocumentFormattingEdits: format2.register(context),
          getFoldingRanges: foldingRanges.register(context),
          getSelectionRanges: selectionRanges.register(context),
          getLinkedEditingRanges: linkedEditing.register(context),
          getDocumentSymbols: documentSymbols.register(context),
          getDocumentColors: documentColors.register(context),
          getColorPresentations: colorPresentations.register(context),
          getDiagnostics: diagnostics.register(context),
          getWorkspaceDiagnostics: workspaceDiagnostics.register(context),
          getReferences: references.register(context),
          getFileReferences: fileReferences.register(context),
          getDefinition: definition3.register(context, "provideDefinition", language_core_1.isDefinitionEnabled),
          getTypeDefinition: definition3.register(context, "provideTypeDefinition", language_core_1.isTypeDefinitionEnabled),
          getImplementations: definition3.register(context, "provideImplementation", language_core_1.isImplementationEnabled),
          getRenameRange: renamePrepare.register(context),
          getRenameEdits: rename.register(context),
          getFileRenameEdits: fileRename.register(context),
          getSemanticTokens: semanticTokens.register(context),
          getHover: hover.register(context),
          getCompletionItems: completions.register(context),
          getCodeActions: codeActions.register(context),
          getSignatureHelp: signatureHelp.register(context),
          getCodeLenses: codeLens.register(context),
          getDocumentHighlights: documentHighlight.register(context),
          getDocumentLinks: documentLink.register(context),
          getWorkspaceSymbols: workspaceSymbol.register(context),
          getAutoInsertSnippet: autoInsert.register(context),
          getDocumentDropEdits: documentDrop.register(context),
          getInlayHints: inlayHints.register(context),
          resolveCodeAction: codeActionResolve.register(context),
          resolveCompletionItem: completionResolve.register(context),
          resolveCodeLens: codeLensResolve.register(context),
          resolveDocumentLink: documentLinkResolve.register(context),
          resolveInlayHint: inlayHintResolve.register(context),
          resolveWorkspaceSymbol: workspaceSymbolResolve.register(context),
          ...callHierarchy.register(context),
          dispose: () => context.plugins.forEach((plugin) => plugin[1].dispose?.()),
          context
        };
      }
    }
  });

  // node_modules/@volar/language-service/lib/types.js
  var require_types2 = __commonJS({
    "node_modules/@volar/language-service/lib/types.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.FileType = void 0;
      var FileType;
      (function(FileType2) {
        FileType2[FileType2["Unknown"] = 0] = "Unknown";
        FileType2[FileType2["File"] = 1] = "File";
        FileType2[FileType2["Directory"] = 2] = "Directory";
        FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
      })(FileType || (exports3.FileType = FileType = {}));
    }
  });

  // node_modules/@volar/language-service/index.js
  var require_language_service = __commonJS({
    "node_modules/@volar/language-service/index.js"(exports3) {
      "use strict";
      var __createBinding = exports3 && exports3.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports3 && exports3.__exportStar || function(m, exports4) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p))
            __createBinding(exports4, m, p);
      };
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.mergeWorkspaceEdits = void 0;
      __exportStar(require_language_core(), exports3);
      __exportStar(require_languageService(), exports3);
      var provideRenameEdits_1 = require_provideRenameEdits();
      Object.defineProperty(exports3, "mergeWorkspaceEdits", { enumerable: true, get: function() {
        return provideRenameEdits_1.mergeWorkspaceEdits;
      } });
      __exportStar(require_types2(), exports3);
      __exportStar(require_transform(), exports3);
      __exportStar(require_uriMap(), exports3);
    }
  });

  // node_modules/@volar/typescript/lib/common.js
  var require_common2 = __commonJS({
    "node_modules/@volar/typescript/lib/common.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.resolveFileLanguageId = resolveFileLanguageId2;
      function resolveFileLanguageId2(path) {
        const ext = path.split(".").pop();
        switch (ext) {
          case "js":
            return "javascript";
          case "cjs":
            return "javascript";
          case "mjs":
            return "javascript";
          case "ts":
            return "typescript";
          case "cts":
            return "typescript";
          case "mts":
            return "typescript";
          case "jsx":
            return "javascriptreact";
          case "tsx":
            return "typescriptreact";
          case "json":
            return "json";
        }
      }
    }
  });

  // node_modules/@volar/typescript/lib/node/dedupe.js
  var require_dedupe2 = __commonJS({
    "node_modules/@volar/typescript/lib/node/dedupe.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.dedupeDocumentSpans = dedupeDocumentSpans;
      function dedupeDocumentSpans(items) {
        return dedupe(items, (item) => [
          item.fileName,
          item.textSpan.start,
          item.textSpan.length
        ].join(":"));
      }
      function dedupe(items, getKey) {
        const map4 = /* @__PURE__ */ new Map();
        for (const item of items.reverse()) {
          map4.set(getKey(item), item);
        }
        return [...map4.values()];
      }
    }
  });

  // node_modules/@volar/typescript/lib/node/utils.js
  var require_utils2 = __commonJS({
    "node_modules/@volar/typescript/lib/node/utils.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.getServiceScript = getServiceScript;
      function getServiceScript(language, fileName) {
        const sourceScript = language.scripts.get(fileName);
        if (sourceScript?.targetIds.size) {
          for (const targetId of sourceScript.targetIds) {
            const targetScript = language.scripts.get(targetId);
            if (targetScript?.generated) {
              const serviceScript = targetScript.generated.languagePlugin.typescript?.getServiceScript(targetScript.generated.root);
              if (serviceScript) {
                return [serviceScript, targetScript, sourceScript];
              }
            }
          }
        }
        if (sourceScript?.associatedOnly) {
          return [void 0, sourceScript, sourceScript];
        }
        if (sourceScript?.generated) {
          const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
          if (serviceScript) {
            return [serviceScript, sourceScript, sourceScript];
          }
        }
        return [void 0, void 0, void 0];
      }
    }
  });

  // node_modules/@volar/typescript/lib/node/transform.js
  var require_transform2 = __commonJS({
    "node_modules/@volar/typescript/lib/node/transform.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.transformCallHierarchyItem = transformCallHierarchyItem;
      exports3.transformDiagnostic = transformDiagnostic;
      exports3.fillSourceFileText = fillSourceFileText;
      exports3.transformFileTextChanges = transformFileTextChanges;
      exports3.transformDocumentSpan = transformDocumentSpan;
      exports3.transformSpan = transformSpan;
      exports3.transformTextChange = transformTextChange;
      exports3.transformTextSpan = transformTextSpan;
      exports3.toSourceOffset = toSourceOffset;
      exports3.toSourceRanges = toSourceRanges;
      exports3.toSourceOffsets = toSourceOffsets;
      exports3.toGeneratedRanges = toGeneratedRanges;
      exports3.toGeneratedOffset = toGeneratedOffset;
      exports3.toGeneratedOffsets = toGeneratedOffsets;
      exports3.getMappingOffset = getMappingOffset;
      var language_core_1 = require_language_core();
      var utils_1 = require_utils2();
      var transformedDiagnostics = /* @__PURE__ */ new WeakMap();
      var transformedSourceFile = /* @__PURE__ */ new WeakSet();
      function transformCallHierarchyItem(language, item, filter) {
        const span = transformSpan(language, item.file, item.span, filter);
        const selectionSpan = transformSpan(language, item.file, item.selectionSpan, filter);
        return {
          ...item,
          file: span?.fileName ?? item.file,
          span: span?.textSpan ?? { start: 0, length: 0 },
          selectionSpan: selectionSpan?.textSpan ?? { start: 0, length: 0 }
        };
      }
      function transformDiagnostic(language, diagnostic, program, isTsc) {
        if (!transformedDiagnostics.has(diagnostic)) {
          transformedDiagnostics.set(diagnostic, void 0);
          const { relatedInformation } = diagnostic;
          if (relatedInformation) {
            diagnostic.relatedInformation = relatedInformation.map((d) => transformDiagnostic(language, d, program, isTsc)).filter((d) => !!d);
          }
          if (diagnostic.file !== void 0 && diagnostic.start !== void 0 && diagnostic.length !== void 0) {
            const [serviceScript] = (0, utils_1.getServiceScript)(language, diagnostic.file.fileName);
            if (serviceScript) {
              const [sourceSpanFileName, sourceSpan] = transformTextSpan(void 0, language, serviceScript, {
                start: diagnostic.start,
                length: diagnostic.length
              }, language_core_1.shouldReportDiagnostics) ?? [];
              const actualDiagnosticFile = sourceSpanFileName ? diagnostic.file.fileName === sourceSpanFileName ? diagnostic.file : program?.getSourceFile(sourceSpanFileName) : void 0;
              if (sourceSpan && actualDiagnosticFile) {
                if (isTsc) {
                  fillSourceFileText(language, diagnostic.file);
                }
                transformedDiagnostics.set(diagnostic, {
                  ...diagnostic,
                  file: actualDiagnosticFile,
                  start: sourceSpan.start,
                  length: sourceSpan.length
                });
              }
            } else {
              transformedDiagnostics.set(diagnostic, diagnostic);
            }
          } else {
            transformedDiagnostics.set(diagnostic, diagnostic);
          }
        }
        return transformedDiagnostics.get(diagnostic);
      }
      function fillSourceFileText(language, sourceFile) {
        if (transformedSourceFile.has(sourceFile)) {
          return;
        }
        transformedSourceFile.add(sourceFile);
        const [serviceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
        if (serviceScript && !serviceScript.preventLeadingOffset) {
          const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
          sourceFile.text = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength()) + sourceFile.text.substring(sourceScript.snapshot.getLength());
        }
      }
      function transformFileTextChanges(language, changes, filter) {
        const changesPerFile = {};
        const newFiles = /* @__PURE__ */ new Set();
        for (const fileChanges of changes) {
          const [_, source] = (0, utils_1.getServiceScript)(language, fileChanges.fileName);
          if (source) {
            fileChanges.textChanges.forEach((c) => {
              const { fileName, textSpan } = transformSpan(language, fileChanges.fileName, c.span, filter) ?? {};
              if (fileName && textSpan) {
                (changesPerFile[fileName] ?? (changesPerFile[fileName] = [])).push({ ...c, span: textSpan });
              }
            });
          } else {
            const list4 = changesPerFile[fileChanges.fileName] ?? (changesPerFile[fileChanges.fileName] = []);
            fileChanges.textChanges.forEach((c) => {
              list4.push(c);
            });
            if (fileChanges.isNewFile) {
              newFiles.add(fileChanges.fileName);
            }
          }
        }
        const result = [];
        for (const fileName in changesPerFile) {
          result.push({
            fileName,
            isNewFile: newFiles.has(fileName),
            textChanges: changesPerFile[fileName]
          });
        }
        return result;
      }
      function transformDocumentSpan(language, documentSpan, filter, shouldFallback) {
        let textSpan = transformSpan(language, documentSpan.fileName, documentSpan.textSpan, filter);
        if (!textSpan && shouldFallback) {
          textSpan = {
            fileName: documentSpan.fileName,
            textSpan: { start: 0, length: 0 }
          };
        }
        if (!textSpan) {
          return;
        }
        const contextSpan = transformSpan(language, documentSpan.fileName, documentSpan.contextSpan, filter);
        const originalTextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalTextSpan, filter);
        const originalContextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalContextSpan, filter);
        return {
          ...documentSpan,
          fileName: textSpan.fileName,
          textSpan: textSpan.textSpan,
          contextSpan: contextSpan?.textSpan,
          originalFileName: originalTextSpan?.fileName,
          originalTextSpan: originalTextSpan?.textSpan,
          originalContextSpan: originalContextSpan?.textSpan
        };
      }
      function transformSpan(language, fileName, textSpan, filter) {
        if (!fileName || !textSpan) {
          return;
        }
        const [serviceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (serviceScript) {
          const [sourceSpanFileName, sourceSpan] = transformTextSpan(void 0, language, serviceScript, textSpan, filter) ?? [];
          if (sourceSpan && sourceSpanFileName) {
            return {
              fileName: sourceSpanFileName,
              textSpan: sourceSpan
            };
          }
        } else {
          return {
            fileName,
            textSpan
          };
        }
      }
      function transformTextChange(sourceScript, language, serviceScript, textChange, filter) {
        const [sourceSpanFileName, sourceSpan] = transformTextSpan(sourceScript, language, serviceScript, textChange.span, filter) ?? [];
        if (sourceSpan && sourceSpanFileName) {
          return [sourceSpanFileName, {
            newText: textChange.newText,
            span: sourceSpan
          }];
        }
        return void 0;
      }
      function transformTextSpan(sourceScript, language, serviceScript, textSpan, filter) {
        const start2 = textSpan.start;
        const end = textSpan.start + textSpan.length;
        for (const [fileName, sourceStart, sourceEnd] of toSourceRanges(sourceScript, language, serviceScript, start2, end, filter)) {
          return [fileName, {
            start: sourceStart,
            length: sourceEnd - sourceStart
          }];
        }
      }
      function toSourceOffset(sourceScript, language, serviceScript, position4, filter) {
        for (const source of toSourceOffsets(sourceScript, language, serviceScript, position4, filter)) {
          return source;
        }
      }
      function* toSourceRanges(sourceScript, language, serviceScript, start2, end, filter) {
        if (sourceScript) {
          const map4 = language.maps.get(serviceScript.code, sourceScript);
          for (const [sourceStart, sourceEnd] of map4.toSourceRange(start2 - getMappingOffset(language, serviceScript), end - getMappingOffset(language, serviceScript), true, filter)) {
            yield [sourceScript.id, sourceStart, sourceEnd];
          }
        } else {
          for (const [sourceScript2, map4] of language.maps.forEach(serviceScript.code)) {
            for (const [sourceStart, sourceEnd] of map4.toSourceRange(start2 - getMappingOffset(language, serviceScript), end - getMappingOffset(language, serviceScript), true, filter)) {
              yield [sourceScript2.id, sourceStart, sourceEnd];
            }
          }
        }
      }
      function* toSourceOffsets(sourceScript, language, serviceScript, position4, filter) {
        if (sourceScript) {
          const map4 = language.maps.get(serviceScript.code, sourceScript);
          for (const [sourceOffset, mapping] of map4.toSourceLocation(position4 - getMappingOffset(language, serviceScript))) {
            if (filter(mapping.data)) {
              yield [sourceScript.id, sourceOffset];
            }
          }
        } else {
          for (const [sourceScript2, map4] of language.maps.forEach(serviceScript.code)) {
            for (const [sourceOffset, mapping] of map4.toSourceLocation(position4 - getMappingOffset(language, serviceScript))) {
              if (filter(mapping.data)) {
                yield [sourceScript2.id, sourceOffset];
              }
            }
          }
        }
      }
      function* toGeneratedRanges(language, serviceScript, sourceScript, start2, end, filter) {
        const map4 = language.maps.get(serviceScript.code, sourceScript);
        for (const [generateStart, generateEnd] of map4.toGeneratedRange(start2, end, true, filter)) {
          yield [
            generateStart + getMappingOffset(language, serviceScript),
            generateEnd + getMappingOffset(language, serviceScript)
          ];
        }
      }
      function toGeneratedOffset(language, serviceScript, sourceScript, position4, filter) {
        for (const [generateOffset] of toGeneratedOffsets(language, serviceScript, sourceScript, position4, filter)) {
          return generateOffset;
        }
      }
      function* toGeneratedOffsets(language, serviceScript, sourceScript, position4, filter) {
        const map4 = language.maps.get(serviceScript.code, sourceScript);
        for (const [generateOffset, mapping] of map4.toGeneratedLocation(position4)) {
          if (filter(mapping.data)) {
            yield [generateOffset + getMappingOffset(language, serviceScript), mapping];
          }
        }
      }
      function getMappingOffset(language, serviceScript) {
        if (serviceScript.preventLeadingOffset) {
          return 0;
        }
        const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
        return sourceScript.snapshot.getLength();
      }
    }
  });

  // node_modules/@volar/typescript/lib/node/proxyLanguageService.js
  var require_proxyLanguageService = __commonJS({
    "node_modules/@volar/typescript/lib/node/proxyLanguageService.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createProxyLanguageService = createProxyLanguageService;
      var language_core_1 = require_language_core();
      var dedupe_1 = require_dedupe2();
      var transform_1 = require_transform2();
      var utils_1 = require_utils2();
      var windowsPathReg = /\\/g;
      function createProxyLanguageService(languageService) {
        const proxyCache = /* @__PURE__ */ new Map();
        let getProxyMethod;
        return {
          initialize(language) {
            getProxyMethod = (target, p) => {
              switch (p) {
                case "getNavigationTree":
                  return getNavigationTree(language, target[p]);
                case "getOutliningSpans":
                  return getOutliningSpans(language, target[p]);
                case "getFormattingEditsForDocument":
                  return getFormattingEditsForDocument(language, target[p]);
                case "getFormattingEditsForRange":
                  return getFormattingEditsForRange(language, target[p]);
                case "getFormattingEditsAfterKeystroke":
                  return getFormattingEditsAfterKeystroke(language, target[p]);
                case "getEditsForFileRename":
                  return getEditsForFileRename(language, target[p]);
                case "getLinkedEditingRangeAtPosition":
                  return getLinkedEditingRangeAtPosition(language, target[p]);
                case "prepareCallHierarchy":
                  return prepareCallHierarchy(language, target[p]);
                case "provideCallHierarchyIncomingCalls":
                  return provideCallHierarchyIncomingCalls(language, target[p]);
                case "provideCallHierarchyOutgoingCalls":
                  return provideCallHierarchyOutgoingCalls(language, target[p]);
                case "organizeImports":
                  return organizeImports(language, target[p]);
                case "getQuickInfoAtPosition":
                  return getQuickInfoAtPosition(language, target[p]);
                case "getSignatureHelpItems":
                  return getSignatureHelpItems(language, target[p]);
                case "getDocumentHighlights":
                  return getDocumentHighlights(language, target[p]);
                case "getApplicableRefactors":
                  return getApplicableRefactors(language, target[p]);
                case "getEditsForRefactor":
                  return getEditsForRefactor(language, target[p]);
                case "getCombinedCodeFix":
                  return getCombinedCodeFix(language, target[p]);
                case "getRenameInfo":
                  return getRenameInfo(language, target[p]);
                case "getCodeFixesAtPosition":
                  return getCodeFixesAtPosition(language, target[p]);
                case "getEncodedSemanticClassifications":
                  return getEncodedSemanticClassifications(language, target[p]);
                case "getSyntacticDiagnostics":
                  return getSyntacticDiagnostics(language, languageService, target[p]);
                case "getSemanticDiagnostics":
                  return getSemanticDiagnostics(language, languageService, target[p]);
                case "getSuggestionDiagnostics":
                  return getSuggestionDiagnostics(language, languageService, target[p]);
                case "getDefinitionAndBoundSpan":
                  return getDefinitionAndBoundSpan(language, target[p]);
                case "findReferences":
                  return findReferences(language, target[p]);
                case "getDefinitionAtPosition":
                  return getDefinitionAtPosition(language, target[p]);
                case "getTypeDefinitionAtPosition":
                  return getTypeDefinitionAtPosition(language, target[p]);
                case "getImplementationAtPosition":
                  return getImplementationAtPosition(language, target[p]);
                case "findRenameLocations":
                  return findRenameLocations(language, target[p]);
                case "getReferencesAtPosition":
                  return getReferencesAtPosition(language, target[p]);
                case "getCompletionsAtPosition":
                  return getCompletionsAtPosition(language, target[p]);
                case "getCompletionEntryDetails":
                  return getCompletionEntryDetails(language, target[p]);
                case "provideInlayHints":
                  return provideInlayHints(language, target[p]);
                case "getFileReferences":
                  return getFileReferences(language, target[p]);
                case "getNavigateToItems":
                  return getNavigateToItems(language, target[p]);
              }
            };
          },
          proxy: new Proxy(languageService, {
            get(target, p, receiver) {
              if (getProxyMethod) {
                if (!proxyCache.has(p)) {
                  proxyCache.set(p, getProxyMethod(target, p));
                }
                const proxyMethod = proxyCache.get(p);
                if (proxyMethod) {
                  return proxyMethod;
                }
              }
              return Reflect.get(target, p, receiver);
            },
            set(target, p, value, receiver) {
              return Reflect.set(target, p, value, receiver);
            }
          })
        };
      }
      function getNavigationTree(language, getNavigationTree2) {
        return (filePath) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (serviceScript || targetScript?.associatedOnly) {
            const tree = getNavigationTree2(targetScript.id);
            tree.childItems = void 0;
            return tree;
          } else {
            return getNavigationTree2(fileName);
          }
        };
      }
      function getOutliningSpans(language, getOutliningSpans2) {
        return (filePath) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (serviceScript || targetScript?.associatedOnly) {
            return [];
          } else {
            return getOutliningSpans2(fileName);
          }
        };
      }
      function getFormattingEditsForDocument(language, getFormattingEditsForDocument2) {
        return (filePath, options) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          if (serviceScript) {
            const map4 = language.maps.get(serviceScript.code, targetScript);
            if (!map4.mappings.some((mapping) => (0, language_core_1.isFormattingEnabled)(mapping.data))) {
              return [];
            }
            const edits = getFormattingEditsForDocument2(targetScript.id, options);
            return edits.map((edit) => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, language_core_1.isFormattingEnabled)?.[1]).filter((edit) => !!edit);
          } else {
            return getFormattingEditsForDocument2(fileName, options);
          }
        };
      }
      function getFormattingEditsForRange(language, getFormattingEditsForRange2) {
        return (filePath, start2, end, options) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          if (serviceScript) {
            const generateStart = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, start2, language_core_1.isFormattingEnabled);
            const generateEnd = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, end, language_core_1.isFormattingEnabled);
            if (generateStart !== void 0 && generateEnd !== void 0) {
              const edits = getFormattingEditsForRange2(targetScript.id, generateStart, generateEnd, options);
              return edits.map((edit) => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, language_core_1.isFormattingEnabled)?.[1]).filter((edit) => !!edit);
            }
            return [];
          } else {
            return getFormattingEditsForRange2(fileName, start2, end, options);
          }
        };
      }
      function getFormattingEditsAfterKeystroke(language, getFormattingEditsAfterKeystroke2) {
        return (filePath, position4, key, options) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          if (serviceScript) {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position4, language_core_1.isFormattingEnabled);
            if (generatePosition !== void 0) {
              const edits = getFormattingEditsAfterKeystroke2(targetScript.id, generatePosition, key, options);
              return edits.map((edit) => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, language_core_1.isFormattingEnabled)?.[1]).filter((edit) => !!edit);
            }
            return [];
          } else {
            return getFormattingEditsAfterKeystroke2(fileName, position4, key, options);
          }
        };
      }
      function getEditsForFileRename(language, getEditsForFileRename2) {
        return (oldFilePath, newFilePath, formatOptions, preferences) => {
          const edits = getEditsForFileRename2(oldFilePath, newFilePath, formatOptions, preferences);
          return (0, transform_1.transformFileTextChanges)(language, edits, language_core_1.isRenameEnabled);
        };
      }
      function getLinkedEditingRangeAtPosition(language, getLinkedEditingRangeAtPosition2) {
        return (filePath, position4) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return void 0;
          }
          if (serviceScript) {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position4, language_core_1.isLinkedEditingEnabled);
            if (generatePosition !== void 0) {
              const info = getLinkedEditingRangeAtPosition2(targetScript.id, generatePosition);
              if (info) {
                return {
                  ranges: info.ranges.map((span) => (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, language_core_1.isLinkedEditingEnabled)?.[1]).filter((span) => !!span),
                  wordPattern: info.wordPattern
                };
              }
            }
          } else {
            return getLinkedEditingRangeAtPosition2(fileName, position4);
          }
        };
      }
      function prepareCallHierarchy(language, prepareCallHierarchy2) {
        return (filePath, position4) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return void 0;
          }
          if (serviceScript) {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position4, language_core_1.isCallHierarchyEnabled);
            if (generatePosition !== void 0) {
              const item = prepareCallHierarchy2(targetScript.id, generatePosition);
              if (Array.isArray(item)) {
                return item.map((item2) => (0, transform_1.transformCallHierarchyItem)(language, item2, language_core_1.isCallHierarchyEnabled));
              } else if (item) {
                return (0, transform_1.transformCallHierarchyItem)(language, item, language_core_1.isCallHierarchyEnabled);
              }
            }
          } else {
            return prepareCallHierarchy2(fileName, position4);
          }
        };
      }
      function provideCallHierarchyIncomingCalls(language, provideCallHierarchyIncomingCalls2) {
        return (filePath, position4) => {
          let calls = [];
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          if (serviceScript) {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position4, language_core_1.isCallHierarchyEnabled);
            if (generatePosition !== void 0) {
              calls = provideCallHierarchyIncomingCalls2(targetScript.id, generatePosition);
            }
          } else {
            calls = provideCallHierarchyIncomingCalls2(fileName, position4);
          }
          return calls.map((call) => {
            const from = (0, transform_1.transformCallHierarchyItem)(language, call.from, language_core_1.isCallHierarchyEnabled);
            const fromSpans = call.fromSpans.map((span) => (0, transform_1.transformSpan)(language, call.from.file, span, language_core_1.isCallHierarchyEnabled)?.textSpan).filter((span) => !!span);
            return {
              from,
              fromSpans
            };
          });
        };
      }
      function provideCallHierarchyOutgoingCalls(language, provideCallHierarchyOutgoingCalls2) {
        return (filePath, position4) => {
          let calls = [];
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          if (serviceScript) {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position4, language_core_1.isCallHierarchyEnabled);
            if (generatePosition !== void 0) {
              calls = provideCallHierarchyOutgoingCalls2(targetScript.id, generatePosition);
            }
          } else {
            calls = provideCallHierarchyOutgoingCalls2(fileName, position4);
          }
          return calls.map((call) => {
            const to = (0, transform_1.transformCallHierarchyItem)(language, call.to, language_core_1.isCallHierarchyEnabled);
            const fromSpans = call.fromSpans.map((span) => serviceScript ? (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, language_core_1.isCallHierarchyEnabled)?.[1] : span).filter((span) => !!span);
            return {
              to,
              fromSpans
            };
          });
        };
      }
      function organizeImports(language, organizeImports2) {
        return (args, formatOptions, preferences) => {
          const unresolved = organizeImports2(args, formatOptions, preferences);
          return (0, transform_1.transformFileTextChanges)(language, unresolved, language_core_1.isCodeActionsEnabled);
        };
      }
      function getQuickInfoAtPosition(language, getQuickInfoAtPosition2) {
        return (filePath, position4) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return void 0;
          }
          if (serviceScript) {
            const infos = [];
            for (const [generatePosition] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position4, language_core_1.isHoverEnabled)) {
              const info = getQuickInfoAtPosition2(targetScript.id, generatePosition);
              if (info) {
                const textSpan = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.textSpan, language_core_1.isHoverEnabled)?.[1];
                if (textSpan) {
                  infos.push({
                    ...info,
                    textSpan
                  });
                }
              }
            }
            if (infos.length === 1) {
              return infos[0];
            } else if (infos.length >= 2) {
              const combine = { ...infos[0] };
              combine.displayParts = combine.displayParts?.slice();
              combine.documentation = combine.documentation?.slice();
              combine.tags = combine.tags?.slice();
              const displayPartsStrs = /* @__PURE__ */ new Set([displayPartsToString(infos[0].displayParts)]);
              const documentationStrs = /* @__PURE__ */ new Set([displayPartsToString(infos[0].documentation)]);
              const tagsStrs = /* @__PURE__ */ new Set();
              for (const tag of infos[0].tags ?? []) {
                tagsStrs.add(tag.name + "__volar__" + displayPartsToString(tag.text));
              }
              for (let i = 1; i < infos.length; i++) {
                const { displayParts, documentation, tags } = infos[i];
                if (displayParts?.length && !displayPartsStrs.has(displayPartsToString(displayParts))) {
                  displayPartsStrs.add(displayPartsToString(displayParts));
                  combine.displayParts ??= [];
                  combine.displayParts.push({ ...displayParts[0], text: "\n\n" + displayParts[0].text });
                  combine.displayParts.push(...displayParts.slice(1));
                }
                if (documentation?.length && !documentationStrs.has(displayPartsToString(documentation))) {
                  documentationStrs.add(displayPartsToString(documentation));
                  combine.documentation ??= [];
                  combine.documentation.push({ ...documentation[0], text: "\n\n" + documentation[0].text });
                  combine.documentation.push(...documentation.slice(1));
                }
                for (const tag of tags ?? []) {
                  if (!tagsStrs.has(tag.name + "__volar__" + displayPartsToString(tag.text))) {
                    tagsStrs.add(tag.name + "__volar__" + displayPartsToString(tag.text));
                    combine.tags ??= [];
                    combine.tags.push(tag);
                  }
                }
              }
              return combine;
            }
          } else {
            return getQuickInfoAtPosition2(fileName, position4);
          }
        };
      }
      function getSignatureHelpItems(language, getSignatureHelpItems2) {
        return (filePath, position4, options) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return void 0;
          }
          if (serviceScript) {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position4, language_core_1.isSignatureHelpEnabled);
            if (generatePosition !== void 0) {
              const result = getSignatureHelpItems2(targetScript.id, generatePosition, options);
              if (result) {
                const applicableSpan = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.applicableSpan, language_core_1.isSignatureHelpEnabled)?.[1];
                if (applicableSpan) {
                  return {
                    ...result,
                    applicableSpan
                  };
                }
              }
            }
          } else {
            return getSignatureHelpItems2(fileName, position4, options);
          }
        };
      }
      function getDocumentHighlights(language, getDocumentHighlights2) {
        return (filePath, position4, filesToSearch) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const unresolved = linkedCodeFeatureWorker(language, fileName, position4, language_core_1.isHighlightEnabled, (fileName2, position5) => getDocumentHighlights2(fileName2, position5, filesToSearch), function* (result) {
            for (const ref2 of result) {
              for (const reference of ref2.highlightSpans) {
                yield [reference.fileName ?? ref2.fileName, reference.textSpan.start];
              }
            }
          });
          const resolved = unresolved.flat().map((highlights) => {
            return {
              ...highlights,
              highlightSpans: highlights.highlightSpans.map((span) => {
                const { textSpan } = (0, transform_1.transformSpan)(language, span.fileName ?? highlights.fileName, span.textSpan, language_core_1.isHighlightEnabled) ?? {};
                if (textSpan) {
                  return {
                    ...span,
                    contextSpan: (0, transform_1.transformSpan)(language, span.fileName ?? highlights.fileName, span.contextSpan, language_core_1.isHighlightEnabled)?.textSpan,
                    textSpan
                  };
                }
              }).filter((span) => !!span)
            };
          });
          return resolved;
        };
      }
      function getApplicableRefactors(language, getApplicableRefactors2) {
        return (filePath, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          if (serviceScript) {
            if (typeof positionOrRange === "number") {
              const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled);
              if (generatePosition !== void 0) {
                return getApplicableRefactors2(targetScript.id, generatePosition, preferences, triggerReason, kind, includeInteractiveActions);
              }
            } else {
              for (const [generatedStart, generatedEnd] of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange.pos, positionOrRange.end, language_core_1.isCodeActionsEnabled)) {
                return getApplicableRefactors2(targetScript.id, { pos: generatedStart, end: generatedEnd }, preferences, triggerReason, kind, includeInteractiveActions);
              }
            }
            return [];
          } else {
            return getApplicableRefactors2(fileName, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions);
          }
        };
      }
      function getEditsForRefactor(language, getEditsForRefactor2) {
        return (filePath, formatOptions, positionOrRange, refactorName, actionName, preferences) => {
          let edits;
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return void 0;
          }
          if (serviceScript) {
            if (typeof positionOrRange === "number") {
              const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled);
              if (generatePosition !== void 0) {
                edits = getEditsForRefactor2(targetScript.id, formatOptions, generatePosition, refactorName, actionName, preferences);
              }
            } else {
              for (const [generatedStart, generatedEnd] of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange.pos, positionOrRange.end, language_core_1.isCodeActionsEnabled)) {
                edits = getEditsForRefactor2(targetScript.id, formatOptions, { pos: generatedStart, end: generatedEnd }, refactorName, actionName, preferences);
              }
            }
          } else {
            edits = getEditsForRefactor2(fileName, formatOptions, positionOrRange, refactorName, actionName, preferences);
          }
          if (edits) {
            edits.edits = (0, transform_1.transformFileTextChanges)(language, edits.edits, language_core_1.isCodeActionsEnabled);
            return edits;
          }
        };
      }
      function getCombinedCodeFix(language, getCombinedCodeFix2) {
        return (...args) => {
          const codeActions = getCombinedCodeFix2(...args);
          codeActions.changes = (0, transform_1.transformFileTextChanges)(language, codeActions.changes, language_core_1.isCodeActionsEnabled);
          return codeActions;
        };
      }
      function getRenameInfo(language, getRenameInfo2) {
        return (filePath, position4, options) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return {
              canRename: false,
              localizedErrorMessage: "Cannot rename"
            };
          }
          if (serviceScript) {
            let failed;
            for (const [generateOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position4, language_core_1.isRenameEnabled)) {
              const info = getRenameInfo2(targetScript.id, generateOffset, options);
              if (info.canRename) {
                const span = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.triggerSpan, language_core_1.isRenameEnabled)?.[1];
                if (span) {
                  info.triggerSpan = span;
                  return info;
                }
              } else {
                failed = info;
              }
            }
            if (failed) {
              return failed;
            }
            return {
              canRename: false,
              localizedErrorMessage: "Failed to get rename locations"
            };
          } else {
            return getRenameInfo2(fileName, position4, options);
          }
        };
      }
      function getCodeFixesAtPosition(language, getCodeFixesAtPosition2) {
        return (filePath, start2, end, errorCodes, formatOptions, preferences) => {
          let fixes = [];
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          if (serviceScript) {
            const generateStart = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, start2, language_core_1.isCodeActionsEnabled);
            const generateEnd = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, end, language_core_1.isCodeActionsEnabled);
            if (generateStart !== void 0 && generateEnd !== void 0) {
              fixes = getCodeFixesAtPosition2(targetScript.id, generateStart, generateEnd, errorCodes, formatOptions, preferences);
            }
          } else {
            fixes = getCodeFixesAtPosition2(fileName, start2, end, errorCodes, formatOptions, preferences);
          }
          fixes = fixes.map((fix) => {
            fix.changes = (0, transform_1.transformFileTextChanges)(language, fix.changes, language_core_1.isCodeActionsEnabled);
            return fix;
          });
          return fixes;
        };
      }
      function getEncodedSemanticClassifications(language, getEncodedSemanticClassifications2) {
        return (filePath, span, format2) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return {
              spans: [],
              endOfLineState: 0
            };
          }
          if (serviceScript) {
            let start2;
            let end;
            const map4 = language.maps.get(serviceScript.code, targetScript);
            for (const mapping of map4.mappings) {
              if ((0, language_core_1.isSemanticTokensEnabled)(mapping.data) && mapping.sourceOffsets[0] >= span.start && mapping.sourceOffsets[0] <= span.start + span.length) {
                start2 ??= mapping.generatedOffsets[0];
                end ??= mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + (mapping.generatedLengths ?? mapping.lengths)[mapping.lengths.length - 1];
                start2 = Math.min(start2, mapping.generatedOffsets[0]);
                end = Math.max(end, mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + (mapping.generatedLengths ?? mapping.lengths)[mapping.lengths.length - 1]);
              }
            }
            start2 ??= 0;
            end ??= targetScript.snapshot.getLength();
            const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
            start2 += mappingOffset;
            end += mappingOffset;
            const result = getEncodedSemanticClassifications2(targetScript.id, { start: start2, length: end - start2 }, format2);
            const spans = [];
            for (let i = 0; i < result.spans.length; i += 3) {
              for (const [_, sourceStart, sourceEnd] of (0, transform_1.toSourceRanges)(sourceScript, language, serviceScript, result.spans[i], result.spans[i] + result.spans[i + 1], language_core_1.isSemanticTokensEnabled)) {
                spans.push(sourceStart, sourceEnd - sourceStart, result.spans[i + 2]);
                break;
              }
            }
            result.spans = spans;
            return result;
          } else {
            return getEncodedSemanticClassifications2(fileName, span, format2);
          }
        };
      }
      function getSyntacticDiagnostics(language, languageService, getSyntacticDiagnostics2) {
        return (filePath) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          return getSyntacticDiagnostics2(targetScript?.id ?? fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter((d) => !!d).filter((d) => !serviceScript || language.scripts.get(d.file.fileName) === sourceScript);
        };
      }
      function getSemanticDiagnostics(language, languageService, getSemanticDiagnostics2) {
        return (filePath) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          return getSemanticDiagnostics2(targetScript?.id ?? fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
        };
      }
      function getSuggestionDiagnostics(language, languageService, getSuggestionDiagnostics2) {
        return (filePath) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          return getSuggestionDiagnostics2(targetScript?.id ?? fileName).map((d) => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
        };
      }
      function getDefinitionAndBoundSpan(language, getDefinitionAndBoundSpan2) {
        return (filePath, position4) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const unresolved = linkedCodeFeatureWorker(language, fileName, position4, language_core_1.isDefinitionEnabled, (fileName2, position5) => getDefinitionAndBoundSpan2(fileName2, position5), function* (result) {
            for (const ref2 of result.definitions ?? []) {
              yield [ref2.fileName, ref2.textSpan.start];
            }
          });
          const textSpan = unresolved.map((s) => (0, transform_1.transformSpan)(language, fileName, s.textSpan, language_core_1.isDefinitionEnabled)?.textSpan).filter((s) => !!s)[0];
          if (!textSpan) {
            return;
          }
          const definitions = unresolved.map((s) => s.definitions?.map((s2) => (0, transform_1.transformDocumentSpan)(language, s2, language_core_1.isDefinitionEnabled, s2.fileName !== fileName)).filter((s2) => !!s2) ?? []).flat();
          return {
            textSpan,
            definitions: (0, dedupe_1.dedupeDocumentSpans)(definitions)
          };
        };
      }
      function findReferences(language, findReferences2) {
        return (filePath, position4) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const unresolved = linkedCodeFeatureWorker(language, fileName, position4, language_core_1.isReferencesEnabled, (fileName2, position5) => findReferences2(fileName2, position5), function* (result) {
            for (const ref2 of result) {
              for (const reference of ref2.references) {
                yield [reference.fileName, reference.textSpan.start];
              }
            }
          });
          const resolved = unresolved.flat().map((symbol) => {
            const definition3 = (0, transform_1.transformDocumentSpan)(language, symbol.definition, language_core_1.isDefinitionEnabled, true);
            return {
              definition: definition3,
              references: symbol.references.map((r) => (0, transform_1.transformDocumentSpan)(language, r, language_core_1.isReferencesEnabled)).filter((r) => !!r)
            };
          });
          return resolved;
        };
      }
      function getDefinitionAtPosition(language, getDefinitionAtPosition2) {
        return (filePath, position4) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const unresolved = linkedCodeFeatureWorker(language, fileName, position4, language_core_1.isDefinitionEnabled, (fileName2, position5) => getDefinitionAtPosition2(fileName2, position5), function* (result) {
            for (const ref2 of result) {
              yield [ref2.fileName, ref2.textSpan.start];
            }
          });
          const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isDefinitionEnabled, s.fileName !== fileName)).filter((s) => !!s);
          return (0, dedupe_1.dedupeDocumentSpans)(resolved);
        };
      }
      function getTypeDefinitionAtPosition(language, getTypeDefinitionAtPosition2) {
        return (filePath, position4) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const unresolved = linkedCodeFeatureWorker(language, fileName, position4, language_core_1.isTypeDefinitionEnabled, (fileName2, position5) => getTypeDefinitionAtPosition2(fileName2, position5), function* (result) {
            for (const ref2 of result) {
              yield [ref2.fileName, ref2.textSpan.start];
            }
          });
          const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isTypeDefinitionEnabled)).filter((s) => !!s);
          return (0, dedupe_1.dedupeDocumentSpans)(resolved);
        };
      }
      function getImplementationAtPosition(language, getImplementationAtPosition2) {
        return (filePath, position4) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const unresolved = linkedCodeFeatureWorker(language, fileName, position4, language_core_1.isImplementationEnabled, (fileName2, position5) => getImplementationAtPosition2(fileName2, position5), function* (result) {
            for (const ref2 of result) {
              yield [ref2.fileName, ref2.textSpan.start];
            }
          });
          const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isImplementationEnabled)).filter((s) => !!s);
          return (0, dedupe_1.dedupeDocumentSpans)(resolved);
        };
      }
      function findRenameLocations(language, findRenameLocations2) {
        return (filePath, position4, findInStrings, findInComments, preferences) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const unresolved = linkedCodeFeatureWorker(language, fileName, position4, language_core_1.isRenameEnabled, (fileName2, position5) => findRenameLocations2(fileName2, position5, findInStrings, findInComments, preferences), function* (result) {
            for (const ref2 of result) {
              yield [ref2.fileName, ref2.textSpan.start];
            }
          });
          const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isRenameEnabled)).filter((s) => !!s);
          return (0, dedupe_1.dedupeDocumentSpans)(resolved);
        };
      }
      function getReferencesAtPosition(language, getReferencesAtPosition2) {
        return (filePath, position4) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const unresolved = linkedCodeFeatureWorker(language, fileName, position4, language_core_1.isReferencesEnabled, (fileName2, position5) => getReferencesAtPosition2(fileName2, position5), function* (result) {
            for (const ref2 of result) {
              yield [ref2.fileName, ref2.textSpan.start];
            }
          });
          const resolved = unresolved.flat().map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isReferencesEnabled)).filter((s) => !!s);
          return (0, dedupe_1.dedupeDocumentSpans)(resolved);
        };
      }
      function getCompletionsAtPosition(language, getCompletionsAtPosition2) {
        return (filePath, position4, options, formattingSettings) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return void 0;
          }
          if (serviceScript) {
            const results = [];
            for (const [generatedOffset, mapping] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position4, language_core_1.isCompletionEnabled)) {
              const result = getCompletionsAtPosition2(targetScript.id, generatedOffset, options, formattingSettings);
              if (!result) {
                continue;
              }
              if (typeof mapping.data.completion === "object" && mapping.data.completion.onlyImport) {
                result.entries = result.entries.filter((entry) => !!entry.sourceDisplay);
              }
              for (const entry of result.entries) {
                entry.replacementSpan = entry.replacementSpan && (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, entry.replacementSpan, language_core_1.isCompletionEnabled)?.[1];
              }
              result.optionalReplacementSpan = result.optionalReplacementSpan && (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.optionalReplacementSpan, language_core_1.isCompletionEnabled)?.[1];
              const isAdditional = typeof mapping.data.completion === "object" && mapping.data.completion.isAdditional;
              if (isAdditional) {
                results.push(result);
              } else {
                results.unshift(result);
              }
            }
            if (results.length) {
              return {
                ...results[0],
                entries: results.map((additionalResult) => additionalResult.entries).flat()
              };
            }
          } else {
            return getCompletionsAtPosition2(fileName, position4, options, formattingSettings);
          }
        };
      }
      function getCompletionEntryDetails(language, getCompletionEntryDetails2) {
        return (filePath, position4, entryName, formatOptions, source, preferences, data2) => {
          let details;
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return void 0;
          }
          if (serviceScript) {
            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position4, language_core_1.isCompletionEnabled);
            if (generatePosition !== void 0) {
              details = getCompletionEntryDetails2(targetScript.id, generatePosition, entryName, formatOptions, source, preferences, data2);
            }
          } else {
            return getCompletionEntryDetails2(fileName, position4, entryName, formatOptions, source, preferences, data2);
          }
          if (details?.codeActions) {
            for (const codeAction of details.codeActions) {
              codeAction.changes = (0, transform_1.transformFileTextChanges)(language, codeAction.changes, language_core_1.isCompletionEnabled);
            }
          }
          return details;
        };
      }
      function provideInlayHints(language, provideInlayHints2) {
        return (filePath, span, preferences) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
          if (targetScript?.associatedOnly) {
            return [];
          }
          if (serviceScript) {
            let start2;
            let end;
            const map4 = language.maps.get(serviceScript.code, targetScript);
            for (const mapping of map4.mappings) {
              if ((0, language_core_1.isInlayHintsEnabled)(mapping.data) && mapping.sourceOffsets[0] >= span.start && mapping.sourceOffsets[0] <= span.start + span.length) {
                start2 ??= mapping.generatedOffsets[0];
                end ??= mapping.generatedOffsets[mapping.generatedOffsets.length - 1];
                start2 = Math.min(start2, mapping.generatedOffsets[0]);
                end = Math.max(end, mapping.generatedOffsets[mapping.generatedOffsets.length - 1]);
              }
            }
            if (start2 === void 0 || end === void 0) {
              start2 = 0;
              end = 0;
            }
            const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
            start2 += mappingOffset;
            end += mappingOffset;
            const result = provideInlayHints2(targetScript.id, { start: start2, length: end - start2 }, preferences);
            const hints = [];
            for (const hint of result) {
              const sourcePosition = (0, transform_1.toSourceOffset)(sourceScript, language, serviceScript, hint.position, language_core_1.isInlayHintsEnabled);
              if (sourcePosition !== void 0) {
                hints.push({
                  ...hint,
                  position: sourcePosition[1]
                });
              }
            }
            return hints;
          } else {
            return provideInlayHints2(fileName, span, preferences);
          }
        };
      }
      function getFileReferences(language, getFileReferences2) {
        return (filePath) => {
          const fileName = filePath.replace(windowsPathReg, "/");
          const unresolved = getFileReferences2(fileName);
          const resolved = unresolved.map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isReferencesEnabled)).filter((s) => !!s);
          return (0, dedupe_1.dedupeDocumentSpans)(resolved);
        };
      }
      function getNavigateToItems(language, getNavigateToItems2) {
        return (...args) => {
          const unresolved = getNavigateToItems2(...args);
          const resolved = unresolved.map((s) => (0, transform_1.transformDocumentSpan)(language, s, language_core_1.isReferencesEnabled)).filter((s) => !!s);
          return (0, dedupe_1.dedupeDocumentSpans)(resolved);
        };
      }
      function linkedCodeFeatureWorker(language, fileName, position4, filter, worker, getLinkedCodes) {
        const results = [];
        const processedFilePositions = /* @__PURE__ */ new Set();
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (serviceScript) {
          for (const [generatedOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position4, filter)) {
            process3(targetScript.id, generatedOffset);
          }
        } else {
          process3(fileName, position4);
        }
        return results;
        function process3(fileName2, position5) {
          if (processedFilePositions.has(fileName2 + ":" + position5)) {
            return;
          }
          processedFilePositions.add(fileName2 + ":" + position5);
          const result = worker(fileName2, position5);
          if (!result) {
            return;
          }
          results.push(result);
          for (const ref2 of getLinkedCodes(result)) {
            processedFilePositions.add(ref2[0] + ":" + ref2[1]);
            const [serviceScript2] = (0, utils_1.getServiceScript)(language, ref2[0]);
            if (!serviceScript2) {
              continue;
            }
            const linkedCodeMap = language.linkedCodeMaps.get(serviceScript2.code);
            if (!linkedCodeMap) {
              continue;
            }
            const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript2);
            for (const linkedCodeOffset of linkedCodeMap.getLinkedOffsets(ref2[1] - mappingOffset)) {
              process3(ref2[0], linkedCodeOffset + mappingOffset);
            }
          }
        }
      }
      function displayPartsToString(displayParts) {
        if (displayParts) {
          return displayParts.map((displayPart) => displayPart.text).join("");
        }
        return "";
      }
    }
  });

  // node_modules/@volar/typescript/lib/resolveModuleName.js
  var require_resolveModuleName = __commonJS({
    "node_modules/@volar/typescript/lib/resolveModuleName.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createResolveModuleName = createResolveModuleName;
      function createResolveModuleName(ts2, getFileSize, host, languagePlugins, getSourceScript) {
        const toSourceFileInfo = /* @__PURE__ */ new Map();
        const moduleResolutionHost = {
          readFile: host.readFile.bind(host),
          directoryExists: host.directoryExists?.bind(host),
          realpath: host.realpath?.bind(host),
          getCurrentDirectory: host.getCurrentDirectory?.bind(host),
          getDirectories: host.getDirectories?.bind(host),
          useCaseSensitiveFileNames: typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames.bind(host) : host.useCaseSensitiveFileNames,
          fileExists(fileName) {
            for (const { typescript } of languagePlugins) {
              if (!typescript) {
                continue;
              }
              for (const { extension: extension2 } of typescript.extraFileExtensions) {
                if (fileName.endsWith(`.d.${extension2}.ts`)) {
                  const sourceFileName = fileName.slice(0, -`.d.${extension2}.ts`.length) + `.${extension2}`;
                  if (fileExists(sourceFileName)) {
                    const sourceScript = getSourceScript(sourceFileName);
                    if (sourceScript?.generated) {
                      const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
                      if (serviceScript) {
                        const dtsPath = sourceFileName + ".d.ts";
                        if ((serviceScript.extension === ".js" || serviceScript.extension === ".jsx") && fileExists(dtsPath)) {
                          toSourceFileInfo.set(fileName, {
                            sourceFileName: dtsPath,
                            extension: ".ts"
                          });
                        } else {
                          toSourceFileInfo.set(fileName, {
                            sourceFileName,
                            extension: serviceScript.extension
                          });
                        }
                        return true;
                      }
                    }
                  }
                }
              }
              if (typescript.resolveHiddenExtensions && fileName.endsWith(`.d.ts`)) {
                for (const { extension: extension2 } of typescript.extraFileExtensions) {
                  const sourceFileName = fileName.slice(0, -`.d.ts`.length) + `.${extension2}`;
                  if (fileExists(sourceFileName)) {
                    const sourceScript = getSourceScript(sourceFileName);
                    if (sourceScript?.generated) {
                      const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
                      if (serviceScript) {
                        toSourceFileInfo.set(fileName, {
                          sourceFileName,
                          extension: serviceScript.extension
                        });
                        return true;
                      }
                    }
                  }
                }
              }
            }
            return host.fileExists(fileName);
          }
        };
        return (moduleName, containingFile, compilerOptions, cache, redirectedReference, resolutionMode) => {
          const result = ts2.resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionHost, cache, redirectedReference, resolutionMode);
          if (result.resolvedModule) {
            const sourceFileInfo = toSourceFileInfo.get(result.resolvedModule.resolvedFileName);
            if (sourceFileInfo) {
              result.resolvedModule.resolvedFileName = sourceFileInfo.sourceFileName;
              result.resolvedModule.extension = sourceFileInfo.extension;
            }
          }
          toSourceFileInfo.clear();
          return result;
        };
        function fileExists(fileName) {
          if (host.fileExists(fileName)) {
            const fileSize = getFileSize?.(fileName) ?? host.readFile(fileName)?.length ?? 0;
            return fileSize < 4 * 1024 * 1024;
          }
          return false;
        }
      }
    }
  });

  // node_modules/@volar/typescript/lib/node/decorateLanguageServiceHost.js
  var require_decorateLanguageServiceHost = __commonJS({
    "node_modules/@volar/typescript/lib/node/decorateLanguageServiceHost.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.decorateLanguageServiceHost = decorateLanguageServiceHost;
      exports3.searchExternalFiles = searchExternalFiles;
      var resolveModuleName_1 = require_resolveModuleName();
      function decorateLanguageServiceHost(ts2, language, languageServiceHost) {
        const pluginExtensions = language.plugins.map((plugin) => plugin.typescript?.extraFileExtensions.map((ext) => "." + ext.extension) ?? []).flat();
        const scripts = /* @__PURE__ */ new Map();
        const crashFileNames = /* @__PURE__ */ new Set();
        const readDirectory = languageServiceHost.readDirectory?.bind(languageServiceHost);
        const resolveModuleNameLiterals = languageServiceHost.resolveModuleNameLiterals?.bind(languageServiceHost);
        const resolveModuleNames = languageServiceHost.resolveModuleNames?.bind(languageServiceHost);
        const getScriptSnapshot = languageServiceHost.getScriptSnapshot.bind(languageServiceHost);
        const getScriptKind = languageServiceHost.getScriptKind?.bind(languageServiceHost);
        if (readDirectory) {
          languageServiceHost.readDirectory = (path, extensions, exclude, include, depth) => {
            if (extensions) {
              for (const ext of pluginExtensions) {
                if (!extensions.includes(ext)) {
                  extensions = [...extensions, ext];
                }
              }
            }
            return readDirectory(path, extensions, exclude, include, depth);
          };
        }
        if (pluginExtensions.length) {
          const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts2, ts2.sys.getFileSize, languageServiceHost, language.plugins, (fileName) => language.scripts.get(fileName));
          const getCanonicalFileName = languageServiceHost.useCaseSensitiveFileNames?.() ? (fileName) => fileName : (fileName) => fileName.toLowerCase();
          const moduleResolutionCache = ts2.createModuleResolutionCache(languageServiceHost.getCurrentDirectory(), getCanonicalFileName, languageServiceHost.getCompilationSettings());
          if (resolveModuleNameLiterals) {
            languageServiceHost.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, ...rest) => {
              if (moduleLiterals.every((name2) => !pluginExtensions.some((ext) => name2.text.endsWith(ext)))) {
                return resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, options, ...rest);
              }
              return moduleLiterals.map((moduleLiteral) => {
                return resolveModuleName(moduleLiteral.text, containingFile, options, moduleResolutionCache, redirectedReference);
              });
            };
          }
          if (resolveModuleNames) {
            languageServiceHost.resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile) => {
              if (moduleNames.every((name2) => !pluginExtensions.some((ext) => name2.endsWith(ext)))) {
                return resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile);
              }
              return moduleNames.map((moduleName) => {
                return resolveModuleName(moduleName, containingFile, options, moduleResolutionCache, redirectedReference).resolvedModule;
              });
            };
          }
        }
        languageServiceHost.getScriptSnapshot = (fileName) => {
          const virtualScript = updateVirtualScript(fileName);
          if (virtualScript) {
            return virtualScript.snapshot;
          }
          return getScriptSnapshot(fileName);
        };
        if (getScriptKind) {
          languageServiceHost.getScriptKind = (fileName) => {
            const virtualScript = updateVirtualScript(fileName);
            if (virtualScript) {
              return virtualScript.scriptKind;
            }
            return getScriptKind(fileName);
          };
        }
        function updateVirtualScript(fileName) {
          if (crashFileNames.has(fileName)) {
            return;
          }
          let version2;
          try {
            version2 = languageServiceHost.getScriptVersion(fileName);
          } catch {
            crashFileNames.add(fileName);
          }
          if (version2 === void 0) {
            return;
          }
          let script = scripts.get(fileName);
          if (!script || script[0] !== version2) {
            script = [version2];
            const sourceScript = language.scripts.get(fileName);
            if (sourceScript?.generated) {
              const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
              if (serviceScript) {
                if (serviceScript.preventLeadingOffset) {
                  script[1] = {
                    extension: serviceScript.extension,
                    scriptKind: serviceScript.scriptKind,
                    snapshot: serviceScript.code.snapshot
                  };
                } else {
                  const sourceContents = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength());
                  const virtualContents = sourceContents.split("\n").map((line) => " ".repeat(line.length)).join("\n") + serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
                  script[1] = {
                    extension: serviceScript.extension,
                    scriptKind: serviceScript.scriptKind,
                    snapshot: ts2.ScriptSnapshot.fromString(virtualContents)
                  };
                }
              }
              if (sourceScript.generated.languagePlugin.typescript?.getExtraServiceScripts) {
                console.warn("getExtraServiceScripts() is not available in TS plugin.");
              }
            }
            scripts.set(fileName, script);
          }
          return script[1];
        }
      }
      function searchExternalFiles(ts2, project, exts) {
        if (project.projectKind !== ts2.server.ProjectKind.Configured) {
          return [];
        }
        const configFile = project.getProjectName();
        const config = ts2.readJsonConfigFile(configFile, project.readFile.bind(project));
        const parseHost = {
          useCaseSensitiveFileNames: project.useCaseSensitiveFileNames(),
          fileExists: project.fileExists.bind(project),
          readFile: project.readFile.bind(project),
          readDirectory: (...args) => {
            args[1] = exts;
            return project.readDirectory(...args);
          }
        };
        const parsed = ts2.parseJsonSourceFileConfigFileContent(config, parseHost, project.getCurrentDirectory());
        return parsed.fileNames;
      }
    }
  });

  // node_modules/@volar/typescript/lib/node/decorateProgram.js
  var require_decorateProgram = __commonJS({
    "node_modules/@volar/typescript/lib/node/decorateProgram.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.decorateProgram = decorateProgram;
      var transform_1 = require_transform2();
      var utils_1 = require_utils2();
      function decorateProgram(language, program) {
        const emit = program.emit;
        const getSyntacticDiagnostics = program.getSyntacticDiagnostics;
        const getSemanticDiagnostics = program.getSemanticDiagnostics;
        const getGlobalDiagnostics = program.getGlobalDiagnostics;
        const getSourceFileByPath = program.getSourceFileByPath;
        const getBindAndCheckDiagnostics = program.getBindAndCheckDiagnostics;
        program.emit = (...args) => {
          const result = emit(...args);
          return {
            ...result,
            diagnostics: result.diagnostics.map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d)
          };
        };
        program.getSyntacticDiagnostics = (sourceFile, cancellationToken) => {
          if (!sourceFile) {
            return getSyntacticDiagnostics(void 0, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d);
          } else {
            const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
            const actualSourceFile = targetScript ? program.getSourceFile(targetScript.id) : sourceFile;
            return getSyntacticDiagnostics(actualSourceFile, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
          }
        };
        program.getSemanticDiagnostics = (sourceFile, cancellationToken) => {
          if (!sourceFile) {
            return getSemanticDiagnostics(void 0, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d);
          } else {
            const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
            const actualSourceFile = targetScript ? program.getSourceFile(targetScript.id) : sourceFile;
            return getSemanticDiagnostics(actualSourceFile, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d).filter((d) => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
          }
        };
        program.getGlobalDiagnostics = (cancellationToken) => {
          return getGlobalDiagnostics(cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d);
        };
        program.getBindAndCheckDiagnostics = (sourceFile, cancellationToken) => {
          if (!sourceFile) {
            return getBindAndCheckDiagnostics(void 0, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d);
          } else {
            const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
            const actualSourceFile = targetScript ? program.getSourceFile(targetScript.id) : sourceFile;
            return getBindAndCheckDiagnostics(actualSourceFile, cancellationToken).map((d) => (0, transform_1.transformDiagnostic)(language, d, program, true)).filter((d) => !!d).filter((d) => !serviceScript || language.scripts.get(d.file.fileName) === sourceScript);
          }
        };
        program.getSourceFileByPath = (path) => {
          const sourceFile = getSourceFileByPath(path);
          if (sourceFile) {
            (0, transform_1.fillSourceFileText)(language, sourceFile);
          }
          return sourceFile;
        };
      }
    }
  });

  // node_modules/@volar/typescript/lib/node/proxyCreateProgram.js
  var require_proxyCreateProgram = __commonJS({
    "node_modules/@volar/typescript/lib/node/proxyCreateProgram.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.proxyCreateProgram = proxyCreateProgram;
      var language_core_1 = require_language_core();
      var resolveModuleName_1 = require_resolveModuleName();
      var decorateProgram_1 = require_decorateProgram();
      var common_1 = require_common2();
      var arrayEqual = (a, b) => {
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      };
      var objectEqual = (a, b) => {
        const keysA = Object.keys(a);
        const keysB = Object.keys(b);
        if (keysA.length !== keysB.length) {
          return false;
        }
        for (const key of keysA) {
          if (a[key] !== b[key]) {
            return false;
          }
        }
        return true;
      };
      function proxyCreateProgram(ts2, original, create) {
        const sourceFileSnapshots = new language_core_1.FileMap(ts2.sys.useCaseSensitiveFileNames);
        const parsedSourceFiles = /* @__PURE__ */ new WeakMap();
        let lastOptions;
        let languagePlugins;
        let language;
        let moduleResolutionCache;
        return new Proxy(original, {
          apply: (target, thisArg, args) => {
            const options = args[0];
            assert(!!options.host, "!!options.host");
            if (!lastOptions || !languagePlugins || !language || !arrayEqual(options.rootNames, lastOptions.rootNames) || !objectEqual(options.options, lastOptions.options)) {
              moduleResolutionCache = ts2.createModuleResolutionCache(options.host.getCurrentDirectory(), options.host.getCanonicalFileName, options.options);
              lastOptions = options;
              const created = create(ts2, options);
              if (Array.isArray(created)) {
                languagePlugins = created;
              } else {
                languagePlugins = created.languagePlugins;
              }
              language = (0, language_core_1.createLanguage)([
                ...languagePlugins,
                { getLanguageId: common_1.resolveFileLanguageId }
              ], new language_core_1.FileMap(ts2.sys.useCaseSensitiveFileNames), (fileName) => {
                if (!sourceFileSnapshots.has(fileName)) {
                  const sourceFileText = originalHost.readFile(fileName);
                  if (sourceFileText !== void 0) {
                    sourceFileSnapshots.set(fileName, [void 0, {
                      getChangeRange() {
                        return void 0;
                      },
                      getLength() {
                        return sourceFileText.length;
                      },
                      getText(start2, end) {
                        return sourceFileText.substring(start2, end);
                      }
                    }]);
                  } else {
                    sourceFileSnapshots.set(fileName, [void 0, void 0]);
                  }
                }
                const snapshot = sourceFileSnapshots.get(fileName)?.[1];
                if (snapshot) {
                  language.scripts.set(fileName, snapshot);
                } else {
                  language.scripts.delete(fileName);
                }
              });
              if ("setup" in created) {
                created.setup?.(language);
              }
            }
            const originalHost = options.host;
            const extensions = languagePlugins.map((plugin) => plugin.typescript?.extraFileExtensions.map(({ extension: extension2 }) => `.${extension2}`) ?? []).flat();
            options.host = { ...originalHost };
            options.host.getSourceFile = (fileName, languageVersionOrOptions, onError, shouldCreateNewSourceFile) => {
              const originalSourceFile = originalHost.getSourceFile(fileName, languageVersionOrOptions, onError, shouldCreateNewSourceFile);
              if (!sourceFileSnapshots.has(fileName) || sourceFileSnapshots.get(fileName)?.[0] !== originalSourceFile) {
                if (originalSourceFile) {
                  sourceFileSnapshots.set(fileName, [originalSourceFile, {
                    getChangeRange() {
                      return void 0;
                    },
                    getLength() {
                      return originalSourceFile.text.length;
                    },
                    getText(start2, end) {
                      return originalSourceFile.text.substring(start2, end);
                    }
                  }]);
                } else {
                  sourceFileSnapshots.set(fileName, [void 0, void 0]);
                }
              }
              if (!originalSourceFile) {
                return;
              }
              if (!parsedSourceFiles.has(originalSourceFile)) {
                const sourceScript = language.scripts.get(fileName);
                assert(!!sourceScript, "!!sourceScript");
                parsedSourceFiles.set(originalSourceFile, void 0);
                if (sourceScript.generated?.languagePlugin.typescript) {
                  const { getServiceScript, getExtraServiceScripts } = sourceScript.generated.languagePlugin.typescript;
                  const serviceScript = getServiceScript(sourceScript.generated.root);
                  if (serviceScript && !serviceScript.preventLeadingOffset) {
                    let patchedText = originalSourceFile.text.split("\n").map((line) => " ".repeat(line.length)).join("\n");
                    let scriptKind = ts2.ScriptKind.TS;
                    scriptKind = serviceScript.scriptKind;
                    patchedText += serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
                    const parsedSourceFile = ts2.createSourceFile(fileName, patchedText, languageVersionOrOptions, void 0, scriptKind);
                    parsedSourceFile.version = originalSourceFile.version;
                    parsedSourceFiles.set(originalSourceFile, parsedSourceFile);
                  }
                  if (getExtraServiceScripts) {
                    console.warn("getExtraServiceScripts() is not available in this use case.");
                  }
                }
              }
              return parsedSourceFiles.get(originalSourceFile) ?? originalSourceFile;
            };
            if (extensions.length) {
              options.options.allowArbitraryExtensions = true;
              const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts2, ts2.sys.getFileSize, originalHost, language.plugins, (fileName) => language.scripts.get(fileName));
              const resolveModuleNameLiterals = originalHost.resolveModuleNameLiterals;
              const resolveModuleNames = originalHost.resolveModuleNames;
              options.host.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, compilerOptions, ...rest) => {
                if (resolveModuleNameLiterals && moduleLiterals.every((name2) => !extensions.some((ext) => name2.text.endsWith(ext)))) {
                  return resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, compilerOptions, ...rest);
                }
                return moduleLiterals.map((moduleLiteral) => {
                  return resolveModuleName(moduleLiteral.text, containingFile, compilerOptions, moduleResolutionCache, redirectedReference);
                });
              };
              options.host.resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, compilerOptions, containingSourceFile) => {
                if (resolveModuleNames && moduleNames.every((name2) => !extensions.some((ext) => name2.endsWith(ext)))) {
                  return resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, compilerOptions, containingSourceFile);
                }
                return moduleNames.map((moduleName) => {
                  return resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionCache, redirectedReference).resolvedModule;
                });
              };
            }
            const program = Reflect.apply(target, thisArg, args);
            (0, decorateProgram_1.decorateProgram)(language, program);
            program.__volar__ = { language };
            return program;
          }
        });
      }
      function assert(condition, message) {
        if (!condition) {
          console.error(message);
          throw new Error(message);
        }
      }
    }
  });

  // node_modules/path-browserify/index.js
  var require_path_browserify = __commonJS({
    "node_modules/path-browserify/index.js"(exports3, module) {
      "use strict";
      function assertPath3(path) {
        if (typeof path !== "string") {
          throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
        }
      }
      function normalizeStringPosix(path, allowAboveRoot) {
        var res = "";
        var lastSegmentLength = 0;
        var lastSlash = -1;
        var dots = 0;
        var code2;
        for (var i = 0; i <= path.length; ++i) {
          if (i < path.length)
            code2 = path.charCodeAt(i);
          else if (code2 === 47)
            break;
          else
            code2 = 47;
          if (code2 === 47) {
            if (lastSlash === i - 1 || dots === 1) {
            } else if (lastSlash !== i - 1 && dots === 2) {
              if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                if (res.length > 2) {
                  var lastSlashIndex = res.lastIndexOf("/");
                  if (lastSlashIndex !== res.length - 1) {
                    if (lastSlashIndex === -1) {
                      res = "";
                      lastSegmentLength = 0;
                    } else {
                      res = res.slice(0, lastSlashIndex);
                      lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                    }
                    lastSlash = i;
                    dots = 0;
                    continue;
                  }
                } else if (res.length === 2 || res.length === 1) {
                  res = "";
                  lastSegmentLength = 0;
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              }
              if (allowAboveRoot) {
                if (res.length > 0)
                  res += "/..";
                else
                  res = "..";
                lastSegmentLength = 2;
              }
            } else {
              if (res.length > 0)
                res += "/" + path.slice(lastSlash + 1, i);
              else
                res = path.slice(lastSlash + 1, i);
              lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
          } else if (code2 === 46 && dots !== -1) {
            ++dots;
          } else {
            dots = -1;
          }
        }
        return res;
      }
      function _format3(sep3, pathObject) {
        var dir = pathObject.dir || pathObject.root;
        var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir) {
          return base;
        }
        if (dir === pathObject.root) {
          return dir + base;
        }
        return dir + sep3 + base;
      }
      var posix3 = {
        // path.resolve([from ...], to)
        resolve: function resolve3() {
          var resolvedPath = "";
          var resolvedAbsolute = false;
          var cwd3;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path;
            if (i >= 0)
              path = arguments[i];
            else {
              if (cwd3 === void 0)
                cwd3 = process.cwd();
              path = cwd3;
            }
            assertPath3(path);
            if (path.length === 0) {
              continue;
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47;
          }
          resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
          if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
              return "/" + resolvedPath;
            else
              return "/";
          } else if (resolvedPath.length > 0) {
            return resolvedPath;
          } else {
            return ".";
          }
        },
        normalize: function normalize4(path) {
          assertPath3(path);
          if (path.length === 0)
            return ".";
          var isAbsolute2 = path.charCodeAt(0) === 47;
          var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
          path = normalizeStringPosix(path, !isAbsolute2);
          if (path.length === 0 && !isAbsolute2)
            path = ".";
          if (path.length > 0 && trailingSeparator)
            path += "/";
          if (isAbsolute2)
            return "/" + path;
          return path;
        },
        isAbsolute: function isAbsolute2(path) {
          assertPath3(path);
          return path.length > 0 && path.charCodeAt(0) === 47;
        },
        join: function join4() {
          if (arguments.length === 0)
            return ".";
          var joined;
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i];
            assertPath3(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else
                joined += "/" + arg;
            }
          }
          if (joined === void 0)
            return ".";
          return posix3.normalize(joined);
        },
        relative: function relative3(from, to) {
          assertPath3(from);
          assertPath3(to);
          if (from === to)
            return "";
          from = posix3.resolve(from);
          to = posix3.resolve(to);
          if (from === to)
            return "";
          var fromStart = 1;
          for (; fromStart < from.length; ++fromStart) {
            if (from.charCodeAt(fromStart) !== 47)
              break;
          }
          var fromEnd = from.length;
          var fromLen = fromEnd - fromStart;
          var toStart = 1;
          for (; toStart < to.length; ++toStart) {
            if (to.charCodeAt(toStart) !== 47)
              break;
          }
          var toEnd = to.length;
          var toLen = toEnd - toStart;
          var length = fromLen < toLen ? fromLen : toLen;
          var lastCommonSep = -1;
          var i = 0;
          for (; i <= length; ++i) {
            if (i === length) {
              if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                  return to.slice(toStart + i + 1);
                } else if (i === 0) {
                  return to.slice(toStart + i);
                }
              } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                  lastCommonSep = i;
                } else if (i === 0) {
                  lastCommonSep = 0;
                }
              }
              break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
              break;
            else if (fromCode === 47)
              lastCommonSep = i;
          }
          var out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === 47) {
              if (out.length === 0)
                out += "..";
              else
                out += "/..";
            }
          }
          if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
          else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47)
              ++toStart;
            return to.slice(toStart);
          }
        },
        _makeLong: function _makeLong2(path) {
          return path;
        },
        dirname: function dirname4(path) {
          assertPath3(path);
          if (path.length === 0)
            return ".";
          var code2 = path.charCodeAt(0);
          var hasRoot = code2 === 47;
          var end = -1;
          var matchedSlash = true;
          for (var i = path.length - 1; i >= 1; --i) {
            code2 = path.charCodeAt(i);
            if (code2 === 47) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : ".";
          if (hasRoot && end === 1)
            return "//";
          return path.slice(0, end);
        },
        basename: function basename4(path, ext) {
          if (ext !== void 0 && typeof ext !== "string")
            throw new TypeError('"ext" argument must be a string');
          assertPath3(path);
          var start2 = 0;
          var end = -1;
          var matchedSlash = true;
          var i;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
              return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
              var code2 = path.charCodeAt(i);
              if (code2 === 47) {
                if (!matchedSlash) {
                  start2 = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code2 === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start2 === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path.length;
            return path.slice(start2, end);
          } else {
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start2 = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1)
              return "";
            return path.slice(start2, end);
          }
        },
        extname: function extname4(path) {
          assertPath3(path);
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var preDotState = 0;
          for (var i = path.length - 1; i >= 0; --i) {
            var code2 = path.charCodeAt(i);
            if (code2 === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code2 === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: function format2(pathObject) {
          if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
          }
          return _format3("/", pathObject);
        },
        parse: function parse5(path) {
          assertPath3(path);
          var ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0)
            return ret;
          var code2 = path.charCodeAt(0);
          var isAbsolute2 = code2 === 47;
          var start2;
          if (isAbsolute2) {
            ret.root = "/";
            start2 = 1;
          } else {
            start2 = 0;
          }
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var i = path.length - 1;
          var preDotState = 0;
          for (; i >= start2; --i) {
            code2 = path.charCodeAt(i);
            if (code2 === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code2 === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute2)
                ret.base = ret.name = path.slice(1, end);
              else
                ret.base = ret.name = path.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute2) {
              ret.name = path.slice(1, startDot);
              ret.base = path.slice(1, end);
            } else {
              ret.name = path.slice(startPart, startDot);
              ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
          }
          if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
          else if (isAbsolute2)
            ret.dir = "/";
          return ret;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      posix3.posix = posix3;
      module.exports = posix3;
    }
  });

  // node_modules/@volar/typescript/lib/protocol/createProject.js
  var require_createProject = __commonJS({
    "node_modules/@volar/typescript/lib/protocol/createProject.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createLanguageServiceHost = createLanguageServiceHost2;
      var language_core_1 = require_language_core();
      var path = require_path_browserify();
      var resolveModuleName_1 = require_resolveModuleName();
      function createLanguageServiceHost2(ts2, sys, language, asScriptId, projectHost) {
        const scriptVersions = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
        let lastProjectVersion;
        let tsProjectVersion = 0;
        let tsFileRegistry = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
        let tsFileDirRegistry = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
        let extraScriptRegistry = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
        let lastTsVirtualFileSnapshots = /* @__PURE__ */ new Set();
        let lastOtherVirtualFileSnapshots = /* @__PURE__ */ new Set();
        let languageServiceHost = {
          ...sys,
          getCurrentDirectory() {
            return projectHost.getCurrentDirectory();
          },
          useCaseSensitiveFileNames() {
            return sys.useCaseSensitiveFileNames;
          },
          getNewLine() {
            return sys.newLine;
          },
          getTypeRootsVersion: () => {
            return "version" in sys ? sys.version : -1;
          },
          getDirectories(dirName) {
            return sys.getDirectories(dirName);
          },
          readDirectory(dirName, extensions, excludes, includes, depth) {
            const exts = new Set(extensions);
            for (const languagePlugin of language.plugins) {
              for (const ext of languagePlugin.typescript?.extraFileExtensions ?? []) {
                exts.add("." + ext.extension);
              }
            }
            extensions = [...exts];
            return sys.readDirectory(dirName, extensions, excludes, includes, depth);
          },
          getCompilationSettings() {
            const options = projectHost.getCompilationSettings();
            if (language.plugins.some((language2) => language2.typescript?.extraFileExtensions.length)) {
              options.allowNonTsExtensions ??= true;
              if (!options.allowNonTsExtensions) {
                console.warn("`allowNonTsExtensions` must be `true`.");
              }
            }
            return options;
          },
          getLocalizedDiagnosticMessages: projectHost.getLocalizedDiagnosticMessages,
          getProjectReferences: projectHost.getProjectReferences,
          getDefaultLibFileName: (options) => {
            try {
              return ts2.getDefaultLibFilePath(options);
            } catch {
              return `/node_modules/typescript/lib/${ts2.getDefaultLibFileName(options)}`;
            }
          },
          readFile(fileName) {
            const snapshot = getScriptSnapshot(fileName);
            if (snapshot) {
              return snapshot.getText(0, snapshot.getLength());
            }
          },
          directoryExists(directoryName) {
            sync();
            if (tsFileDirRegistry.has(directoryName)) {
              return true;
            }
            return sys.directoryExists(directoryName);
          },
          fileExists(fileName) {
            return getScriptVersion(fileName) !== "";
          },
          getProjectVersion() {
            sync();
            return tsProjectVersion + ("version" in sys ? `:${sys.version}` : "");
          },
          getScriptFileNames() {
            sync();
            return [...tsFileRegistry.keys()];
          },
          getScriptKind(fileName) {
            sync();
            if (extraScriptRegistry.has(fileName)) {
              return extraScriptRegistry.get(fileName).scriptKind;
            }
            const sourceScript = language.scripts.get(asScriptId(fileName));
            if (sourceScript?.generated) {
              const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
              if (serviceScript) {
                return serviceScript.scriptKind;
              }
            }
            switch (path.extname(fileName)) {
              case ".js":
              case ".cjs":
              case ".mjs":
                return ts2.ScriptKind.JS;
              case ".jsx":
                return ts2.ScriptKind.JSX;
              case ".ts":
              case ".cts":
              case ".mts":
                return ts2.ScriptKind.TS;
              case ".tsx":
                return ts2.ScriptKind.TSX;
              case ".json":
                return ts2.ScriptKind.JSON;
              default:
                return ts2.ScriptKind.Unknown;
            }
          },
          getScriptVersion,
          getScriptSnapshot
        };
        for (const plugin of language.plugins) {
          if (plugin.typescript?.resolveLanguageServiceHost) {
            languageServiceHost = plugin.typescript.resolveLanguageServiceHost(languageServiceHost);
          }
        }
        if (language.plugins.some((plugin) => plugin.typescript?.extraFileExtensions.length)) {
          const moduleCache = ts2.createModuleResolutionCache(languageServiceHost.getCurrentDirectory(), languageServiceHost.useCaseSensitiveFileNames?.() ? (s) => s : (s) => s.toLowerCase(), languageServiceHost.getCompilationSettings());
          const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts2, sys.getFileSize, languageServiceHost, language.plugins, (fileName) => language.scripts.get(asScriptId(fileName)));
          let lastSysVersion = "version" in sys ? sys.version : void 0;
          languageServiceHost.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, sourceFile) => {
            if ("version" in sys && lastSysVersion !== sys.version) {
              lastSysVersion = sys.version;
              moduleCache.clear();
            }
            return moduleLiterals.map((moduleLiteral) => {
              return resolveModuleName(moduleLiteral.text, containingFile, options, moduleCache, redirectedReference, sourceFile.impliedNodeFormat);
            });
          };
          languageServiceHost.resolveModuleNames = (moduleNames, containingFile, _reusedNames, redirectedReference, options) => {
            if ("version" in sys && lastSysVersion !== sys.version) {
              lastSysVersion = sys.version;
              moduleCache.clear();
            }
            return moduleNames.map((moduleName) => {
              return resolveModuleName(moduleName, containingFile, options, moduleCache, redirectedReference).resolvedModule;
            });
          };
        }
        return {
          languageServiceHost,
          getExtraServiceScript
        };
        function getExtraServiceScript(fileName) {
          sync();
          return extraScriptRegistry.get(fileName);
        }
        function sync() {
          const newProjectVersion = projectHost.getProjectVersion?.();
          const shouldUpdate = newProjectVersion === void 0 || newProjectVersion !== lastProjectVersion;
          if (!shouldUpdate) {
            return;
          }
          lastProjectVersion = newProjectVersion;
          extraScriptRegistry.clear();
          const newTsVirtualFileSnapshots = /* @__PURE__ */ new Set();
          const newOtherVirtualFileSnapshots = /* @__PURE__ */ new Set();
          const tsFileNamesSet = /* @__PURE__ */ new Set();
          for (const fileName of projectHost.getScriptFileNames()) {
            const sourceScript = language.scripts.get(asScriptId(fileName));
            if (sourceScript?.generated) {
              const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
              if (serviceScript) {
                newTsVirtualFileSnapshots.add(serviceScript.code.snapshot);
                tsFileNamesSet.add(fileName);
              }
              for (const extraServiceScript of sourceScript.generated.languagePlugin.typescript?.getExtraServiceScripts?.(fileName, sourceScript.generated.root) ?? []) {
                newTsVirtualFileSnapshots.add(extraServiceScript.code.snapshot);
                tsFileNamesSet.add(extraServiceScript.fileName);
                extraScriptRegistry.set(extraServiceScript.fileName, extraServiceScript);
              }
              for (const code2 of (0, language_core_1.forEachEmbeddedCode)(sourceScript.generated.root)) {
                newOtherVirtualFileSnapshots.add(code2.snapshot);
              }
            } else {
              tsFileNamesSet.add(fileName);
            }
          }
          if (!setEquals(lastTsVirtualFileSnapshots, newTsVirtualFileSnapshots)) {
            tsProjectVersion++;
          } else if (setEquals(lastOtherVirtualFileSnapshots, newOtherVirtualFileSnapshots)) {
            tsProjectVersion++;
          }
          lastTsVirtualFileSnapshots = newTsVirtualFileSnapshots;
          lastOtherVirtualFileSnapshots = newOtherVirtualFileSnapshots;
          tsFileRegistry.clear();
          tsFileDirRegistry.clear();
          for (const fileName of tsFileNamesSet) {
            tsFileRegistry.set(fileName, true);
            const parts = fileName.split("/");
            for (let i = 1; i < parts.length; i++) {
              const dirName = parts.slice(0, i).join("/");
              tsFileDirRegistry.set(dirName, true);
            }
          }
        }
        function getScriptSnapshot(fileName) {
          sync();
          if (extraScriptRegistry.has(fileName)) {
            return extraScriptRegistry.get(fileName).code.snapshot;
          }
          const sourceScript = language.scripts.get(asScriptId(fileName));
          if (sourceScript?.generated) {
            const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
            if (serviceScript) {
              return serviceScript.code.snapshot;
            }
          } else if (sourceScript) {
            return sourceScript.snapshot;
          }
        }
        function getScriptVersion(fileName) {
          sync();
          if (!scriptVersions.has(fileName)) {
            scriptVersions.set(fileName, { lastVersion: 0, map: /* @__PURE__ */ new WeakMap() });
          }
          const version2 = scriptVersions.get(fileName);
          if (extraScriptRegistry.has(fileName)) {
            const snapshot = extraScriptRegistry.get(fileName).code.snapshot;
            if (!version2.map.has(snapshot)) {
              version2.map.set(snapshot, version2.lastVersion++);
            }
            return version2.map.get(snapshot).toString();
          }
          const sourceScript = language.scripts.get(asScriptId(fileName));
          if (sourceScript?.generated) {
            const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
            if (serviceScript) {
              if (!version2.map.has(serviceScript.code.snapshot)) {
                version2.map.set(serviceScript.code.snapshot, version2.lastVersion++);
              }
              return version2.map.get(serviceScript.code.snapshot).toString();
            }
          }
          const isOpenedFile = !!projectHost.getScriptSnapshot(fileName);
          if (isOpenedFile) {
            const sourceScript2 = language.scripts.get(asScriptId(fileName));
            if (sourceScript2 && !sourceScript2.generated) {
              if (!version2.map.has(sourceScript2.snapshot)) {
                version2.map.set(sourceScript2.snapshot, version2.lastVersion++);
              }
              return version2.map.get(sourceScript2.snapshot).toString();
            }
          }
          if (sys.fileExists(fileName)) {
            return sys.getModifiedTime?.(fileName)?.valueOf().toString() ?? "0";
          }
          return "";
        }
      }
      function setEquals(a, b) {
        if (a.size !== b.size) {
          return false;
        }
        for (const item of a) {
          if (!b.has(item)) {
            return false;
          }
        }
        return true;
      }
    }
  });

  // node_modules/@volar/typescript/lib/typescript/core.js
  var require_core = __commonJS({
    "node_modules/@volar/typescript/lib/typescript/core.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.every = every;
      exports3.findIndex = findIndex;
      exports3.indexOfAnyCharCode = indexOfAnyCharCode;
      exports3.map = map4;
      exports3.flatten = flatten;
      exports3.flatMap = flatMap;
      exports3.some = some;
      exports3.sort = sort;
      exports3.lastOrUndefined = lastOrUndefined;
      exports3.last = last;
      exports3.equateStringsCaseInsensitive = equateStringsCaseInsensitive;
      exports3.equateStringsCaseSensitive = equateStringsCaseSensitive;
      exports3.compareStringsCaseSensitive = compareStringsCaseSensitive;
      exports3.getStringComparer = getStringComparer;
      exports3.endsWith = endsWith;
      exports3.stringContains = stringContains;
      exports3.createGetCanonicalFileName = createGetCanonicalFileName;
      exports3.startsWith = startsWith;
      var emptyArray = [];
      function every(array, callback) {
        if (array) {
          for (let i = 0; i < array.length; i++) {
            if (!callback(array[i], i)) {
              return false;
            }
          }
        }
        return true;
      }
      function findIndex(array, predicate, startIndex) {
        if (array === void 0) {
          return -1;
        }
        for (let i = startIndex ?? 0; i < array.length; i++) {
          if (predicate(array[i], i)) {
            return i;
          }
        }
        return -1;
      }
      function contains(array, value, equalityComparer = equateValues) {
        if (array) {
          for (const v of array) {
            if (equalityComparer(v, value)) {
              return true;
            }
          }
        }
        return false;
      }
      function indexOfAnyCharCode(text4, charCodes, start2) {
        for (let i = start2 || 0; i < text4.length; i++) {
          if (contains(charCodes, text4.charCodeAt(i))) {
            return i;
          }
        }
        return -1;
      }
      function map4(array, f) {
        let result;
        if (array) {
          result = [];
          for (let i = 0; i < array.length; i++) {
            result.push(f(array[i], i));
          }
        }
        return result;
      }
      function flatten(array) {
        const result = [];
        for (const v of array) {
          if (v) {
            if (isArray2(v)) {
              addRange(result, v);
            } else {
              result.push(v);
            }
          }
        }
        return result;
      }
      function flatMap(array, mapfn) {
        let result;
        if (array) {
          for (let i = 0; i < array.length; i++) {
            const v = mapfn(array[i], i);
            if (v) {
              if (isArray2(v)) {
                result = addRange(result, v);
              } else {
                result = append(result, v);
              }
            }
          }
        }
        return result || emptyArray;
      }
      function some(array, predicate) {
        if (array) {
          if (predicate) {
            for (const v of array) {
              if (predicate(v)) {
                return true;
              }
            }
          } else {
            return array.length > 0;
          }
        }
        return false;
      }
      function append(to, value) {
        if (value === void 0) {
          return to;
        }
        if (to === void 0) {
          return [value];
        }
        to.push(value);
        return to;
      }
      function toOffset(array, offset2) {
        return offset2 < 0 ? array.length + offset2 : offset2;
      }
      function addRange(to, from, start2, end) {
        if (from === void 0 || from.length === 0) {
          return to;
        }
        if (to === void 0) {
          return from.slice(start2, end);
        }
        start2 = start2 === void 0 ? 0 : toOffset(from, start2);
        end = end === void 0 ? from.length : toOffset(from, end);
        for (let i = start2; i < end && i < from.length; i++) {
          if (from[i] !== void 0) {
            to.push(from[i]);
          }
        }
        return to;
      }
      function sort(array, comparer) {
        return array.length === 0 ? array : array.slice().sort(comparer);
      }
      function lastOrUndefined(array) {
        return array === void 0 || array.length === 0 ? void 0 : array[array.length - 1];
      }
      function last(array) {
        return array[array.length - 1];
      }
      function isArray2(value) {
        return Array.isArray ? Array.isArray(value) : value instanceof Array;
      }
      function identity2(x) {
        return x;
      }
      function toLowerCase(x) {
        return x.toLowerCase();
      }
      var fileNameLowerCaseRegExp = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g;
      function toFileNameLowerCase(x) {
        return fileNameLowerCaseRegExp.test(x) ? x.replace(fileNameLowerCaseRegExp, toLowerCase) : x;
      }
      function equateValues(a, b) {
        return a === b;
      }
      function equateStringsCaseInsensitive(a, b) {
        return a === b || a !== void 0 && b !== void 0 && a.toUpperCase() === b.toUpperCase();
      }
      function equateStringsCaseSensitive(a, b) {
        return equateValues(a, b);
      }
      function compareComparableValues(a, b) {
        return a === b ? 0 : a === void 0 ? -1 : b === void 0 ? 1 : a < b ? -1 : 1;
      }
      function compareStringsCaseInsensitive(a, b) {
        if (a === b) {
          return 0;
        }
        if (a === void 0) {
          return -1;
        }
        if (b === void 0) {
          return 1;
        }
        a = a.toUpperCase();
        b = b.toUpperCase();
        return a < b ? -1 : a > b ? 1 : 0;
      }
      function compareStringsCaseSensitive(a, b) {
        return compareComparableValues(a, b);
      }
      function getStringComparer(ignoreCase) {
        return ignoreCase ? compareStringsCaseInsensitive : compareStringsCaseSensitive;
      }
      function endsWith(str, suffix) {
        const expectedPos = str.length - suffix.length;
        return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;
      }
      function stringContains(str, substring) {
        return str.indexOf(substring) !== -1;
      }
      function createGetCanonicalFileName(useCaseSensitiveFileNames) {
        return useCaseSensitiveFileNames ? identity2 : toFileNameLowerCase;
      }
      function startsWith(str, prefix) {
        return str.lastIndexOf(prefix, 0) === 0;
      }
    }
  });

  // node_modules/@volar/typescript/lib/typescript/path.js
  var require_path = __commonJS({
    "node_modules/@volar/typescript/lib/typescript/path.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.directorySeparator = void 0;
      exports3.isRootedDiskPath = isRootedDiskPath;
      exports3.hasExtension = hasExtension;
      exports3.fileExtensionIsOneOf = fileExtensionIsOneOf;
      exports3.getDirectoryPath = getDirectoryPath;
      exports3.combinePaths = combinePaths;
      exports3.getNormalizedPathComponents = getNormalizedPathComponents;
      exports3.normalizePath = normalizePath;
      exports3.removeTrailingDirectorySeparator = removeTrailingDirectorySeparator;
      exports3.containsPath = containsPath;
      var core_1 = require_core();
      exports3.directorySeparator = "/";
      var altDirectorySeparator = "\\";
      var urlSchemeSeparator = "://";
      var backslashRegExp = /\\/g;
      function isAnyDirectorySeparator(charCode) {
        return charCode === 47 || charCode === 92;
      }
      function isRootedDiskPath(path) {
        return getEncodedRootLength(path) > 0;
      }
      function hasExtension(fileName) {
        return (0, core_1.stringContains)(getBaseFileName(fileName), ".");
      }
      function fileExtensionIs(path, extension2) {
        return path.length > extension2.length && (0, core_1.endsWith)(path, extension2);
      }
      function fileExtensionIsOneOf(path, extensions) {
        for (const extension2 of extensions) {
          if (fileExtensionIs(path, extension2)) {
            return true;
          }
        }
        return false;
      }
      function hasTrailingDirectorySeparator(path) {
        return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));
      }
      function isVolumeCharacter(charCode) {
        return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90;
      }
      function getFileUrlVolumeSeparatorEnd(url, start2) {
        const ch0 = url.charCodeAt(start2);
        if (ch0 === 58) {
          return start2 + 1;
        }
        if (ch0 === 37 && url.charCodeAt(start2 + 1) === 51) {
          const ch2 = url.charCodeAt(start2 + 2);
          if (ch2 === 97 || ch2 === 65) {
            return start2 + 3;
          }
        }
        return -1;
      }
      function getEncodedRootLength(path) {
        if (!path) {
          return 0;
        }
        const ch0 = path.charCodeAt(0);
        if (ch0 === 47 || ch0 === 92) {
          if (path.charCodeAt(1) !== ch0) {
            return 1;
          }
          const p1 = path.indexOf(ch0 === 47 ? exports3.directorySeparator : altDirectorySeparator, 2);
          if (p1 < 0) {
            return path.length;
          }
          return p1 + 1;
        }
        if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58) {
          const ch2 = path.charCodeAt(2);
          if (ch2 === 47 || ch2 === 92) {
            return 3;
          }
          if (path.length === 2) {
            return 2;
          }
        }
        const schemeEnd = path.indexOf(urlSchemeSeparator);
        if (schemeEnd !== -1) {
          const authorityStart = schemeEnd + urlSchemeSeparator.length;
          const authorityEnd = path.indexOf(exports3.directorySeparator, authorityStart);
          if (authorityEnd !== -1) {
            const scheme = path.slice(0, schemeEnd);
            const authority = path.slice(authorityStart, authorityEnd);
            if (scheme === "file" && (authority === "" || authority === "localhost") && isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {
              const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);
              if (volumeSeparatorEnd !== -1) {
                if (path.charCodeAt(volumeSeparatorEnd) === 47) {
                  return ~(volumeSeparatorEnd + 1);
                }
                if (volumeSeparatorEnd === path.length) {
                  return ~volumeSeparatorEnd;
                }
              }
            }
            return ~(authorityEnd + 1);
          }
          return ~path.length;
        }
        return 0;
      }
      function getRootLength(path) {
        const rootLength = getEncodedRootLength(path);
        return rootLength < 0 ? ~rootLength : rootLength;
      }
      function getDirectoryPath(path) {
        path = normalizeSlashes(path);
        const rootLength = getRootLength(path);
        if (rootLength === path.length) {
          return path;
        }
        path = removeTrailingDirectorySeparator(path);
        return path.slice(0, Math.max(rootLength, path.lastIndexOf(exports3.directorySeparator)));
      }
      function getBaseFileName(path, extensions, ignoreCase) {
        path = normalizeSlashes(path);
        const rootLength = getRootLength(path);
        if (rootLength === path.length) {
          return "";
        }
        path = removeTrailingDirectorySeparator(path);
        const name2 = path.slice(Math.max(getRootLength(path), path.lastIndexOf(exports3.directorySeparator) + 1));
        const extension2 = extensions !== void 0 && ignoreCase !== void 0 ? getAnyExtensionFromPath(name2, extensions, ignoreCase) : void 0;
        return extension2 ? name2.slice(0, name2.length - extension2.length) : name2;
      }
      function tryGetExtensionFromPath(path, extension2, stringEqualityComparer) {
        if (!(0, core_1.startsWith)(extension2, ".")) {
          extension2 = "." + extension2;
        }
        if (path.length >= extension2.length && path.charCodeAt(path.length - extension2.length) === 46) {
          const pathExtension = path.slice(path.length - extension2.length);
          if (stringEqualityComparer(pathExtension, extension2)) {
            return pathExtension;
          }
        }
      }
      function getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {
        if (typeof extensions === "string") {
          return tryGetExtensionFromPath(path, extensions, stringEqualityComparer) || "";
        }
        for (const extension2 of extensions) {
          const result = tryGetExtensionFromPath(path, extension2, stringEqualityComparer);
          if (result) {
            return result;
          }
        }
        return "";
      }
      function getAnyExtensionFromPath(path, extensions, ignoreCase) {
        if (extensions) {
          return getAnyExtensionFromPathWorker(removeTrailingDirectorySeparator(path), extensions, ignoreCase ? core_1.equateStringsCaseInsensitive : core_1.equateStringsCaseSensitive);
        }
        const baseFileName = getBaseFileName(path);
        const extensionIndex = baseFileName.lastIndexOf(".");
        if (extensionIndex >= 0) {
          return baseFileName.substring(extensionIndex);
        }
        return "";
      }
      function pathComponents(path, rootLength) {
        const root2 = path.substring(0, rootLength);
        const rest = path.substring(rootLength).split(exports3.directorySeparator);
        if (rest.length && !(0, core_1.lastOrUndefined)(rest)) {
          rest.pop();
        }
        return [root2, ...rest];
      }
      function getPathComponents(path, currentDirectory = "") {
        path = combinePaths(currentDirectory, path);
        return pathComponents(path, getRootLength(path));
      }
      function getPathFromPathComponents(pathComponents2) {
        if (pathComponents2.length === 0) {
          return "";
        }
        const root2 = pathComponents2[0] && ensureTrailingDirectorySeparator(pathComponents2[0]);
        return root2 + pathComponents2.slice(1).join(exports3.directorySeparator);
      }
      function normalizeSlashes(path) {
        return path.indexOf("\\") !== -1 ? path.replace(backslashRegExp, exports3.directorySeparator) : path;
      }
      function reducePathComponents(components) {
        if (!(0, core_1.some)(components)) {
          return [];
        }
        const reduced = [components[0]];
        for (let i = 1; i < components.length; i++) {
          const component = components[i];
          if (!component) {
            continue;
          }
          if (component === ".") {
            continue;
          }
          if (component === "..") {
            if (reduced.length > 1) {
              if (reduced[reduced.length - 1] !== "..") {
                reduced.pop();
                continue;
              }
            } else if (reduced[0]) {
              continue;
            }
          }
          reduced.push(component);
        }
        return reduced;
      }
      function combinePaths(path, ...paths) {
        if (path) {
          path = normalizeSlashes(path);
        }
        for (let relativePath of paths) {
          if (!relativePath) {
            continue;
          }
          relativePath = normalizeSlashes(relativePath);
          if (!path || getRootLength(relativePath) !== 0) {
            path = relativePath;
          } else {
            path = ensureTrailingDirectorySeparator(path) + relativePath;
          }
        }
        return path;
      }
      function getNormalizedPathComponents(path, currentDirectory) {
        return reducePathComponents(getPathComponents(path, currentDirectory));
      }
      function normalizePath(path) {
        path = normalizeSlashes(path);
        if (!relativePathSegmentRegExp.test(path)) {
          return path;
        }
        const simplified = path.replace(/\/\.\//g, "/").replace(/^\.\//, "");
        if (simplified !== path) {
          path = simplified;
          if (!relativePathSegmentRegExp.test(path)) {
            return path;
          }
        }
        const normalized = getPathFromPathComponents(reducePathComponents(getPathComponents(path)));
        return normalized && hasTrailingDirectorySeparator(path) ? ensureTrailingDirectorySeparator(normalized) : normalized;
      }
      function removeTrailingDirectorySeparator(path) {
        if (hasTrailingDirectorySeparator(path)) {
          return path.substr(0, path.length - 1);
        }
        return path;
      }
      function ensureTrailingDirectorySeparator(path) {
        if (!hasTrailingDirectorySeparator(path)) {
          return path + exports3.directorySeparator;
        }
        return path;
      }
      var relativePathSegmentRegExp = /(?:\/\/)|(?:^|\/)\.\.?(?:$|\/)/;
      function containsPath(parent, child, currentDirectory, ignoreCase) {
        if (typeof currentDirectory === "string") {
          parent = combinePaths(currentDirectory, parent);
          child = combinePaths(currentDirectory, child);
        } else if (typeof currentDirectory === "boolean") {
          ignoreCase = currentDirectory;
        }
        if (parent === void 0 || child === void 0) {
          return false;
        }
        if (parent === child) {
          return true;
        }
        const parentComponents = reducePathComponents(getPathComponents(parent));
        const childComponents = reducePathComponents(getPathComponents(child));
        if (childComponents.length < parentComponents.length) {
          return false;
        }
        const componentEqualityComparer = ignoreCase ? core_1.equateStringsCaseInsensitive : core_1.equateStringsCaseSensitive;
        for (let i = 0; i < parentComponents.length; i++) {
          const equalityComparer = i === 0 ? core_1.equateStringsCaseInsensitive : componentEqualityComparer;
          if (!equalityComparer(parentComponents[i], childComponents[i])) {
            return false;
          }
        }
        return true;
      }
    }
  });

  // node_modules/@volar/typescript/lib/typescript/utilities.js
  var require_utilities = __commonJS({
    "node_modules/@volar/typescript/lib/typescript/utilities.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.matchFiles = matchFiles;
      var core_1 = require_core();
      var path_1 = require_path();
      var reservedCharacterPattern = /[^\w\s\/]/g;
      var wildcardCharCodes = [
        42,
        63
        /* CharacterCodes.question */
      ];
      var commonPackageFolders = ["node_modules", "bower_components", "jspm_packages"];
      var implicitExcludePathRegexPattern = `(?!(${commonPackageFolders.join("|")})(/|$))`;
      var filesMatcher = {
        /**
         * Matches any single directory segment unless it is the last segment and a .min.js file
         * Breakdown:
         *  [^./]                   # matches everything up to the first . character (excluding directory separators)
         *  (\\.(?!min\\.js$))?     # matches . characters but not if they are part of the .min.js file extension
         */
        singleAsteriskRegexFragment: "([^./]|(\\.(?!min\\.js$))?)*",
        /**
         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
         * files or directories, does not match subdirectories that start with a . character
         */
        doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,
        replaceWildcardCharacter: (match) => replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment)
      };
      var directoriesMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        /**
         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
         * files or directories, does not match subdirectories that start with a . character
         */
        doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,
        replaceWildcardCharacter: (match) => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment)
      };
      var excludeMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        doubleAsteriskRegexFragment: "(/.+?)?",
        replaceWildcardCharacter: (match) => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)
      };
      var wildcardMatchers = {
        files: filesMatcher,
        directories: directoriesMatcher,
        exclude: excludeMatcher
      };
      function getRegularExpressionForWildcard(specs, basePath, usage) {
        const patterns = getRegularExpressionsForWildcards(specs, basePath, usage);
        if (!patterns || !patterns.length) {
          return void 0;
        }
        const pattern = patterns.map((pattern2) => `(${pattern2})`).join("|");
        const terminator = usage === "exclude" ? "($|/)" : "$";
        return `^(${pattern})${terminator}`;
      }
      function getRegularExpressionsForWildcards(specs, basePath, usage) {
        if (specs === void 0 || specs.length === 0) {
          return void 0;
        }
        return (0, core_1.flatMap)(specs, (spec) => spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]));
      }
      function isImplicitGlob(lastPathComponent) {
        return !/[.*?]/.test(lastPathComponent);
      }
      function getSubPatternFromSpec(spec, basePath, usage, { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter: replaceWildcardCharacter2 }) {
        let subpattern = "";
        let hasWrittenComponent = false;
        const components = (0, path_1.getNormalizedPathComponents)(spec, basePath);
        const lastComponent = (0, core_1.last)(components);
        if (usage !== "exclude" && lastComponent === "**") {
          return void 0;
        }
        components[0] = (0, path_1.removeTrailingDirectorySeparator)(components[0]);
        if (isImplicitGlob(lastComponent)) {
          components.push("**", "*");
        }
        let optionalCount = 0;
        for (let component of components) {
          if (component === "**") {
            subpattern += doubleAsteriskRegexFragment;
          } else {
            if (usage === "directories") {
              subpattern += "(";
              optionalCount++;
            }
            if (hasWrittenComponent) {
              subpattern += path_1.directorySeparator;
            }
            if (usage !== "exclude") {
              let componentPattern = "";
              if (component.charCodeAt(0) === 42) {
                componentPattern += "([^./]" + singleAsteriskRegexFragment + ")?";
                component = component.substr(1);
              } else if (component.charCodeAt(0) === 63) {
                componentPattern += "[^./]";
                component = component.substr(1);
              }
              componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter2);
              if (componentPattern !== component) {
                subpattern += implicitExcludePathRegexPattern;
              }
              subpattern += componentPattern;
            } else {
              subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter2);
            }
          }
          hasWrittenComponent = true;
        }
        while (optionalCount > 0) {
          subpattern += ")?";
          optionalCount--;
        }
        return subpattern;
      }
      function replaceWildcardCharacter(match, singleAsteriskRegexFragment) {
        return match === "*" ? singleAsteriskRegexFragment : match === "?" ? "[^/]" : "\\" + match;
      }
      function getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {
        path = (0, path_1.normalizePath)(path);
        currentDirectory = (0, path_1.normalizePath)(currentDirectory);
        const absolutePath = (0, path_1.combinePaths)(currentDirectory, path);
        return {
          includeFilePatterns: (0, core_1.map)(getRegularExpressionsForWildcards(includes, absolutePath, "files"), (pattern) => `^${pattern}$`),
          includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, "files"),
          includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, "directories"),
          excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, "exclude"),
          basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames)
        };
      }
      function getRegexFromPattern(pattern, useCaseSensitiveFileNames) {
        return new RegExp(pattern, useCaseSensitiveFileNames ? "" : "i");
      }
      function matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getFileSystemEntries, realpath) {
        path = (0, path_1.normalizePath)(path);
        currentDirectory = (0, path_1.normalizePath)(currentDirectory);
        const patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);
        const includeFileRegexes = patterns.includeFilePatterns && patterns.includeFilePatterns.map((pattern) => getRegexFromPattern(pattern, useCaseSensitiveFileNames));
        const includeDirectoryRegex = patterns.includeDirectoryPattern && getRegexFromPattern(patterns.includeDirectoryPattern, useCaseSensitiveFileNames);
        const excludeRegex = patterns.excludePattern && getRegexFromPattern(patterns.excludePattern, useCaseSensitiveFileNames);
        const results = includeFileRegexes ? includeFileRegexes.map(() => []) : [[]];
        const visited = /* @__PURE__ */ new Map();
        const toCanonical = (0, core_1.createGetCanonicalFileName)(useCaseSensitiveFileNames);
        for (const basePath of patterns.basePaths) {
          visitDirectory(basePath, (0, path_1.combinePaths)(currentDirectory, basePath), depth);
        }
        return (0, core_1.flatten)(results);
        function visitDirectory(path2, absolutePath, depth2) {
          const canonicalPath = toCanonical(realpath(absolutePath));
          if (visited.has(canonicalPath)) {
            return;
          }
          visited.set(canonicalPath, true);
          const { files, directories } = getFileSystemEntries(path2);
          for (const current2 of (0, core_1.sort)(files, core_1.compareStringsCaseSensitive)) {
            const name2 = (0, path_1.combinePaths)(path2, current2);
            const absoluteName = (0, path_1.combinePaths)(absolutePath, current2);
            if (extensions && !(0, path_1.fileExtensionIsOneOf)(name2, extensions)) {
              continue;
            }
            if (excludeRegex && excludeRegex.test(absoluteName)) {
              continue;
            }
            if (!includeFileRegexes) {
              results[0].push(name2);
            } else {
              const includeIndex = (0, core_1.findIndex)(includeFileRegexes, (re) => re.test(absoluteName));
              if (includeIndex !== -1) {
                results[includeIndex].push(name2);
              }
            }
          }
          if (depth2 !== void 0) {
            depth2--;
            if (depth2 === 0) {
              return;
            }
          }
          for (const current2 of (0, core_1.sort)(directories, core_1.compareStringsCaseSensitive)) {
            const name2 = (0, path_1.combinePaths)(path2, current2);
            const absoluteName = (0, path_1.combinePaths)(absolutePath, current2);
            if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) && (!excludeRegex || !excludeRegex.test(absoluteName))) {
              visitDirectory(name2, absoluteName, depth2);
            }
          }
        }
      }
      function getBasePaths(path, includes, useCaseSensitiveFileNames) {
        const basePaths = [path];
        if (includes) {
          const includeBasePaths = [];
          for (const include of includes) {
            const absolute = (0, path_1.isRootedDiskPath)(include) ? include : (0, path_1.normalizePath)((0, path_1.combinePaths)(path, include));
            includeBasePaths.push(getIncludeBasePath(absolute));
          }
          includeBasePaths.sort((0, core_1.getStringComparer)(!useCaseSensitiveFileNames));
          for (const includeBasePath of includeBasePaths) {
            if ((0, core_1.every)(basePaths, (basePath) => !(0, path_1.containsPath)(basePath, includeBasePath, path, !useCaseSensitiveFileNames))) {
              basePaths.push(includeBasePath);
            }
          }
        }
        return basePaths;
      }
      function getIncludeBasePath(absolute) {
        const wildcardOffset = (0, core_1.indexOfAnyCharCode)(absolute, wildcardCharCodes);
        if (wildcardOffset < 0) {
          return !(0, path_1.hasExtension)(absolute) ? absolute : (0, path_1.removeTrailingDirectorySeparator)((0, path_1.getDirectoryPath)(absolute));
        }
        return absolute.substring(0, absolute.lastIndexOf(path_1.directorySeparator, wildcardOffset));
      }
    }
  });

  // node_modules/@volar/typescript/lib/protocol/createSys.js
  var require_createSys = __commonJS({
    "node_modules/@volar/typescript/lib/protocol/createSys.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createSys = createSys2;
      var path = require_path_browserify();
      var utilities_1 = require_utilities();
      var vscode_uri_1 = require_umd();
      var currentCwd = "";
      function createSys2(sys, env2, getCurrentDirectory, uriConverter) {
        let version2 = 0;
        const caseSensitive = sys?.useCaseSensitiveFileNames ?? false;
        const root2 = {
          name: "",
          dirs: /* @__PURE__ */ new Map(),
          files: /* @__PURE__ */ new Map(),
          requestedRead: false
        };
        const promises = /* @__PURE__ */ new Set();
        const fileWatcher = env2.onDidChangeWatchedFiles?.(({ changes }) => {
          version2++;
          for (const change of changes) {
            const changeUri = vscode_uri_1.URI.parse(change.uri);
            const fileName = uriConverter.asFileName(changeUri);
            const dirName = path.dirname(fileName);
            const baseName = path.basename(fileName);
            const fileExists2 = change.type === 1 || change.type === 2;
            const dir = getDir(dirName, fileExists2);
            dir.files.set(normalizeFileId(baseName), fileExists2 ? {
              name: baseName,
              stat: {
                type: 1,
                ctime: Date.now(),
                mtime: Date.now(),
                size: -1
              },
              requestedStat: false,
              requestedText: false
            } : {
              name: baseName,
              stat: void 0,
              text: void 0,
              requestedStat: true,
              requestedText: true
            });
          }
        });
        return {
          dispose() {
            fileWatcher?.dispose();
          },
          args: sys?.args ?? [],
          newLine: sys?.newLine ?? "\n",
          useCaseSensitiveFileNames: caseSensitive,
          realpath: sys?.realpath,
          write: sys?.write ?? (() => {
          }),
          writeFile: sys?.writeFile ?? (() => {
          }),
          createDirectory: sys?.createDirectory ?? (() => {
          }),
          exit: sys?.exit ?? (() => {
          }),
          getExecutingFilePath: sys?.getExecutingFilePath ?? (() => getCurrentDirectory + "/__fake__.js"),
          getCurrentDirectory,
          getModifiedTime,
          readFile,
          readDirectory,
          getDirectories,
          resolvePath,
          fileExists,
          directoryExists,
          get version() {
            return version2;
          },
          async sync() {
            while (promises.size) {
              await Promise.all(promises);
            }
            return version2;
          }
        };
        function resolvePath(fsPath) {
          if (sys) {
            const currentDirectory = getCurrentDirectory();
            if (currentCwd !== currentDirectory) {
              currentCwd = currentDirectory;
              if (sys.directoryExists(currentDirectory)) {
                try {
                  process.chdir(currentDirectory);
                } catch {
                }
              }
            }
            return sys.resolvePath(fsPath).replace(/\\/g, "/");
          }
          return path.resolve(fsPath).replace(/\\/g, "/");
        }
        function readFile(fileName, encoding) {
          fileName = resolvePath(fileName);
          const dirPath = path.dirname(fileName);
          const dir = getDir(dirPath);
          const name2 = path.basename(fileName);
          readFileWorker(fileName, encoding, dir);
          return dir.files.get(normalizeFileId(name2))?.text;
        }
        function directoryExists(dirName) {
          dirName = resolvePath(dirName);
          const dir = getDir(dirName);
          if (dir.exists === void 0) {
            dir.exists = false;
            const result = env2.fs?.stat(uriConverter.asUri(dirName));
            if (typeof result === "object" && "then" in result) {
              const promise = result;
              promises.add(promise);
              result.then((result2) => {
                promises.delete(promise);
                dir.exists = result2?.type === 2;
                if (dir.exists) {
                  version2++;
                }
              });
            } else {
              dir.exists = result?.type === 2;
            }
          }
          return dir.exists;
        }
        function getModifiedTime(fileName) {
          fileName = resolvePath(fileName);
          const file = getFile(fileName);
          if (!file.requestedStat) {
            file.requestedStat = true;
            handleStat(fileName, file);
          }
          return file.stat ? new Date(file.stat.mtime) : /* @__PURE__ */ new Date(0);
        }
        function fileExists(fileName) {
          fileName = resolvePath(fileName);
          const file = getFile(fileName);
          const exists = () => file.text !== void 0 || file.stat?.type === 1;
          if (exists()) {
            return true;
          }
          if (!file.requestedStat) {
            file.requestedStat = true;
            handleStat(fileName, file);
          }
          return exists();
        }
        function handleStat(fileName, file) {
          const result = env2.fs?.stat(uriConverter.asUri(fileName));
          if (typeof result === "object" && "then" in result) {
            const promise = result;
            promises.add(promise);
            result.then((result2) => {
              promises.delete(promise);
              if (file.stat?.type !== result2?.type || file.stat?.mtime !== result2?.mtime) {
                version2++;
              }
              file.stat = result2;
            });
          } else {
            file.stat = result;
          }
        }
        function getFile(fileName) {
          fileName = resolvePath(fileName);
          const dirPath = path.dirname(fileName);
          const baseName = path.basename(fileName);
          const dir = getDir(dirPath);
          let file = dir.files.get(normalizeFileId(baseName));
          if (!file) {
            dir.files.set(normalizeFileId(baseName), file = {
              name: baseName,
              requestedStat: false,
              requestedText: false
            });
          }
          return file;
        }
        function getDirectories(dirName) {
          dirName = resolvePath(dirName);
          readDirectoryWorker(dirName);
          const dir = getDir(dirName);
          return [...dir.dirs.values()].filter((dir2) => dir2.exists).map((dir2) => dir2.name);
        }
        function readDirectory(dirName, extensions, excludes, includes, depth) {
          dirName = resolvePath(dirName);
          const currentDirectory = getCurrentDirectory();
          const matches = (0, utilities_1.matchFiles)(dirName, extensions, excludes, includes, caseSensitive, currentDirectory, depth, (dirPath) => {
            dirPath = resolvePath(dirPath);
            readDirectoryWorker(dirPath);
            const dir = getDir(dirPath);
            return {
              files: [...dir.files.values()].filter((file) => file.stat?.type === 1).map((file) => file.name),
              directories: [...dir.dirs.values()].filter((dir2) => dir2.exists).map((dir2) => dir2.name)
            };
          }, sys?.realpath ? (path2) => sys.realpath(path2) : (path2) => path2);
          return [...new Set(matches)];
        }
        function readFileWorker(fileName, encoding, dir) {
          const name2 = path.basename(fileName);
          let file = dir.files.get(normalizeFileId(name2));
          if (!file) {
            dir.files.set(normalizeFileId(name2), file = {
              name: name2,
              requestedStat: false,
              requestedText: false
            });
          }
          if (file.requestedText) {
            return;
          }
          file.requestedText = true;
          const uri = uriConverter.asUri(fileName);
          const result = env2.fs?.readFile(uri, encoding);
          if (typeof result === "object" && "then" in result) {
            const promise = result;
            promises.add(promise);
            result.then((result2) => {
              promises.delete(promise);
              if (result2 !== void 0) {
                file.text = result2;
                if (file.stat) {
                  file.stat.mtime++;
                }
                version2++;
              }
            });
          } else if (result !== void 0) {
            file.text = result;
          }
        }
        function readDirectoryWorker(dirName) {
          const dir = getDir(dirName);
          if (dir.requestedRead) {
            return;
          }
          dir.requestedRead = true;
          const result = env2.fs?.readDirectory(uriConverter.asUri(dirName || "."));
          if (typeof result === "object" && "then" in result) {
            const promise = result;
            promises.add(promise);
            result.then((result2) => {
              promises.delete(promise);
              if (onReadDirectoryResult(dirName, dir, result2)) {
                version2++;
              }
            });
          } else {
            onReadDirectoryResult(dirName, dir, result ?? []);
          }
        }
        function onReadDirectoryResult(dirName, dir, result) {
          result = result.filter(([name2]) => name2 !== "." && name2 !== "..");
          let updated = false;
          for (const [name2, _fileType] of result) {
            let fileType = _fileType;
            if (fileType === 64) {
              const stat = env2.fs?.stat(uriConverter.asUri(dirName + "/" + name2));
              if (typeof stat === "object" && "then" in stat) {
                const promise = stat;
                promises.add(promise);
                stat.then((stat2) => {
                  promises.delete(promise);
                  if (stat2?.type === 1) {
                    let file = dir.files.get(normalizeFileId(name2));
                    if (!file) {
                      dir.files.set(normalizeFileId(name2), file = {
                        name: name2,
                        requestedStat: false,
                        requestedText: false
                      });
                    }
                    if (stat2.type !== file.stat?.type || stat2.mtime !== file.stat?.mtime) {
                      version2++;
                    }
                    file.stat = stat2;
                    file.requestedStat = true;
                  } else if (stat2?.type === 2) {
                    const childDir = getDirFromDir(dir, name2);
                    if (!childDir.exists) {
                      childDir.exists = true;
                      version2++;
                    }
                  }
                });
              } else if (stat) {
                fileType = stat.type;
              }
            }
            if (fileType === 1) {
              let file = dir.files.get(normalizeFileId(name2));
              if (!file) {
                dir.files.set(normalizeFileId(name2), file = {
                  name: name2,
                  requestedStat: false,
                  requestedText: false
                });
              }
              if (!file.stat) {
                file.stat = {
                  type: 1,
                  mtime: 0,
                  ctime: 0,
                  size: 0
                };
                updated = true;
              }
            } else if (fileType === 2) {
              const childDir = getDirFromDir(dir, name2);
              if (!childDir.exists) {
                childDir.exists = true;
                updated = true;
              }
            }
          }
          return updated;
        }
        function getDir(dirName, markExists = false) {
          const dirNames = [];
          let currentDirPath = dirName;
          let currentDirName = path.basename(currentDirPath);
          let lastDirPath;
          while (lastDirPath !== currentDirPath) {
            lastDirPath = currentDirPath;
            dirNames.push(currentDirName);
            currentDirPath = path.dirname(currentDirPath);
            currentDirName = path.basename(currentDirPath);
          }
          let currentDir = root2;
          for (let i = dirNames.length - 1; i >= 0; i--) {
            const nextDirName = dirNames[i];
            currentDir = getDirFromDir(currentDir, nextDirName);
            if (markExists && !currentDir.exists) {
              currentDir.exists = true;
              version2++;
            }
          }
          return currentDir;
        }
        function getDirFromDir(dir, name2) {
          let target = dir.dirs.get(normalizeFileId(name2));
          if (!target) {
            dir.dirs.set(normalizeFileId(name2), target = {
              name: name2,
              dirs: /* @__PURE__ */ new Map(),
              files: /* @__PURE__ */ new Map()
            });
          }
          return target;
        }
        function normalizeFileId(fileName) {
          return caseSensitive ? fileName : fileName.toLowerCase();
        }
      }
    }
  });

  // node_modules/@volar/typescript/index.js
  var require_typescript = __commonJS({
    "node_modules/@volar/typescript/index.js"(exports3) {
      "use strict";
      var __createBinding = exports3 && exports3.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports3 && exports3.__exportStar || function(m, exports4) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p))
            __createBinding(exports4, m, p);
      };
      Object.defineProperty(exports3, "__esModule", { value: true });
      __exportStar(require_common2(), exports3);
      __exportStar(require_proxyLanguageService(), exports3);
      __exportStar(require_decorateLanguageServiceHost(), exports3);
      __exportStar(require_decorateProgram(), exports3);
      __exportStar(require_proxyCreateProgram(), exports3);
      __exportStar(require_createProject(), exports3);
      __exportStar(require_createSys(), exports3);
    }
  });

  // node_modules/vscode-nls/lib/common/ral.js
  var require_ral = __commonJS({
    "node_modules/vscode-nls/lib/common/ral.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error("No runtime abstraction layer installed");
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error("No runtime abstraction layer provided");
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports3.default = RAL;
    }
  });

  // node_modules/vscode-nls/lib/common/common.js
  var require_common3 = __commonJS({
    "node_modules/vscode-nls/lib/common/common.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.config = exports3.loadMessageBundle = exports3.localize = exports3.format = exports3.setPseudo = exports3.isPseudo = exports3.isDefined = exports3.BundleFormat = exports3.MessageFormat = void 0;
      var ral_1 = require_ral();
      var MessageFormat;
      (function(MessageFormat2) {
        MessageFormat2["file"] = "file";
        MessageFormat2["bundle"] = "bundle";
        MessageFormat2["both"] = "both";
      })(MessageFormat = exports3.MessageFormat || (exports3.MessageFormat = {}));
      var BundleFormat;
      (function(BundleFormat2) {
        BundleFormat2["standalone"] = "standalone";
        BundleFormat2["languagePack"] = "languagePack";
      })(BundleFormat = exports3.BundleFormat || (exports3.BundleFormat = {}));
      var LocalizeInfo;
      (function(LocalizeInfo2) {
        function is2(value) {
          var candidate = value;
          return candidate && isDefined(candidate.key) && isDefined(candidate.comment);
        }
        LocalizeInfo2.is = is2;
      })(LocalizeInfo || (LocalizeInfo = {}));
      function isDefined(value) {
        return typeof value !== "undefined";
      }
      exports3.isDefined = isDefined;
      exports3.isPseudo = false;
      function setPseudo(pseudo) {
        exports3.isPseudo = pseudo;
      }
      exports3.setPseudo = setPseudo;
      function format2(message, args) {
        var result;
        if (exports3.isPseudo) {
          message = "\uFF3B" + message.replace(/[aouei]/g, "$&$&") + "\uFF3D";
        }
        if (args.length === 0) {
          result = message;
        } else {
          result = message.replace(/\{(\d+)\}/g, function(match, rest) {
            var index4 = rest[0];
            var arg = args[index4];
            var replacement = match;
            if (typeof arg === "string") {
              replacement = arg;
            } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
              replacement = String(arg);
            }
            return replacement;
          });
        }
        return result;
      }
      exports3.format = format2;
      function localize2(_key, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        return format2(message, args);
      }
      exports3.localize = localize2;
      function loadMessageBundle(file) {
        return (0, ral_1.default)().loadMessageBundle(file);
      }
      exports3.loadMessageBundle = loadMessageBundle;
      function config(opts) {
        return (0, ral_1.default)().config(opts);
      }
      exports3.config = config;
    }
  });

  // node_modules/vscode-nls/lib/browser/main.js
  var require_main = __commonJS({
    "node_modules/vscode-nls/lib/browser/main.js"(exports3) {
      "use strict";
      var __spreadArray = exports3 && exports3.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.config = exports3.loadMessageBundle = exports3.BundleFormat = exports3.MessageFormat = void 0;
      var ral_1 = require_ral();
      var common_1 = require_common3();
      var common_2 = require_common3();
      Object.defineProperty(exports3, "MessageFormat", { enumerable: true, get: function() {
        return common_2.MessageFormat;
      } });
      Object.defineProperty(exports3, "BundleFormat", { enumerable: true, get: function() {
        return common_2.BundleFormat;
      } });
      function loadMessageBundle(_file) {
        return function(key, message) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          if (typeof key === "number") {
            throw new Error("Browser implementation does currently not support externalized strings.");
          } else {
            return common_1.localize.apply(void 0, __spreadArray([key, message], args, false));
          }
        };
      }
      exports3.loadMessageBundle = loadMessageBundle;
      function config(options) {
        var _a4;
        (0, common_1.setPseudo)(((_a4 = options === null || options === void 0 ? void 0 : options.locale) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase()) === "pseudo");
        return loadMessageBundle;
      }
      exports3.config = config;
      ral_1.default.install(Object.freeze({
        loadMessageBundle,
        config
      }));
    }
  });

  // node_modules/volar-service-typescript/lib/shared.js
  var require_shared = __commonJS({
    "node_modules/volar-service-typescript/lib/shared.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.getConfigTitle = getConfigTitle;
      exports3.isTsDocument = isTsDocument;
      exports3.isJsonDocument = isJsonDocument;
      exports3.safeCall = safeCall;
      function getConfigTitle(document5) {
        if (document5.languageId === "javascriptreact") {
          return "javascript";
        }
        if (document5.languageId === "typescriptreact") {
          return "typescript";
        }
        return document5.languageId;
      }
      function isTsDocument(document5) {
        return document5.languageId === "javascript" || document5.languageId === "typescript" || document5.languageId === "javascriptreact" || document5.languageId === "typescriptreact";
      }
      function isJsonDocument(document5) {
        return document5.languageId === "json" || document5.languageId === "jsonc";
      }
      function safeCall(cb) {
        try {
          return cb();
        } catch {
        }
      }
    }
  });

  // node_modules/volar-service-typescript/lib/plugins/directiveComment.js
  var require_directiveComment = __commonJS({
    "node_modules/volar-service-typescript/lib/plugins/directiveComment.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.create = create;
      var nls = require_main();
      var shared_1 = require_shared();
      var localize2 = nls.loadMessageBundle();
      var directives = [
        {
          value: "@ts-check",
          description: localize2("ts-check", "Enables semantic checking in a JavaScript file. Must be at the top of a file.")
        },
        {
          value: "@ts-nocheck",
          description: localize2("ts-nocheck", "Disables semantic checking in a JavaScript file. Must be at the top of a file.")
        },
        {
          value: "@ts-ignore",
          description: localize2("ts-ignore", "Suppresses @ts-check errors on the next line of a file.")
        },
        {
          value: "@ts-expect-error",
          description: localize2("ts-expect-error", "Suppresses @ts-check errors on the next line of a file, expecting at least one to exist.")
        }
      ];
      function create() {
        return {
          name: "typescript-directive-comment",
          capabilities: {
            completionProvider: {
              triggerCharacters: ["@"]
            }
          },
          create() {
            return {
              provideCompletionItems(document5, position4) {
                if (!(0, shared_1.isTsDocument)(document5)) {
                  return;
                }
                const prefix = document5.getText({
                  start: { line: position4.line, character: 0 },
                  end: position4
                });
                const match = prefix.match(/^\s*\/\/+\s?(@[a-zA-Z\-]*)?$/);
                if (match) {
                  const items = directives.map((directive) => {
                    const item = { label: directive.value };
                    item.insertTextFormat = 2;
                    item.detail = directive.description;
                    const range = {
                      start: {
                        line: position4.line,
                        character: Math.max(0, position4.character - (match[1] ? match[1].length : 0))
                      },
                      end: position4
                    };
                    item.textEdit = {
                      range,
                      newText: directive.value
                    };
                    return item;
                  });
                  return {
                    isIncomplete: false,
                    items
                  };
                }
              }
            };
          }
        };
      }
    }
  });

  // node_modules/semver/internal/constants.js
  var require_constants = __commonJS({
    "node_modules/semver/internal/constants.js"(exports3, module) {
      var SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
      9007199254740991;
      var MAX_SAFE_COMPONENT_LENGTH = 16;
      var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
      var RELEASE_TYPES = [
        "major",
        "premajor",
        "minor",
        "preminor",
        "patch",
        "prepatch",
        "prerelease"
      ];
      module.exports = {
        MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER,
        RELEASE_TYPES,
        SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
      };
    }
  });

  // node_modules/semver/internal/debug.js
  var require_debug = __commonJS({
    "node_modules/semver/internal/debug.js"(exports3, module) {
      var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
      module.exports = debug;
    }
  });

  // node_modules/semver/internal/re.js
  var require_re = __commonJS({
    "node_modules/semver/internal/re.js"(exports3, module) {
      var {
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_LENGTH
      } = require_constants();
      var debug = require_debug();
      exports3 = module.exports = {};
      var re = exports3.re = [];
      var safeRe = exports3.safeRe = [];
      var src = exports3.src = [];
      var t = exports3.t = {};
      var R = 0;
      var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
      var safeRegexReplacements = [
        ["\\s", 1],
        ["\\d", MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
      ];
      var makeSafeRegex = (value) => {
        for (const [token, max] of safeRegexReplacements) {
          value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
        }
        return value;
      };
      var createToken = (name2, value, isGlobal) => {
        const safe2 = makeSafeRegex(value);
        const index4 = R++;
        debug(name2, index4, value);
        t[name2] = index4;
        src[index4] = value;
        re[index4] = new RegExp(value, isGlobal ? "g" : void 0);
        safeRe[index4] = new RegExp(safe2, isGlobal ? "g" : void 0);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
      createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
      createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
      createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
      createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
      createToken("FULL", `^${src[t.FULLPLAIN]}$`);
      createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
      createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
      createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
      createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
      createToken("COERCERTL", src[t.COERCE], true);
      createToken("COERCERTLFULL", src[t.COERCEFULL], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports3.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports3.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
      createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
      exports3.comparatorTrimReplace = "$1$2$3";
      createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    }
  });

  // node_modules/semver/internal/parse-options.js
  var require_parse_options = __commonJS({
    "node_modules/semver/internal/parse-options.js"(exports3, module) {
      var looseOption = Object.freeze({ loose: true });
      var emptyOpts = Object.freeze({});
      var parseOptions = (options) => {
        if (!options) {
          return emptyOpts;
        }
        if (typeof options !== "object") {
          return looseOption;
        }
        return options;
      };
      module.exports = parseOptions;
    }
  });

  // node_modules/semver/internal/identifiers.js
  var require_identifiers = __commonJS({
    "node_modules/semver/internal/identifiers.js"(exports3, module) {
      var numeric = /^[0-9]+$/;
      var compareIdentifiers = (a, b) => {
        const anum = numeric.test(a);
        const bnum = numeric.test(b);
        if (anum && bnum) {
          a = +a;
          b = +b;
        }
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      };
      var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
      module.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    }
  });

  // node_modules/semver/classes/semver.js
  var require_semver = __commonJS({
    "node_modules/semver/classes/semver.js"(exports3, module) {
      var debug = require_debug();
      var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
      var { safeRe: re, t } = require_re();
      var parseOptions = require_parse_options();
      var { compareIdentifiers } = require_identifiers();
      var SemVer = class {
        constructor(version2, options) {
          options = parseOptions(options);
          if (version2 instanceof SemVer) {
            if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
              return version2;
            } else {
              version2 = version2.version;
            }
          } else if (typeof version2 !== "string") {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
          }
          if (version2.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`
            );
          }
          debug("SemVer", version2, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version2}`);
          }
          this.raw = version2;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          let i = 0;
          do {
            const a = this.build[i];
            const b = other.build[i];
            debug("build compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.
        inc(release, identifier, identifierBase) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier, identifierBase);
              this.inc("pre", identifier, identifierBase);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier, identifierBase);
              }
              this.inc("pre", identifier, identifierBase);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre": {
              const base = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === false) {
                throw new Error("invalid increment argument: identifier is empty");
              }
              if (this.prerelease.length === 0) {
                this.prerelease = [base];
              } else {
                let i = this.prerelease.length;
                while (--i >= 0) {
                  if (typeof this.prerelease[i] === "number") {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }
                if (i === -1) {
                  if (identifier === this.prerelease.join(".") && identifierBase === false) {
                    throw new Error("invalid increment argument: identifier already exists");
                  }
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                let prerelease = [identifier, base];
                if (identifierBase === false) {
                  prerelease = [identifier];
                }
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = prerelease;
                  }
                } else {
                  this.prerelease = prerelease;
                }
              }
              break;
            }
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.raw = this.format();
          if (this.build.length) {
            this.raw += `+${this.build.join(".")}`;
          }
          return this;
        }
      };
      module.exports = SemVer;
    }
  });

  // node_modules/semver/functions/parse.js
  var require_parse = __commonJS({
    "node_modules/semver/functions/parse.js"(exports3, module) {
      var SemVer = require_semver();
      var parse5 = (version2, options, throwErrors = false) => {
        if (version2 instanceof SemVer) {
          return version2;
        }
        try {
          return new SemVer(version2, options);
        } catch (er) {
          if (!throwErrors) {
            return null;
          }
          throw er;
        }
      };
      module.exports = parse5;
    }
  });

  // node_modules/semver/functions/valid.js
  var require_valid = __commonJS({
    "node_modules/semver/functions/valid.js"(exports3, module) {
      var parse5 = require_parse();
      var valid = (version2, options) => {
        const v = parse5(version2, options);
        return v ? v.version : null;
      };
      module.exports = valid;
    }
  });

  // node_modules/semver/functions/clean.js
  var require_clean = __commonJS({
    "node_modules/semver/functions/clean.js"(exports3, module) {
      var parse5 = require_parse();
      var clean = (version2, options) => {
        const s = parse5(version2.trim().replace(/^[=v]+/, ""), options);
        return s ? s.version : null;
      };
      module.exports = clean;
    }
  });

  // node_modules/semver/functions/inc.js
  var require_inc = __commonJS({
    "node_modules/semver/functions/inc.js"(exports3, module) {
      var SemVer = require_semver();
      var inc = (version2, release, options, identifier, identifierBase) => {
        if (typeof options === "string") {
          identifierBase = identifier;
          identifier = options;
          options = void 0;
        }
        try {
          return new SemVer(
            version2 instanceof SemVer ? version2.version : version2,
            options
          ).inc(release, identifier, identifierBase).version;
        } catch (er) {
          return null;
        }
      };
      module.exports = inc;
    }
  });

  // node_modules/semver/functions/diff.js
  var require_diff = __commonJS({
    "node_modules/semver/functions/diff.js"(exports3, module) {
      var parse5 = require_parse();
      var diff = (version1, version2) => {
        const v1 = parse5(version1, null, true);
        const v2 = parse5(version2, null, true);
        const comparison = v1.compare(v2);
        if (comparison === 0) {
          return null;
        }
        const v1Higher = comparison > 0;
        const highVersion = v1Higher ? v1 : v2;
        const lowVersion = v1Higher ? v2 : v1;
        const highHasPre = !!highVersion.prerelease.length;
        const lowHasPre = !!lowVersion.prerelease.length;
        if (lowHasPre && !highHasPre) {
          if (!lowVersion.patch && !lowVersion.minor) {
            return "major";
          }
          if (highVersion.patch) {
            return "patch";
          }
          if (highVersion.minor) {
            return "minor";
          }
          return "major";
        }
        const prefix = highHasPre ? "pre" : "";
        if (v1.major !== v2.major) {
          return prefix + "major";
        }
        if (v1.minor !== v2.minor) {
          return prefix + "minor";
        }
        if (v1.patch !== v2.patch) {
          return prefix + "patch";
        }
        return "prerelease";
      };
      module.exports = diff;
    }
  });

  // node_modules/semver/functions/major.js
  var require_major = __commonJS({
    "node_modules/semver/functions/major.js"(exports3, module) {
      var SemVer = require_semver();
      var major = (a, loose) => new SemVer(a, loose).major;
      module.exports = major;
    }
  });

  // node_modules/semver/functions/minor.js
  var require_minor = __commonJS({
    "node_modules/semver/functions/minor.js"(exports3, module) {
      var SemVer = require_semver();
      var minor = (a, loose) => new SemVer(a, loose).minor;
      module.exports = minor;
    }
  });

  // node_modules/semver/functions/patch.js
  var require_patch = __commonJS({
    "node_modules/semver/functions/patch.js"(exports3, module) {
      var SemVer = require_semver();
      var patch = (a, loose) => new SemVer(a, loose).patch;
      module.exports = patch;
    }
  });

  // node_modules/semver/functions/prerelease.js
  var require_prerelease = __commonJS({
    "node_modules/semver/functions/prerelease.js"(exports3, module) {
      var parse5 = require_parse();
      var prerelease = (version2, options) => {
        const parsed = parse5(version2, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
      };
      module.exports = prerelease;
    }
  });

  // node_modules/semver/functions/compare.js
  var require_compare = __commonJS({
    "node_modules/semver/functions/compare.js"(exports3, module) {
      var SemVer = require_semver();
      var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
      module.exports = compare;
    }
  });

  // node_modules/semver/functions/rcompare.js
  var require_rcompare = __commonJS({
    "node_modules/semver/functions/rcompare.js"(exports3, module) {
      var compare = require_compare();
      var rcompare = (a, b, loose) => compare(b, a, loose);
      module.exports = rcompare;
    }
  });

  // node_modules/semver/functions/compare-loose.js
  var require_compare_loose = __commonJS({
    "node_modules/semver/functions/compare-loose.js"(exports3, module) {
      var compare = require_compare();
      var compareLoose = (a, b) => compare(a, b, true);
      module.exports = compareLoose;
    }
  });

  // node_modules/semver/functions/compare-build.js
  var require_compare_build = __commonJS({
    "node_modules/semver/functions/compare-build.js"(exports3, module) {
      var SemVer = require_semver();
      var compareBuild = (a, b, loose) => {
        const versionA = new SemVer(a, loose);
        const versionB = new SemVer(b, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
      };
      module.exports = compareBuild;
    }
  });

  // node_modules/semver/functions/sort.js
  var require_sort = __commonJS({
    "node_modules/semver/functions/sort.js"(exports3, module) {
      var compareBuild = require_compare_build();
      var sort = (list4, loose) => list4.sort((a, b) => compareBuild(a, b, loose));
      module.exports = sort;
    }
  });

  // node_modules/semver/functions/rsort.js
  var require_rsort = __commonJS({
    "node_modules/semver/functions/rsort.js"(exports3, module) {
      var compareBuild = require_compare_build();
      var rsort = (list4, loose) => list4.sort((a, b) => compareBuild(b, a, loose));
      module.exports = rsort;
    }
  });

  // node_modules/semver/functions/gt.js
  var require_gt = __commonJS({
    "node_modules/semver/functions/gt.js"(exports3, module) {
      var compare = require_compare();
      var gt = (a, b, loose) => compare(a, b, loose) > 0;
      module.exports = gt;
    }
  });

  // node_modules/semver/functions/lt.js
  var require_lt = __commonJS({
    "node_modules/semver/functions/lt.js"(exports3, module) {
      var compare = require_compare();
      var lt = (a, b, loose) => compare(a, b, loose) < 0;
      module.exports = lt;
    }
  });

  // node_modules/semver/functions/eq.js
  var require_eq = __commonJS({
    "node_modules/semver/functions/eq.js"(exports3, module) {
      var compare = require_compare();
      var eq = (a, b, loose) => compare(a, b, loose) === 0;
      module.exports = eq;
    }
  });

  // node_modules/semver/functions/neq.js
  var require_neq = __commonJS({
    "node_modules/semver/functions/neq.js"(exports3, module) {
      var compare = require_compare();
      var neq = (a, b, loose) => compare(a, b, loose) !== 0;
      module.exports = neq;
    }
  });

  // node_modules/semver/functions/gte.js
  var require_gte = __commonJS({
    "node_modules/semver/functions/gte.js"(exports3, module) {
      var compare = require_compare();
      var gte = (a, b, loose) => compare(a, b, loose) >= 0;
      module.exports = gte;
    }
  });

  // node_modules/semver/functions/lte.js
  var require_lte = __commonJS({
    "node_modules/semver/functions/lte.js"(exports3, module) {
      var compare = require_compare();
      var lte = (a, b, loose) => compare(a, b, loose) <= 0;
      module.exports = lte;
    }
  });

  // node_modules/semver/functions/cmp.js
  var require_cmp = __commonJS({
    "node_modules/semver/functions/cmp.js"(exports3, module) {
      var eq = require_eq();
      var neq = require_neq();
      var gt = require_gt();
      var gte = require_gte();
      var lt = require_lt();
      var lte = require_lte();
      var cmp = (a, op, b, loose) => {
        switch (op) {
          case "===":
            if (typeof a === "object") {
              a = a.version;
            }
            if (typeof b === "object") {
              b = b.version;
            }
            return a === b;
          case "!==":
            if (typeof a === "object") {
              a = a.version;
            }
            if (typeof b === "object") {
              b = b.version;
            }
            return a !== b;
          case "":
          case "=":
          case "==":
            return eq(a, b, loose);
          case "!=":
            return neq(a, b, loose);
          case ">":
            return gt(a, b, loose);
          case ">=":
            return gte(a, b, loose);
          case "<":
            return lt(a, b, loose);
          case "<=":
            return lte(a, b, loose);
          default:
            throw new TypeError(`Invalid operator: ${op}`);
        }
      };
      module.exports = cmp;
    }
  });

  // node_modules/semver/functions/coerce.js
  var require_coerce = __commonJS({
    "node_modules/semver/functions/coerce.js"(exports3, module) {
      var SemVer = require_semver();
      var parse5 = require_parse();
      var { safeRe: re, t } = require_re();
      var coerce = (version2, options) => {
        if (version2 instanceof SemVer) {
          return version2;
        }
        if (typeof version2 === "number") {
          version2 = String(version2);
        }
        if (typeof version2 !== "string") {
          return null;
        }
        options = options || {};
        let match = null;
        if (!options.rtl) {
          match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
        } else {
          const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
          let next;
          while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
              match = next;
            }
            coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
          }
          coerceRtlRegex.lastIndex = -1;
        }
        if (match === null) {
          return null;
        }
        const major = match[2];
        const minor = match[3] || "0";
        const patch = match[4] || "0";
        const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
        const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
        return parse5(`${major}.${minor}.${patch}${prerelease}${build}`, options);
      };
      module.exports = coerce;
    }
  });

  // node_modules/semver/internal/lrucache.js
  var require_lrucache = __commonJS({
    "node_modules/semver/internal/lrucache.js"(exports3, module) {
      var LRUCache2 = class {
        constructor() {
          this.max = 1e3;
          this.map = /* @__PURE__ */ new Map();
        }
        get(key) {
          const value = this.map.get(key);
          if (value === void 0) {
            return void 0;
          } else {
            this.map.delete(key);
            this.map.set(key, value);
            return value;
          }
        }
        delete(key) {
          return this.map.delete(key);
        }
        set(key, value) {
          const deleted = this.delete(key);
          if (!deleted && value !== void 0) {
            if (this.map.size >= this.max) {
              const firstKey = this.map.keys().next().value;
              this.delete(firstKey);
            }
            this.map.set(key, value);
          }
          return this;
        }
      };
      module.exports = LRUCache2;
    }
  });

  // node_modules/semver/classes/range.js
  var require_range = __commonJS({
    "node_modules/semver/classes/range.js"(exports3, module) {
      var SPACE_CHARACTERS = /\s+/g;
      var Range2 = class {
        constructor(range, options) {
          options = parseOptions(options);
          if (range instanceof Range2) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
              return range;
            } else {
              return new Range2(range.raw, options);
            }
          }
          if (range instanceof Comparator) {
            this.raw = range.value;
            this.set = [[range]];
            this.formatted = void 0;
            return this;
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
          this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
          }
          if (this.set.length > 1) {
            const first = this.set[0];
            this.set = this.set.filter((c) => !isNullSet(c[0]));
            if (this.set.length === 0) {
              this.set = [first];
            } else if (this.set.length > 1) {
              for (const c of this.set) {
                if (c.length === 1 && isAny(c[0])) {
                  this.set = [c];
                  break;
                }
              }
            }
          }
          this.formatted = void 0;
        }
        get range() {
          if (this.formatted === void 0) {
            this.formatted = "";
            for (let i = 0; i < this.set.length; i++) {
              if (i > 0) {
                this.formatted += "||";
              }
              const comps = this.set[i];
              for (let k = 0; k < comps.length; k++) {
                if (k > 0) {
                  this.formatted += " ";
                }
                this.formatted += comps[k].toString().trim();
              }
            }
          }
          return this.formatted;
        }
        format() {
          return this.range;
        }
        toString() {
          return this.range;
        }
        parseRange(range) {
          const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
          const memoKey = memoOpts + ":" + range;
          const cached = cache.get(memoKey);
          if (cached) {
            return cached;
          }
          const loose = this.options.loose;
          const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
          debug("hyphen replace", range);
          range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
          debug("comparator trim", range);
          range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
          debug("tilde trim", range);
          range = range.replace(re[t.CARETTRIM], caretTrimReplace);
          debug("caret trim", range);
          let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
          if (loose) {
            rangeList = rangeList.filter((comp) => {
              debug("loose invalid filter", comp, this.options);
              return !!comp.match(re[t.COMPARATORLOOSE]);
            });
          }
          debug("range list", rangeList);
          const rangeMap = /* @__PURE__ */ new Map();
          const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
          for (const comp of comparators) {
            if (isNullSet(comp)) {
              return [comp];
            }
            rangeMap.set(comp.value, comp);
          }
          if (rangeMap.size > 1 && rangeMap.has("")) {
            rangeMap.delete("");
          }
          const result = [...rangeMap.values()];
          cache.set(memoKey, result);
          return result;
        }
        intersects(range, options) {
          if (!(range instanceof Range2)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some((thisComparators) => {
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
              return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
                return rangeComparators.every((rangeComparator) => {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        }
        // if ANY of the sets match ALL of its comparators, then pass
        test(version2) {
          if (!version2) {
            return false;
          }
          if (typeof version2 === "string") {
            try {
              version2 = new SemVer(version2, this.options);
            } catch (er) {
              return false;
            }
          }
          for (let i = 0; i < this.set.length; i++) {
            if (testSet(this.set[i], version2, this.options)) {
              return true;
            }
          }
          return false;
        }
      };
      module.exports = Range2;
      var LRU = require_lrucache();
      var cache = new LRU();
      var parseOptions = require_parse_options();
      var Comparator = require_comparator();
      var debug = require_debug();
      var SemVer = require_semver();
      var {
        safeRe: re,
        t,
        comparatorTrimReplace,
        tildeTrimReplace,
        caretTrimReplace
      } = require_re();
      var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
      var isNullSet = (c) => c.value === "<0.0.0-0";
      var isAny = (c) => c.value === "";
      var isSatisfiable = (comparators, options) => {
        let result = true;
        const remainingComparators = comparators.slice();
        let testComparator = remainingComparators.pop();
        while (result && remainingComparators.length) {
          result = remainingComparators.every((otherComparator) => {
            return testComparator.intersects(otherComparator, options);
          });
          testComparator = remainingComparators.pop();
        }
        return result;
      };
      var parseComparator = (comp, options) => {
        debug("comp", comp, options);
        comp = replaceCarets(comp, options);
        debug("caret", comp);
        comp = replaceTildes(comp, options);
        debug("tildes", comp);
        comp = replaceXRanges(comp, options);
        debug("xrange", comp);
        comp = replaceStars(comp, options);
        debug("stars", comp);
        return comp;
      };
      var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
      var replaceTildes = (comp, options) => {
        return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
      };
      var replaceTilde = (comp, options) => {
        const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
        return comp.replace(r, (_, M, m, p, pr) => {
          debug("tilde", comp, _, M, m, p, pr);
          let ret;
          if (isX(M)) {
            ret = "";
          } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
          } else if (pr) {
            debug("replaceTilde pr", pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
          }
          debug("tilde return", ret);
          return ret;
        });
      };
      var replaceCarets = (comp, options) => {
        return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
      };
      var replaceCaret = (comp, options) => {
        debug("caret", comp, options);
        const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
        const z = options.includePrerelease ? "-0" : "";
        return comp.replace(r, (_, M, m, p, pr) => {
          debug("caret", comp, _, M, m, p, pr);
          let ret;
          if (isX(M)) {
            ret = "";
          } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            if (M === "0") {
              ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
              ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
          } else if (pr) {
            debug("replaceCaret pr", pr);
            if (M === "0") {
              if (m === "0") {
                ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
          } else {
            debug("no pr");
            if (M === "0") {
              if (m === "0") {
                ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
          }
          debug("caret return", ret);
          return ret;
        });
      };
      var replaceXRanges = (comp, options) => {
        debug("replaceXRanges", comp, options);
        return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
      };
      var replaceXRange = (comp, options) => {
        comp = comp.trim();
        const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
        return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
          debug("xRange", comp, ret, gtlt, M, m, p, pr);
          const xM = isX(M);
          const xm = xM || isX(m);
          const xp = xm || isX(p);
          const anyX = xp;
          if (gtlt === "=" && anyX) {
            gtlt = "";
          }
          pr = options.includePrerelease ? "-0" : "";
          if (xM) {
            if (gtlt === ">" || gtlt === "<") {
              ret = "<0.0.0-0";
            } else {
              ret = "*";
            }
          } else if (gtlt && anyX) {
            if (xm) {
              m = 0;
            }
            p = 0;
            if (gtlt === ">") {
              gtlt = ">=";
              if (xm) {
                M = +M + 1;
                m = 0;
                p = 0;
              } else {
                m = +m + 1;
                p = 0;
              }
            } else if (gtlt === "<=") {
              gtlt = "<";
              if (xm) {
                M = +M + 1;
              } else {
                m = +m + 1;
              }
            }
            if (gtlt === "<") {
              pr = "-0";
            }
            ret = `${gtlt + M}.${m}.${p}${pr}`;
          } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
          } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
          }
          debug("xRange return", ret);
          return ret;
        });
      };
      var replaceStars = (comp, options) => {
        debug("replaceStars", comp, options);
        return comp.trim().replace(re[t.STAR], "");
      };
      var replaceGTE0 = (comp, options) => {
        debug("replaceGTE0", comp, options);
        return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
      };
      var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
        if (isX(fM)) {
          from = "";
        } else if (isX(fm)) {
          from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        } else if (isX(fp)) {
          from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        } else if (fpr) {
          from = `>=${from}`;
        } else {
          from = `>=${from}${incPr ? "-0" : ""}`;
        }
        if (isX(tM)) {
          to = "";
        } else if (isX(tm)) {
          to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
          to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
          to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
          to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
          to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
      };
      var testSet = (set, version2, options) => {
        for (let i = 0; i < set.length; i++) {
          if (!set[i].test(version2)) {
            return false;
          }
        }
        if (version2.prerelease.length && !options.includePrerelease) {
          for (let i = 0; i < set.length; i++) {
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
              continue;
            }
            if (set[i].semver.prerelease.length > 0) {
              const allowed = set[i].semver;
              if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
                return true;
              }
            }
          }
          return false;
        }
        return true;
      };
    }
  });

  // node_modules/semver/classes/comparator.js
  var require_comparator = __commonJS({
    "node_modules/semver/classes/comparator.js"(exports3, module) {
      var ANY = Symbol("SemVer ANY");
      var Comparator = class {
        static get ANY() {
          return ANY;
        }
        constructor(comp, options) {
          options = parseOptions(options);
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          comp = comp.trim().split(/\s+/).join(" ");
          debug("comparator", comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = "";
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug("comp", this);
        }
        parse(comp) {
          const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
          const m = comp.match(r);
          if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
          }
          this.operator = m[1] !== void 0 ? m[1] : "";
          if (this.operator === "=") {
            this.operator = "";
          }
          if (!m[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer(m[2], this.options.loose);
          }
        }
        toString() {
          return this.value;
        }
        test(version2) {
          debug("Comparator.test", version2, this.options.loose);
          if (this.semver === ANY || version2 === ANY) {
            return true;
          }
          if (typeof version2 === "string") {
            try {
              version2 = new SemVer(version2, this.options);
            } catch (er) {
              return false;
            }
          }
          return cmp(version2, this.operator, this.semver, this.options);
        }
        intersects(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (this.operator === "") {
            if (this.value === "") {
              return true;
            }
            return new Range2(comp.value, options).test(this.value);
          } else if (comp.operator === "") {
            if (comp.value === "") {
              return true;
            }
            return new Range2(this.value, options).test(comp.semver);
          }
          options = parseOptions(options);
          if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
            return false;
          }
          if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
            return false;
          }
          if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
            return true;
          }
          if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
            return true;
          }
          if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
            return true;
          }
          if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
            return true;
          }
          if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
            return true;
          }
          return false;
        }
      };
      module.exports = Comparator;
      var parseOptions = require_parse_options();
      var { safeRe: re, t } = require_re();
      var cmp = require_cmp();
      var debug = require_debug();
      var SemVer = require_semver();
      var Range2 = require_range();
    }
  });

  // node_modules/semver/functions/satisfies.js
  var require_satisfies = __commonJS({
    "node_modules/semver/functions/satisfies.js"(exports3, module) {
      var Range2 = require_range();
      var satisfies = (version2, range, options) => {
        try {
          range = new Range2(range, options);
        } catch (er) {
          return false;
        }
        return range.test(version2);
      };
      module.exports = satisfies;
    }
  });

  // node_modules/semver/ranges/to-comparators.js
  var require_to_comparators = __commonJS({
    "node_modules/semver/ranges/to-comparators.js"(exports3, module) {
      var Range2 = require_range();
      var toComparators = (range, options) => new Range2(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
      module.exports = toComparators;
    }
  });

  // node_modules/semver/ranges/max-satisfying.js
  var require_max_satisfying = __commonJS({
    "node_modules/semver/ranges/max-satisfying.js"(exports3, module) {
      var SemVer = require_semver();
      var Range2 = require_range();
      var maxSatisfying = (versions, range, options) => {
        let max = null;
        let maxSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range2(range, options);
        } catch (er) {
          return null;
        }
        versions.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!max || maxSV.compare(v) === -1) {
              max = v;
              maxSV = new SemVer(max, options);
            }
          }
        });
        return max;
      };
      module.exports = maxSatisfying;
    }
  });

  // node_modules/semver/ranges/min-satisfying.js
  var require_min_satisfying = __commonJS({
    "node_modules/semver/ranges/min-satisfying.js"(exports3, module) {
      var SemVer = require_semver();
      var Range2 = require_range();
      var minSatisfying = (versions, range, options) => {
        let min = null;
        let minSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range2(range, options);
        } catch (er) {
          return null;
        }
        versions.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!min || minSV.compare(v) === 1) {
              min = v;
              minSV = new SemVer(min, options);
            }
          }
        });
        return min;
      };
      module.exports = minSatisfying;
    }
  });

  // node_modules/semver/ranges/min-version.js
  var require_min_version = __commonJS({
    "node_modules/semver/ranges/min-version.js"(exports3, module) {
      var SemVer = require_semver();
      var Range2 = require_range();
      var gt = require_gt();
      var minVersion = (range, loose) => {
        range = new Range2(range, loose);
        let minver = new SemVer("0.0.0");
        if (range.test(minver)) {
          return minver;
        }
        minver = new SemVer("0.0.0-0");
        if (range.test(minver)) {
          return minver;
        }
        minver = null;
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let setMin = null;
          comparators.forEach((comparator) => {
            const compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
              case ">":
                if (compver.prerelease.length === 0) {
                  compver.patch++;
                } else {
                  compver.prerelease.push(0);
                }
                compver.raw = compver.format();
              case "":
              case ">=":
                if (!setMin || gt(compver, setMin)) {
                  setMin = compver;
                }
                break;
              case "<":
              case "<=":
                break;
              default:
                throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
          });
          if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
          }
        }
        if (minver && range.test(minver)) {
          return minver;
        }
        return null;
      };
      module.exports = minVersion;
    }
  });

  // node_modules/semver/ranges/valid.js
  var require_valid2 = __commonJS({
    "node_modules/semver/ranges/valid.js"(exports3, module) {
      var Range2 = require_range();
      var validRange = (range, options) => {
        try {
          return new Range2(range, options).range || "*";
        } catch (er) {
          return null;
        }
      };
      module.exports = validRange;
    }
  });

  // node_modules/semver/ranges/outside.js
  var require_outside = __commonJS({
    "node_modules/semver/ranges/outside.js"(exports3, module) {
      var SemVer = require_semver();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var Range2 = require_range();
      var satisfies = require_satisfies();
      var gt = require_gt();
      var lt = require_lt();
      var lte = require_lte();
      var gte = require_gte();
      var outside = (version2, range, hilo, options) => {
        version2 = new SemVer(version2, options);
        range = new Range2(range, options);
        let gtfn, ltefn, ltfn, comp, ecomp;
        switch (hilo) {
          case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
          case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (satisfies(version2, range, options)) {
          return false;
        }
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let high = null;
          let low = null;
          comparators.forEach((comparator) => {
            if (comparator.semver === ANY) {
              comparator = new Comparator(">=0.0.0");
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
              high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
              low = comparator;
            }
          });
          if (high.operator === comp || high.operator === ecomp) {
            return false;
          }
          if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
            return false;
          } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
            return false;
          }
        }
        return true;
      };
      module.exports = outside;
    }
  });

  // node_modules/semver/ranges/gtr.js
  var require_gtr = __commonJS({
    "node_modules/semver/ranges/gtr.js"(exports3, module) {
      var outside = require_outside();
      var gtr = (version2, range, options) => outside(version2, range, ">", options);
      module.exports = gtr;
    }
  });

  // node_modules/semver/ranges/ltr.js
  var require_ltr = __commonJS({
    "node_modules/semver/ranges/ltr.js"(exports3, module) {
      var outside = require_outside();
      var ltr = (version2, range, options) => outside(version2, range, "<", options);
      module.exports = ltr;
    }
  });

  // node_modules/semver/ranges/intersects.js
  var require_intersects = __commonJS({
    "node_modules/semver/ranges/intersects.js"(exports3, module) {
      var Range2 = require_range();
      var intersects = (r1, r2, options) => {
        r1 = new Range2(r1, options);
        r2 = new Range2(r2, options);
        return r1.intersects(r2, options);
      };
      module.exports = intersects;
    }
  });

  // node_modules/semver/ranges/simplify.js
  var require_simplify = __commonJS({
    "node_modules/semver/ranges/simplify.js"(exports3, module) {
      var satisfies = require_satisfies();
      var compare = require_compare();
      module.exports = (versions, range, options) => {
        const set = [];
        let first = null;
        let prev = null;
        const v = versions.sort((a, b) => compare(a, b, options));
        for (const version2 of v) {
          const included = satisfies(version2, range, options);
          if (included) {
            prev = version2;
            if (!first) {
              first = version2;
            }
          } else {
            if (prev) {
              set.push([first, prev]);
            }
            prev = null;
            first = null;
          }
        }
        if (first) {
          set.push([first, null]);
        }
        const ranges = [];
        for (const [min, max] of set) {
          if (min === max) {
            ranges.push(min);
          } else if (!max && min === v[0]) {
            ranges.push("*");
          } else if (!max) {
            ranges.push(`>=${min}`);
          } else if (min === v[0]) {
            ranges.push(`<=${max}`);
          } else {
            ranges.push(`${min} - ${max}`);
          }
        }
        const simplified = ranges.join(" || ");
        const original = typeof range.raw === "string" ? range.raw : String(range);
        return simplified.length < original.length ? simplified : range;
      };
    }
  });

  // node_modules/semver/ranges/subset.js
  var require_subset = __commonJS({
    "node_modules/semver/ranges/subset.js"(exports3, module) {
      var Range2 = require_range();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var satisfies = require_satisfies();
      var compare = require_compare();
      var subset = (sub, dom, options = {}) => {
        if (sub === dom) {
          return true;
        }
        sub = new Range2(sub, options);
        dom = new Range2(dom, options);
        let sawNonNull = false;
        OUTER:
          for (const simpleSub of sub.set) {
            for (const simpleDom of dom.set) {
              const isSub = simpleSubset(simpleSub, simpleDom, options);
              sawNonNull = sawNonNull || isSub !== null;
              if (isSub) {
                continue OUTER;
              }
            }
            if (sawNonNull) {
              return false;
            }
          }
        return true;
      };
      var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
      var minimumVersion = [new Comparator(">=0.0.0")];
      var simpleSubset = (sub, dom, options) => {
        if (sub === dom) {
          return true;
        }
        if (sub.length === 1 && sub[0].semver === ANY) {
          if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
          } else if (options.includePrerelease) {
            sub = minimumVersionWithPreRelease;
          } else {
            sub = minimumVersion;
          }
        }
        if (dom.length === 1 && dom[0].semver === ANY) {
          if (options.includePrerelease) {
            return true;
          } else {
            dom = minimumVersion;
          }
        }
        const eqSet = /* @__PURE__ */ new Set();
        let gt, lt;
        for (const c of sub) {
          if (c.operator === ">" || c.operator === ">=") {
            gt = higherGT(gt, c, options);
          } else if (c.operator === "<" || c.operator === "<=") {
            lt = lowerLT(lt, c, options);
          } else {
            eqSet.add(c.semver);
          }
        }
        if (eqSet.size > 1) {
          return null;
        }
        let gtltComp;
        if (gt && lt) {
          gtltComp = compare(gt.semver, lt.semver, options);
          if (gtltComp > 0) {
            return null;
          } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
            return null;
          }
        }
        for (const eq of eqSet) {
          if (gt && !satisfies(eq, String(gt), options)) {
            return null;
          }
          if (lt && !satisfies(eq, String(lt), options)) {
            return null;
          }
          for (const c of dom) {
            if (!satisfies(eq, String(c), options)) {
              return false;
            }
          }
          return true;
        }
        let higher, lower;
        let hasDomLT, hasDomGT;
        let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
        let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
        if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
          needDomLTPre = false;
        }
        for (const c of dom) {
          hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
          hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
          if (gt) {
            if (needDomGTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                needDomGTPre = false;
              }
            }
            if (c.operator === ">" || c.operator === ">=") {
              higher = higherGT(gt, c, options);
              if (higher === c && higher !== gt) {
                return false;
              }
            } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
              return false;
            }
          }
          if (lt) {
            if (needDomLTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                needDomLTPre = false;
              }
            }
            if (c.operator === "<" || c.operator === "<=") {
              lower = lowerLT(lt, c, options);
              if (lower === c && lower !== lt) {
                return false;
              }
            } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
              return false;
            }
          }
          if (!c.operator && (lt || gt) && gtltComp !== 0) {
            return false;
          }
        }
        if (gt && hasDomLT && !lt && gtltComp !== 0) {
          return false;
        }
        if (lt && hasDomGT && !gt && gtltComp !== 0) {
          return false;
        }
        if (needDomGTPre || needDomLTPre) {
          return false;
        }
        return true;
      };
      var higherGT = (a, b, options) => {
        if (!a) {
          return b;
        }
        const comp = compare(a.semver, b.semver, options);
        return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
      };
      var lowerLT = (a, b, options) => {
        if (!a) {
          return b;
        }
        const comp = compare(a.semver, b.semver, options);
        return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
      };
      module.exports = subset;
    }
  });

  // node_modules/semver/index.js
  var require_semver2 = __commonJS({
    "node_modules/semver/index.js"(exports3, module) {
      var internalRe = require_re();
      var constants = require_constants();
      var SemVer = require_semver();
      var identifiers = require_identifiers();
      var parse5 = require_parse();
      var valid = require_valid();
      var clean = require_clean();
      var inc = require_inc();
      var diff = require_diff();
      var major = require_major();
      var minor = require_minor();
      var patch = require_patch();
      var prerelease = require_prerelease();
      var compare = require_compare();
      var rcompare = require_rcompare();
      var compareLoose = require_compare_loose();
      var compareBuild = require_compare_build();
      var sort = require_sort();
      var rsort = require_rsort();
      var gt = require_gt();
      var lt = require_lt();
      var eq = require_eq();
      var neq = require_neq();
      var gte = require_gte();
      var lte = require_lte();
      var cmp = require_cmp();
      var coerce = require_coerce();
      var Comparator = require_comparator();
      var Range2 = require_range();
      var satisfies = require_satisfies();
      var toComparators = require_to_comparators();
      var maxSatisfying = require_max_satisfying();
      var minSatisfying = require_min_satisfying();
      var minVersion = require_min_version();
      var validRange = require_valid2();
      var outside = require_outside();
      var gtr = require_gtr();
      var ltr = require_ltr();
      var intersects = require_intersects();
      var simplifyRange = require_simplify();
      var subset = require_subset();
      module.exports = {
        parse: parse5,
        valid,
        clean,
        inc,
        diff,
        major,
        minor,
        patch,
        prerelease,
        compare,
        rcompare,
        compareLoose,
        compareBuild,
        sort,
        rsort,
        gt,
        lt,
        eq,
        neq,
        gte,
        lte,
        cmp,
        coerce,
        Comparator,
        Range: Range2,
        satisfies,
        toComparators,
        maxSatisfying,
        minSatisfying,
        minVersion,
        validRange,
        outside,
        gtr,
        ltr,
        intersects,
        simplifyRange,
        subset,
        SemVer,
        re: internalRe.re,
        src: internalRe.src,
        tokens: internalRe.t,
        SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
        RELEASE_TYPES: constants.RELEASE_TYPES,
        compareIdentifiers: identifiers.compareIdentifiers,
        rcompareIdentifiers: identifiers.rcompareIdentifiers
      };
    }
  });

  // node_modules/volar-service-typescript/lib/protocol.const.js
  var require_protocol_const = __commonJS({
    "node_modules/volar-service-typescript/lib/protocol.const.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.EventName = exports3.DisplayPartKind = exports3.KindModifiers = exports3.DiagnosticCategory = exports3.Kind = void 0;
      var Kind = class {
      };
      exports3.Kind = Kind;
      Kind.alias = "alias";
      Kind.callSignature = "call";
      Kind.class = "class";
      Kind.const = "const";
      Kind.constructorImplementation = "constructor";
      Kind.constructSignature = "construct";
      Kind.directory = "directory";
      Kind.enum = "enum";
      Kind.enumMember = "enum member";
      Kind.externalModuleName = "external module name";
      Kind.function = "function";
      Kind.indexSignature = "index";
      Kind.interface = "interface";
      Kind.keyword = "keyword";
      Kind.let = "let";
      Kind.localFunction = "local function";
      Kind.localVariable = "local var";
      Kind.method = "method";
      Kind.memberGetAccessor = "getter";
      Kind.memberSetAccessor = "setter";
      Kind.memberVariable = "property";
      Kind.module = "module";
      Kind.primitiveType = "primitive type";
      Kind.script = "script";
      Kind.type = "type";
      Kind.variable = "var";
      Kind.warning = "warning";
      Kind.string = "string";
      Kind.parameter = "parameter";
      Kind.typeParameter = "type parameter";
      var DiagnosticCategory = class {
      };
      exports3.DiagnosticCategory = DiagnosticCategory;
      DiagnosticCategory.error = "error";
      DiagnosticCategory.warning = "warning";
      DiagnosticCategory.suggestion = "suggestion";
      var KindModifiers = class {
      };
      exports3.KindModifiers = KindModifiers;
      KindModifiers.optional = "optional";
      KindModifiers.deprecated = "deprecated";
      KindModifiers.color = "color";
      KindModifiers.dtsFile = ".d.ts";
      KindModifiers.tsFile = ".ts";
      KindModifiers.tsxFile = ".tsx";
      KindModifiers.jsFile = ".js";
      KindModifiers.jsxFile = ".jsx";
      KindModifiers.jsonFile = ".json";
      KindModifiers.fileExtensionKindModifiers = [
        KindModifiers.dtsFile,
        KindModifiers.tsFile,
        KindModifiers.tsxFile,
        KindModifiers.jsFile,
        KindModifiers.jsxFile,
        KindModifiers.jsonFile
      ];
      var DisplayPartKind = class {
      };
      exports3.DisplayPartKind = DisplayPartKind;
      DisplayPartKind.functionName = "functionName";
      DisplayPartKind.methodName = "methodName";
      DisplayPartKind.parameterName = "parameterName";
      DisplayPartKind.propertyName = "propertyName";
      DisplayPartKind.punctuation = "punctuation";
      DisplayPartKind.text = "text";
      var EventName;
      (function(EventName2) {
        EventName2["syntaxDiag"] = "syntaxDiag";
        EventName2["semanticDiag"] = "semanticDiag";
        EventName2["suggestionDiag"] = "suggestionDiag";
        EventName2["configFileDiag"] = "configFileDiag";
        EventName2["telemetry"] = "telemetry";
        EventName2["projectLanguageServiceState"] = "projectLanguageServiceState";
        EventName2["projectsUpdatedInBackground"] = "projectsUpdatedInBackground";
        EventName2["beginInstallTypes"] = "beginInstallTypes";
        EventName2["endInstallTypes"] = "endInstallTypes";
        EventName2["typesInstallerInitializationFailed"] = "typesInstallerInitializationFailed";
        EventName2["surveyReady"] = "surveyReady";
        EventName2["projectLoadingStart"] = "projectLoadingStart";
        EventName2["projectLoadingFinish"] = "projectLoadingFinish";
      })(EventName || (exports3.EventName = EventName = {}));
    }
  });

  // node_modules/volar-service-typescript/lib/utils/modifiers.js
  var require_modifiers = __commonJS({
    "node_modules/volar-service-typescript/lib/utils/modifiers.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.parseKindModifier = parseKindModifier;
      function parseKindModifier(kindModifiers) {
        return new Set(kindModifiers.split(/,|\s+/g));
      }
    }
  });

  // node_modules/volar-service-typescript/lib/utils/previewer.js
  var require_previewer = __commonJS({
    "node_modules/volar-service-typescript/lib/utils/previewer.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.plainWithLinks = plainWithLinks;
      exports3.tagsMarkdownPreview = tagsMarkdownPreview;
      exports3.markdownDocumentation = markdownDocumentation;
      exports3.addMarkdownDocumentation = addMarkdownDocumentation;
      function replaceLinks(text4) {
        return text4.replace(/\{@(link|linkplain|linkcode) (https?:\/\/[^ |}]+?)(?:[| ]([^{}\n]+?))?\}/gi, (_, tag, link2, text5) => {
          switch (tag) {
            case "linkcode":
              return `[\`${text5 ? text5.trim() : link2}\`](${link2})`;
            default:
              return `[${text5 ? text5.trim() : link2}](${link2})`;
          }
        });
      }
      function processInlineTags(text4) {
        return replaceLinks(text4);
      }
      function getTagBodyText(tag, fileNameToUri, getTextDocument) {
        if (!tag.text) {
          return void 0;
        }
        function makeCodeblock(text5) {
          if (text5.match(/^\s*[~`]{3}/g)) {
            return text5;
          }
          return "```\n" + text5 + "\n```";
        }
        const text4 = convertLinkTags(tag.text, fileNameToUri, getTextDocument);
        switch (tag.name) {
          case "example":
            const captionTagMatches = text4.match(/<caption>(.*?)<\/caption>\s*(\r\n|\n)/);
            if (captionTagMatches && captionTagMatches.index === 0) {
              return captionTagMatches[1] + "\n\n" + makeCodeblock(text4.slice(captionTagMatches[0].length));
            } else {
              return makeCodeblock(text4);
            }
          case "author":
            const emailMatch = text4.match(/(.+)\s<([-.\w]+@[-.\w]+)>/);
            if (emailMatch === null) {
              return text4;
            } else {
              return `${emailMatch[1]} ${emailMatch[2]}`;
            }
          case "default":
            return makeCodeblock(text4);
        }
        return processInlineTags(text4);
      }
      function getTagDocumentation(tag, fileNameToUri, getTextDocument) {
        switch (tag.name) {
          case "augments":
          case "extends":
          case "param":
          case "template":
            const body = convertLinkTags(tag.text, fileNameToUri, getTextDocument).split(/^(\S+)\s*-?\s*/);
            if (body?.length === 3) {
              const param = body[1];
              const doc = body[2];
              const label2 = `*@${tag.name}* \`${param}\``;
              if (!doc) {
                return label2;
              }
              return label2 + (doc.match(/\r\n|\n/g) ? "  \n" + processInlineTags(doc) : ` \u2014 ${processInlineTags(doc)}`);
            }
        }
        const label = `*@${tag.name}*`;
        const text4 = getTagBodyText(tag, fileNameToUri, getTextDocument);
        if (!text4) {
          return label;
        }
        return label + (text4.match(/\r\n|\n/g) ? "  \n" + text4 : ` \u2014 ${text4}`);
      }
      function plainWithLinks(parts, fileNameToUri, getTextDocument) {
        return processInlineTags(convertLinkTags(parts, fileNameToUri, getTextDocument));
      }
      function convertLinkTags(parts, fileNameToUri, getTextDocument) {
        if (!parts) {
          return "";
        }
        if (typeof parts === "string") {
          return parts;
        }
        const out = [];
        let currentLink;
        for (const part of parts) {
          switch (part.kind) {
            case "link":
              if (currentLink) {
                const text4 = currentLink.text ?? currentLink.name;
                let target = currentLink.target;
                if (typeof currentLink.target === "object" && "fileName" in currentLink.target) {
                  const _target = currentLink.target;
                  const fileDoc = getTextDocument(fileNameToUri(_target.fileName));
                  if (fileDoc) {
                    const start2 = fileDoc.positionAt(_target.textSpan.start);
                    const end = fileDoc.positionAt(_target.textSpan.start + _target.textSpan.length);
                    target = {
                      file: _target.fileName,
                      start: {
                        line: start2.line + 1,
                        offset: start2.character + 1
                      },
                      end: {
                        line: end.line + 1,
                        offset: end.character + 1
                      }
                    };
                  } else {
                    target = {
                      file: _target.fileName,
                      start: {
                        line: 1,
                        offset: 1
                      },
                      end: {
                        line: 1,
                        offset: 1
                      }
                    };
                  }
                }
                if (target) {
                  const link2 = fileNameToUri(target.file) + `#L${target.start.line},${target.start.offset}`;
                  out.push(`[${text4}](${link2})`);
                } else {
                  if (text4) {
                    out.push(text4);
                  }
                }
                currentLink = void 0;
              } else {
                currentLink = {};
              }
              break;
            case "linkName":
              if (currentLink) {
                currentLink.name = part.text;
                currentLink.target = part.target;
              }
              break;
            case "linkText":
              if (currentLink) {
                currentLink.text = part.text;
              }
              break;
            default:
              out.push(part.text);
              break;
          }
        }
        return processInlineTags(out.join(""));
      }
      function tagsMarkdownPreview(tags, fileNameToUri, getTextDocument) {
        return tags.map((tag) => getTagDocumentation(tag, fileNameToUri, getTextDocument)).join("  \n\n");
      }
      function markdownDocumentation(documentation, tags, fileNameToUri, getTextDocument) {
        return addMarkdownDocumentation("", documentation, tags, fileNameToUri, getTextDocument);
      }
      function addMarkdownDocumentation(out, documentation, tags, fileNameToUri, getTextDocument) {
        if (documentation) {
          out += plainWithLinks(documentation, fileNameToUri, getTextDocument);
        }
        if (tags) {
          const tagsPreview = tagsMarkdownPreview(tags, fileNameToUri, getTextDocument);
          if (tagsPreview) {
            out += "\n\n" + tagsPreview;
          }
        }
        return out;
      }
    }
  });

  // node_modules/volar-service-typescript/lib/utils/typeConverters.js
  var require_typeConverters = __commonJS({
    "node_modules/volar-service-typescript/lib/utils/typeConverters.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.SymbolKind = void 0;
      var PConst = require_protocol_const();
      var SymbolKind2;
      (function(SymbolKind3) {
        function fromProtocolScriptElementKind(kind) {
          switch (kind) {
            case PConst.Kind.module:
              return 2;
            case PConst.Kind.class:
              return 5;
            case PConst.Kind.enum:
              return 10;
            case PConst.Kind.enumMember:
              return 22;
            case PConst.Kind.interface:
              return 11;
            case PConst.Kind.indexSignature:
              return 6;
            case PConst.Kind.callSignature:
              return 6;
            case PConst.Kind.method:
              return 6;
            case PConst.Kind.memberVariable:
              return 7;
            case PConst.Kind.memberGetAccessor:
              return 7;
            case PConst.Kind.memberSetAccessor:
              return 7;
            case PConst.Kind.variable:
              return 13;
            case PConst.Kind.let:
              return 13;
            case PConst.Kind.const:
              return 13;
            case PConst.Kind.localVariable:
              return 13;
            case PConst.Kind.alias:
              return 13;
            case PConst.Kind.function:
              return 12;
            case PConst.Kind.localFunction:
              return 12;
            case PConst.Kind.constructSignature:
              return 9;
            case PConst.Kind.constructorImplementation:
              return 9;
            case PConst.Kind.typeParameter:
              return 26;
            case PConst.Kind.string:
              return 15;
            default:
              return 13;
          }
        }
        SymbolKind3.fromProtocolScriptElementKind = fromProtocolScriptElementKind;
      })(SymbolKind2 || (exports3.SymbolKind = SymbolKind2 = {}));
    }
  });

  // node_modules/volar-service-typescript/lib/utils/lspConverters.js
  var require_lspConverters = __commonJS({
    "node_modules/volar-service-typescript/lib/utils/lspConverters.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.convertDiagnostic = convertDiagnostic;
      exports3.applyCompletionEntryDetails = applyCompletionEntryDetails;
      exports3.convertCompletionInfo = convertCompletionInfo;
      exports3.getLineText = getLineText;
      exports3.convertNavigateToItem = convertNavigateToItem;
      exports3.convertInlayHint = convertInlayHint;
      exports3.convertHighlightSpan = convertHighlightSpan;
      exports3.convertSelectionRange = convertSelectionRange;
      exports3.convertFileTextChanges = convertFileTextChanges;
      exports3.convertRenameLocations = convertRenameLocations;
      exports3.convertQuickInfo = convertQuickInfo;
      exports3.convertNavTree = convertNavTree;
      exports3.convertOutliningSpan = convertOutliningSpan;
      exports3.convertOutliningSpanKind = convertOutliningSpanKind;
      exports3.convertTextChange = convertTextChange;
      exports3.convertCallHierarchyIncomingCall = convertCallHierarchyIncomingCall;
      exports3.convertCallHierarchyOutgoingCall = convertCallHierarchyOutgoingCall;
      exports3.convertCallHierarchyItem = convertCallHierarchyItem;
      exports3.convertDocumentSpanToLocation = convertDocumentSpanToLocation;
      exports3.convertDefinitionInfoAndBoundSpan = convertDefinitionInfoAndBoundSpan;
      exports3.convertDocumentSpantoLocationLink = convertDocumentSpantoLocationLink;
      exports3.convertTextSpan = convertTextSpan;
      var path = require_path_browserify();
      var semver = require_semver2();
      var PConst = require_protocol_const();
      var modifiers_1 = require_modifiers();
      var previewer = require_previewer();
      var typeConverters = require_typeConverters();
      function convertDiagnostic(diag, document5, fileNameToUri, getTextDocument) {
        if (diag.start === void 0) {
          return;
        }
        if (diag.length === void 0) {
          return;
        }
        const diagnostic = {
          range: {
            start: document5.positionAt(diag.start),
            end: document5.positionAt(diag.start + diag.length)
          },
          severity: convertDiagnosticCategory(diag.category),
          source: "ts",
          code: diag.code,
          message: getMessageText(diag)
        };
        if (diag.relatedInformation) {
          diagnostic.relatedInformation = diag.relatedInformation.map((rErr) => convertDiagnosticRelatedInformation(rErr, fileNameToUri, getTextDocument)).filter((v) => !!v);
        }
        if (diag.reportsUnnecessary) {
          if (diagnostic.tags === void 0) {
            diagnostic.tags = [];
          }
          diagnostic.tags.push(1);
        }
        if (diag.reportsDeprecated) {
          if (diagnostic.tags === void 0) {
            diagnostic.tags = [];
          }
          diagnostic.tags.push(2);
        }
        return diagnostic;
      }
      function convertDiagnosticRelatedInformation(diag, fileNameToUri, getTextDocument) {
        if (diag.start === void 0) {
          return;
        }
        if (diag.length === void 0) {
          return;
        }
        let document5;
        if (diag.file) {
          document5 = getTextDocument(fileNameToUri(diag.file.fileName));
        }
        if (!document5) {
          return;
        }
        const diagnostic = {
          location: {
            uri: document5.uri,
            range: {
              start: document5.positionAt(diag.start),
              end: document5.positionAt(diag.start + diag.length)
            }
          },
          message: getMessageText(diag)
        };
        return diagnostic;
      }
      function convertDiagnosticCategory(input) {
        switch (input) {
          case 0:
            return 2;
          case 1:
            return 1;
          case 2:
            return 4;
          case 3:
            return 3;
        }
        return 1;
      }
      function getMessageText(diag, level = 0) {
        let messageText = "  ".repeat(level);
        if (typeof diag.messageText === "string") {
          messageText += diag.messageText;
        } else {
          messageText += diag.messageText.messageText;
          if (diag.messageText.next) {
            for (const info of diag.messageText.next) {
              messageText += "\n" + getMessageText(info, level + 1);
            }
          }
        }
        return messageText;
      }
      function applyCompletionEntryDetails(ts2, item, data2, document5, fileNameToUri, getTextDocument) {
        const { sourceDisplay } = data2;
        if (sourceDisplay) {
          item.labelDetails ??= {};
          item.labelDetails.description = ts2.displayPartsToString(sourceDisplay);
        }
        const detailTexts = [];
        if (data2.codeActions) {
          item.additionalTextEdits ??= [];
          for (const action of data2.codeActions) {
            detailTexts.push(action.description);
            for (const changes of action.changes) {
              const ranges = changes.textChanges.map((change) => convertTextSpan(change.span, document5));
              ranges.forEach((range, index4) => {
                item.additionalTextEdits?.push({ range, newText: changes.textChanges[index4].newText });
              });
            }
          }
        }
        if (data2.displayParts) {
          detailTexts.push(previewer.plainWithLinks(data2.displayParts, fileNameToUri, getTextDocument));
        }
        if (detailTexts.length) {
          item.detail = detailTexts.join("\n");
        }
        item.documentation = {
          kind: "markdown",
          value: previewer.markdownDocumentation(data2.documentation, data2.tags, fileNameToUri, getTextDocument)
        };
        if (data2) {
          handleKindModifiers(item, data2);
        }
      }
      function convertCompletionInfo(ts2, completionContext, document5, position4, createData) {
        const lt_320 = semver.lt(ts2.version, "3.2.0");
        const gte_300 = semver.gte(ts2.version, "3.0.0");
        const wordRange = completionContext.optionalReplacementSpan ? convertTextSpan(completionContext.optionalReplacementSpan, document5) : void 0;
        const line = getLineText(document5, position4.line);
        const dotAccessorContext = getDotAccessorContext(document5);
        const entries = completionContext.entries.map((tsEntry) => ({
          ...convertCompletionEntry(tsEntry, document5),
          data: createData(tsEntry)
        }));
        return {
          isIncomplete: !!completionContext.isIncomplete,
          items: entries
        };
        function convertCompletionEntry(tsEntry, document6) {
          const item = { label: tsEntry.name };
          item.kind = convertCompletionItemKind(tsEntry.kind);
          if (tsEntry.source && tsEntry.hasAction) {
            item.sortText = "\uFFFF" + tsEntry.sortText;
          } else {
            item.sortText = tsEntry.sortText;
          }
          const { sourceDisplay, isSnippet, labelDetails } = tsEntry;
          if (sourceDisplay) {
            item.labelDetails ??= {};
            item.labelDetails.description = ts2.displayPartsToString(sourceDisplay);
          }
          if (labelDetails) {
            item.labelDetails ??= {};
            Object.assign(item.labelDetails, labelDetails);
          }
          item.preselect = tsEntry.isRecommended;
          let range = getRangeFromReplacementSpan(tsEntry, document6);
          item.commitCharacters = getCommitCharacters(tsEntry, {
            isNewIdentifierLocation: completionContext.isNewIdentifierLocation,
            isInValidCommitCharacterContext: isInValidCommitCharacterContext(document6, position4),
            enableCallCompletions: true
            // TODO: suggest.completeFunctionCalls
          });
          item.insertText = tsEntry.insertText;
          item.insertTextFormat = isSnippet ? 2 : 1;
          item.filterText = getFilterText(tsEntry, wordRange, line, tsEntry.insertText);
          if (completionContext?.isMemberCompletion && dotAccessorContext && !isSnippet) {
            item.filterText = dotAccessorContext.text + (item.insertText || item.label);
            if (!range) {
              const replacementRange = wordRange;
              if (replacementRange) {
                range = {
                  inserting: dotAccessorContext.range,
                  replacing: rangeUnion(dotAccessorContext.range, replacementRange)
                };
              } else {
                range = dotAccessorContext.range;
              }
              item.insertText = item.filterText;
            }
          }
          handleKindModifiers(item, tsEntry);
          if (!range && wordRange) {
            range = {
              inserting: { start: wordRange.start, end: position4 },
              replacing: wordRange
            };
          }
          if (range) {
            if ("start" in range) {
              item.textEdit = {
                range,
                newText: item.insertText || item.label
              };
            } else {
              item.textEdit = {
                insert: range.inserting,
                replace: range.replacing,
                newText: item.insertText || item.label
              };
            }
          }
          return item;
        }
        function getDotAccessorContext(document6) {
          let dotAccessorContext2;
          if (gte_300) {
            if (!completionContext) {
              return;
            }
            const isMemberCompletion = completionContext.isMemberCompletion;
            if (isMemberCompletion) {
              const dotMatch = line.slice(0, position4.character).match(/\??\.\s*$/) || void 0;
              if (dotMatch) {
                const range = {
                  start: { line: position4.line, character: position4.character - dotMatch[0].length },
                  end: position4
                };
                const text4 = document6.getText(range);
                dotAccessorContext2 = { range, text: text4 };
              }
            }
          }
          return dotAccessorContext2;
        }
        function getRangeFromReplacementSpan(tsEntry, document6) {
          if (!tsEntry.replacementSpan) {
            return;
          }
          let replaceRange = {
            start: document6.positionAt(tsEntry.replacementSpan.start),
            end: document6.positionAt(tsEntry.replacementSpan.start + tsEntry.replacementSpan.length)
          };
          if (replaceRange.start.line !== replaceRange.end.line) {
            replaceRange = {
              start: {
                line: replaceRange.start.line,
                character: replaceRange.start.character
              },
              end: {
                line: replaceRange.start.line,
                character: document6.positionAt(document6.offsetAt({ line: replaceRange.start.line + 1, character: 0 }) - 1).character
              }
            };
          }
          return {
            inserting: replaceRange,
            replacing: replaceRange
          };
        }
        function getFilterText(tsEntry, wordRange2, line2, insertText) {
          if (tsEntry.name.startsWith("#")) {
            const wordStart = wordRange2 ? line2.charAt(wordRange2.start.character) : void 0;
            if (insertText) {
              if (insertText.startsWith("this.#")) {
                return wordStart === "#" ? insertText : insertText.replace(/^this\.#/, "");
              } else {
                return insertText;
              }
            } else {
              return wordStart === "#" ? void 0 : tsEntry.name.replace(/^#/, "");
            }
          }
          if (insertText?.startsWith("this.")) {
            return void 0;
          } else if (insertText?.startsWith("[")) {
            return insertText.replace(/^\[['"](.+)[['"]\]$/, ".$1");
          }
          return insertText;
        }
        function getCommitCharacters(entry, context) {
          if (entry.kind === PConst.Kind.warning) {
            return void 0;
          }
          if (context.isNewIdentifierLocation || !context.isInValidCommitCharacterContext) {
            return void 0;
          }
          const commitCharacters = [".", ",", ";"];
          if (context.enableCallCompletions) {
            commitCharacters.push("(");
          }
          return commitCharacters;
        }
        function isInValidCommitCharacterContext(document6, position5) {
          if (lt_320) {
            if (position5.character > 1) {
              const preText = document6.getText({
                start: { line: position5.line, character: 0 },
                end: position5
              });
              return preText.match(/(\s|^)\.$/ig) === null;
            }
          }
          return true;
        }
      }
      function convertCompletionItemKind(kind) {
        switch (kind) {
          case PConst.Kind.primitiveType:
          case PConst.Kind.keyword:
            return 14;
          case PConst.Kind.const:
          case PConst.Kind.let:
          case PConst.Kind.variable:
          case PConst.Kind.localVariable:
          case PConst.Kind.alias:
          case PConst.Kind.parameter:
            return 6;
          case PConst.Kind.memberVariable:
          case PConst.Kind.memberGetAccessor:
          case PConst.Kind.memberSetAccessor:
            return 5;
          case PConst.Kind.function:
          case PConst.Kind.localFunction:
            return 3;
          case PConst.Kind.method:
          case PConst.Kind.constructSignature:
          case PConst.Kind.callSignature:
          case PConst.Kind.indexSignature:
            return 2;
          case PConst.Kind.enum:
            return 13;
          case PConst.Kind.enumMember:
            return 20;
          case PConst.Kind.module:
          case PConst.Kind.externalModuleName:
            return 9;
          case PConst.Kind.class:
          case PConst.Kind.type:
            return 7;
          case PConst.Kind.interface:
            return 8;
          case PConst.Kind.warning:
            return 1;
          case PConst.Kind.script:
            return 17;
          case PConst.Kind.directory:
            return 19;
          case PConst.Kind.string:
            return 21;
          default:
            return 10;
        }
      }
      function handleKindModifiers(item, tsEntry) {
        if (tsEntry.kindModifiers) {
          const kindModifiers = (0, modifiers_1.parseKindModifier)(tsEntry.kindModifiers);
          if (kindModifiers.has(PConst.KindModifiers.optional)) {
            if (!item.insertText) {
              item.insertText = item.label;
            }
            if (!item.filterText) {
              item.filterText = item.label;
            }
            item.label += "?";
          }
          if (kindModifiers.has(PConst.KindModifiers.deprecated)) {
            item.tags = [1];
          }
          if (kindModifiers.has(PConst.KindModifiers.color)) {
            item.kind = 16;
          }
          if (tsEntry.kind === PConst.Kind.script) {
            for (const extModifier of PConst.KindModifiers.fileExtensionKindModifiers) {
              if (kindModifiers.has(extModifier)) {
                if (tsEntry.name.toLowerCase().endsWith(extModifier)) {
                  item.detail = tsEntry.name;
                } else {
                  item.detail = tsEntry.name + extModifier;
                }
                break;
              }
            }
          }
        }
      }
      function rangeUnion(a, b) {
        const start2 = a.start.line < b.start.line || a.start.line === b.start.line && a.start.character < b.start.character ? a.start : b.start;
        const end = a.end.line > b.end.line || a.end.line === b.end.line && a.end.character > b.end.character ? a.end : b.end;
        return { start: start2, end };
      }
      function getLineText(document5, line) {
        const endOffset = document5.offsetAt({ line: line + 1, character: 0 });
        const end = document5.positionAt(endOffset);
        const text4 = document5.getText({
          start: { line, character: 0 },
          end: end.line === line ? end : document5.positionAt(endOffset - 1)
        });
        return text4;
      }
      function convertNavigateToItem(item, document5) {
        const info = {
          name: getLabel(item),
          kind: convertScriptElementKind(item.kind),
          location: {
            uri: document5.uri,
            range: convertTextSpan(item.textSpan, document5)
          }
        };
        const kindModifiers = item.kindModifiers ? (0, modifiers_1.parseKindModifier)(item.kindModifiers) : void 0;
        if (kindModifiers?.has(PConst.KindModifiers.deprecated)) {
          info.tags = [1];
        }
        return info;
      }
      function getLabel(item) {
        const label = item.name;
        if (item.kind === "method" || item.kind === "function") {
          return label + "()";
        }
        return label;
      }
      function convertScriptElementKind(kind) {
        switch (kind) {
          case PConst.Kind.method:
            return 6;
          case PConst.Kind.enum:
            return 10;
          case PConst.Kind.enumMember:
            return 22;
          case PConst.Kind.function:
            return 12;
          case PConst.Kind.class:
            return 5;
          case PConst.Kind.interface:
            return 11;
          case PConst.Kind.type:
            return 5;
          case PConst.Kind.memberVariable:
            return 8;
          case PConst.Kind.memberGetAccessor:
            return 8;
          case PConst.Kind.memberSetAccessor:
            return 8;
          case PConst.Kind.variable:
            return 13;
          default:
            return 13;
        }
      }
      function convertInlayHint(hint, document5) {
        const result = {
          position: document5.positionAt(hint.position),
          label: hint.text,
          kind: hint.kind === "Type" ? 1 : hint.kind === "Parameter" ? 2 : void 0
        };
        result.paddingLeft = hint.whitespaceBefore;
        result.paddingRight = hint.whitespaceAfter;
        return result;
      }
      function convertHighlightSpan(span, document5) {
        return {
          kind: span.kind === "writtenReference" ? 3 : 2,
          range: convertTextSpan(span.textSpan, document5)
        };
      }
      function convertSelectionRange(range, document5) {
        return {
          parent: range.parent ? convertSelectionRange(range.parent, document5) : void 0,
          range: convertTextSpan(range.textSpan, document5)
        };
      }
      function convertFileTextChanges(changes, fileNameToUri, getTextDocument) {
        const workspaceEdit = {};
        for (const change of changes) {
          if (!workspaceEdit.documentChanges) {
            workspaceEdit.documentChanges = [];
          }
          const uri = fileNameToUri(change.fileName);
          if (change.isNewFile) {
            workspaceEdit.documentChanges.push({ kind: "create", uri: uri.toString() });
            workspaceEdit.documentChanges.push({
              textDocument: {
                uri: uri.toString(),
                version: null
                // fix https://github.com/johnsoncodehk/volar/issues/2025
              },
              edits: change.textChanges.map((edit) => ({
                newText: edit.newText,
                range: {
                  start: { line: 0, character: edit.span.start },
                  end: { line: 0, character: edit.span.start + edit.span.length }
                }
              }))
            });
          } else {
            const doc = getTextDocument(uri);
            workspaceEdit.documentChanges.push({
              textDocument: {
                uri: uri.toString(),
                version: null
                // fix https://github.com/johnsoncodehk/volar/issues/2025
              },
              edits: change.textChanges.map((edit) => convertTextChange(edit, doc))
            });
          }
        }
        return workspaceEdit;
      }
      function convertRenameLocations(newText, locations, fileNameToUri, getTextDocument) {
        const workspaceEdit = {};
        for (const location of locations) {
          if (!workspaceEdit.changes) {
            workspaceEdit.changes = {};
          }
          const uri = fileNameToUri(location.fileName);
          const doc = getTextDocument(uri);
          if (!workspaceEdit.changes[uri.toString()]) {
            workspaceEdit.changes[uri.toString()] = [];
          }
          let _newText = newText;
          if (location.prefixText) {
            _newText = location.prefixText + _newText;
          }
          if (location.suffixText) {
            _newText = _newText + location.suffixText;
          }
          workspaceEdit.changes[uri.toString()].push({
            newText: _newText,
            range: convertTextSpan(location.textSpan, doc)
          });
        }
        return workspaceEdit;
      }
      function convertQuickInfo(ts2, info, document5, fileNameToUri, getTextDocument) {
        const parts = [];
        const displayString = ts2.displayPartsToString(info.displayParts);
        const documentation = previewer.markdownDocumentation(info.documentation ?? [], info.tags, fileNameToUri, getTextDocument);
        if (displayString) {
          parts.push(["```typescript", displayString, "```"].join("\n"));
        }
        if (documentation) {
          parts.push(documentation);
        }
        const markdown = {
          kind: "markdown",
          value: parts.join("\n\n")
        };
        return {
          contents: markdown,
          range: convertTextSpan(info.textSpan, document5)
        };
      }
      function convertNavTree(item, document5) {
        if (!shouldIncludeEntry(item)) {
          return [];
        }
        let remain = item.childItems ?? [];
        return item.spans.map((span) => {
          const childItems = [];
          remain = remain.filter((child) => {
            const childStart = child.spans[0].start;
            const childEnd = child.spans[child.spans.length - 1].start + child.spans[child.spans.length - 1].length;
            if (childStart >= span.start && childEnd <= span.start + span.length) {
              childItems.push(child);
              return false;
            }
            return true;
          });
          const nameSpan = item.spans.length === 1 ? item.nameSpan ?? span : span;
          const fullRange = {
            start: Math.min(span.start, nameSpan.start),
            end: Math.max(span.start + span.length, nameSpan.start + nameSpan.length)
          };
          const symbol = {
            name: item.text,
            kind: getSymbolKind(item.kind),
            range: convertTextSpan({
              start: fullRange.start,
              length: fullRange.end - fullRange.start
            }, document5),
            selectionRange: convertTextSpan(nameSpan, document5),
            children: childItems.map((item2) => convertNavTree(item2, document5)).flat()
          };
          const kindModifiers = (0, modifiers_1.parseKindModifier)(item.kindModifiers);
          if (kindModifiers.has(PConst.KindModifiers.deprecated)) {
            symbol.deprecated = true;
            symbol.tags ??= [];
            symbol.tags.push(1);
          }
          return symbol;
        });
      }
      var getSymbolKind = (kind) => {
        switch (kind) {
          case PConst.Kind.module:
            return 2;
          case PConst.Kind.class:
            return 5;
          case PConst.Kind.enum:
            return 10;
          case PConst.Kind.interface:
            return 11;
          case PConst.Kind.method:
            return 6;
          case PConst.Kind.memberVariable:
            return 7;
          case PConst.Kind.memberGetAccessor:
            return 7;
          case PConst.Kind.memberSetAccessor:
            return 7;
          case PConst.Kind.variable:
            return 13;
          case PConst.Kind.const:
            return 13;
          case PConst.Kind.localVariable:
            return 13;
          case PConst.Kind.function:
            return 12;
          case PConst.Kind.localFunction:
            return 12;
          case PConst.Kind.constructSignature:
            return 9;
          case PConst.Kind.constructorImplementation:
            return 9;
        }
        return 13;
      };
      function shouldIncludeEntry(item) {
        if (item.kind === PConst.Kind.alias) {
          return false;
        }
        return !!(item.text && item.text !== "<function>" && item.text !== "<class>");
      }
      function convertOutliningSpan(outliningSpan, document5) {
        const start2 = document5.positionAt(outliningSpan.textSpan.start);
        const end = adjustFoldingEnd(start2, document5.positionAt(outliningSpan.textSpan.start + outliningSpan.textSpan.length), document5);
        return {
          startLine: start2.line,
          endLine: end.line,
          startCharacter: start2.character,
          endCharacter: end.character,
          kind: convertOutliningSpanKind(outliningSpan.kind)
        };
      }
      function convertOutliningSpanKind(kind) {
        switch (kind) {
          case "comment":
            return "comment";
          case "region":
            return "region";
          case "imports":
            return "imports";
          case "code":
          default:
            return void 0;
        }
      }
      var foldEndPairCharacters = ["}", "]", ")", "`"];
      function adjustFoldingEnd(start2, end, document5) {
        if (end.character > 0) {
          const foldEndCharacter = document5.getText({
            start: { line: end.line, character: end.character - 1 },
            end
          });
          if (foldEndPairCharacters.includes(foldEndCharacter)) {
            const endOffset = Math.max(document5.offsetAt({ line: end.line, character: 0 }) - 1, document5.offsetAt(start2));
            return document5.positionAt(endOffset);
          }
        }
        return end;
      }
      function convertTextChange(edit, document5) {
        return {
          range: convertTextSpan(edit.span, document5),
          newText: edit.newText
        };
      }
      function convertCallHierarchyIncomingCall(item, ctx) {
        const uri = ctx.fileNameToUri(item.from.file);
        const document5 = ctx.getTextDocument(uri);
        return {
          from: convertCallHierarchyItem(item.from, ctx),
          fromRanges: item.fromSpans.map((span) => convertTextSpan(span, document5)).filter((span) => !!span)
        };
      }
      function convertCallHierarchyOutgoingCall(item, fromDocument, ctx) {
        return {
          to: convertCallHierarchyItem(item.to, ctx),
          fromRanges: item.fromSpans.map((span) => convertTextSpan(span, fromDocument)).filter((span) => !!span)
        };
      }
      function convertCallHierarchyItem(item, ctx) {
        const rootPath = ctx.languageService.getProgram()?.getCompilerOptions().rootDir ?? "";
        const uri = ctx.fileNameToUri(item.file);
        const document5 = ctx.getTextDocument(uri);
        const useFileName = isSourceFileItem(item);
        const name2 = useFileName ? path.basename(item.file) : item.name;
        const detail = useFileName ? path.relative(rootPath, path.dirname(item.file)) : item.containerName ?? "";
        const result = {
          kind: typeConverters.SymbolKind.fromProtocolScriptElementKind(item.kind),
          name: name2,
          detail,
          uri: uri.toString(),
          range: convertTextSpan(item.span, document5),
          selectionRange: convertTextSpan(item.selectionSpan, document5)
        };
        const kindModifiers = item.kindModifiers ? (0, modifiers_1.parseKindModifier)(item.kindModifiers) : void 0;
        if (kindModifiers?.has(PConst.KindModifiers.deprecated)) {
          result.tags = [1];
        }
        return result;
      }
      function isSourceFileItem(item) {
        return item.kind === PConst.Kind.script || item.kind === PConst.Kind.module && item.selectionSpan.start === 0;
      }
      function convertDocumentSpanToLocation(documentSpan, ctx) {
        const uri = ctx.fileNameToUri(documentSpan.fileName);
        const document5 = ctx.getTextDocument(uri);
        const range = convertTextSpan(documentSpan.textSpan, document5);
        return {
          uri: uri.toString(),
          range
        };
      }
      function convertDefinitionInfoAndBoundSpan(info, document5, ctx) {
        if (!info.definitions) {
          return [];
        }
        const originSelectionRange = convertTextSpan(info.textSpan, document5);
        return info.definitions.map((entry) => {
          const link2 = convertDocumentSpantoLocationLink(entry, ctx);
          if (link2) {
            link2.originSelectionRange ??= originSelectionRange;
            return link2;
          }
        }).filter((entry) => !!entry);
      }
      function convertDocumentSpantoLocationLink(documentSpan, ctx) {
        const targetUri = ctx.fileNameToUri(documentSpan.fileName);
        const document5 = ctx.getTextDocument(targetUri);
        const targetSelectionRange = convertTextSpan(documentSpan.textSpan, document5);
        const targetRange = documentSpan.contextSpan ? convertTextSpan(documentSpan.contextSpan, document5) : targetSelectionRange;
        const originSelectionRange = documentSpan.originalTextSpan ? convertTextSpan(documentSpan.originalTextSpan, document5) : void 0;
        return {
          targetUri: targetUri.toString(),
          targetRange,
          targetSelectionRange,
          originSelectionRange
        };
      }
      function convertTextSpan(textSpan, document5) {
        if (!document5) {
          return {
            start: { line: 0, character: 0 },
            end: { line: 0, character: 0 }
          };
        }
        return {
          start: document5.positionAt(textSpan.start),
          end: document5.positionAt(textSpan.start + textSpan.length)
        };
      }
    }
  });

  // node_modules/volar-service-typescript/lib/configs/getFormatCodeSettings.js
  var require_getFormatCodeSettings = __commonJS({
    "node_modules/volar-service-typescript/lib/configs/getFormatCodeSettings.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.getFormatCodeSettings = getFormatCodeSettings;
      var shared_1 = require_shared();
      async function getFormatCodeSettings(ctx, document5, options) {
        const config = await ctx.env.getConfiguration?.((0, shared_1.getConfigTitle)(document5) + ".format") ?? {};
        return {
          convertTabsToSpaces: options?.insertSpaces,
          tabSize: options?.tabSize,
          indentSize: options?.tabSize,
          indentStyle: 2,
          newLineCharacter: "\n",
          insertSpaceAfterCommaDelimiter: config.insertSpaceAfterCommaDelimiter ?? true,
          insertSpaceAfterConstructor: config.insertSpaceAfterConstructor ?? false,
          insertSpaceAfterSemicolonInForStatements: config.insertSpaceAfterSemicolonInForStatements ?? true,
          insertSpaceBeforeAndAfterBinaryOperators: config.insertSpaceBeforeAndAfterBinaryOperators ?? true,
          insertSpaceAfterKeywordsInControlFlowStatements: config.insertSpaceAfterKeywordsInControlFlowStatements ?? true,
          insertSpaceAfterFunctionKeywordForAnonymousFunctions: config.insertSpaceAfterFunctionKeywordForAnonymousFunctions ?? true,
          insertSpaceBeforeFunctionParenthesis: config.insertSpaceBeforeFunctionParenthesis ?? false,
          insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: config.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis ?? false,
          insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: config.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets ?? false,
          insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: config.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces ?? true,
          insertSpaceAfterOpeningAndBeforeClosingEmptyBraces: config.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces ?? true,
          insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: config.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces ?? false,
          insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: config.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces ?? false,
          insertSpaceAfterTypeAssertion: config.insertSpaceAfterTypeAssertion ?? false,
          placeOpenBraceOnNewLineForFunctions: config.placeOpenBraceOnNewLineForFunctions ?? false,
          placeOpenBraceOnNewLineForControlBlocks: config.placeOpenBraceOnNewLineForControlBlocks ?? false,
          semicolons: config.semicolons ?? "ignore"
        };
      }
    }
  });

  // node_modules/volar-service-typescript/lib/syntaxOnlyService.js
  var require_syntaxOnlyService = __commonJS({
    "node_modules/volar-service-typescript/lib/syntaxOnlyService.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createSyntaxOnlyService = createSyntaxOnlyService;
      function createSyntaxOnlyService(ts2, syntaxOnly) {
        let currentProjectVersion = -1;
        let fileNames = [];
        const scriptInfos = /* @__PURE__ */ new Map();
        const host = {
          getProjectVersion: () => currentProjectVersion.toString(),
          getScriptFileNames: () => fileNames,
          getScriptSnapshot: (fileName) => scriptInfos.get(fileName).snapshot,
          getScriptKind: (fileName) => scriptInfos.get(fileName).kind,
          getScriptVersion: (fileName) => scriptInfos.get(fileName).version.toString(),
          getCompilationSettings: () => ({}),
          getCurrentDirectory: () => "",
          getDefaultLibFileName: () => "",
          readFile: () => void 0,
          fileExists: (fileName) => scriptInfos.has(fileName)
        };
        return {
          languageService: syntaxOnly ? ts2.createLanguageService(host, void 0, ts2.LanguageServiceMode.Syntactic) : ts2.createLanguageService(host),
          updateFile
        };
        function updateFile(fileName, snapshot, scriptKind) {
          let scriptInfo = scriptInfos.get(fileName);
          if (scriptInfo?.snapshot === snapshot && scriptInfo.kind === scriptKind) {
            return;
          }
          currentProjectVersion++;
          scriptInfo = {
            snapshot,
            kind: scriptKind,
            version: (scriptInfo?.version ?? 0) + 1
          };
          const filesChanged = !scriptInfos.has(fileName);
          scriptInfos.set(fileName, scriptInfo);
          if (filesChanged) {
            fileNames = [...scriptInfos.keys()];
          }
        }
      }
    }
  });

  // node_modules/volar-service-typescript/lib/plugins/syntactic.js
  var require_syntactic = __commonJS({
    "node_modules/volar-service-typescript/lib/plugins/syntactic.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.getLanguageServiceByDocument = getLanguageServiceByDocument;
      exports3.create = create;
      var getFormatCodeSettings_1 = require_getFormatCodeSettings();
      var shared_1 = require_shared();
      var syntaxOnlyService_1 = require_syntaxOnlyService();
      var lspConverters_1 = require_lspConverters();
      var snapshots = /* @__PURE__ */ new WeakMap();
      var created;
      function getLanguageServiceByDocument(ts2, document5) {
        if (!created) {
          created = (0, syntaxOnlyService_1.createSyntaxOnlyService)(ts2, true);
        }
        let cache = snapshots.get(document5);
        if (!cache || cache[0] !== document5.version) {
          const snapshot = ts2.ScriptSnapshot.fromString(document5.getText());
          cache = [document5.version, snapshot];
          snapshots.set(document5, cache);
          created.updateFile(document5.uri, cache[1], document5.languageId === "javascript" ? ts2.ScriptKind.JS : document5.languageId === "javascriptreact" ? ts2.ScriptKind.JSX : document5.languageId === "typescriptreact" ? ts2.ScriptKind.TSX : ts2.ScriptKind.TS);
        }
        return {
          languageService: created.languageService,
          fileName: document5.uri
        };
      }
      function create(ts2, { isFormattingEnabled = async (document5, context) => {
        return await context.env.getConfiguration?.((0, shared_1.getConfigTitle)(document5) + ".format.enable") ?? true;
      } } = {}) {
        return {
          name: "typescript-syntactic",
          capabilities: {
            autoInsertionProvider: {
              triggerCharacters: [">", ">"],
              configurationSections: ["javascript.autoClosingTags", "typescript.autoClosingTags"]
            },
            foldingRangeProvider: true,
            selectionRangeProvider: true,
            documentSymbolProvider: true,
            documentFormattingProvider: true,
            documentOnTypeFormattingProvider: {
              // https://github.com/microsoft/vscode/blob/ce119308e8fd4cd3f992d42b297588e7abe33a0c/extensions/typescript-language-features/src/languageFeatures/formatting.ts#L99
              triggerCharacters: [";", "}", "\n"]
            }
          },
          create(context) {
            return {
              async provideAutoInsertSnippet(document5, selection, change) {
                if (document5.offsetAt(selection) !== change.rangeOffset + change.text.length) {
                  return;
                }
                if ((document5.languageId === "javascriptreact" || document5.languageId === "typescriptreact") && change.text.endsWith(">") && (await context.env.getConfiguration?.((0, shared_1.getConfigTitle)(document5) + ".autoClosingTags") ?? true)) {
                  const { languageService, fileName } = getLanguageServiceByDocument(ts2, document5);
                  const close = languageService.getJsxClosingTagAtPosition(fileName, document5.offsetAt(selection));
                  if (close) {
                    return "$0" + close.newText;
                  }
                }
              },
              provideFoldingRanges(document5) {
                if (!(0, shared_1.isTsDocument)(document5)) {
                  return;
                }
                const { languageService, fileName } = getLanguageServiceByDocument(ts2, document5);
                const outliningSpans = (0, shared_1.safeCall)(() => languageService.getOutliningSpans(fileName));
                if (!outliningSpans) {
                  return [];
                }
                return outliningSpans.map((span) => (0, lspConverters_1.convertOutliningSpan)(span, document5));
              },
              provideSelectionRanges(document5, positions) {
                if (!(0, shared_1.isTsDocument)(document5)) {
                  return;
                }
                const { languageService, fileName } = getLanguageServiceByDocument(ts2, document5);
                const ranges = positions.map((position4) => {
                  const offset2 = document5.offsetAt(position4);
                  const range = (0, shared_1.safeCall)(() => languageService.getSmartSelectionRange(fileName, offset2));
                  if (!range) {
                    return;
                  }
                  return (0, lspConverters_1.convertSelectionRange)(range, document5);
                });
                if (ranges.every((range) => !!range)) {
                  return ranges;
                }
              },
              provideDocumentSymbols(document5) {
                if (!(0, shared_1.isTsDocument)(document5)) {
                  return;
                }
                const { languageService, fileName } = getLanguageServiceByDocument(ts2, document5);
                const barItems = (0, shared_1.safeCall)(() => languageService.getNavigationTree(fileName));
                if (!barItems) {
                  return [];
                }
                return barItems.childItems?.map((item) => (0, lspConverters_1.convertNavTree)(item, document5)).flat() ?? [];
              },
              async provideDocumentFormattingEdits(document5, range, options, codeOptions) {
                if (!(0, shared_1.isTsDocument)(document5)) {
                  return;
                }
                if (!await isFormattingEnabled(document5, context)) {
                  return;
                }
                const tsOptions = await (0, getFormatCodeSettings_1.getFormatCodeSettings)(context, document5, options);
                if (codeOptions) {
                  tsOptions.baseIndentSize = codeOptions.initialIndentLevel * options.tabSize;
                }
                const { languageService, fileName } = getLanguageServiceByDocument(ts2, document5);
                const scriptEdits = range ? (0, shared_1.safeCall)(() => languageService.getFormattingEditsForRange(fileName, document5.offsetAt(range.start), document5.offsetAt(range.end), tsOptions)) : (0, shared_1.safeCall)(() => languageService.getFormattingEditsForDocument(fileName, tsOptions));
                if (!scriptEdits) {
                  return [];
                }
                return scriptEdits.map((edit) => (0, lspConverters_1.convertTextChange)(edit, document5));
              },
              async provideOnTypeFormattingEdits(document5, position4, key, options, codeOptions) {
                if (!(0, shared_1.isTsDocument)(document5)) {
                  return;
                }
                if (!await isFormattingEnabled(document5, context)) {
                  return;
                }
                const tsOptions = await (0, getFormatCodeSettings_1.getFormatCodeSettings)(context, document5, options);
                if (codeOptions) {
                  tsOptions.baseIndentSize = codeOptions.initialIndentLevel * options.tabSize;
                }
                const { languageService, fileName } = getLanguageServiceByDocument(ts2, document5);
                const scriptEdits = (0, shared_1.safeCall)(() => languageService.getFormattingEditsAfterKeystroke(fileName, document5.offsetAt(position4), key, tsOptions));
                if (!scriptEdits) {
                  return [];
                }
                return scriptEdits.map((edit) => (0, lspConverters_1.convertTextChange)(edit, document5));
              }
            };
          }
        };
      }
    }
  });

  // node_modules/volar-service-typescript/lib/plugins/docCommentTemplate.js
  var require_docCommentTemplate = __commonJS({
    "node_modules/volar-service-typescript/lib/plugins/docCommentTemplate.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.create = create;
      var nls = require_main();
      var shared_1 = require_shared();
      var lspConverters_1 = require_lspConverters();
      var syntactic_1 = require_syntactic();
      var localize2 = nls.loadMessageBundle();
      var defaultJsDoc = `/**
 * $0
 */`;
      function create(ts2) {
        return {
          name: "typescript-doc-comment-template",
          capabilities: {
            completionProvider: {
              triggerCharacters: ["*"]
            }
          },
          create() {
            return {
              provideCompletionItems(document5, position4) {
                if (!(0, shared_1.isTsDocument)(document5)) {
                  return;
                }
                if (!isPotentiallyValidDocCompletionPosition(document5, position4)) {
                  return;
                }
                const { languageService, fileName } = (0, syntactic_1.getLanguageServiceByDocument)(ts2, document5);
                const offset2 = document5.offsetAt(position4);
                const docCommentTemplate = languageService.getDocCommentTemplateAtPosition(fileName, offset2);
                if (!docCommentTemplate) {
                  return;
                }
                let insertText;
                if (docCommentTemplate.newText === "/** */") {
                  insertText = defaultJsDoc;
                } else {
                  insertText = templateToSnippet(docCommentTemplate.newText);
                }
                const item = createCompletionItem(document5, position4, insertText);
                return {
                  isIncomplete: false,
                  items: [item]
                };
              }
            };
          }
        };
      }
      function createCompletionItem(document5, position4, insertText) {
        const item = { label: "/** */" };
        item.kind = 1;
        item.detail = localize2("typescript.jsDocCompletionItem.documentation", "JSDoc comment");
        item.sortText = "\0";
        item.insertTextFormat = 2;
        const line = (0, lspConverters_1.getLineText)(document5, position4.line);
        const prefix = line.slice(0, position4.character).match(/\/\**\s*$/);
        const suffix = line.slice(position4.character).match(/^\s*\**\//);
        const start2 = { line: position4.line, character: position4.character + (prefix ? -prefix[0].length : 0) };
        const end = { line: position4.line, character: position4.character + (suffix ? suffix[0].length : 0) };
        const range = { start: start2, end };
        item.textEdit = { range, newText: insertText };
        return item;
      }
      function isPotentiallyValidDocCompletionPosition(document5, position4) {
        const line = (0, lspConverters_1.getLineText)(document5, position4.line);
        const prefix = line.slice(0, position4.character);
        if (!/^\s*$|\/\*\*\s*$|^\s*\/\*\*+\s*$/.test(prefix)) {
          return false;
        }
        const suffix = line.slice(position4.character);
        return /^\s*(\*+\/)?\s*$/.test(suffix);
      }
      function templateToSnippet(template) {
        let snippetIndex = 1;
        template = template.replace(/\$/g, "\\$");
        template = template.replace(/^[ \t]*(?=(\/|[ ]\*))/gm, "");
        template = template.replace(/^(\/\*\*\s*\*[ ]*)$/m, (x) => x + `$0`);
        template = template.replace(/\* @param([ ]\{\S+\})?\s+(\S+)[ \t]*$/gm, (_param, type, post) => {
          let out = "* @param ";
          if (type === " {any}" || type === " {*}") {
            out += `{\${${snippetIndex++}:*}} `;
          } else if (type) {
            out += type + " ";
          }
          out += post + ` \${${snippetIndex++}}`;
          return out;
        });
        template = template.replace(/\* @returns[ \t]*$/gm, `* @returns \${${snippetIndex++}}`);
        return template;
      }
    }
  });

  // node_modules/typescript-auto-import-cache/out/4_0/index.js
  var require__ = __commonJS({
    "node_modules/typescript-auto-import-cache/out/4_0/index.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      function default_1(ts2, host, _service) {
        var _a4, _b3;
        const importSuggestionsCache = (_b3 = (_a4 = ts2.Completions) === null || _a4 === void 0 ? void 0 : _a4.createImportSuggestionsForFileCache) === null || _b3 === void 0 ? void 0 : _b3.call(_a4);
        host.getImportSuggestionsCache = () => importSuggestionsCache;
      }
      exports3.default = default_1;
    }
  });

  // node_modules/typescript-auto-import-cache/out/4_4/moduleSpecifierCache.js
  var require_moduleSpecifierCache = __commonJS({
    "node_modules/typescript-auto-import-cache/out/4_4/moduleSpecifierCache.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createModuleSpecifierCache = void 0;
      function createModuleSpecifierCache() {
        let cache;
        let currentKey;
        const result = {
          get(fromFileName, toFileName, preferences) {
            if (!cache || currentKey !== key(fromFileName, preferences))
              return void 0;
            return cache.get(toFileName);
          },
          set(fromFileName, toFileName, preferences, modulePaths, moduleSpecifiers) {
            ensureCache(fromFileName, preferences).set(toFileName, createInfo(
              modulePaths,
              moduleSpecifiers,
              /*isAutoImportable*/
              true
            ));
            if (moduleSpecifiers) {
              for (const p of modulePaths) {
                if (p.isInNodeModules) {
                }
              }
            }
          },
          setModulePaths(fromFileName, toFileName, preferences, modulePaths) {
            const cache2 = ensureCache(fromFileName, preferences);
            const info = cache2.get(toFileName);
            if (info) {
              info.modulePaths = modulePaths;
            } else {
              cache2.set(toFileName, createInfo(
                modulePaths,
                /*moduleSpecifiers*/
                void 0,
                /*isAutoImportable*/
                void 0
              ));
            }
          },
          setIsAutoImportable(fromFileName, toFileName, preferences, isAutoImportable) {
            const cache2 = ensureCache(fromFileName, preferences);
            const info = cache2.get(toFileName);
            if (info) {
              info.isAutoImportable = isAutoImportable;
            } else {
              cache2.set(toFileName, createInfo(
                /*modulePaths*/
                void 0,
                /*moduleSpecifiers*/
                void 0,
                isAutoImportable
              ));
            }
          },
          clear() {
            cache === null || cache === void 0 ? void 0 : cache.clear();
            currentKey = void 0;
          },
          count() {
            return cache ? cache.size : 0;
          }
        };
        return result;
        function ensureCache(fromFileName, preferences) {
          const newKey = key(fromFileName, preferences);
          if (cache && currentKey !== newKey) {
            result.clear();
          }
          currentKey = newKey;
          return cache || (cache = /* @__PURE__ */ new Map());
        }
        function key(fromFileName, preferences) {
          return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference}`;
        }
        function createInfo(modulePaths, moduleSpecifiers, isAutoImportable) {
          return { modulePaths, moduleSpecifiers, isAutoImportable };
        }
      }
      exports3.createModuleSpecifierCache = createModuleSpecifierCache;
    }
  });

  // node_modules/typescript-auto-import-cache/out/4_4/packageJsonCache.js
  var require_packageJsonCache = __commonJS({
    "node_modules/typescript-auto-import-cache/out/4_4/packageJsonCache.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createPackageJsonCache = exports3.canCreatePackageJsonCache = void 0;
      function canCreatePackageJsonCache(ts2) {
        return "createPackageJsonInfo" in ts2 && "getDirectoryPath" in ts2 && "combinePaths" in ts2 && "tryFileExists" in ts2 && "forEachAncestorDirectory" in ts2;
      }
      exports3.canCreatePackageJsonCache = canCreatePackageJsonCache;
      function createPackageJsonCache(ts2, host) {
        const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts2;
        const packageJsons = /* @__PURE__ */ new Map();
        const directoriesWithoutPackageJson = /* @__PURE__ */ new Map();
        return {
          addOrUpdate,
          // @ts-expect-error
          forEach: packageJsons.forEach.bind(packageJsons),
          get: packageJsons.get.bind(packageJsons),
          delete: (fileName) => {
            packageJsons.delete(fileName);
            directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
          },
          getInDirectory: (directory) => {
            return packageJsons.get(combinePaths(directory, "package.json")) || void 0;
          },
          directoryHasPackageJson,
          searchDirectoryAndAncestors: (directory) => {
            forEachAncestorDirectory(directory, (ancestor) => {
              if (directoryHasPackageJson(ancestor) !== 3) {
                return true;
              }
              const packageJsonFileName = host.toPath(combinePaths(ancestor, "package.json"));
              if (tryFileExists(host, packageJsonFileName)) {
                addOrUpdate(packageJsonFileName);
              } else {
                directoriesWithoutPackageJson.set(ancestor, true);
              }
            });
          }
        };
        function addOrUpdate(fileName) {
          const packageJsonInfo = (
            // Debug.checkDefined(
            createPackageJsonInfo(fileName, host.host)
          );
          packageJsons.set(fileName, packageJsonInfo);
          directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
        }
        function directoryHasPackageJson(directory) {
          return packageJsons.has(combinePaths(directory, "package.json")) ? -1 : directoriesWithoutPackageJson.has(directory) ? 0 : 3;
        }
      }
      exports3.createPackageJsonCache = createPackageJsonCache;
    }
  });

  // node_modules/typescript-auto-import-cache/out/4_4/index.js
  var require__2 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/4_4/index.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      var moduleSpecifierCache_1 = require_moduleSpecifierCache();
      var packageJsonCache_1 = require_packageJsonCache();
      function default_1(ts2, host, service) {
        const _createCacheableExportInfoMap = ts2.createCacheableExportInfoMap;
        const _combinePaths = ts2.combinePaths;
        const _forEachAncestorDirectory = ts2.forEachAncestorDirectory;
        const _getDirectoryPath = ts2.getDirectoryPath;
        const _toPath = ts2.toPath;
        const _createGetCanonicalFileName = ts2.createGetCanonicalFileName;
        if (!_createCacheableExportInfoMap || !_combinePaths || !_forEachAncestorDirectory || !_getDirectoryPath || !_toPath || !_createGetCanonicalFileName || !(0, packageJsonCache_1.canCreatePackageJsonCache)(ts2))
          return;
        const moduleSpecifierCache = (0, moduleSpecifierCache_1.createModuleSpecifierCache)();
        const exportMapCache = _createCacheableExportInfoMap({
          getCurrentProgram() {
            return service.getProgram();
          },
          getPackageJsonAutoImportProvider() {
            return service.getProgram();
          }
        });
        const packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts2, Object.assign(Object.assign({}, host), {
          // @ts-expect-error
          host: Object.assign({}, host),
          toPath
        }));
        host.getCachedExportInfoMap = () => exportMapCache;
        host.getModuleSpecifierCache = () => moduleSpecifierCache;
        host.getPackageJsonsVisibleToFile = (fileName, rootDir) => {
          const rootPath = rootDir && toPath(rootDir);
          const filePath = toPath(fileName);
          const result = [];
          const processDirectory = (directory) => {
            switch (packageJsonCache.directoryHasPackageJson(directory)) {
              case 3:
                packageJsonCache.searchDirectoryAndAncestors(directory);
                return processDirectory(directory);
              case -1:
                const info = packageJsonCache.getInDirectory(directory);
                if (info)
                  result.push(info);
            }
            if (rootPath && rootPath === directory) {
              return true;
            }
          };
          _forEachAncestorDirectory(_getDirectoryPath(filePath), processDirectory);
          return result;
        };
        function toPath(fileName) {
          var _a4;
          return _toPath(fileName, host.getCurrentDirectory(), _createGetCanonicalFileName((_a4 = host.useCaseSensitiveFileNames) === null || _a4 === void 0 ? void 0 : _a4.call(host)));
        }
      }
      exports3.default = default_1;
    }
  });

  // node_modules/typescript-auto-import-cache/out/4_7/moduleSpecifierCache.js
  var require_moduleSpecifierCache2 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/4_7/moduleSpecifierCache.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createModuleSpecifierCache = exports3.nodeModulesPathPart = void 0;
      exports3.nodeModulesPathPart = "/node_modules/";
      function createModuleSpecifierCache() {
        let containedNodeModulesWatchers;
        let cache;
        let currentKey;
        const result = {
          get(fromFileName, toFileName, preferences, options) {
            if (!cache || currentKey !== key(fromFileName, preferences, options))
              return void 0;
            return cache.get(toFileName);
          },
          set(fromFileName, toFileName, preferences, options, modulePaths, moduleSpecifiers) {
            ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(
              modulePaths,
              moduleSpecifiers,
              /*isBlockedByPackageJsonDependencies*/
              false
            ));
            if (moduleSpecifiers) {
              for (const p of modulePaths) {
                if (p.isInNodeModules) {
                }
              }
            }
          },
          setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
            const cache2 = ensureCache(fromFileName, preferences, options);
            const info = cache2.get(toFileName);
            if (info) {
              info.modulePaths = modulePaths;
            } else {
              cache2.set(toFileName, createInfo(
                modulePaths,
                /*moduleSpecifiers*/
                void 0,
                /*isBlockedByPackageJsonDependencies*/
                void 0
              ));
            }
          },
          setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, isBlockedByPackageJsonDependencies) {
            const cache2 = ensureCache(fromFileName, preferences, options);
            const info = cache2.get(toFileName);
            if (info) {
              info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
            } else {
              cache2.set(toFileName, createInfo(
                /*modulePaths*/
                void 0,
                /*moduleSpecifiers*/
                void 0,
                isBlockedByPackageJsonDependencies
              ));
            }
          },
          clear() {
            containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.forEach((watcher) => watcher.close());
            cache === null || cache === void 0 ? void 0 : cache.clear();
            containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.clear();
            currentKey = void 0;
          },
          count() {
            return cache ? cache.size : 0;
          }
        };
        return result;
        function ensureCache(fromFileName, preferences, options) {
          const newKey = key(fromFileName, preferences, options);
          if (cache && currentKey !== newKey) {
            result.clear();
          }
          currentKey = newKey;
          return cache || (cache = /* @__PURE__ */ new Map());
        }
        function key(fromFileName, preferences, options) {
          return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
        }
        function createInfo(modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies) {
          return { modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies };
        }
      }
      exports3.createModuleSpecifierCache = createModuleSpecifierCache;
    }
  });

  // node_modules/typescript-auto-import-cache/out/4_7/packageJsonCache.js
  var require_packageJsonCache2 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/4_7/packageJsonCache.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createPackageJsonCache = void 0;
      function createPackageJsonCache(ts2, host) {
        const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts2;
        const packageJsons = /* @__PURE__ */ new Map();
        const directoriesWithoutPackageJson = /* @__PURE__ */ new Map();
        return {
          addOrUpdate,
          forEach: packageJsons.forEach.bind(packageJsons),
          get: packageJsons.get.bind(packageJsons),
          delete: (fileName) => {
            packageJsons.delete(fileName);
            directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
          },
          getInDirectory: (directory) => {
            return packageJsons.get(combinePaths(directory, "package.json")) || void 0;
          },
          directoryHasPackageJson,
          searchDirectoryAndAncestors: (directory) => {
            forEachAncestorDirectory(directory, (ancestor) => {
              if (directoryHasPackageJson(ancestor) !== 3) {
                return true;
              }
              const packageJsonFileName = host.toPath(combinePaths(ancestor, "package.json"));
              if (tryFileExists(host, packageJsonFileName)) {
                addOrUpdate(packageJsonFileName);
              } else {
                directoriesWithoutPackageJson.set(ancestor, true);
              }
            });
          }
        };
        function addOrUpdate(fileName) {
          const packageJsonInfo = (
            // Debug.checkDefined(
            createPackageJsonInfo(fileName, host.host)
          );
          packageJsons.set(fileName, packageJsonInfo);
          directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
        }
        function directoryHasPackageJson(directory) {
          return packageJsons.has(combinePaths(directory, "package.json")) ? -1 : directoriesWithoutPackageJson.has(directory) ? 0 : 3;
        }
      }
      exports3.createPackageJsonCache = createPackageJsonCache;
    }
  });

  // node_modules/typescript-auto-import-cache/out/4_7/index.js
  var require__3 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/4_7/index.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      var moduleSpecifierCache_1 = require_moduleSpecifierCache2();
      var packageJsonCache_1 = require_packageJsonCache2();
      function default_1(ts2, host, service) {
        const _createCacheableExportInfoMap = ts2.createCacheableExportInfoMap;
        const _combinePaths = ts2.combinePaths;
        const _forEachAncestorDirectory = ts2.forEachAncestorDirectory;
        const _getDirectoryPath = ts2.getDirectoryPath;
        const _toPath = ts2.toPath;
        const _createGetCanonicalFileName = ts2.createGetCanonicalFileName;
        if (!_createCacheableExportInfoMap || !_combinePaths || !_forEachAncestorDirectory || !_getDirectoryPath || !_toPath || !_createGetCanonicalFileName)
          return;
        const moduleSpecifierCache = (0, moduleSpecifierCache_1.createModuleSpecifierCache)();
        const exportMapCache = _createCacheableExportInfoMap({
          getCurrentProgram() {
            return service.getProgram();
          },
          getPackageJsonAutoImportProvider() {
            return service.getProgram();
          },
          getGlobalTypingsCacheLocation() {
            return void 0;
          }
        });
        const packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts2, Object.assign(Object.assign({}, host), {
          // @ts-expect-error
          host: Object.assign({}, host),
          toPath
        }));
        host.getCachedExportInfoMap = () => exportMapCache;
        host.getModuleSpecifierCache = () => moduleSpecifierCache;
        host.getPackageJsonsVisibleToFile = (fileName, rootDir) => {
          const rootPath = rootDir && toPath(rootDir);
          const filePath = toPath(fileName);
          const result = [];
          const processDirectory = (directory) => {
            switch (packageJsonCache.directoryHasPackageJson(directory)) {
              case 3:
                packageJsonCache.searchDirectoryAndAncestors(directory);
                return processDirectory(directory);
              case -1:
                const info = packageJsonCache.getInDirectory(directory);
                if (info)
                  result.push(info);
            }
            if (rootPath && rootPath === directory) {
              return true;
            }
          };
          _forEachAncestorDirectory(_getDirectoryPath(filePath), processDirectory);
          return result;
        };
        function toPath(fileName) {
          var _a4;
          return _toPath(fileName, host.getCurrentDirectory(), _createGetCanonicalFileName((_a4 = host.useCaseSensitiveFileNames) === null || _a4 === void 0 ? void 0 : _a4.call(host)));
        }
      }
      exports3.default = default_1;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_0/packageJsonCache.js
  var require_packageJsonCache3 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_0/packageJsonCache.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createPackageJsonCache = void 0;
      function createPackageJsonCache(ts2, host) {
        const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts2;
        const packageJsons = /* @__PURE__ */ new Map();
        const directoriesWithoutPackageJson = /* @__PURE__ */ new Map();
        return {
          addOrUpdate,
          // @ts-expect-error
          forEach: packageJsons.forEach.bind(packageJsons),
          get: packageJsons.get.bind(packageJsons),
          delete: (fileName) => {
            packageJsons.delete(fileName);
            directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
          },
          getInDirectory: (directory) => {
            return packageJsons.get(combinePaths(directory, "package.json")) || void 0;
          },
          directoryHasPackageJson,
          searchDirectoryAndAncestors: (directory) => {
            forEachAncestorDirectory(directory, (ancestor) => {
              if (directoryHasPackageJson(ancestor) !== 3) {
                return true;
              }
              const packageJsonFileName = host.toPath(combinePaths(ancestor, "package.json"));
              if (tryFileExists(host, packageJsonFileName)) {
                addOrUpdate(packageJsonFileName);
              } else {
                directoriesWithoutPackageJson.set(ancestor, true);
              }
            });
          }
        };
        function addOrUpdate(fileName) {
          const packageJsonInfo = (
            /*Debug.checkDefined( */
            createPackageJsonInfo(fileName, host.host)
          );
          packageJsons.set(fileName, packageJsonInfo);
          directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
        }
        function directoryHasPackageJson(directory) {
          return packageJsons.has(combinePaths(directory, "package.json")) ? -1 : directoriesWithoutPackageJson.has(directory) ? 0 : 3;
        }
      }
      exports3.createPackageJsonCache = createPackageJsonCache;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_0/projectService.js
  var require_projectService = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_0/projectService.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createProjectService = void 0;
      var packageJsonCache_1 = require_packageJsonCache3();
      function createProjectService(ts2, sys, currentDirectory, hostConfiguration, serverMode) {
        const { toPath, getNormalizedAbsolutePath, normalizePath: toNormalizedPath, createGetCanonicalFileName, forEachAncestorDirectory, getDirectoryPath } = ts2;
        const projectService = {
          serverMode,
          host: sys,
          currentDirectory: toNormalizedPath(currentDirectory),
          toCanonicalFileName: createGetCanonicalFileName(sys.useCaseSensitiveFileNames),
          toPath(fileName) {
            return toPath(fileName, this.currentDirectory, this.toCanonicalFileName);
          },
          getExecutingFilePath() {
            return this.getNormalizedAbsolutePath(this.host.getExecutingFilePath());
          },
          getNormalizedAbsolutePath(fileName) {
            return getNormalizedAbsolutePath(fileName, this.host.getCurrentDirectory());
          },
          packageJsonCache: void 0,
          getPackageJsonsVisibleToFile(fileName, rootDir) {
            const packageJsonCache = this.packageJsonCache;
            const rootPath = rootDir && this.toPath(rootDir);
            const filePath = this.toPath(fileName);
            const result = [];
            const processDirectory = (directory) => {
              switch (packageJsonCache.directoryHasPackageJson(directory)) {
                case 3:
                  packageJsonCache.searchDirectoryAndAncestors(directory);
                  return processDirectory(directory);
                case -1:
                  const info = packageJsonCache.getInDirectory(directory);
                  if (info)
                    result.push(info);
              }
              if (rootPath && rootPath === directory) {
                return true;
              }
            };
            forEachAncestorDirectory(getDirectoryPath(filePath), processDirectory);
            return result;
          },
          includePackageJsonAutoImports() {
            switch (hostConfiguration.preferences.includePackageJsonAutoImports) {
              case "on":
                return 1;
              case "off":
                return 0;
              default:
                return 2;
            }
          },
          fileExists(fileName) {
            return this.host.fileExists(fileName);
          }
        };
        projectService.packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts2, projectService);
        return projectService;
      }
      exports3.createProjectService = createProjectService;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_0/moduleSpecifierCache.js
  var require_moduleSpecifierCache3 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_0/moduleSpecifierCache.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createModuleSpecifierCache = exports3.nodeModulesPathPart = void 0;
      exports3.nodeModulesPathPart = "/node_modules/";
      function createModuleSpecifierCache() {
        let containedNodeModulesWatchers;
        let cache;
        let currentKey;
        const result = {
          get(fromFileName, toFileName, preferences, options) {
            if (!cache || currentKey !== key(fromFileName, preferences, options))
              return void 0;
            return cache.get(toFileName);
          },
          set(fromFileName, toFileName, preferences, options, modulePaths, moduleSpecifiers) {
            ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(
              modulePaths,
              moduleSpecifiers,
              /*isBlockedByPackageJsonDependencies*/
              false
            ));
            if (moduleSpecifiers) {
              for (const p of modulePaths) {
                if (p.isInNodeModules) {
                }
              }
            }
          },
          setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
            const cache2 = ensureCache(fromFileName, preferences, options);
            const info = cache2.get(toFileName);
            if (info) {
              info.modulePaths = modulePaths;
            } else {
              cache2.set(toFileName, createInfo(
                modulePaths,
                /*moduleSpecifiers*/
                void 0,
                /*isBlockedByPackageJsonDependencies*/
                void 0
              ));
            }
          },
          setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, isBlockedByPackageJsonDependencies) {
            const cache2 = ensureCache(fromFileName, preferences, options);
            const info = cache2.get(toFileName);
            if (info) {
              info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
            } else {
              cache2.set(toFileName, createInfo(
                /*modulePaths*/
                void 0,
                /*moduleSpecifiers*/
                void 0,
                isBlockedByPackageJsonDependencies
              ));
            }
          },
          clear() {
            containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.forEach((watcher) => watcher.close());
            cache === null || cache === void 0 ? void 0 : cache.clear();
            containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.clear();
            currentKey = void 0;
          },
          count() {
            return cache ? cache.size : 0;
          }
        };
        return result;
        function ensureCache(fromFileName, preferences, options) {
          const newKey = key(fromFileName, preferences, options);
          if (cache && currentKey !== newKey) {
            result.clear();
          }
          currentKey = newKey;
          return cache || (cache = /* @__PURE__ */ new Map());
        }
        function key(fromFileName, preferences, options) {
          return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
        }
        function createInfo(modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies) {
          return { modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies };
        }
      }
      exports3.createModuleSpecifierCache = createModuleSpecifierCache;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_0/autoImportProviderProject.js
  var require_autoImportProviderProject = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_0/autoImportProviderProject.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createAutoImportProviderProjectStatic = void 0;
      var project_1 = require_project();
      function createAutoImportProviderProjectStatic(tsBase, host, createLanguageService2) {
        const ts2 = tsBase;
        const { combinePaths, inferredTypesContainingFile, arrayFrom, resolvePackageNameToPackageJson, concatenate, forEach, startsWith, getEntrypointsFromPackageJsonInfo, mapDefined, timestamp } = ts2;
        return {
          maxDependencies: 10,
          compilerOptionsOverrides: {
            diagnostics: false,
            skipLibCheck: true,
            sourceMap: false,
            types: ts2.emptyArray,
            lib: ts2.emptyArray,
            noLib: true
          },
          getRootFileNames(dependencySelection, hostProject, moduleResolutionHost, compilerOptions) {
            var _a4, _b3;
            if (!dependencySelection) {
              return ts2.emptyArray;
            }
            const program = hostProject.getCurrentProgram();
            if (!program) {
              return ts2.emptyArray;
            }
            const start2 = timestamp();
            let dependencyNames;
            let rootNames;
            const rootFileName = combinePaths(hostProject.currentDirectory, inferredTypesContainingFile);
            const packageJsons = hostProject.getPackageJsonsForAutoImport(combinePaths(hostProject.currentDirectory, rootFileName));
            for (const packageJson of packageJsons) {
              (_a4 = packageJson.dependencies) === null || _a4 === void 0 ? void 0 : _a4.forEach((_, dependenyName) => addDependency(dependenyName));
              (_b3 = packageJson.peerDependencies) === null || _b3 === void 0 ? void 0 : _b3.forEach((_, dependencyName) => addDependency(dependencyName));
            }
            let dependenciesAdded = 0;
            if (dependencyNames) {
              const symlinkCache = hostProject.getSymlinkCache();
              for (const name2 of arrayFrom(dependencyNames.keys())) {
                if (dependencySelection === 2 && dependenciesAdded > this.maxDependencies) {
                  hostProject.log(`AutoImportProviderProject: attempted to add more than ${this.maxDependencies} dependencies. Aborting.`);
                  return ts2.emptyArray;
                }
                const packageJson = resolvePackageNameToPackageJson(
                  name2,
                  hostProject.currentDirectory,
                  compilerOptions,
                  moduleResolutionHost,
                  // @ts-expect-error
                  program.getModuleResolutionCache()
                );
                if (packageJson) {
                  const entrypoints = getRootNamesFromPackageJson(packageJson, program, symlinkCache);
                  if (entrypoints) {
                    rootNames = concatenate(rootNames, entrypoints);
                    dependenciesAdded += entrypoints.length ? 1 : 0;
                    continue;
                  }
                }
                const done = forEach([hostProject.currentDirectory, hostProject.getGlobalTypingsCacheLocation()], (directory) => {
                  if (directory) {
                    const typesPackageJson = resolvePackageNameToPackageJson(
                      `@types/${name2}`,
                      directory,
                      compilerOptions,
                      moduleResolutionHost,
                      // @ts-expect-error
                      program.getModuleResolutionCache()
                    );
                    if (typesPackageJson) {
                      const entrypoints = getRootNamesFromPackageJson(typesPackageJson, program, symlinkCache);
                      rootNames = concatenate(rootNames, entrypoints);
                      dependenciesAdded += (entrypoints === null || entrypoints === void 0 ? void 0 : entrypoints.length) ? 1 : 0;
                      return true;
                    }
                  }
                });
                if (done)
                  continue;
                if (packageJson && compilerOptions.allowJs && compilerOptions.maxNodeModuleJsDepth) {
                  const entrypoints = getRootNamesFromPackageJson(
                    packageJson,
                    program,
                    symlinkCache,
                    /*allowJs*/
                    true
                  );
                  rootNames = concatenate(rootNames, entrypoints);
                  dependenciesAdded += (entrypoints === null || entrypoints === void 0 ? void 0 : entrypoints.length) ? 1 : 0;
                }
              }
            }
            if (rootNames === null || rootNames === void 0 ? void 0 : rootNames.length) {
              hostProject.log(`AutoImportProviderProject: found ${rootNames.length} root files in ${dependenciesAdded} dependencies in ${timestamp() - start2} ms`);
            }
            return rootNames || ts2.emptyArray;
            function addDependency(dependency) {
              if (!startsWith(dependency, "@types/")) {
                (dependencyNames || (dependencyNames = /* @__PURE__ */ new Set())).add(dependency);
              }
            }
            function getRootNamesFromPackageJson(packageJson, program2, symlinkCache, resolveJs) {
              var _a5;
              const entrypoints = getEntrypointsFromPackageJsonInfo(
                packageJson,
                compilerOptions,
                moduleResolutionHost,
                // @ts-expect-error
                program2.getModuleResolutionCache(),
                resolveJs
              );
              if (entrypoints) {
                const real = (_a5 = moduleResolutionHost.realpath) === null || _a5 === void 0 ? void 0 : _a5.call(moduleResolutionHost, packageJson.packageDirectory);
                const isSymlink = real && real !== packageJson.packageDirectory;
                if (isSymlink) {
                  symlinkCache.setSymlinkedDirectory(packageJson.packageDirectory, {
                    real,
                    realPath: hostProject.toPath(real)
                  });
                }
                return mapDefined(entrypoints, (entrypoint) => {
                  const resolvedFileName = isSymlink ? entrypoint.replace(packageJson.packageDirectory, real) : entrypoint;
                  if (!program2.getSourceFile(resolvedFileName) && !(isSymlink && program2.getSourceFile(entrypoint))) {
                    return resolvedFileName;
                  }
                });
              }
            }
          },
          create(dependencySelection, hostProject, moduleResolutionHost) {
            if (dependencySelection === 0) {
              return void 0;
            }
            const compilerOptions = Object.assign(Object.assign({}, hostProject.getCompilerOptions()), this.compilerOptionsOverrides);
            let rootNames = this.getRootFileNames(dependencySelection, hostProject, moduleResolutionHost, compilerOptions);
            if (!rootNames.length) {
              return void 0;
            }
            return createAutoImportProviderProject(tsBase, host, createLanguageService2, { self: this, hostProject, rootNames, compilerOptions });
          }
        };
      }
      exports3.createAutoImportProviderProjectStatic = createAutoImportProviderProjectStatic;
      function createAutoImportProviderProject(tsBase, host, createLanguageService2, options) {
        const { self: self2, rootNames, compilerOptions, hostProject } = options;
        const ts2 = tsBase;
        const { some } = ts2;
        const project = Object.assign(Object.assign({}, (0, project_1.createProject)(tsBase, host, createLanguageService2, {
          projectService: hostProject.projectService,
          currentDirectory: hostProject.currentDirectory,
          compilerOptions
        })), {
          projectVersion: 0,
          getProjectVersion() {
            return this.projectVersion.toString();
          },
          rootFileNames: rootNames,
          hostProject,
          isEmpty() {
            return !some(this.rootFileNames);
          },
          isOrphan() {
            return true;
          },
          updateGraph() {
            var _a4;
            let rootFileNames = this.rootFileNames;
            if (!rootFileNames) {
              rootFileNames = self2.getRootFileNames(this.hostProject.includePackageJsonAutoImports(), this.hostProject, this.hostProject.getModuleResolutionHostForAutoImportProvider(), this.getCompilationSettings());
            }
            this.rootFileNames = rootFileNames;
            const oldProgram = this.getCurrentProgram();
            this.program = (_a4 = this.languageService) === null || _a4 === void 0 ? void 0 : _a4.getProgram();
            this.dirty = false;
            if (oldProgram && oldProgram !== this.getCurrentProgram()) {
              this.hostProject.clearCachedExportInfoMap();
            }
          },
          scheduleInvalidateResolutionsOfFailedLookupLocations() {
            return;
          },
          hasRoots() {
            var _a4;
            return !!((_a4 = this.rootFileNames) === null || _a4 === void 0 ? void 0 : _a4.length);
          },
          markAsDirty() {
            if (!this.dirty) {
              this.rootFileNames = void 0;
              this.projectVersion++;
              this.dirty = true;
            }
          },
          getScriptFileNames() {
            return this.rootFileNames || ts2.emptyArray;
          },
          getLanguageService() {
            throw new Error("AutoImportProviderProject language service should never be used. To get the program, use `project.getCurrentProgram()`.");
          },
          onAutoImportProviderSettingsChanged() {
            throw new Error("AutoImportProviderProject is an auto import provider; use `markAsDirty()` instead.");
          },
          onPackageJsonChange() {
            throw new Error("package.json changes should be notified on an AutoImportProvider's host project");
          },
          getModuleResolutionHostForAutoImportProvider() {
            throw new Error("AutoImportProviderProject cannot provide its own host; use `hostProject.getModuleResolutionHostForAutomImportProvider()` instead.");
          },
          includePackageJsonAutoImports() {
            return 0;
          },
          getTypeAcquisition() {
            return { enable: false };
          },
          getSymlinkCache() {
            return this.hostProject.getSymlinkCache();
          },
          getModuleResolutionCache() {
            var _a4, _b3;
            return (_b3 = (_a4 = this.hostProject.languageService) === null || _a4 === void 0 ? void 0 : _a4.getProgram()) === null || _b3 === void 0 ? void 0 : _b3.getModuleResolutionCache();
          }
        });
        return (0, project_1.initProject)(project, new Proxy(host, {
          get(target, key) {
            return key in project ? project[key] : target[key];
          },
          set(_target, key, value) {
            project[key] = value;
            return true;
          }
        }), createLanguageService2);
      }
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_0/project.js
  var require_project = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_0/project.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.initProject = exports3.createProject = void 0;
      var moduleSpecifierCache_1 = require_moduleSpecifierCache3();
      var autoImportProviderProject_1 = require_autoImportProviderProject();
      function createProject(ts2, host, createLanguageService2, options) {
        var _a4;
        const { combinePaths, inferredTypesContainingFile, createSymlinkCache, toPath, createCacheableExportInfoMap, timestamp, isInsideNodeModules, LanguageServiceMode } = ts2;
        const AutoImportProviderProject = (0, autoImportProviderProject_1.createAutoImportProviderProjectStatic)(ts2, host, createLanguageService2);
        const { projectService, compilerOptions, currentDirectory } = options;
        function updateProjectIfDirty(project) {
          return project.dirty && project.updateGraph();
        }
        return {
          dirty: false,
          hostProject: void 0,
          languageServiceEnabled: true,
          languageService: void 0,
          projectService,
          getCanonicalFileName: projectService.toCanonicalFileName,
          exportMapCache: void 0,
          getCachedExportInfoMap() {
            return this.exportMapCache || (this.exportMapCache = createCacheableExportInfoMap(this));
          },
          clearCachedExportInfoMap() {
            var _a5;
            (_a5 = this.exportMapCache) === null || _a5 === void 0 ? void 0 : _a5.clear();
          },
          moduleSpecifierCache: ((_a4 = options.createModuleSpecifierCache) !== null && _a4 !== void 0 ? _a4 : moduleSpecifierCache_1.createModuleSpecifierCache)(),
          getModuleSpecifierCache() {
            return this.moduleSpecifierCache;
          },
          compilerOptions,
          getCompilationSettings() {
            return this.compilerOptions;
          },
          getCompilerOptions() {
            return this.compilerOptions;
          },
          program: void 0,
          getCurrentProgram() {
            return this.program;
          },
          currentDirectory: projectService.getNormalizedAbsolutePath(currentDirectory || ""),
          getCurrentDirectory() {
            return this.currentDirectory;
          },
          symlinks: void 0,
          getSymlinkCache() {
            if (!this.symlinks) {
              this.symlinks = createSymlinkCache(this.getCurrentDirectory(), this.getCanonicalFileName);
            }
            if (this.program && !this.symlinks.hasProcessedResolutions()) {
              this.symlinks.setSymlinksFromResolutions(
                this.program.getSourceFiles(),
                // @ts-expect-error
                this.program.getAutomaticTypeDirectiveResolutions()
              );
            }
            return this.symlinks;
          },
          packageJsonsForAutoImport: void 0,
          getPackageJsonsForAutoImport(rootDir) {
            const packageJsons = this.getPackageJsonsVisibleToFile(combinePaths(this.currentDirectory, inferredTypesContainingFile), rootDir);
            this.packageJsonsForAutoImport = new Set(packageJsons.map((p) => p.fileName));
            return packageJsons;
          },
          getPackageJsonsVisibleToFile(fileName, rootDir) {
            return this.projectService.getPackageJsonsVisibleToFile(fileName, rootDir);
          },
          getModuleResolutionHostForAutoImportProvider() {
            var _a5;
            if (this.program) {
              return {
                // @ts-expect-error
                fileExists: this.program.fileExists,
                // @ts-expect-error
                directoryExists: this.program.directoryExists,
                // @ts-expect-error
                realpath: this.program.realpath || ((_a5 = this.projectService.host.realpath) === null || _a5 === void 0 ? void 0 : _a5.bind(this.projectService.host)),
                getCurrentDirectory: this.getCurrentDirectory.bind(this),
                readFile: this.projectService.host.readFile.bind(this.projectService.host),
                getDirectories: this.projectService.host.getDirectories.bind(this.projectService.host),
                // trace: this.projectService.host.trace?.bind(this.projectService.host),
                trace: () => {
                },
                // @ts-expect-error
                useCaseSensitiveFileNames: this.program.useCaseSensitiveFileNames()
              };
            }
            return this.projectService.host;
          },
          autoImportProviderHost: void 0,
          getPackageJsonAutoImportProvider() {
            if (this.autoImportProviderHost === false) {
              return void 0;
            }
            if (this.projectService.serverMode !== LanguageServiceMode.Semantic) {
              this.autoImportProviderHost = false;
              return void 0;
            }
            if (this.autoImportProviderHost) {
              updateProjectIfDirty(this.autoImportProviderHost);
              if (this.autoImportProviderHost.isEmpty()) {
                this.autoImportProviderHost.close();
                this.autoImportProviderHost = void 0;
                return void 0;
              }
              return this.autoImportProviderHost.getCurrentProgram();
            }
            const dependencySelection = projectService.includePackageJsonAutoImports();
            if (dependencySelection) {
              const start2 = timestamp();
              this.autoImportProviderHost = AutoImportProviderProject.create(dependencySelection, this, this.getModuleResolutionHostForAutoImportProvider());
              if (this.autoImportProviderHost) {
                updateProjectIfDirty(this.autoImportProviderHost);
                this.sendPerformanceEvent("CreatePackageJsonAutoImportProvider", timestamp() - start2);
                return this.autoImportProviderHost.getCurrentProgram();
              }
            }
          },
          includePackageJsonAutoImports() {
            if (this.projectService.includePackageJsonAutoImports() === 0 || !this.languageServiceEnabled || isInsideNodeModules(this.currentDirectory)) {
              return 0;
            }
            return this.projectService.includePackageJsonAutoImports();
          },
          close() {
          },
          log(_message) {
          },
          sendPerformanceEvent(_kind, _durationMs) {
          },
          toPath(fileName) {
            return toPath(fileName, this.currentDirectory, this.projectService.toCanonicalFileName);
          },
          getGlobalTypingsCacheLocation() {
            return void 0;
          },
          useSourceOfProjectReferenceRedirect() {
            return !this.getCompilerOptions().disableSourceOfProjectReferenceRedirect;
          },
          onAutoImportProviderSettingsChanged() {
            var _a5;
            if (this.autoImportProviderHost === false) {
              this.autoImportProviderHost = void 0;
            } else {
              (_a5 = this.autoImportProviderHost) === null || _a5 === void 0 ? void 0 : _a5.markAsDirty();
            }
          }
        };
      }
      exports3.createProject = createProject;
      function initProject(project, host, createLanguageService2) {
        const languageService = createLanguageService2(host);
        project.languageService = languageService;
        project.program = languageService.getProgram();
        return project;
      }
      exports3.initProject = initProject;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_0/index.js
  var require__4 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_0/index.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      var projectService_1 = require_projectService();
      var project_1 = require_project();
      var projectService;
      var projects = /* @__PURE__ */ new Set();
      function default_1(ts2, sys, host, createLanguageService2, _createProject = project_1.createProject) {
        const hostConfiguration = { preferences: { includePackageJsonAutoImports: "auto" } };
        if (!projectService) {
          projectService = (0, projectService_1.createProjectService)(ts2, sys, host.getCurrentDirectory(), hostConfiguration, ts2.LanguageServiceMode.Semantic);
        }
        const project = _createProject(ts2, host, createLanguageService2, {
          projectService,
          currentDirectory: host.getCurrentDirectory(),
          compilerOptions: host.getCompilationSettings()
        });
        const proxyMethods = [
          "getCachedExportInfoMap",
          "getModuleSpecifierCache",
          "getGlobalTypingsCacheLocation",
          "getSymlinkCache",
          "getPackageJsonsVisibleToFile",
          "getPackageJsonAutoImportProvider",
          "includePackageJsonAutoImports",
          "useSourceOfProjectReferenceRedirect"
        ];
        proxyMethods.forEach((key) => host[key] = project[key].bind(project));
        (0, project_1.initProject)(project, host, createLanguageService2);
        projects.add(project);
        return {
          languageService: project.languageService,
          setPreferences(newPreferences) {
            let onAutoImportProviderSettingsChanged = newPreferences.includePackageJsonAutoImports !== hostConfiguration.preferences.includePackageJsonAutoImports;
            hostConfiguration.preferences = newPreferences;
            if (onAutoImportProviderSettingsChanged) {
              project.onAutoImportProviderSettingsChanged();
            }
          },
          projectUpdated(path) {
            projects.forEach((projectToUpdate) => {
              var _a4, _b3, _c;
              if (project === projectToUpdate || !projectToUpdate.autoImportProviderHost)
                return;
              const realPaths = [...(_c = (_b3 = (_a4 = projectToUpdate.symlinks) === null || _a4 === void 0 ? void 0 : _a4.getSymlinkedDirectoriesByRealpath()) === null || _b3 === void 0 ? void 0 : _b3.keys()) !== null && _c !== void 0 ? _c : []].map((name2) => projectToUpdate.projectService.getNormalizedAbsolutePath(name2));
              if (realPaths.includes(projectToUpdate.projectService.toCanonicalFileName(path))) {
                projectToUpdate.autoImportProviderHost.markAsDirty();
              }
            });
          }
        };
      }
      exports3.default = default_1;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_3/project.js
  var require_project2 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_3/project.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createProject = void 0;
      var project_1 = require_project();
      function createProject(ts2, host, createLanguageService2, options) {
        const { createSymlinkCache, ensureTrailingDirectorySeparator } = ts2;
        const project = (0, project_1.createProject)(ts2, host, createLanguageService2, options);
        project.getSymlinkCache = () => {
          if (!project.symlinks) {
            project.symlinks = createSymlinkCache(project.getCurrentDirectory(), project.getCanonicalFileName);
            const setSymlinkedDirectory = project.symlinks.setSymlinkedDirectory;
            project.symlinks.setSymlinkedDirectory = (symlink, real) => {
              if (typeof real === "object") {
                real.real = ensureTrailingDirectorySeparator(real.real);
                real.realPath = ensureTrailingDirectorySeparator(real.realPath);
              }
              setSymlinkedDirectory(symlink, real);
            };
          }
          if (project.program && !project.symlinks.hasProcessedResolutions()) {
            project.symlinks.setSymlinksFromResolutions(
              // @ts-expect-error
              project.program.forEachResolvedModule,
              // @ts-expect-error
              project.program.forEachResolvedTypeReferenceDirective,
              // @ts-expect-error
              project.program.getAutomaticTypeDirectiveResolutions()
            );
          }
          return project.symlinks;
        };
        return project;
      }
      exports3.createProject = createProject;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_3/index.js
  var require__5 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_3/index.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      var _5_0_1 = require__4();
      var project_1 = require_project2();
      function default_1(ts2, sys, host, createLanguageService2) {
        return (0, _5_0_1.default)(ts2, sys, host, createLanguageService2, project_1.createProject);
      }
      exports3.default = default_1;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_5/moduleSpecifierCache.js
  var require_moduleSpecifierCache4 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_5/moduleSpecifierCache.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createModuleSpecifierCache = void 0;
      function createModuleSpecifierCache() {
        let containedNodeModulesWatchers;
        let cache;
        let currentKey;
        const result = {
          get(fromFileName, toFileName, preferences, options) {
            if (!cache || currentKey !== key(fromFileName, preferences, options))
              return void 0;
            return cache.get(toFileName);
          },
          set(fromFileName, toFileName, preferences, options, kind, modulePaths, moduleSpecifiers) {
            ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(
              kind,
              modulePaths,
              moduleSpecifiers,
              /*isBlockedByPackageJsonDependencies*/
              false
            ));
            if (moduleSpecifiers) {
              for (const p of modulePaths) {
                if (p.isInNodeModules) {
                }
              }
            }
          },
          setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
            const cache2 = ensureCache(fromFileName, preferences, options);
            const info = cache2.get(toFileName);
            if (info) {
              info.modulePaths = modulePaths;
            } else {
              cache2.set(toFileName, createInfo(
                /*kind*/
                void 0,
                modulePaths,
                /*moduleSpecifiers*/
                void 0,
                /*isBlockedByPackageJsonDependencies*/
                void 0
              ));
            }
          },
          setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, isBlockedByPackageJsonDependencies) {
            const cache2 = ensureCache(fromFileName, preferences, options);
            const info = cache2.get(toFileName);
            if (info) {
              info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
            } else {
              cache2.set(toFileName, createInfo(
                /*kind*/
                void 0,
                /*modulePaths*/
                void 0,
                /*moduleSpecifiers*/
                void 0,
                isBlockedByPackageJsonDependencies
              ));
            }
          },
          clear() {
            containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.forEach((watcher) => watcher.close());
            cache === null || cache === void 0 ? void 0 : cache.clear();
            containedNodeModulesWatchers === null || containedNodeModulesWatchers === void 0 ? void 0 : containedNodeModulesWatchers.clear();
            currentKey = void 0;
          },
          count() {
            return cache ? cache.size : 0;
          }
        };
        return result;
        function ensureCache(fromFileName, preferences, options) {
          const newKey = key(fromFileName, preferences, options);
          if (cache && currentKey !== newKey) {
            result.clear();
          }
          currentKey = newKey;
          return cache || (cache = /* @__PURE__ */ new Map());
        }
        function key(fromFileName, preferences, options) {
          return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
        }
        function createInfo(kind, modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies) {
          return { kind, modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies };
        }
      }
      exports3.createModuleSpecifierCache = createModuleSpecifierCache;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_5/project.js
  var require_project3 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_5/project.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createProject = void 0;
      var project_1 = require_project2();
      var moduleSpecifierCache_1 = require_moduleSpecifierCache4();
      function createProject(ts2, host, createLanguageService2, options) {
        options.createModuleSpecifierCache = moduleSpecifierCache_1.createModuleSpecifierCache;
        return (0, project_1.createProject)(ts2, host, createLanguageService2, options);
      }
      exports3.createProject = createProject;
    }
  });

  // node_modules/typescript-auto-import-cache/out/5_5/index.js
  var require__6 = __commonJS({
    "node_modules/typescript-auto-import-cache/out/5_5/index.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      var _5_0_1 = require__4();
      var project_1 = require_project3();
      function default_1(ts2, sys, host, createLanguageService2) {
        return (0, _5_0_1.default)(ts2, sys, host, createLanguageService2, project_1.createProject);
      }
      exports3.default = default_1;
    }
  });

  // node_modules/typescript-auto-import-cache/out/index.js
  var require_out = __commonJS({
    "node_modules/typescript-auto-import-cache/out/index.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createLanguageService = void 0;
      var semver = require_semver2();
      var _4_0_1 = require__();
      var _4_4_1 = require__2();
      var _4_7_1 = require__3();
      var _5_0_1 = require__4();
      var _5_3_1 = require__5();
      var _5_5_1 = require__6();
      function createLanguageService2(ts2, sys, host, createLanguageService3) {
        if (semver.gte(ts2.version, "5.5.1")) {
          return (0, _5_5_1.default)(ts2, sys, host, createLanguageService3);
        } else if (semver.gte(ts2.version, "5.3.0")) {
          return (0, _5_3_1.default)(ts2, sys, host, createLanguageService3);
        } else if (semver.gte(ts2.version, "5.0.0")) {
          return (0, _5_0_1.default)(ts2, sys, host, createLanguageService3);
        } else if (semver.gte(ts2.version, "4.7.0")) {
          const service = createLanguageService3(host);
          (0, _4_7_1.default)(ts2, host, service);
          return { languageService: service };
        } else if (semver.gte(ts2.version, "4.4.0")) {
          const service = createLanguageService3(host);
          (0, _4_4_1.default)(ts2, host, service);
          return { languageService: service };
        } else if (semver.gte(ts2.version, "4.0.0")) {
          const service = createLanguageService3(host);
          (0, _4_0_1.default)(ts2, host, service);
          return { languageService: service };
        }
        return { languageService: createLanguageService3(host) };
      }
      exports3.createLanguageService = createLanguageService2;
    }
  });

  // node_modules/volar-service-typescript/lib/configs/getUserPreferences.js
  var require_getUserPreferences = __commonJS({
    "node_modules/volar-service-typescript/lib/configs/getUserPreferences.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.getUserPreferences = getUserPreferences;
      var path = require_path_browserify();
      var shared_1 = require_shared();
      var vscode_uri_1 = require_umd();
      async function getUserPreferences(ctx, document5) {
        let currentDirectory = "";
        if (ctx.project.typescript) {
          currentDirectory = ctx.project.typescript.languageServiceHost.getCurrentDirectory();
        }
        const uri = vscode_uri_1.URI.parse(document5.uri);
        const documentUri = ctx.decodeEmbeddedDocumentUri(uri)?.[0] ?? uri;
        const config = await ctx.env.getConfiguration?.((0, shared_1.getConfigTitle)(document5)) ?? {};
        const preferencesConfig = config?.preferences ?? {};
        const preferences = {
          ...config.unstable ?? {},
          quotePreference: getQuoteStylePreference(preferencesConfig),
          importModuleSpecifierPreference: getImportModuleSpecifierPreference(preferencesConfig),
          importModuleSpecifierEnding: getImportModuleSpecifierEndingPreference(preferencesConfig),
          jsxAttributeCompletionStyle: getJsxAttributeCompletionStyle(preferencesConfig),
          allowTextChangesInNewFiles: documentUri.scheme === "file",
          providePrefixAndSuffixTextForRename: (preferencesConfig.renameShorthandProperties ?? true) === false ? false : preferencesConfig.useAliasesForRenames ?? true,
          allowRenameOfImportPath: true,
          includeAutomaticOptionalChainCompletions: config.suggest?.includeAutomaticOptionalChainCompletions ?? true,
          provideRefactorNotApplicableReason: true,
          generateReturnInDocTemplate: config.suggest?.jsdoc?.generateReturns ?? true,
          includeCompletionsForImportStatements: config.suggest?.includeCompletionsForImportStatements ?? true,
          includeCompletionsWithSnippetText: config.suggest?.includeCompletionsWithSnippetText ?? true,
          includeCompletionsWithClassMemberSnippets: config.suggest?.classMemberSnippets?.enabled ?? true,
          includeCompletionsWithObjectLiteralMethodSnippets: config.suggest?.objectLiteralMethodSnippets?.enabled ?? true,
          autoImportFileExcludePatterns: getAutoImportFileExcludePatternsPreference(preferencesConfig, currentDirectory),
          useLabelDetailsInCompletionEntries: true,
          allowIncompleteCompletions: true,
          displayPartsForJSDoc: true,
          // inlay hints
          includeInlayParameterNameHints: getInlayParameterNameHintsPreference(config),
          includeInlayParameterNameHintsWhenArgumentMatchesName: !(config.inlayHints?.parameterNames?.suppressWhenArgumentMatchesName ?? true),
          includeInlayFunctionParameterTypeHints: config.inlayHints?.parameterTypes?.enabled ?? false,
          includeInlayVariableTypeHints: config.inlayHints?.variableTypes?.enabled ?? false,
          includeInlayVariableTypeHintsWhenTypeMatchesName: !(config.inlayHints?.variableTypes?.suppressWhenTypeMatchesName ?? true),
          includeInlayPropertyDeclarationTypeHints: config.inlayHints?.propertyDeclarationTypes?.enabled ?? false,
          includeInlayFunctionLikeReturnTypeHints: config.inlayHints?.functionLikeReturnTypes?.enabled ?? false,
          includeInlayEnumMemberValueHints: config.inlayHints?.enumMemberValues?.enabled ?? false,
          // https://github.com/microsoft/vscode/blob/main/extensions/typescript-language-features/src/languageFeatures/completions.ts#L728-L730
          includeCompletionsForModuleExports: config.suggest?.autoImports ?? true,
          includeCompletionsWithInsertText: true,
          includePackageJsonAutoImports: preferencesConfig.includePackageJsonAutoImports ?? "auto"
        };
        return preferences;
      }
      function getQuoteStylePreference(config) {
        switch (config.quoteStyle) {
          case "single":
            return "single";
          case "double":
            return "double";
          default:
            return "auto";
        }
      }
      function getAutoImportFileExcludePatternsPreference(config, workspacePath) {
        return workspacePath && config.autoImportFileExcludePatterns?.map((p) => {
          const slashNormalized = p.replace(/\\/g, "/");
          const isRelative = /^\.\.?($|\/)/.test(slashNormalized);
          return path.isAbsolute(p) ? p : p.startsWith("*") ? "/" + slashNormalized : isRelative ? path.join(workspacePath, p) : "/**/" + slashNormalized;
        });
      }
      function getImportModuleSpecifierPreference(config) {
        switch (config.importModuleSpecifier) {
          case "project-relative":
            return "project-relative";
          case "relative":
            return "relative";
          case "non-relative":
            return "non-relative";
          default:
            return void 0;
        }
      }
      function getImportModuleSpecifierEndingPreference(config) {
        switch (config.importModuleSpecifierEnding) {
          case "minimal":
            return "minimal";
          case "index":
            return "index";
          case "js":
            return "js";
          default:
            return "minimal";
        }
      }
      function getJsxAttributeCompletionStyle(config) {
        switch (config.jsxAttributeCompletionStyle) {
          case "braces":
            return "braces";
          case "none":
            return "none";
          default:
            return "auto";
        }
      }
      function getInlayParameterNameHintsPreference(config) {
        switch (config.inlayHints?.parameterNames?.enabled) {
          case "none":
            return "none";
          case "literals":
            return "literals";
          case "all":
            return "all";
          default:
            return void 0;
        }
      }
    }
  });

  // node_modules/volar-service-typescript/lib/utils/fixNames.js
  var require_fixNames = __commonJS({
    "node_modules/volar-service-typescript/lib/utils/fixNames.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.addMissingOverride = exports3.addMissingAwait = exports3.fixImport = exports3.spelling = exports3.forgottenThisPropertyAccess = exports3.unusedIdentifier = exports3.unreachableCode = exports3.classDoesntImplementInheritedAbstractMember = exports3.classIncorrectlyImplementsInterface = exports3.awaitInSyncFunction = exports3.extendsInterfaceBecomesImplements = exports3.constructorForDerivedNeedSuperCall = exports3.annotateWithTypeFromJSDoc = void 0;
      exports3.annotateWithTypeFromJSDoc = "annotateWithTypeFromJSDoc";
      exports3.constructorForDerivedNeedSuperCall = "constructorForDerivedNeedSuperCall";
      exports3.extendsInterfaceBecomesImplements = "extendsInterfaceBecomesImplements";
      exports3.awaitInSyncFunction = "fixAwaitInSyncFunction";
      exports3.classIncorrectlyImplementsInterface = "fixClassIncorrectlyImplementsInterface";
      exports3.classDoesntImplementInheritedAbstractMember = "fixClassDoesntImplementInheritedAbstractMember";
      exports3.unreachableCode = "fixUnreachableCode";
      exports3.unusedIdentifier = "unusedIdentifier";
      exports3.forgottenThisPropertyAccess = "forgottenThisPropertyAccess";
      exports3.spelling = "spelling";
      exports3.fixImport = "import";
      exports3.addMissingAwait = "addMissingAwait";
      exports3.addMissingOverride = "fixOverrideModifier";
    }
  });

  // node_modules/volar-service-typescript/lib/semanticFeatures/codeActionResolve.js
  var require_codeActionResolve = __commonJS({
    "node_modules/volar-service-typescript/lib/semanticFeatures/codeActionResolve.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      exports3.resolveFixAllCodeAction = resolveFixAllCodeAction;
      exports3.resolveRefactorCodeAction = resolveRefactorCodeAction;
      exports3.resolveOrganizeImportsCodeAction = resolveOrganizeImportsCodeAction;
      var getFormatCodeSettings_1 = require_getFormatCodeSettings();
      var getUserPreferences_1 = require_getUserPreferences();
      var shared_1 = require_shared();
      var lspConverters_1 = require_lspConverters();
      var vscode_uri_1 = require_umd();
      function register2(ctx) {
        return async (codeAction, formattingOptions) => {
          const data2 = codeAction.data;
          const document5 = ctx.getTextDocument(vscode_uri_1.URI.parse(data2.uri));
          const [formatOptions, preferences] = await Promise.all([
            (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document5, formattingOptions),
            (0, getUserPreferences_1.getUserPreferences)(ctx, document5)
          ]);
          if (data2?.type === "fixAll") {
            resolveFixAllCodeAction(ctx, codeAction, data2, formatOptions, preferences);
          } else if (data2?.type === "refactor") {
            resolveRefactorCodeAction(ctx, codeAction, data2, document5, formatOptions, preferences);
          } else if (data2?.type === "organizeImports") {
            resolveOrganizeImportsCodeAction(ctx, codeAction, data2, formatOptions, preferences);
          }
          return codeAction;
        };
      }
      function resolveFixAllCodeAction(ctx, codeAction, data2, formatOptions, preferences) {
        const fixes = data2.fixIds.map((fixId) => (0, shared_1.safeCall)(() => ctx.languageService.getCombinedCodeFix({ type: "file", fileName: data2.fileName }, fixId, formatOptions, preferences)));
        const changes = fixes.map((fix) => fix?.changes ?? []).flat();
        codeAction.edit = (0, lspConverters_1.convertFileTextChanges)(changes, ctx.fileNameToUri, ctx.getTextDocument);
      }
      function resolveRefactorCodeAction(ctx, codeAction, data2, document5, formatOptions, preferences) {
        const editInfo = (0, shared_1.safeCall)(() => ctx.languageService.getEditsForRefactor(data2.fileName, formatOptions, data2.range, data2.refactorName, data2.actionName, preferences));
        if (!editInfo) {
          return;
        }
        codeAction.edit = (0, lspConverters_1.convertFileTextChanges)(editInfo.edits, ctx.fileNameToUri, ctx.getTextDocument);
        if (editInfo.renameLocation !== void 0 && editInfo.renameFilename !== void 0) {
          codeAction.command = ctx.commands.rename.create(document5.uri, document5.positionAt(editInfo.renameLocation));
        }
      }
      function resolveOrganizeImportsCodeAction(ctx, codeAction, data2, formatOptions, preferences) {
        const changes = (0, shared_1.safeCall)(() => ctx.languageService.organizeImports({ type: "file", fileName: data2.fileName }, formatOptions, preferences));
        codeAction.edit = (0, lspConverters_1.convertFileTextChanges)(changes ?? [], ctx.fileNameToUri, ctx.getTextDocument);
      }
    }
  });

  // node_modules/volar-service-typescript/lib/semanticFeatures/codeAction.js
  var require_codeAction = __commonJS({
    "node_modules/volar-service-typescript/lib/semanticFeatures/codeAction.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var getFormatCodeSettings_1 = require_getFormatCodeSettings();
      var getUserPreferences_1 = require_getUserPreferences();
      var shared_1 = require_shared();
      var fixNames = require_fixNames();
      var lspConverters_1 = require_lspConverters();
      var codeActionResolve_1 = require_codeActionResolve();
      var renameCommandRefactors = /* @__PURE__ */ new Set([
        "refactor.rewrite.property.generateAccessors",
        "refactor.extract.type",
        "refactor.extract.interface",
        "refactor.extract.typedef",
        "refactor.extract.constant",
        "refactor.extract.function"
      ]);
      function register2(ctx) {
        let resolveCommandSupport = ctx.env.clientCapabilities?.textDocument?.codeAction?.resolveSupport?.properties?.includes("command");
        let resolveEditSupport = ctx.env.clientCapabilities?.textDocument?.codeAction?.resolveSupport?.properties?.includes("edit");
        let loged = false;
        const wranUnsupportResolve = () => {
          if (loged) {
            return;
          }
          loged = true;
          console.warn("[volar-service-typescript] The language client lacks support for the command/edit properties in the resolve code action. Therefore, the code action resolve is pre-calculated.");
        };
        if (!ctx.env.clientCapabilities) {
          resolveCommandSupport = true;
          resolveEditSupport = true;
        }
        return async (uri, document5, range, context, formattingOptions) => {
          const [formatOptions, preferences] = await Promise.all([
            (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document5, formattingOptions),
            (0, getUserPreferences_1.getUserPreferences)(ctx, document5)
          ]);
          const fileName = ctx.uriToFileName(uri);
          const start2 = document5.offsetAt(range.start);
          const end = document5.offsetAt(range.end);
          let result = [];
          const onlyQuickFix = matchOnlyKind(`${"quickfix"}.ts`);
          if (!context.only || onlyQuickFix) {
            for (const error of context.diagnostics) {
              const codeFixes = (0, shared_1.safeCall)(() => ctx.languageService.getCodeFixesAtPosition(fileName, document5.offsetAt(error.range.start), document5.offsetAt(error.range.end), [Number(error.code)], formatOptions, preferences)) ?? [];
              for (const codeFix of codeFixes) {
                result = result.concat(convertCodeFixAction(codeFix, [error], onlyQuickFix ?? ""));
              }
            }
          }
          if (context.only) {
            for (const only of context.only) {
              if (only.split(".")[0] === "refactor") {
                const refactors = (0, shared_1.safeCall)(() => ctx.languageService.getApplicableRefactors(fileName, { pos: start2, end }, preferences, void 0, only)) ?? [];
                for (const refactor of refactors) {
                  result = result.concat(convertApplicableRefactorInfo(refactor));
                }
              }
            }
          } else {
            const refactors = (0, shared_1.safeCall)(() => ctx.languageService.getApplicableRefactors(fileName, { pos: start2, end }, preferences, void 0, void 0)) ?? [];
            for (const refactor of refactors) {
              result = result.concat(convertApplicableRefactorInfo(refactor));
            }
          }
          const onlySourceOrganizeImports = matchOnlyKind(`${"source.organizeImports"}.ts`);
          if (onlySourceOrganizeImports) {
            const action = {
              title: "Organize Imports",
              kind: onlySourceOrganizeImports
            };
            const data2 = {
              type: "organizeImports",
              uri: document5.uri,
              fileName
            };
            if (resolveEditSupport) {
              action.data = data2;
            } else {
              wranUnsupportResolve();
              (0, codeActionResolve_1.resolveOrganizeImportsCodeAction)(ctx, action, data2, formatOptions, preferences);
            }
            result.push(action);
          }
          const onlySourceFixAll = matchOnlyKind(`${"source.fixAll"}.ts`);
          if (onlySourceFixAll) {
            const action = {
              title: "Fix All",
              kind: onlySourceFixAll
            };
            const data2 = {
              uri: document5.uri,
              type: "fixAll",
              fileName,
              fixIds: [
                fixNames.classIncorrectlyImplementsInterface,
                fixNames.awaitInSyncFunction,
                fixNames.unreachableCode
              ]
            };
            if (resolveEditSupport) {
              action.data = data2;
            } else {
              wranUnsupportResolve();
              (0, codeActionResolve_1.resolveFixAllCodeAction)(ctx, action, data2, formatOptions, preferences);
            }
            result.push(action);
          }
          const onlyRemoveUnused = matchOnlyKind(`${"source"}.removeUnused.ts`);
          if (onlyRemoveUnused) {
            const action = {
              title: "Remove all unused code",
              kind: onlyRemoveUnused
            };
            const data2 = {
              uri: document5.uri,
              type: "fixAll",
              fileName,
              fixIds: [
                // not working and throw
                fixNames.unusedIdentifier,
                // TODO: remove patching
                "unusedIdentifier_prefix",
                "unusedIdentifier_deleteImports",
                "unusedIdentifier_delete",
                "unusedIdentifier_infer"
              ]
            };
            if (resolveEditSupport) {
              action.data = data2;
            } else {
              wranUnsupportResolve();
              (0, codeActionResolve_1.resolveFixAllCodeAction)(ctx, action, data2, formatOptions, preferences);
            }
            result.push(action);
          }
          const onlyAddMissingImports = matchOnlyKind(`${"source"}.addMissingImports.ts`);
          if (onlyAddMissingImports) {
            const action = {
              title: "Add all missing imports",
              kind: onlyAddMissingImports
            };
            const data2 = {
              uri: document5.uri,
              type: "fixAll",
              fileName,
              fixIds: [
                // not working and throw
                fixNames.fixImport,
                // TODO: remove patching
                "fixMissingImport"
              ]
            };
            if (resolveEditSupport) {
              action.data = data2;
            } else {
              wranUnsupportResolve();
              (0, codeActionResolve_1.resolveFixAllCodeAction)(ctx, action, data2, formatOptions, preferences);
            }
            result.push(action);
          }
          for (const codeAction of result) {
            if (codeAction.diagnostics === void 0) {
              codeAction.diagnostics = context.diagnostics;
            }
          }
          return result;
          function matchOnlyKind(kind) {
            if (context.only) {
              for (const only of context.only) {
                const a = only.split(".");
                const b = kind.split(".");
                if (a.length <= b.length) {
                  let matchNums = 0;
                  for (let i = 0; i < a.length; i++) {
                    if (a[i] == b[i]) {
                      matchNums++;
                    }
                  }
                  if (matchNums === a.length) {
                    return only;
                  }
                }
              }
            }
          }
          function convertCodeFixAction(codeFix, diagnostics, kind) {
            const edit = (0, lspConverters_1.convertFileTextChanges)(codeFix.changes, ctx.fileNameToUri, ctx.getTextDocument);
            const codeActions = [];
            const fix = {
              title: codeFix.description,
              kind,
              edit
            };
            fix.diagnostics = diagnostics;
            codeActions.push(fix);
            if (codeFix.fixAllDescription && codeFix.fixId) {
              const fixAll = {
                title: codeFix.fixAllDescription,
                kind
              };
              const data2 = {
                uri: document5.uri,
                type: "fixAll",
                fileName,
                fixIds: [codeFix.fixId]
              };
              if (resolveEditSupport) {
                fixAll.data = data2;
              } else {
                wranUnsupportResolve();
                (0, codeActionResolve_1.resolveFixAllCodeAction)(ctx, fixAll, data2, formatOptions, preferences);
              }
              fixAll.diagnostics = diagnostics;
              codeActions.push(fixAll);
            }
            return codeActions;
          }
          function convertApplicableRefactorInfo(refactor) {
            const codeActions = [];
            for (const action of refactor.actions) {
              const codeAction = {
                title: action.description,
                kind: action.kind
              };
              if (action.notApplicableReason) {
                codeAction.disabled = { reason: action.notApplicableReason };
              }
              if (refactor.inlineable) {
                codeAction.isPreferred = true;
              }
              const data2 = {
                uri: document5.uri,
                type: "refactor",
                fileName,
                range: { pos: start2, end },
                refactorName: refactor.name,
                actionName: action.name
              };
              const hasCommand = renameCommandRefactors.has(action.kind);
              if (hasCommand && resolveCommandSupport && resolveEditSupport) {
                codeAction.data = data2;
              } else if (!hasCommand && resolveEditSupport) {
                codeAction.data = data2;
              } else if (!codeAction.disabled) {
                wranUnsupportResolve();
                (0, codeActionResolve_1.resolveRefactorCodeAction)(ctx, codeAction, data2, document5, formatOptions, preferences);
              }
              codeActions.push(codeAction);
            }
            return codeActions;
          }
        };
      }
    }
  });

  // node_modules/volar-service-typescript/lib/semanticFeatures/semanticTokens.js
  var require_semanticTokens = __commonJS({
    "node_modules/volar-service-typescript/lib/semanticFeatures/semanticTokens.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.register = register2;
      var shared_1 = require_shared();
      function register2(ts2, ctx) {
        return (uri, document5, range, legend) => {
          const fileName = ctx.uriToFileName(uri);
          const start2 = range ? document5.offsetAt(range.start) : 0;
          const length = range ? document5.offsetAt(range.end) - start2 : document5.getText().length;
          if (ctx.project.typescript?.languageServiceHost.getCancellationToken?.().isCancellationRequested()) {
            return;
          }
          const response = (0, shared_1.safeCall)(() => ctx.languageService.getEncodedSemanticClassifications(fileName, { start: start2, length }, ts2.SemanticClassificationFormat.TwentyTwenty));
          if (!response) {
            return;
          }
          let tokenModifiersTable = [];
          tokenModifiersTable[
            2
            /* TokenModifier.async */
          ] = 1 << legend.tokenModifiers.indexOf("async");
          tokenModifiersTable[
            0
            /* TokenModifier.declaration */
          ] = 1 << legend.tokenModifiers.indexOf("declaration");
          tokenModifiersTable[
            3
            /* TokenModifier.readonly */
          ] = 1 << legend.tokenModifiers.indexOf("readonly");
          tokenModifiersTable[
            1
            /* TokenModifier.static */
          ] = 1 << legend.tokenModifiers.indexOf("static");
          tokenModifiersTable[
            5
            /* TokenModifier.local */
          ] = 1 << legend.tokenModifiers.indexOf("local");
          tokenModifiersTable[
            4
            /* TokenModifier.defaultLibrary */
          ] = 1 << legend.tokenModifiers.indexOf("defaultLibrary");
          tokenModifiersTable = tokenModifiersTable.map((mod) => Math.max(mod, 0));
          const end = start2 + length;
          const tokenSpan = response.spans;
          const tokens = [];
          let i = 0;
          while (i < tokenSpan.length) {
            const offset2 = tokenSpan[i++];
            if (offset2 >= end) {
              break;
            }
            const length2 = tokenSpan[i++];
            const tsClassification = tokenSpan[i++];
            const tokenType = getTokenTypeFromClassification(tsClassification);
            if (tokenType === void 0) {
              continue;
            }
            const tokenModifiers2 = getTokenModifierFromClassification(tsClassification);
            const startPos = document5.positionAt(offset2);
            const endPos = document5.positionAt(offset2 + length2);
            const serverToken = tsTokenTypeToServerTokenType(tokenType);
            if (serverToken === void 0) {
              continue;
            }
            const serverTokenModifiers = tsTokenModifierToServerTokenModifier(tokenModifiers2);
            for (let line = startPos.line; line <= endPos.line; line++) {
              const startCharacter = line === startPos.line ? startPos.character : 0;
              const endCharacter = line === endPos.line ? endPos.character : docLineLength(document5, line);
              tokens.push([line, startCharacter, endCharacter - startCharacter, serverToken, serverTokenModifiers]);
            }
          }
          return tokens;
          function tsTokenTypeToServerTokenType(tokenType) {
            return legend.tokenTypes.indexOf(tokenTypes[tokenType]);
          }
          function tsTokenModifierToServerTokenModifier(input) {
            let m = 0;
            let i2 = 0;
            while (input) {
              if (input & 1) {
                m |= tokenModifiersTable[i2];
              }
              input = input >> 1;
              i2++;
            }
            return m;
          }
        };
      }
      function docLineLength(document5, line) {
        const currentLineOffset = document5.offsetAt({ line, character: 0 });
        const nextLineOffset = document5.offsetAt({ line: line + 1, character: 0 });
        return nextLineOffset - currentLineOffset;
      }
      function getTokenTypeFromClassification(tsClassification) {
        if (tsClassification > 255) {
          return (tsClassification >> 8) - 1;
        }
        return void 0;
      }
      function getTokenModifierFromClassification(tsClassification) {
        return tsClassification & 255;
      }
      var tokenTypes = [];
      tokenTypes[
        0
        /* TokenType.class */
      ] = "class";
      tokenTypes[
        1
        /* TokenType.enum */
      ] = "enum";
      tokenTypes[
        2
        /* TokenType.interface */
      ] = "interface";
      tokenTypes[
        3
        /* TokenType.namespace */
      ] = "namespace";
      tokenTypes[
        4
        /* TokenType.typeParameter */
      ] = "typeParameter";
      tokenTypes[
        5
        /* TokenType.type */
      ] = "type";
      tokenTypes[
        6
        /* TokenType.parameter */
      ] = "parameter";
      tokenTypes[
        7
        /* TokenType.variable */
      ] = "variable";
      tokenTypes[
        8
        /* TokenType.enumMember */
      ] = "enumMember";
      tokenTypes[
        9
        /* TokenType.property */
      ] = "property";
      tokenTypes[
        10
        /* TokenType.function */
      ] = "function";
      tokenTypes[
        11
        /* TokenType.method */
      ] = "method";
      var tokenModifiers = [];
      tokenModifiers[
        2
        /* TokenModifier.async */
      ] = "async";
      tokenModifiers[
        0
        /* TokenModifier.declaration */
      ] = "declaration";
      tokenModifiers[
        3
        /* TokenModifier.readonly */
      ] = "readonly";
      tokenModifiers[
        1
        /* TokenModifier.static */
      ] = "static";
      tokenModifiers[
        5
        /* TokenModifier.local */
      ] = "local";
      tokenModifiers[
        4
        /* TokenModifier.defaultLibrary */
      ] = "defaultLibrary";
      var tokenTypeMap = [];
      tokenTypeMap[
        11
        /* ExperimentalProtocol.ClassificationType.className */
      ] = 0;
      tokenTypeMap[
        12
        /* ExperimentalProtocol.ClassificationType.enumName */
      ] = 1;
      tokenTypeMap[
        13
        /* ExperimentalProtocol.ClassificationType.interfaceName */
      ] = 2;
      tokenTypeMap[
        14
        /* ExperimentalProtocol.ClassificationType.moduleName */
      ] = 3;
      tokenTypeMap[
        15
        /* ExperimentalProtocol.ClassificationType.typeParameterName */
      ] = 4;
      tokenTypeMap[
        16
        /* ExperimentalProtocol.ClassificationType.typeAliasName */
      ] = 5;
      tokenTypeMap[
        17
        /* ExperimentalProtocol.ClassificationType.parameterName */
      ] = 6;
    }
  });

  // node_modules/volar-service-typescript/lib/utils/snippetForFunctionCall.js
  var require_snippetForFunctionCall = __commonJS({
    "node_modules/volar-service-typescript/lib/utils/snippetForFunctionCall.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.snippetForFunctionCall = snippetForFunctionCall;
      var PConst = require_protocol_const();
      function snippetForFunctionCall(item, displayParts) {
        if (item.insertText && typeof item.insertText !== "string") {
          return { snippet: item.insertText, parameterCount: 0 };
        }
        let _tabstop = 1;
        const parameterListParts = getParameterListParts(displayParts);
        let snippet = "";
        snippet += `${item.insertText || item.label}(`;
        snippet = appendJoinedPlaceholders(snippet, parameterListParts.parts, ", ");
        if (parameterListParts.hasOptionalParameters) {
          snippet += "$" + _tabstop++;
        }
        snippet += ")";
        snippet += "$" + _tabstop++;
        return { snippet, parameterCount: parameterListParts.parts.length + (parameterListParts.hasOptionalParameters ? 1 : 0) };
        function appendJoinedPlaceholders(snippet2, parts, joiner) {
          for (let i = 0; i < parts.length; ++i) {
            const paramterPart = parts[i];
            snippet2 += "${" + _tabstop++ + ":" + paramterPart.text + "}";
            if (i !== parts.length - 1) {
              snippet2 += joiner;
            }
          }
          return snippet2;
        }
      }
      function getParameterListParts(displayParts) {
        const parts = [];
        let isInMethod = false;
        let hasOptionalParameters = false;
        let parenCount = 0;
        let braceCount = 0;
        outer: {
          for (let i = 0; i < displayParts.length; ++i) {
            const part = displayParts[i];
            switch (part.kind) {
              case PConst.DisplayPartKind.methodName:
              case PConst.DisplayPartKind.functionName:
              case PConst.DisplayPartKind.text:
              case PConst.DisplayPartKind.propertyName:
                if (parenCount === 0 && braceCount === 0) {
                  isInMethod = true;
                }
                break;
              case PConst.DisplayPartKind.parameterName:
                if (parenCount === 1 && braceCount === 0 && isInMethod) {
                  const next = displayParts[i + 1];
                  const nameIsFollowedByOptionalIndicator = next && next.text === "?";
                  const nameIsThis = part.text === "this";
                  if (!nameIsFollowedByOptionalIndicator && !nameIsThis) {
                    parts.push(part);
                  }
                  hasOptionalParameters = hasOptionalParameters || nameIsFollowedByOptionalIndicator;
                }
                break;
              case PConst.DisplayPartKind.punctuation:
                if (part.text === "(") {
                  ++parenCount;
                } else if (part.text === ")") {
                  --parenCount;
                  if (parenCount <= 0 && isInMethod) {
                    break outer;
                  }
                } else if (part.text === "..." && parenCount === 1) {
                  hasOptionalParameters = true;
                  break outer;
                } else if (part.text === "{") {
                  ++braceCount;
                } else if (part.text === "}") {
                  --braceCount;
                }
                break;
            }
          }
        }
        return { hasOptionalParameters, parts };
      }
    }
  });

  // node_modules/volar-service-typescript/lib/plugins/semantic.js
  var require_semantic = __commonJS({
    "node_modules/volar-service-typescript/lib/plugins/semantic.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.create = create;
      var path = require_path_browserify();
      var semver = require_semver2();
      var tsWithImportCache = require_out();
      var vscode_uri_1 = require_umd();
      var getFormatCodeSettings_1 = require_getFormatCodeSettings();
      var getUserPreferences_1 = require_getUserPreferences();
      var codeActions = require_codeAction();
      var codeActionResolve = require_codeActionResolve();
      var semanticTokens = require_semanticTokens();
      var shared_1 = require_shared();
      var lspConverters_1 = require_lspConverters();
      var snippetForFunctionCall_1 = require_snippetForFunctionCall();
      var documentRegistries = [];
      function getDocumentRegistry(ts2, useCaseSensitiveFileNames, currentDirectory) {
        let documentRegistry = documentRegistries.find((item) => item[0] === useCaseSensitiveFileNames && item[1] === currentDirectory)?.[2];
        if (!documentRegistry) {
          documentRegistry = ts2.createDocumentRegistry(useCaseSensitiveFileNames, currentDirectory);
          documentRegistries.push([useCaseSensitiveFileNames, currentDirectory, documentRegistry]);
        }
        return documentRegistry;
      }
      function create(ts2, { isValidationEnabled = async (document5, context) => {
        return await context.env.getConfiguration?.((0, shared_1.getConfigTitle)(document5) + ".validate.enable") ?? true;
      }, isSuggestionsEnabled = async (document5, context) => {
        return await context.env.getConfiguration?.((0, shared_1.getConfigTitle)(document5) + ".suggest.enabled") ?? true;
      } } = {}) {
        return {
          name: "typescript-semantic",
          capabilities: {
            completionProvider: {
              triggerCharacters: getBasicTriggerCharacters(ts2.version),
              resolveProvider: true
            },
            renameProvider: {
              prepareProvider: true
            },
            fileRenameProvider: true,
            codeActionProvider: {
              codeActionKinds: [
                "",
                "quickfix",
                "refactor",
                "refactor.extract",
                "refactor.inline",
                "refactor.rewrite",
                "source",
                "source.fixAll",
                "source.organizeImports"
              ],
              resolveProvider: true
            },
            inlayHintProvider: {},
            callHierarchyProvider: true,
            definitionProvider: true,
            typeDefinitionProvider: true,
            diagnosticProvider: {},
            hoverProvider: true,
            implementationProvider: true,
            referencesProvider: true,
            fileReferencesProvider: true,
            documentHighlightProvider: true,
            semanticTokensProvider: {
              // https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#standard-token-types-and-modifiers
              legend: {
                tokenTypes: [
                  "namespace",
                  "class",
                  "enum",
                  "interface",
                  "typeParameter",
                  "type",
                  "parameter",
                  "variable",
                  "property",
                  "enumMember",
                  "function",
                  "method"
                ],
                tokenModifiers: [
                  "declaration",
                  "readonly",
                  "static",
                  "async",
                  "defaultLibrary",
                  "local"
                  // additional
                ]
              }
            },
            workspaceSymbolProvider: {},
            signatureHelpProvider: {
              triggerCharacters: ["(", ",", "<"],
              retriggerCharacters: [")"]
            }
          },
          create(context) {
            if (!context.project.typescript) {
              console.warn(`[volar] typescript-semantic requires typescript project.`);
              return {};
            }
            const { sys, languageServiceHost, uriConverter, getExtraServiceScript } = context.project.typescript;
            const created = tsWithImportCache.createLanguageService(ts2, sys, languageServiceHost, (proxiedHost) => ts2.createLanguageService(proxiedHost, getDocumentRegistry(ts2, sys.useCaseSensitiveFileNames, languageServiceHost.getCurrentDirectory())));
            const { languageService } = created;
            const ctx = {
              ...context,
              languageServiceHost,
              languageService,
              uriToFileName(uri) {
                const virtualScript = getVirtualScriptByUri(uri);
                if (virtualScript) {
                  return virtualScript.fileName;
                }
                return uriConverter.asFileName(uri);
              },
              fileNameToUri(fileName) {
                const extraServiceScript = getExtraServiceScript(fileName);
                if (extraServiceScript) {
                  const sourceScript2 = context.language.scripts.fromVirtualCode(extraServiceScript.code);
                  return context.encodeEmbeddedDocumentUri(sourceScript2.id, extraServiceScript.code.id);
                }
                const uri = uriConverter.asUri(fileName);
                const sourceScript = context.language.scripts.get(uri);
                const serviceScript = sourceScript?.generated?.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
                if (sourceScript && serviceScript) {
                  return context.encodeEmbeddedDocumentUri(sourceScript.id, serviceScript.code.id);
                }
                return uri;
              },
              getTextDocument(uri) {
                const decoded = context.decodeEmbeddedDocumentUri(uri);
                if (decoded) {
                  const sourceScript = context.language.scripts.get(decoded[0]);
                  const virtualCode = sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                  if (virtualCode) {
                    return context.documents.get(uri, virtualCode.languageId, virtualCode.snapshot);
                  }
                } else {
                  const sourceFile = context.language.scripts.get(uri);
                  if (sourceFile) {
                    return context.documents.get(uri, sourceFile.languageId, sourceFile.snapshot);
                  }
                }
              }
            };
            const getCodeActions = codeActions.register(ctx);
            const doCodeActionResolve = codeActionResolve.register(ctx);
            const getDocumentSemanticTokens = semanticTokens.register(ts2, ctx);
            const renameInfoOptions = { allowRenameOfImportPath: true };
            let formattingOptions;
            if (created.setPreferences && context.env.getConfiguration) {
              updatePreferences();
              context.env.onDidChangeConfiguration?.(updatePreferences);
              async function updatePreferences() {
                const preferences = await context.env.getConfiguration?.("typescript.preferences");
                if (preferences) {
                  created.setPreferences?.(preferences);
                }
              }
            }
            if (created.projectUpdated) {
              let updateSourceScriptFileNames = function() {
                sourceScriptNames.clear();
                for (const fileName of languageServiceHost.getScriptFileNames()) {
                  const maybeEmbeddedUri = ctx.fileNameToUri(fileName);
                  const decoded = context.decodeEmbeddedDocumentUri(maybeEmbeddedUri);
                  const uri = decoded ? decoded[0] : maybeEmbeddedUri;
                  const sourceScript = context.language.scripts.get(uri);
                  if (sourceScript?.generated) {
                    const tsCode = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
                    if (tsCode) {
                      sourceScriptNames.add(normalizeFileName(fileName));
                    }
                  } else if (sourceScript) {
                    sourceScriptNames.add(normalizeFileName(fileName));
                  }
                }
              };
              const sourceScriptNames = /* @__PURE__ */ new Set();
              const normalizeFileName = sys.useCaseSensitiveFileNames ? (id) => id : (id) => id.toLowerCase();
              updateSourceScriptFileNames();
              context.env.onDidChangeWatchedFiles?.((params) => {
                const someFileCreateOrDeiete = params.changes.some((change) => change.type !== 2);
                if (someFileCreateOrDeiete) {
                  updateSourceScriptFileNames();
                }
                for (const change of params.changes) {
                  const fileName = uriConverter.asFileName(vscode_uri_1.URI.parse(change.uri));
                  if (sourceScriptNames.has(normalizeFileName(fileName))) {
                    created.projectUpdated?.(languageServiceHost.getCurrentDirectory());
                  }
                }
              });
            }
            return {
              provide: {
                "typescript/languageService": () => languageService,
                "typescript/languageServiceHost": () => languageServiceHost,
                "typescript/documentFileName": (uri) => ctx.uriToFileName(uri),
                "typescript/documentUri": (fileName) => ctx.fileNameToUri(fileName)
              },
              dispose() {
                languageService.dispose();
              },
              provideDocumentFormattingEdits(_document, _range, options) {
                formattingOptions = options;
                return void 0;
              },
              provideOnTypeFormattingEdits(_document, _position, _key, options) {
                formattingOptions = options;
                return void 0;
              },
              async provideCompletionItems(document5, position4, completeContext, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (!await isSuggestionsEnabled(document5, context)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const preferences = await (0, getUserPreferences_1.getUserPreferences)(ctx, document5);
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const info = (0, shared_1.safeCall)(() => ctx.languageService.getCompletionsAtPosition(fileName, offset2, {
                  ...preferences,
                  triggerCharacter: completeContext.triggerCharacter,
                  triggerKind: completeContext.triggerKind
                }));
                if (info) {
                  return (0, lspConverters_1.convertCompletionInfo)(ts2, info, document5, position4, (tsEntry) => ({
                    uri: document5.uri,
                    fileName,
                    offset: offset2,
                    originalItem: {
                      name: tsEntry.name,
                      source: tsEntry.source,
                      data: tsEntry.data,
                      labelDetails: tsEntry.labelDetails
                    }
                  }));
                }
              },
              async resolveCompletionItem(item, token) {
                if (await isCancellationRequestedWhileSync(token)) {
                  return item;
                }
                const data2 = item.data;
                if (!data2) {
                  return item;
                }
                const { fileName, offset: offset2 } = data2;
                const uri = vscode_uri_1.URI.parse(data2.uri);
                const document5 = ctx.getTextDocument(uri);
                const [formatOptions, preferences] = await Promise.all([
                  (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document5, formattingOptions),
                  (0, getUserPreferences_1.getUserPreferences)(ctx, document5)
                ]);
                const details = (0, shared_1.safeCall)(() => ctx.languageService.getCompletionEntryDetails(fileName, offset2, data2.originalItem.name, formatOptions, data2.originalItem.source, preferences, data2.originalItem.data));
                if (!details) {
                  return item;
                }
                if (data2.originalItem.labelDetails) {
                  item.labelDetails ??= {};
                  Object.assign(item.labelDetails, data2.originalItem.labelDetails);
                }
                (0, lspConverters_1.applyCompletionEntryDetails)(ts2, item, details, document5, ctx.fileNameToUri, ctx.getTextDocument);
                const useCodeSnippetsOnMethodSuggest = await ctx.env.getConfiguration?.((0, shared_1.getConfigTitle)(document5) + ".suggest.completeFunctionCalls") ?? false;
                const useCodeSnippet = useCodeSnippetsOnMethodSuggest && (item.kind === 3 || item.kind === 2);
                if (useCodeSnippet) {
                  const shouldCompleteFunction = isValidFunctionCompletionContext(ctx.languageService, fileName, offset2, document5);
                  if (shouldCompleteFunction) {
                    const { snippet, parameterCount } = (0, snippetForFunctionCall_1.snippetForFunctionCall)({
                      insertText: item.insertText ?? item.textEdit?.newText,
                      // insertText is dropped by LSP in some case: https://github.com/microsoft/vscode-languageserver-node/blob/9b742021fb04ad081aa3676a9eecf4fa612084b4/client/src/common/codeConverter.ts#L659-L664
                      label: item.label
                    }, details.displayParts);
                    if (item.textEdit) {
                      item.textEdit.newText = snippet;
                    }
                    if (item.insertText) {
                      item.insertText = snippet;
                    }
                    item.insertTextFormat = 2;
                    if (parameterCount > 0) {
                    }
                  }
                }
                return item;
                function isValidFunctionCompletionContext(client, filepath, offset3, document6) {
                  try {
                    const response = client.getQuickInfoAtPosition(filepath, offset3);
                    if (response) {
                      switch (response.kind) {
                        case "var":
                        case "let":
                        case "const":
                        case "alias":
                          return false;
                      }
                    }
                  } catch {
                  }
                  const position4 = document6.positionAt(offset3);
                  const after = (0, lspConverters_1.getLineText)(document6, position4.line).slice(position4.character);
                  return after.match(/^[a-z_$0-9]*\s*\(/gi) === null;
                }
              },
              async provideRenameRange(document5, position4, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const renameInfo = (0, shared_1.safeCall)(() => ctx.languageService.getRenameInfo(fileName, offset2, renameInfoOptions));
                if (!renameInfo) {
                  return;
                }
                if (!renameInfo.canRename) {
                  return { message: renameInfo.localizedErrorMessage };
                }
                return (0, lspConverters_1.convertTextSpan)(renameInfo.triggerSpan, document5);
              },
              async provideRenameEdits(document5, position4, newName, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5, true)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const renameInfo = (0, shared_1.safeCall)(() => ctx.languageService.getRenameInfo(fileName, offset2, renameInfoOptions));
                if (!renameInfo?.canRename) {
                  return;
                }
                if (renameInfo.fileToRename) {
                  const [formatOptions, preferences] = await Promise.all([
                    (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document5, formattingOptions),
                    (0, getUserPreferences_1.getUserPreferences)(ctx, document5)
                  ]);
                  return renameFile(renameInfo.fileToRename, newName, formatOptions, preferences);
                }
                const { providePrefixAndSuffixTextForRename } = await (0, getUserPreferences_1.getUserPreferences)(ctx, document5);
                const entries = ctx.languageService.findRenameLocations(fileName, offset2, false, false, providePrefixAndSuffixTextForRename);
                if (!entries) {
                  return;
                }
                return (0, lspConverters_1.convertRenameLocations)(newName, entries, ctx.fileNameToUri, ctx.getTextDocument);
                function renameFile(fileToRename, newName2, formatOptions, preferences) {
                  if (!path.extname(newName2)) {
                    newName2 += path.extname(fileToRename);
                  }
                  const dirname4 = path.dirname(fileToRename);
                  const newFilePath = path.join(dirname4, newName2);
                  const response = (0, shared_1.safeCall)(() => ctx.languageService.getEditsForFileRename(fileToRename, newFilePath, formatOptions, preferences));
                  if (!response) {
                    return;
                  }
                  const edits = (0, lspConverters_1.convertFileTextChanges)(response, ctx.fileNameToUri, ctx.getTextDocument);
                  if (!edits.documentChanges) {
                    edits.documentChanges = [];
                  }
                  edits.documentChanges.push({
                    kind: "rename",
                    oldUri: ctx.fileNameToUri(fileToRename).toString(),
                    newUri: ctx.fileNameToUri(newFilePath).toString()
                  });
                  return edits;
                }
              },
              async provideCodeActions(document5, range, context2, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                return getCodeActions(uri, document5, range, context2, formattingOptions);
              },
              async resolveCodeAction(codeAction, token) {
                if (await isCancellationRequestedWhileSync(token)) {
                  return codeAction;
                }
                return doCodeActionResolve(codeAction, formattingOptions);
              },
              async provideInlayHints(document5, range, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const preferences = await (0, getUserPreferences_1.getUserPreferences)(ctx, document5);
                const fileName = ctx.uriToFileName(uri);
                const start2 = document5.offsetAt(range.start);
                const end = document5.offsetAt(range.end);
                const inlayHints = (0, shared_1.safeCall)(() => "provideInlayHints" in ctx.languageService ? ctx.languageService.provideInlayHints(fileName, { start: start2, length: end - start2 }, preferences) : []);
                if (!inlayHints) {
                  return [];
                }
                return inlayHints.map((hint) => (0, lspConverters_1.convertInlayHint)(hint, document5));
              },
              async provideCallHierarchyItems(document5, position4, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const calls = (0, shared_1.safeCall)(() => ctx.languageService.prepareCallHierarchy(fileName, offset2));
                if (!calls) {
                  return [];
                }
                const items = Array.isArray(calls) ? calls : [calls];
                return items.map((item) => (0, lspConverters_1.convertCallHierarchyItem)(item, ctx));
              },
              async provideCallHierarchyIncomingCalls(item, token) {
                if (await isCancellationRequestedWhileSync(token)) {
                  return [];
                }
                const uri = vscode_uri_1.URI.parse(item.uri);
                const document5 = ctx.getTextDocument(uri);
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(item.selectionRange.start);
                const calls = (0, shared_1.safeCall)(() => ctx.languageService.provideCallHierarchyIncomingCalls(fileName, offset2));
                if (!calls) {
                  return [];
                }
                const items = Array.isArray(calls) ? calls : [calls];
                return items.map((item2) => (0, lspConverters_1.convertCallHierarchyIncomingCall)(item2, ctx));
              },
              async provideCallHierarchyOutgoingCalls(item, token) {
                if (await isCancellationRequestedWhileSync(token)) {
                  return [];
                }
                const uri = vscode_uri_1.URI.parse(item.uri);
                const document5 = ctx.getTextDocument(uri);
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(item.selectionRange.start);
                const calls = (0, shared_1.safeCall)(() => ctx.languageService.provideCallHierarchyOutgoingCalls(fileName, offset2));
                if (!calls) {
                  return [];
                }
                const items = Array.isArray(calls) ? calls : [calls];
                return items.map((item2) => (0, lspConverters_1.convertCallHierarchyOutgoingCall)(item2, document5, ctx));
              },
              async provideDefinition(document5, position4, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const info = (0, shared_1.safeCall)(() => ctx.languageService.getDefinitionAndBoundSpan(fileName, offset2));
                if (!info) {
                  return [];
                }
                return (0, lspConverters_1.convertDefinitionInfoAndBoundSpan)(info, document5, ctx);
              },
              async provideTypeDefinition(document5, position4, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const entries = (0, shared_1.safeCall)(() => ctx.languageService.getTypeDefinitionAtPosition(fileName, offset2));
                if (!entries) {
                  return [];
                }
                return entries.map((entry) => (0, lspConverters_1.convertDocumentSpantoLocationLink)(entry, ctx));
              },
              provideDiagnostics(document5, token) {
                return provideDiagnosticsWorker(document5, token, "syntactic");
              },
              provideSemanticDiagnostics(document5, token) {
                return provideDiagnosticsWorker(document5, token, "semantic");
              },
              async provideHover(document5, position4, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const info = (0, shared_1.safeCall)(() => ctx.languageService.getQuickInfoAtPosition(fileName, offset2));
                if (!info) {
                  return;
                }
                return (0, lspConverters_1.convertQuickInfo)(ts2, info, document5, ctx.fileNameToUri, ctx.getTextDocument);
              },
              async provideImplementation(document5, position4, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const entries = (0, shared_1.safeCall)(() => ctx.languageService.getImplementationAtPosition(fileName, offset2));
                if (!entries) {
                  return [];
                }
                return entries.map((entry) => (0, lspConverters_1.convertDocumentSpantoLocationLink)(entry, ctx));
              },
              async provideReferences(document5, position4, referenceContext, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5, true)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const references = (0, shared_1.safeCall)(() => ctx.languageService.findReferences(fileName, offset2));
                if (!references) {
                  return [];
                }
                const result = [];
                for (const reference of references) {
                  if (referenceContext.includeDeclaration) {
                    const definition3 = (0, lspConverters_1.convertDocumentSpanToLocation)(reference.definition, ctx);
                    if (definition3) {
                      result.push(definition3);
                    }
                  }
                  for (const referenceEntry of reference.references) {
                    const reference2 = (0, lspConverters_1.convertDocumentSpanToLocation)(referenceEntry, ctx);
                    if (reference2) {
                      result.push(reference2);
                    }
                  }
                }
                return result;
              },
              async provideFileReferences(document5, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5, true)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const entries = (0, shared_1.safeCall)(() => ctx.languageService.getFileReferences(fileName));
                if (!entries) {
                  return [];
                }
                return entries.map((entry) => (0, lspConverters_1.convertDocumentSpanToLocation)(entry, ctx));
              },
              async provideDocumentHighlights(document5, position4, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const highlights = (0, shared_1.safeCall)(() => ctx.languageService.getDocumentHighlights(fileName, offset2, [fileName]));
                if (!highlights) {
                  return [];
                }
                const results = [];
                for (const highlight of highlights) {
                  for (const span of highlight.highlightSpans) {
                    results.push((0, lspConverters_1.convertHighlightSpan)(span, document5));
                  }
                }
                return results;
              },
              async provideDocumentSemanticTokens(document5, range, legend, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                return getDocumentSemanticTokens(uri, document5, range, legend);
              },
              async provideWorkspaceSymbols(query, token) {
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const items = (0, shared_1.safeCall)(() => ctx.languageService.getNavigateToItems(query));
                if (!items) {
                  return [];
                }
                return items.filter((item) => item.containerName || item.kind !== "alias").map((item) => (0, lspConverters_1.convertNavigateToItem)(item, ctx.getTextDocument(ctx.fileNameToUri(item.fileName)))).filter((item) => !!item);
              },
              async provideFileRenameEdits(oldUri, newUri, token) {
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const document5 = ctx.getTextDocument(oldUri);
                const [formatOptions, preferences] = await Promise.all([
                  (0, getFormatCodeSettings_1.getFormatCodeSettings)(ctx, document5, formattingOptions),
                  (0, getUserPreferences_1.getUserPreferences)(ctx, document5)
                ]);
                const fileToRename = ctx.uriToFileName(oldUri);
                const newFilePath = ctx.uriToFileName(newUri);
                const response = (0, shared_1.safeCall)(() => ctx.languageService.getEditsForFileRename(fileToRename, newFilePath, formatOptions, preferences));
                if (!response?.length) {
                  return;
                }
                return (0, lspConverters_1.convertFileTextChanges)(response, ctx.fileNameToUri, ctx.getTextDocument);
              },
              async provideSignatureHelp(document5, position4, context2, token) {
                const uri = vscode_uri_1.URI.parse(document5.uri);
                if (!isSemanticDocument(uri, document5)) {
                  return;
                }
                if (await isCancellationRequestedWhileSync(token)) {
                  return;
                }
                const options = {};
                if (context2?.triggerKind === 1) {
                  options.triggerReason = {
                    kind: "invoked"
                  };
                } else if (context2?.triggerKind === 2) {
                  options.triggerReason = {
                    kind: "characterTyped",
                    triggerCharacter: context2.triggerCharacter
                  };
                } else if (context2?.triggerKind === 3) {
                  options.triggerReason = {
                    kind: "retrigger",
                    triggerCharacter: context2.triggerCharacter
                  };
                }
                const fileName = ctx.uriToFileName(uri);
                const offset2 = document5.offsetAt(position4);
                const helpItems = (0, shared_1.safeCall)(() => ctx.languageService.getSignatureHelpItems(fileName, offset2, options));
                if (!helpItems) {
                  return;
                }
                return {
                  activeSignature: helpItems.selectedItemIndex,
                  activeParameter: helpItems.argumentIndex,
                  signatures: helpItems.items.map((item) => {
                    const signature = {
                      label: "",
                      documentation: void 0,
                      parameters: []
                    };
                    signature.label += ts2.displayPartsToString(item.prefixDisplayParts);
                    item.parameters.forEach((p, i, a) => {
                      const label = ts2.displayPartsToString(p.displayParts);
                      const parameter = {
                        label,
                        documentation: ts2.displayPartsToString(p.documentation)
                      };
                      signature.label += label;
                      signature.parameters.push(parameter);
                      if (i < a.length - 1) {
                        signature.label += ts2.displayPartsToString(item.separatorDisplayParts);
                      }
                    });
                    signature.label += ts2.displayPartsToString(item.suffixDisplayParts);
                    return signature;
                  })
                };
              }
            };
            async function provideDiagnosticsWorker(document5, token, mode) {
              const uri = vscode_uri_1.URI.parse(document5.uri);
              if (!isSemanticDocument(uri, document5)) {
                return;
              }
              if (!await isValidationEnabled(document5, context)) {
                return;
              }
              if (mode === "semantic" && await isCancellationRequestedWhileSync(token)) {
                return;
              }
              const fileName = ctx.uriToFileName(uri);
              const program = ctx.languageService.getProgram();
              const sourceFile = program?.getSourceFile(fileName);
              if (!program || !sourceFile) {
                return [];
              }
              const tsToken = {
                isCancellationRequested() {
                  return ctx.project.typescript?.languageServiceHost.getCancellationToken?.().isCancellationRequested() ?? false;
                },
                throwIfCancellationRequested() {
                }
              };
              if (mode === "syntactic") {
                const syntacticDiagnostics = (0, shared_1.safeCall)(() => program.getSyntacticDiagnostics(sourceFile, tsToken)) ?? [];
                const suggestionDiagnostics = (0, shared_1.safeCall)(() => ctx.languageService.getSuggestionDiagnostics(fileName)) ?? [];
                return [...syntacticDiagnostics, ...suggestionDiagnostics].map((diagnostic) => (0, lspConverters_1.convertDiagnostic)(diagnostic, document5, ctx.fileNameToUri, ctx.getTextDocument)).filter((diagnostic) => !!diagnostic);
              } else if (mode === "semantic") {
                const semanticDiagnostics = (0, shared_1.safeCall)(() => program.getSemanticDiagnostics(sourceFile, tsToken)) ?? [];
                const declarationDiagnostics = getEmitDeclarations(program.getCompilerOptions()) ? (0, shared_1.safeCall)(() => program.getDeclarationDiagnostics(sourceFile, tsToken)) ?? [] : [];
                return [...semanticDiagnostics, ...declarationDiagnostics].map((diagnostic) => (0, lspConverters_1.convertDiagnostic)(diagnostic, document5, ctx.fileNameToUri, ctx.getTextDocument)).filter((diagnostic) => !!diagnostic);
              }
            }
            function getEmitDeclarations(compilerOptions) {
              return !!(compilerOptions.declaration || compilerOptions.composite);
            }
            function isSemanticDocument(uri, document5, withJson = false) {
              const virtualScript = getVirtualScriptByUri(uri);
              if (virtualScript) {
                return true;
              }
              if (withJson && (0, shared_1.isJsonDocument)(document5)) {
                return true;
              }
              return (0, shared_1.isTsDocument)(document5);
            }
            async function isCancellationRequestedWhileSync(token) {
              if (sys.sync) {
                let oldSysVersion;
                let newSysVersion = sys.version;
                do {
                  oldSysVersion = newSysVersion;
                  languageService.getProgram();
                  newSysVersion = await aggressiveSync(sys.sync);
                } while (newSysVersion !== oldSysVersion && !token.isCancellationRequested);
              }
              return token.isCancellationRequested;
            }
            async function aggressiveSync(fn) {
              const promise = fn();
              let newVersion;
              let syncing = true;
              promise.then((version2) => {
                newVersion = version2;
                syncing = false;
              });
              while (syncing) {
                languageService.getProgram();
                await Promise.race([promise, sleep(10)]);
              }
              return newVersion;
            }
            function sleep(ms) {
              return new Promise((resolve3) => setTimeout(resolve3, ms));
            }
            function getVirtualScriptByUri(uri) {
              const decoded = context.decodeEmbeddedDocumentUri(uri);
              const sourceScript = decoded && context.language.scripts.get(decoded[0]);
              const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
              if (virtualCode && sourceScript?.generated?.languagePlugin.typescript) {
                const { getServiceScript, getExtraServiceScripts } = sourceScript.generated?.languagePlugin.typescript;
                const sourceFileName = uriConverter.asFileName(sourceScript.id);
                if (getServiceScript(sourceScript.generated.root)?.code === virtualCode) {
                  return {
                    fileName: sourceFileName,
                    code: virtualCode
                  };
                }
                for (const extraScript of getExtraServiceScripts?.(sourceFileName, sourceScript.generated.root) ?? []) {
                  if (extraScript.code === virtualCode) {
                    return extraScript;
                  }
                }
              }
            }
          }
        };
      }
      function getBasicTriggerCharacters(tsVersion) {
        const triggerCharacters = [".", '"', "'", "`", "/", "<"];
        if (semver.lt(tsVersion, "3.1.0") || semver.gte(tsVersion, "3.2.0")) {
          triggerCharacters.push("@");
        }
        if (semver.gte(tsVersion, "3.8.1")) {
          triggerCharacters.push("#");
        }
        if (semver.gte(tsVersion, "4.3.0")) {
          triggerCharacters.push(" ");
        }
        return triggerCharacters;
      }
    }
  });

  // node_modules/volar-service-typescript/index.js
  var require_volar_service_typescript = __commonJS({
    "node_modules/volar-service-typescript/index.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.create = create;
      var directiveComment_1 = require_directiveComment();
      var docCommentTemplate_1 = require_docCommentTemplate();
      var semantic_1 = require_semantic();
      var syntactic_1 = require_syntactic();
      function create(ts2, options) {
        return [
          (0, semantic_1.create)(ts2, options),
          (0, syntactic_1.create)(ts2, options),
          (0, docCommentTemplate_1.create)(ts2),
          (0, directiveComment_1.create)()
        ];
      }
    }
  });

  // node_modules/@volar/jsdelivr/lib/npm.js
  var require_npm = __commonJS({
    "node_modules/@volar/jsdelivr/lib/npm.js"(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.createNpmFileSystem = createNpmFileSystem2;
      var textCache = /* @__PURE__ */ new Map();
      var jsonCache = /* @__PURE__ */ new Map();
      function createNpmFileSystem2(getCdnPath = (uri) => {
        if (uri.path === "/node_modules") {
          return "";
        } else if (uri.path.startsWith("/node_modules/")) {
          return uri.path.slice("/node_modules".length);
        }
      }, getPackageVersion, onFetch) {
        const fetchResults = /* @__PURE__ */ new Map();
        const flatResults = /* @__PURE__ */ new Map();
        return {
          async stat(uri) {
            const path = getCdnPath(uri);
            if (path === void 0) {
              return;
            }
            if (path === "") {
              return {
                type: 2,
                size: -1,
                ctime: -1,
                mtime: -1
              };
            }
            return await _stat(path);
          },
          async readFile(uri) {
            const path = getCdnPath(uri);
            if (path === void 0) {
              return;
            }
            return await _readFile(path);
          },
          readDirectory(uri) {
            const path = getCdnPath(uri);
            if (path === void 0) {
              return [];
            }
            return _readDirectory(path);
          }
        };
        async function _stat(path) {
          const [modName, pkgName, pkgVersion, pkgFilePath] = resolvePackageName(path);
          if (!pkgName) {
            if (modName.startsWith("@")) {
              return {
                type: 2,
                ctime: -1,
                mtime: -1,
                size: -1
              };
            } else {
              return;
            }
          }
          if (!await isValidPackageName(pkgName)) {
            return;
          }
          if (!pkgFilePath) {
            return {
              type: 2,
              ctime: -1,
              mtime: -1,
              size: -1
            };
          }
          if (!flatResults.has(modName)) {
            flatResults.set(modName, flat(pkgName, pkgVersion));
          }
          const flatResult = await flatResults.get(modName);
          const filePath = path.slice(modName.length);
          const file = flatResult.find((file2) => file2.name === filePath);
          if (file) {
            return {
              type: 1,
              ctime: new Date(file.time).valueOf(),
              mtime: new Date(file.time).valueOf(),
              size: file.size
            };
          } else if (flatResult.some((file2) => file2.name.startsWith(filePath + "/"))) {
            return {
              type: 2,
              ctime: -1,
              mtime: -1,
              size: -1
            };
          }
        }
        async function _readDirectory(path) {
          const [modName, pkgName, pkgVersion] = resolvePackageName(path);
          if (!pkgName || !await isValidPackageName(pkgName)) {
            return [];
          }
          if (!flatResults.has(modName)) {
            flatResults.set(modName, flat(pkgName, pkgVersion));
          }
          const flatResult = await flatResults.get(modName);
          const dirPath = path.slice(modName.length);
          const files = flatResult.filter((f) => f.name.substring(0, f.name.lastIndexOf("/")) === dirPath).map((f) => f.name.slice(dirPath.length + 1));
          const dirs = flatResult.filter((f) => f.name.startsWith(dirPath + "/") && f.name.substring(dirPath.length + 1).split("/").length >= 2).map((f) => f.name.slice(dirPath.length + 1).split("/")[0]);
          return [
            ...files.map((f) => [f, 1]),
            ...[...new Set(dirs)].map((f) => [f, 2])
          ];
        }
        async function _readFile(path) {
          const [_modName, pkgName] = resolvePackageName(path);
          if (!pkgName || !await isValidPackageName(pkgName)) {
            return;
          }
          if (!fetchResults.has(path)) {
            fetchResults.set(path, (async () => {
              if ((await _stat(path))?.type !== 1) {
                return;
              }
              const text4 = await fetchText(`https://cdn.jsdelivr.net/npm/${path}`);
              if (text4 !== void 0) {
                onFetch?.(path, text4);
              }
              return text4;
            })());
          }
          return await fetchResults.get(path);
        }
        async function flat(pkgName, version2) {
          version2 ??= "latest";
          if (version2 === "latest") {
            const data2 = await fetchJson(`https://data.jsdelivr.com/v1/package/resolve/npm/${pkgName}@${version2}`);
            if (!data2?.version) {
              return [];
            }
            version2 = data2.version;
          }
          const flat2 = await fetchJson(`https://data.jsdelivr.com/v1/package/npm/${pkgName}@${version2}/flat`);
          if (!flat2) {
            return [];
          }
          return flat2.files;
        }
        async function isValidPackageName(pkgName) {
          if (pkgName.endsWith("/node_modules")) {
            return false;
          }
          if (pkgName.startsWith("@typescript/") || pkgName.startsWith("@types/typescript__")) {
            return false;
          }
          if (pkgName.startsWith("@types/")) {
            let originalPkgName = pkgName.slice("@types/".length);
            if (originalPkgName.indexOf("__") >= 0) {
              originalPkgName = "@" + originalPkgName.replace("__", "/");
            }
            const packageJson = await _readFile(`${originalPkgName}/package.json`);
            if (packageJson) {
              const packageJsonObj = JSON.parse(packageJson);
              if (packageJsonObj.types || packageJsonObj.typings) {
                return false;
              }
              const indexDts = await _stat(`${originalPkgName}/index.d.ts`);
              if (indexDts?.type === 1) {
                return false;
              }
            }
          }
          return true;
        }
        function resolvePackageName(input) {
          const parts = input.split("/");
          let modName = parts[0];
          let path;
          if (modName.startsWith("@")) {
            if (!parts[1]) {
              return [modName, void 0, void 0, ""];
            }
            modName += "/" + parts[1];
            path = parts.slice(2).join("/");
          } else {
            path = parts.slice(1).join("/");
          }
          let pkgName = modName;
          let version2;
          if (modName.lastIndexOf("@") >= 1) {
            pkgName = modName.substring(0, modName.lastIndexOf("@"));
            version2 = modName.substring(modName.lastIndexOf("@") + 1);
          }
          if (!version2 && getPackageVersion) {
            getPackageVersion?.(pkgName);
          }
          return [modName, pkgName, version2, path];
        }
      }
      async function fetchText(url) {
        if (!textCache.has(url)) {
          textCache.set(url, (async () => {
            try {
              const res = await fetch(url);
              if (res.status === 200) {
                return await res.text();
              }
            } catch {
            }
          })());
        }
        return await textCache.get(url);
      }
      async function fetchJson(url) {
        if (!jsonCache.has(url)) {
          jsonCache.set(url, (async () => {
            try {
              const res = await fetch(url);
              if (res.status === 200) {
                return await res.json();
              }
            } catch {
            }
          })());
        }
        return await jsonCache.get(url);
      }
    }
  });

  // node_modules/@volar/jsdelivr/index.js
  var require_jsdelivr = __commonJS({
    "node_modules/@volar/jsdelivr/index.js"(exports3) {
      "use strict";
      var __createBinding = exports3 && exports3.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports3 && exports3.__exportStar || function(m, exports4) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p))
            __createBinding(exports4, m, p);
      };
      Object.defineProperty(exports3, "__esModule", { value: true });
      __exportStar(require_npm(), exports3);
    }
  });

  // node_modules/acorn-jsx/xhtml.js
  var require_xhtml = __commonJS({
    "node_modules/acorn-jsx/xhtml.js"(exports3, module) {
      module.exports = {
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        "int": "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
      };
    }
  });

  // node_modules/acorn/dist/acorn.js
  var require_acorn = __commonJS({
    "node_modules/acorn/dist/acorn.js"(exports3, module) {
      (function(global2, factory) {
        typeof exports3 === "object" && typeof module !== "undefined" ? factory(exports3) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
      })(exports3, function(exports4) {
        "use strict";
        var astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        var astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
        var nonASCIIidentifierChars2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
        var nonASCIIidentifierStartChars2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
        var reservedWords2 = {
          3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
          5: "class enum extends super const export import",
          6: "enum",
          strict: "implements interface let package private protected public static yield",
          strictBind: "eval arguments"
        };
        var ecma5AndLessKeywords2 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
        var keywords$12 = {
          5: ecma5AndLessKeywords2,
          "5module": ecma5AndLessKeywords2 + " export import",
          6: ecma5AndLessKeywords2 + " const class extends export import super"
        };
        var keywordRelationalOperator2 = /^in(stanceof)?$/;
        var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
        var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
        function isInAstralSet2(code2, set) {
          var pos = 65536;
          for (var i2 = 0; i2 < set.length; i2 += 2) {
            pos += set[i2];
            if (pos > code2) {
              return false;
            }
            pos += set[i2 + 1];
            if (pos >= code2) {
              return true;
            }
          }
          return false;
        }
        function isIdentifierStart2(code2, astral) {
          if (code2 < 65) {
            return code2 === 36;
          }
          if (code2 < 91) {
            return true;
          }
          if (code2 < 97) {
            return code2 === 95;
          }
          if (code2 < 123) {
            return true;
          }
          if (code2 <= 65535) {
            return code2 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code2));
          }
          if (astral === false) {
            return false;
          }
          return isInAstralSet2(code2, astralIdentifierStartCodes2);
        }
        function isIdentifierChar2(code2, astral) {
          if (code2 < 48) {
            return code2 === 36;
          }
          if (code2 < 58) {
            return true;
          }
          if (code2 < 65) {
            return false;
          }
          if (code2 < 91) {
            return true;
          }
          if (code2 < 97) {
            return code2 === 95;
          }
          if (code2 < 123) {
            return true;
          }
          if (code2 <= 65535) {
            return code2 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code2));
          }
          if (astral === false) {
            return false;
          }
          return isInAstralSet2(code2, astralIdentifierStartCodes2) || isInAstralSet2(code2, astralIdentifierCodes2);
        }
        var TokenType3 = function TokenType4(label, conf) {
          if (conf === void 0)
            conf = {};
          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop || null;
          this.updateContext = null;
        };
        function binop2(name2, prec) {
          return new TokenType3(name2, { beforeExpr: true, binop: prec });
        }
        var beforeExpr2 = { beforeExpr: true }, startsExpr2 = { startsExpr: true };
        var keywords2 = {};
        function kw2(name2, options) {
          if (options === void 0)
            options = {};
          options.keyword = name2;
          return keywords2[name2] = new TokenType3(name2, options);
        }
        var types$12 = {
          num: new TokenType3("num", startsExpr2),
          regexp: new TokenType3("regexp", startsExpr2),
          string: new TokenType3("string", startsExpr2),
          name: new TokenType3("name", startsExpr2),
          privateId: new TokenType3("privateId", startsExpr2),
          eof: new TokenType3("eof"),
          // Punctuation token types.
          bracketL: new TokenType3("[", { beforeExpr: true, startsExpr: true }),
          bracketR: new TokenType3("]"),
          braceL: new TokenType3("{", { beforeExpr: true, startsExpr: true }),
          braceR: new TokenType3("}"),
          parenL: new TokenType3("(", { beforeExpr: true, startsExpr: true }),
          parenR: new TokenType3(")"),
          comma: new TokenType3(",", beforeExpr2),
          semi: new TokenType3(";", beforeExpr2),
          colon: new TokenType3(":", beforeExpr2),
          dot: new TokenType3("."),
          question: new TokenType3("?", beforeExpr2),
          questionDot: new TokenType3("?."),
          arrow: new TokenType3("=>", beforeExpr2),
          template: new TokenType3("template"),
          invalidTemplate: new TokenType3("invalidTemplate"),
          ellipsis: new TokenType3("...", beforeExpr2),
          backQuote: new TokenType3("`", startsExpr2),
          dollarBraceL: new TokenType3("${", { beforeExpr: true, startsExpr: true }),
          // Operators. These carry several kinds of properties to help the
          // parser use them properly (the presence of these properties is
          // what categorizes them as operators).
          //
          // `binop`, when present, specifies that this operator is a binary
          // operator, and will refer to its precedence.
          //
          // `prefix` and `postfix` mark the operator as a prefix or postfix
          // unary operator.
          //
          // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
          // binary operators with a very low precedence, that should result
          // in AssignmentExpression nodes.
          eq: new TokenType3("=", { beforeExpr: true, isAssign: true }),
          assign: new TokenType3("_=", { beforeExpr: true, isAssign: true }),
          incDec: new TokenType3("++/--", { prefix: true, postfix: true, startsExpr: true }),
          prefix: new TokenType3("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
          logicalOR: binop2("||", 1),
          logicalAND: binop2("&&", 2),
          bitwiseOR: binop2("|", 3),
          bitwiseXOR: binop2("^", 4),
          bitwiseAND: binop2("&", 5),
          equality: binop2("==/!=/===/!==", 6),
          relational: binop2("</>/<=/>=", 7),
          bitShift: binop2("<</>>/>>>", 8),
          plusMin: new TokenType3("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
          modulo: binop2("%", 10),
          star: binop2("*", 10),
          slash: binop2("/", 10),
          starstar: new TokenType3("**", { beforeExpr: true }),
          coalesce: binop2("??", 1),
          // Keyword token types.
          _break: kw2("break"),
          _case: kw2("case", beforeExpr2),
          _catch: kw2("catch"),
          _continue: kw2("continue"),
          _debugger: kw2("debugger"),
          _default: kw2("default", beforeExpr2),
          _do: kw2("do", { isLoop: true, beforeExpr: true }),
          _else: kw2("else", beforeExpr2),
          _finally: kw2("finally"),
          _for: kw2("for", { isLoop: true }),
          _function: kw2("function", startsExpr2),
          _if: kw2("if"),
          _return: kw2("return", beforeExpr2),
          _switch: kw2("switch"),
          _throw: kw2("throw", beforeExpr2),
          _try: kw2("try"),
          _var: kw2("var"),
          _const: kw2("const"),
          _while: kw2("while", { isLoop: true }),
          _with: kw2("with"),
          _new: kw2("new", { beforeExpr: true, startsExpr: true }),
          _this: kw2("this", startsExpr2),
          _super: kw2("super", startsExpr2),
          _class: kw2("class", startsExpr2),
          _extends: kw2("extends", beforeExpr2),
          _export: kw2("export"),
          _import: kw2("import", startsExpr2),
          _null: kw2("null", startsExpr2),
          _true: kw2("true", startsExpr2),
          _false: kw2("false", startsExpr2),
          _in: kw2("in", { beforeExpr: true, binop: 7 }),
          _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }),
          _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
          _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }),
          _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true })
        };
        var lineBreak2 = /\r\n?|\n|\u2028|\u2029/;
        var lineBreakG2 = new RegExp(lineBreak2.source, "g");
        function isNewLine2(code2) {
          return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
        }
        function nextLineBreak2(code2, from, end) {
          if (end === void 0)
            end = code2.length;
          for (var i2 = from; i2 < end; i2++) {
            var next = code2.charCodeAt(i2);
            if (isNewLine2(next)) {
              return i2 < end - 1 && next === 13 && code2.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
            }
          }
          return -1;
        }
        var nonASCIIwhitespace2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
        var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
        var ref2 = Object.prototype;
        var hasOwnProperty4 = ref2.hasOwnProperty;
        var toString4 = ref2.toString;
        var hasOwn2 = Object.hasOwn || function(obj, propName) {
          return hasOwnProperty4.call(obj, propName);
        };
        var isArray2 = Array.isArray || function(obj) {
          return toString4.call(obj) === "[object Array]";
        };
        var regexpCache2 = /* @__PURE__ */ Object.create(null);
        function wordsRegexp2(words) {
          return regexpCache2[words] || (regexpCache2[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
        }
        function codePointToString2(code2) {
          if (code2 <= 65535) {
            return String.fromCharCode(code2);
          }
          code2 -= 65536;
          return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
        }
        var loneSurrogate2 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
        var Position4 = function Position5(line, col) {
          this.line = line;
          this.column = col;
        };
        Position4.prototype.offset = function offset2(n) {
          return new Position4(this.line, this.column + n);
        };
        var SourceLocation3 = function SourceLocation4(p, start2, end) {
          this.start = start2;
          this.end = end;
          if (p.sourceFile !== null) {
            this.source = p.sourceFile;
          }
        };
        function getLineInfo2(input, offset2) {
          for (var line = 1, cur = 0; ; ) {
            var nextBreak = nextLineBreak2(input, cur, offset2);
            if (nextBreak < 0) {
              return new Position4(line, offset2 - cur);
            }
            ++line;
            cur = nextBreak;
          }
        }
        var defaultOptions2 = {
          // `ecmaVersion` indicates the ECMAScript version to parse. Must be
          // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
          // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
          // (the latest version the library supports). This influences
          // support for strict mode, the set of reserved words, and support
          // for new syntax features.
          ecmaVersion: null,
          // `sourceType` indicates the mode the code should be parsed in.
          // Can be either `"script"` or `"module"`. This influences global
          // strict mode and parsing of `import` and `export` declarations.
          sourceType: "script",
          // `onInsertedSemicolon` can be a callback that will be called when
          // a semicolon is automatically inserted. It will be passed the
          // position of the inserted semicolon as an offset, and if
          // `locations` is enabled, it is given the location as a `{line,
          // column}` object as second argument.
          onInsertedSemicolon: null,
          // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
          // trailing commas.
          onTrailingComma: null,
          // By default, reserved words are only enforced if ecmaVersion >= 5.
          // Set `allowReserved` to a boolean value to explicitly turn this on
          // an off. When this option has the value "never", reserved words
          // and keywords can also not be used as property names.
          allowReserved: null,
          // When enabled, a return at the top level is not considered an
          // error.
          allowReturnOutsideFunction: false,
          // When enabled, import/export statements are not constrained to
          // appearing at the top of the program, and an import.meta expression
          // in a script isn't considered an error.
          allowImportExportEverywhere: false,
          // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
          // When enabled, await identifiers are allowed to appear at the top-level scope,
          // but they are still not allowed in non-async functions.
          allowAwaitOutsideFunction: null,
          // When enabled, super identifiers are not constrained to
          // appearing in methods and do not raise an error when they appear elsewhere.
          allowSuperOutsideMethod: null,
          // When enabled, hashbang directive in the beginning of file is
          // allowed and treated as a line comment. Enabled by default when
          // `ecmaVersion` >= 2023.
          allowHashBang: false,
          // By default, the parser will verify that private properties are
          // only used in places where they are valid and have been declared.
          // Set this to false to turn such checks off.
          checkPrivateFields: true,
          // When `locations` is on, `loc` properties holding objects with
          // `start` and `end` properties in `{line, column}` form (with
          // line being 1-based and column 0-based) will be attached to the
          // nodes.
          locations: false,
          // A function can be passed as `onToken` option, which will
          // cause Acorn to call that function with object in the same
          // format as tokens returned from `tokenizer().getToken()`. Note
          // that you are not allowed to call the parser from the
          // callback—that will corrupt its internal state.
          onToken: null,
          // A function can be passed as `onComment` option, which will
          // cause Acorn to call that function with `(block, text, start,
          // end)` parameters whenever a comment is skipped. `block` is a
          // boolean indicating whether this is a block (`/* */`) comment,
          // `text` is the content of the comment, and `start` and `end` are
          // character offsets that denote the start and end of the comment.
          // When the `locations` option is on, two more parameters are
          // passed, the full `{line, column}` locations of the start and
          // end of the comments. Note that you are not allowed to call the
          // parser from the callback—that will corrupt its internal state.
          // When this option has an array as value, objects representing the
          // comments are pushed to it.
          onComment: null,
          // Nodes have their start and end characters offsets recorded in
          // `start` and `end` properties (directly on the node, rather than
          // the `loc` object, which holds line/column data. To also add a
          // [semi-standardized][range] `range` property holding a `[start,
          // end]` array with the same numbers, set the `ranges` option to
          // `true`.
          //
          // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
          ranges: false,
          // It is possible to parse multiple files into a single AST by
          // passing the tree produced by parsing the first file as
          // `program` option in subsequent parses. This will add the
          // toplevel forms of the parsed file to the `Program` (top) node
          // of an existing parse tree.
          program: null,
          // When `locations` is on, you can pass this to record the source
          // file in every node's `loc` object.
          sourceFile: null,
          // This value, if given, is stored in every node, whether
          // `locations` is on or off.
          directSourceFile: null,
          // When enabled, parenthesized expressions are represented by
          // (non-standard) ParenthesizedExpression nodes
          preserveParens: false
        };
        var warnedAboutEcmaVersion2 = false;
        function getOptions2(opts) {
          var options = {};
          for (var opt in defaultOptions2) {
            options[opt] = opts && hasOwn2(opts, opt) ? opts[opt] : defaultOptions2[opt];
          }
          if (options.ecmaVersion === "latest") {
            options.ecmaVersion = 1e8;
          } else if (options.ecmaVersion == null) {
            if (!warnedAboutEcmaVersion2 && typeof console === "object" && console.warn) {
              warnedAboutEcmaVersion2 = true;
              console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
            }
            options.ecmaVersion = 11;
          } else if (options.ecmaVersion >= 2015) {
            options.ecmaVersion -= 2009;
          }
          if (options.allowReserved == null) {
            options.allowReserved = options.ecmaVersion < 5;
          }
          if (!opts || opts.allowHashBang == null) {
            options.allowHashBang = options.ecmaVersion >= 14;
          }
          if (isArray2(options.onToken)) {
            var tokens = options.onToken;
            options.onToken = function(token) {
              return tokens.push(token);
            };
          }
          if (isArray2(options.onComment)) {
            options.onComment = pushComment2(options, options.onComment);
          }
          return options;
        }
        function pushComment2(options, array) {
          return function(block, text4, start2, end, startLoc, endLoc) {
            var comment = {
              type: block ? "Block" : "Line",
              value: text4,
              start: start2,
              end
            };
            if (options.locations) {
              comment.loc = new SourceLocation3(this, startLoc, endLoc);
            }
            if (options.ranges) {
              comment.range = [start2, end];
            }
            array.push(comment);
          };
        }
        var SCOPE_TOP2 = 1, SCOPE_FUNCTION2 = 2, SCOPE_ASYNC2 = 4, SCOPE_GENERATOR2 = 8, SCOPE_ARROW2 = 16, SCOPE_SIMPLE_CATCH2 = 32, SCOPE_SUPER2 = 64, SCOPE_DIRECT_SUPER2 = 128, SCOPE_CLASS_STATIC_BLOCK2 = 256, SCOPE_VAR2 = SCOPE_TOP2 | SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2;
        function functionFlags2(async, generator) {
          return SCOPE_FUNCTION2 | (async ? SCOPE_ASYNC2 : 0) | (generator ? SCOPE_GENERATOR2 : 0);
        }
        var BIND_NONE2 = 0, BIND_VAR2 = 1, BIND_LEXICAL2 = 2, BIND_FUNCTION2 = 3, BIND_SIMPLE_CATCH2 = 4, BIND_OUTSIDE2 = 5;
        var Parser3 = function Parser4(options, input, startPos) {
          this.options = options = getOptions2(options);
          this.sourceFile = options.sourceFile;
          this.keywords = wordsRegexp2(keywords$12[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
          var reserved = "";
          if (options.allowReserved !== true) {
            reserved = reservedWords2[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
            if (options.sourceType === "module") {
              reserved += " await";
            }
          }
          this.reservedWords = wordsRegexp2(reserved);
          var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
          this.reservedWordsStrict = wordsRegexp2(reservedStrict);
          this.reservedWordsStrictBind = wordsRegexp2(reservedStrict + " " + reservedWords2.strictBind);
          this.input = String(input);
          this.containsEsc = false;
          if (startPos) {
            this.pos = startPos;
            this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak2).length;
          } else {
            this.pos = this.lineStart = 0;
            this.curLine = 1;
          }
          this.type = types$12.eof;
          this.value = null;
          this.start = this.end = this.pos;
          this.startLoc = this.endLoc = this.curPosition();
          this.lastTokEndLoc = this.lastTokStartLoc = null;
          this.lastTokStart = this.lastTokEnd = this.pos;
          this.context = this.initialContext();
          this.exprAllowed = true;
          this.inModule = options.sourceType === "module";
          this.strict = this.inModule || this.strictDirective(this.pos);
          this.potentialArrowAt = -1;
          this.potentialArrowInForAwait = false;
          this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
          this.labels = [];
          this.undefinedExports = /* @__PURE__ */ Object.create(null);
          if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
            this.skipLineComment(2);
          }
          this.scopeStack = [];
          this.enterScope(SCOPE_TOP2);
          this.regexpState = null;
          this.privateNameStack = [];
        };
        var prototypeAccessors2 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
        Parser3.prototype.parse = function parse6() {
          var node3 = this.options.program || this.startNode();
          this.nextToken();
          return this.parseTopLevel(node3);
        };
        prototypeAccessors2.inFunction.get = function() {
          return (this.currentVarScope().flags & SCOPE_FUNCTION2) > 0;
        };
        prototypeAccessors2.inGenerator.get = function() {
          return (this.currentVarScope().flags & SCOPE_GENERATOR2) > 0 && !this.currentVarScope().inClassFieldInit;
        };
        prototypeAccessors2.inAsync.get = function() {
          return (this.currentVarScope().flags & SCOPE_ASYNC2) > 0 && !this.currentVarScope().inClassFieldInit;
        };
        prototypeAccessors2.canAwait.get = function() {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
            var scope = this.scopeStack[i2];
            if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK2) {
              return false;
            }
            if (scope.flags & SCOPE_FUNCTION2) {
              return (scope.flags & SCOPE_ASYNC2) > 0;
            }
          }
          return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
        };
        prototypeAccessors2.allowSuper.get = function() {
          var ref3 = this.currentThisScope();
          var flags = ref3.flags;
          var inClassFieldInit = ref3.inClassFieldInit;
          return (flags & SCOPE_SUPER2) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
        };
        prototypeAccessors2.allowDirectSuper.get = function() {
          return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER2) > 0;
        };
        prototypeAccessors2.treatFunctionsAsVar.get = function() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        };
        prototypeAccessors2.allowNewDotTarget.get = function() {
          var ref3 = this.currentThisScope();
          var flags = ref3.flags;
          var inClassFieldInit = ref3.inClassFieldInit;
          return (flags & (SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2)) > 0 || inClassFieldInit;
        };
        prototypeAccessors2.inClassStaticBlock.get = function() {
          return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK2) > 0;
        };
        Parser3.extend = function extend3() {
          var plugins = [], len = arguments.length;
          while (len--)
            plugins[len] = arguments[len];
          var cls = this;
          for (var i2 = 0; i2 < plugins.length; i2++) {
            cls = plugins[i2](cls);
          }
          return cls;
        };
        Parser3.parse = function parse6(input, options) {
          return new this(options, input).parse();
        };
        Parser3.parseExpressionAt = function parseExpressionAt3(input, pos, options) {
          var parser = new this(options, input, pos);
          parser.nextToken();
          return parser.parseExpression();
        };
        Parser3.tokenizer = function tokenizer3(input, options) {
          return new this(options, input);
        };
        Object.defineProperties(Parser3.prototype, prototypeAccessors2);
        var pp$92 = Parser3.prototype;
        var literal2 = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
        pp$92.strictDirective = function(start2) {
          if (this.options.ecmaVersion < 5) {
            return false;
          }
          for (; ; ) {
            skipWhiteSpace2.lastIndex = start2;
            start2 += skipWhiteSpace2.exec(this.input)[0].length;
            var match = literal2.exec(this.input.slice(start2));
            if (!match) {
              return false;
            }
            if ((match[1] || match[2]) === "use strict") {
              skipWhiteSpace2.lastIndex = start2 + match[0].length;
              var spaceAfter = skipWhiteSpace2.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
              var next = this.input.charAt(end);
              return next === ";" || next === "}" || lineBreak2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
            }
            start2 += match[0].length;
            skipWhiteSpace2.lastIndex = start2;
            start2 += skipWhiteSpace2.exec(this.input)[0].length;
            if (this.input[start2] === ";") {
              start2++;
            }
          }
        };
        pp$92.eat = function(type) {
          if (this.type === type) {
            this.next();
            return true;
          } else {
            return false;
          }
        };
        pp$92.isContextual = function(name2) {
          return this.type === types$12.name && this.value === name2 && !this.containsEsc;
        };
        pp$92.eatContextual = function(name2) {
          if (!this.isContextual(name2)) {
            return false;
          }
          this.next();
          return true;
        };
        pp$92.expectContextual = function(name2) {
          if (!this.eatContextual(name2)) {
            this.unexpected();
          }
        };
        pp$92.canInsertSemicolon = function() {
          return this.type === types$12.eof || this.type === types$12.braceR || lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
        };
        pp$92.insertSemicolon = function() {
          if (this.canInsertSemicolon()) {
            if (this.options.onInsertedSemicolon) {
              this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
            }
            return true;
          }
        };
        pp$92.semicolon = function() {
          if (!this.eat(types$12.semi) && !this.insertSemicolon()) {
            this.unexpected();
          }
        };
        pp$92.afterTrailingComma = function(tokType, notNext) {
          if (this.type === tokType) {
            if (this.options.onTrailingComma) {
              this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
            }
            if (!notNext) {
              this.next();
            }
            return true;
          }
        };
        pp$92.expect = function(type) {
          this.eat(type) || this.unexpected();
        };
        pp$92.unexpected = function(pos) {
          this.raise(pos != null ? pos : this.start, "Unexpected token");
        };
        var DestructuringErrors3 = function DestructuringErrors4() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
        };
        pp$92.checkPatternErrors = function(refDestructuringErrors, isAssign) {
          if (!refDestructuringErrors) {
            return;
          }
          if (refDestructuringErrors.trailingComma > -1) {
            this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
          }
          var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
          if (parens > -1) {
            this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
          }
        };
        pp$92.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
          if (!refDestructuringErrors) {
            return false;
          }
          var shorthandAssign = refDestructuringErrors.shorthandAssign;
          var doubleProto = refDestructuringErrors.doubleProto;
          if (!andThrow) {
            return shorthandAssign >= 0 || doubleProto >= 0;
          }
          if (shorthandAssign >= 0) {
            this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
          }
          if (doubleProto >= 0) {
            this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
          }
        };
        pp$92.checkYieldAwaitInDefaultParams = function() {
          if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
            this.raise(this.yieldPos, "Yield expression cannot be a default value");
          }
          if (this.awaitPos) {
            this.raise(this.awaitPos, "Await expression cannot be a default value");
          }
        };
        pp$92.isSimpleAssignTarget = function(expr) {
          if (expr.type === "ParenthesizedExpression") {
            return this.isSimpleAssignTarget(expr.expression);
          }
          return expr.type === "Identifier" || expr.type === "MemberExpression";
        };
        var pp$82 = Parser3.prototype;
        pp$82.parseTopLevel = function(node3) {
          var exports5 = /* @__PURE__ */ Object.create(null);
          if (!node3.body) {
            node3.body = [];
          }
          while (this.type !== types$12.eof) {
            var stmt = this.parseStatement(null, true, exports5);
            node3.body.push(stmt);
          }
          if (this.inModule) {
            for (var i2 = 0, list5 = Object.keys(this.undefinedExports); i2 < list5.length; i2 += 1) {
              var name2 = list5[i2];
              this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
            }
          }
          this.adaptDirectivePrologue(node3.body);
          this.next();
          node3.sourceType = this.options.sourceType;
          return this.finishNode(node3, "Program");
        };
        var loopLabel2 = { kind: "loop" }, switchLabel2 = { kind: "switch" };
        pp$82.isLet = function(context) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
            return false;
          }
          skipWhiteSpace2.lastIndex = this.pos;
          var skip = skipWhiteSpace2.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 91 || nextCh === 92) {
            return true;
          }
          if (context) {
            return false;
          }
          if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          if (isIdentifierStart2(nextCh, true)) {
            var pos = next + 1;
            while (isIdentifierChar2(nextCh = this.input.charCodeAt(pos), true)) {
              ++pos;
            }
            if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
              return true;
            }
            var ident = this.input.slice(next, pos);
            if (!keywordRelationalOperator2.test(ident)) {
              return true;
            }
          }
          return false;
        };
        pp$82.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
            return false;
          }
          skipWhiteSpace2.lastIndex = this.pos;
          var skip = skipWhiteSpace2.exec(this.input);
          var next = this.pos + skip[0].length, after;
          return !lineBreak2.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar2(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
        };
        pp$82.parseStatement = function(context, topLevel, exports5) {
          var starttype = this.type, node3 = this.startNode(), kind;
          if (this.isLet(context)) {
            starttype = types$12._var;
            kind = "let";
          }
          switch (starttype) {
            case types$12._break:
            case types$12._continue:
              return this.parseBreakContinueStatement(node3, starttype.keyword);
            case types$12._debugger:
              return this.parseDebuggerStatement(node3);
            case types$12._do:
              return this.parseDoStatement(node3);
            case types$12._for:
              return this.parseForStatement(node3);
            case types$12._function:
              if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
                this.unexpected();
              }
              return this.parseFunctionStatement(node3, false, !context);
            case types$12._class:
              if (context) {
                this.unexpected();
              }
              return this.parseClass(node3, true);
            case types$12._if:
              return this.parseIfStatement(node3);
            case types$12._return:
              return this.parseReturnStatement(node3);
            case types$12._switch:
              return this.parseSwitchStatement(node3);
            case types$12._throw:
              return this.parseThrowStatement(node3);
            case types$12._try:
              return this.parseTryStatement(node3);
            case types$12._const:
            case types$12._var:
              kind = kind || this.value;
              if (context && kind !== "var") {
                this.unexpected();
              }
              return this.parseVarStatement(node3, kind);
            case types$12._while:
              return this.parseWhileStatement(node3);
            case types$12._with:
              return this.parseWithStatement(node3);
            case types$12.braceL:
              return this.parseBlock(true, node3);
            case types$12.semi:
              return this.parseEmptyStatement(node3);
            case types$12._export:
            case types$12._import:
              if (this.options.ecmaVersion > 10 && starttype === types$12._import) {
                skipWhiteSpace2.lastIndex = this.pos;
                var skip = skipWhiteSpace2.exec(this.input);
                var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                if (nextCh === 40 || nextCh === 46) {
                  return this.parseExpressionStatement(node3, this.parseExpression());
                }
              }
              if (!this.options.allowImportExportEverywhere) {
                if (!topLevel) {
                  this.raise(this.start, "'import' and 'export' may only appear at the top level");
                }
                if (!this.inModule) {
                  this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
                }
              }
              return starttype === types$12._import ? this.parseImport(node3) : this.parseExport(node3, exports5);
            default:
              if (this.isAsyncFunction()) {
                if (context) {
                  this.unexpected();
                }
                this.next();
                return this.parseFunctionStatement(node3, true, !context);
              }
              var maybeName = this.value, expr = this.parseExpression();
              if (starttype === types$12.name && expr.type === "Identifier" && this.eat(types$12.colon)) {
                return this.parseLabeledStatement(node3, maybeName, expr, context);
              } else {
                return this.parseExpressionStatement(node3, expr);
              }
          }
        };
        pp$82.parseBreakContinueStatement = function(node3, keyword) {
          var isBreak = keyword === "break";
          this.next();
          if (this.eat(types$12.semi) || this.insertSemicolon()) {
            node3.label = null;
          } else if (this.type !== types$12.name) {
            this.unexpected();
          } else {
            node3.label = this.parseIdent();
            this.semicolon();
          }
          var i2 = 0;
          for (; i2 < this.labels.length; ++i2) {
            var lab = this.labels[i2];
            if (node3.label == null || lab.name === node3.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop")) {
                break;
              }
              if (node3.label && isBreak) {
                break;
              }
            }
          }
          if (i2 === this.labels.length) {
            this.raise(node3.start, "Unsyntactic " + keyword);
          }
          return this.finishNode(node3, isBreak ? "BreakStatement" : "ContinueStatement");
        };
        pp$82.parseDebuggerStatement = function(node3) {
          this.next();
          this.semicolon();
          return this.finishNode(node3, "DebuggerStatement");
        };
        pp$82.parseDoStatement = function(node3) {
          this.next();
          this.labels.push(loopLabel2);
          node3.body = this.parseStatement("do");
          this.labels.pop();
          this.expect(types$12._while);
          node3.test = this.parseParenExpression();
          if (this.options.ecmaVersion >= 6) {
            this.eat(types$12.semi);
          } else {
            this.semicolon();
          }
          return this.finishNode(node3, "DoWhileStatement");
        };
        pp$82.parseForStatement = function(node3) {
          this.next();
          var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
          this.labels.push(loopLabel2);
          this.enterScope(0);
          this.expect(types$12.parenL);
          if (this.type === types$12.semi) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node3, null);
          }
          var isLet = this.isLet();
          if (this.type === types$12._var || this.type === types$12._const || isLet) {
            var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
            this.next();
            this.parseVar(init$1, true, kind);
            this.finishNode(init$1, "VariableDeclaration");
            if ((this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
              if (this.options.ecmaVersion >= 9) {
                if (this.type === types$12._in) {
                  if (awaitAt > -1) {
                    this.unexpected(awaitAt);
                  }
                } else {
                  node3.await = awaitAt > -1;
                }
              }
              return this.parseForIn(node3, init$1);
            }
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node3, init$1);
          }
          var startsWithLet = this.isContextual("let"), isForOf = false;
          var containsEsc = this.containsEsc;
          var refDestructuringErrors = new DestructuringErrors3();
          var initPos = this.start;
          var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
          if (this.type === types$12._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            if (awaitAt > -1) {
              if (this.type === types$12._in) {
                this.unexpected(awaitAt);
              }
              node3.await = true;
            } else if (isForOf && this.options.ecmaVersion >= 8) {
              if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
                this.unexpected();
              } else if (this.options.ecmaVersion >= 9) {
                node3.await = false;
              }
            }
            if (startsWithLet && isForOf) {
              this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
            }
            this.toAssignable(init, false, refDestructuringErrors);
            this.checkLValPattern(init);
            return this.parseForIn(node3, init);
          } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node3, init);
        };
        pp$82.parseFunctionStatement = function(node3, isAsync, declarationPosition) {
          this.next();
          return this.parseFunction(node3, FUNC_STATEMENT2 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT2), false, isAsync);
        };
        pp$82.parseIfStatement = function(node3) {
          this.next();
          node3.test = this.parseParenExpression();
          node3.consequent = this.parseStatement("if");
          node3.alternate = this.eat(types$12._else) ? this.parseStatement("if") : null;
          return this.finishNode(node3, "IfStatement");
        };
        pp$82.parseReturnStatement = function(node3) {
          if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
            this.raise(this.start, "'return' outside of function");
          }
          this.next();
          if (this.eat(types$12.semi) || this.insertSemicolon()) {
            node3.argument = null;
          } else {
            node3.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node3, "ReturnStatement");
        };
        pp$82.parseSwitchStatement = function(node3) {
          this.next();
          node3.discriminant = this.parseParenExpression();
          node3.cases = [];
          this.expect(types$12.braceL);
          this.labels.push(switchLabel2);
          this.enterScope(0);
          var cur;
          for (var sawDefault = false; this.type !== types$12.braceR; ) {
            if (this.type === types$12._case || this.type === types$12._default) {
              var isCase = this.type === types$12._case;
              if (cur) {
                this.finishNode(cur, "SwitchCase");
              }
              node3.cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) {
                  this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
                }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(types$12.colon);
            } else {
              if (!cur) {
                this.unexpected();
              }
              cur.consequent.push(this.parseStatement(null));
            }
          }
          this.exitScope();
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          this.next();
          this.labels.pop();
          return this.finishNode(node3, "SwitchStatement");
        };
        pp$82.parseThrowStatement = function(node3) {
          this.next();
          if (lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) {
            this.raise(this.lastTokEnd, "Illegal newline after throw");
          }
          node3.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node3, "ThrowStatement");
        };
        var empty$12 = [];
        pp$82.parseCatchClauseParam = function() {
          var param = this.parseBindingAtom();
          var simple = param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH2 : 0);
          this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH2 : BIND_LEXICAL2);
          this.expect(types$12.parenR);
          return param;
        };
        pp$82.parseTryStatement = function(node3) {
          this.next();
          node3.block = this.parseBlock();
          node3.handler = null;
          if (this.type === types$12._catch) {
            var clause = this.startNode();
            this.next();
            if (this.eat(types$12.parenL)) {
              clause.param = this.parseCatchClauseParam();
            } else {
              if (this.options.ecmaVersion < 10) {
                this.unexpected();
              }
              clause.param = null;
              this.enterScope(0);
            }
            clause.body = this.parseBlock(false);
            this.exitScope();
            node3.handler = this.finishNode(clause, "CatchClause");
          }
          node3.finalizer = this.eat(types$12._finally) ? this.parseBlock() : null;
          if (!node3.handler && !node3.finalizer) {
            this.raise(node3.start, "Missing catch or finally clause");
          }
          return this.finishNode(node3, "TryStatement");
        };
        pp$82.parseVarStatement = function(node3, kind, allowMissingInitializer) {
          this.next();
          this.parseVar(node3, false, kind, allowMissingInitializer);
          this.semicolon();
          return this.finishNode(node3, "VariableDeclaration");
        };
        pp$82.parseWhileStatement = function(node3) {
          this.next();
          node3.test = this.parseParenExpression();
          this.labels.push(loopLabel2);
          node3.body = this.parseStatement("while");
          this.labels.pop();
          return this.finishNode(node3, "WhileStatement");
        };
        pp$82.parseWithStatement = function(node3) {
          if (this.strict) {
            this.raise(this.start, "'with' in strict mode");
          }
          this.next();
          node3.object = this.parseParenExpression();
          node3.body = this.parseStatement("with");
          return this.finishNode(node3, "WithStatement");
        };
        pp$82.parseEmptyStatement = function(node3) {
          this.next();
          return this.finishNode(node3, "EmptyStatement");
        };
        pp$82.parseLabeledStatement = function(node3, maybeName, expr, context) {
          for (var i$1 = 0, list5 = this.labels; i$1 < list5.length; i$1 += 1) {
            var label = list5[i$1];
            if (label.name === maybeName) {
              this.raise(expr.start, "Label '" + maybeName + "' is already declared");
            }
          }
          var kind = this.type.isLoop ? "loop" : this.type === types$12._switch ? "switch" : null;
          for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
            var label$1 = this.labels[i2];
            if (label$1.statementStart === node3.start) {
              label$1.statementStart = this.start;
              label$1.kind = kind;
            } else {
              break;
            }
          }
          this.labels.push({ name: maybeName, kind, statementStart: this.start });
          node3.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
          this.labels.pop();
          node3.label = expr;
          return this.finishNode(node3, "LabeledStatement");
        };
        pp$82.parseExpressionStatement = function(node3, expr) {
          node3.expression = expr;
          this.semicolon();
          return this.finishNode(node3, "ExpressionStatement");
        };
        pp$82.parseBlock = function(createNewLexicalScope, node3, exitStrict) {
          if (createNewLexicalScope === void 0)
            createNewLexicalScope = true;
          if (node3 === void 0)
            node3 = this.startNode();
          node3.body = [];
          this.expect(types$12.braceL);
          if (createNewLexicalScope) {
            this.enterScope(0);
          }
          while (this.type !== types$12.braceR) {
            var stmt = this.parseStatement(null);
            node3.body.push(stmt);
          }
          if (exitStrict) {
            this.strict = false;
          }
          this.next();
          if (createNewLexicalScope) {
            this.exitScope();
          }
          return this.finishNode(node3, "BlockStatement");
        };
        pp$82.parseFor = function(node3, init) {
          node3.init = init;
          this.expect(types$12.semi);
          node3.test = this.type === types$12.semi ? null : this.parseExpression();
          this.expect(types$12.semi);
          node3.update = this.type === types$12.parenR ? null : this.parseExpression();
          this.expect(types$12.parenR);
          node3.body = this.parseStatement("for");
          this.exitScope();
          this.labels.pop();
          return this.finishNode(node3, "ForStatement");
        };
        pp$82.parseForIn = function(node3, init) {
          var isForIn = this.type === types$12._in;
          this.next();
          if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
            this.raise(
              init.start,
              (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
            );
          }
          node3.left = init;
          node3.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
          this.expect(types$12.parenR);
          node3.body = this.parseStatement("for");
          this.exitScope();
          this.labels.pop();
          return this.finishNode(node3, isForIn ? "ForInStatement" : "ForOfStatement");
        };
        pp$82.parseVar = function(node3, isFor, kind, allowMissingInitializer) {
          node3.declarations = [];
          node3.kind = kind;
          for (; ; ) {
            var decl = this.startNode();
            this.parseVarId(decl, kind);
            if (this.eat(types$12.eq)) {
              decl.init = this.parseMaybeAssign(isFor);
            } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
              this.unexpected();
            } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$12._in || this.isContextual("of")))) {
              this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
            } else {
              decl.init = null;
            }
            node3.declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(types$12.comma)) {
              break;
            }
          }
          return node3;
        };
        pp$82.parseVarId = function(decl, kind) {
          decl.id = this.parseBindingAtom();
          this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR2 : BIND_LEXICAL2, false);
        };
        var FUNC_STATEMENT2 = 1, FUNC_HANGING_STATEMENT2 = 2, FUNC_NULLABLE_ID2 = 4;
        pp$82.parseFunction = function(node3, statement, allowExpressionBody, isAsync, forInit) {
          this.initFunction(node3);
          if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
            if (this.type === types$12.star && statement & FUNC_HANGING_STATEMENT2) {
              this.unexpected();
            }
            node3.generator = this.eat(types$12.star);
          }
          if (this.options.ecmaVersion >= 8) {
            node3.async = !!isAsync;
          }
          if (statement & FUNC_STATEMENT2) {
            node3.id = statement & FUNC_NULLABLE_ID2 && this.type !== types$12.name ? null : this.parseIdent();
            if (node3.id && !(statement & FUNC_HANGING_STATEMENT2)) {
              this.checkLValSimple(node3.id, this.strict || node3.generator || node3.async ? this.treatFunctionsAsVar ? BIND_VAR2 : BIND_LEXICAL2 : BIND_FUNCTION2);
            }
          }
          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          this.enterScope(functionFlags2(node3.async, node3.generator));
          if (!(statement & FUNC_STATEMENT2)) {
            node3.id = this.type === types$12.name ? this.parseIdent() : null;
          }
          this.parseFunctionParams(node3);
          this.parseFunctionBody(node3, allowExpressionBody, false, forInit);
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node3, statement & FUNC_STATEMENT2 ? "FunctionDeclaration" : "FunctionExpression");
        };
        pp$82.parseFunctionParams = function(node3) {
          this.expect(types$12.parenL);
          node3.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
          this.checkYieldAwaitInDefaultParams();
        };
        pp$82.parseClass = function(node3, isStatement) {
          this.next();
          var oldStrict = this.strict;
          this.strict = true;
          this.parseClassId(node3, isStatement);
          this.parseClassSuper(node3);
          var privateNameMap = this.enterClassBody();
          var classBody = this.startNode();
          var hadConstructor = false;
          classBody.body = [];
          this.expect(types$12.braceL);
          while (this.type !== types$12.braceR) {
            var element2 = this.parseClassElement(node3.superClass !== null);
            if (element2) {
              classBody.body.push(element2);
              if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
                if (hadConstructor) {
                  this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
                }
                hadConstructor = true;
              } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element2)) {
                this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
              }
            }
          }
          this.strict = oldStrict;
          this.next();
          node3.body = this.finishNode(classBody, "ClassBody");
          this.exitClassBody();
          return this.finishNode(node3, isStatement ? "ClassDeclaration" : "ClassExpression");
        };
        pp$82.parseClassElement = function(constructorAllowsSuper) {
          if (this.eat(types$12.semi)) {
            return null;
          }
          var ecmaVersion2 = this.options.ecmaVersion;
          var node3 = this.startNode();
          var keyName = "";
          var isGenerator = false;
          var isAsync = false;
          var kind = "method";
          var isStatic = false;
          if (this.eatContextual("static")) {
            if (ecmaVersion2 >= 13 && this.eat(types$12.braceL)) {
              this.parseClassStaticBlock(node3);
              return node3;
            }
            if (this.isClassElementNameStart() || this.type === types$12.star) {
              isStatic = true;
            } else {
              keyName = "static";
            }
          }
          node3.static = isStatic;
          if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
            if ((this.isClassElementNameStart() || this.type === types$12.star) && !this.canInsertSemicolon()) {
              isAsync = true;
            } else {
              keyName = "async";
            }
          }
          if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$12.star)) {
            isGenerator = true;
          }
          if (!keyName && !isAsync && !isGenerator) {
            var lastValue = this.value;
            if (this.eatContextual("get") || this.eatContextual("set")) {
              if (this.isClassElementNameStart()) {
                kind = lastValue;
              } else {
                keyName = lastValue;
              }
            }
          }
          if (keyName) {
            node3.computed = false;
            node3.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
            node3.key.name = keyName;
            this.finishNode(node3.key, "Identifier");
          } else {
            this.parseClassElementName(node3);
          }
          if (ecmaVersion2 < 13 || this.type === types$12.parenL || kind !== "method" || isGenerator || isAsync) {
            var isConstructor = !node3.static && checkKeyName2(node3, "constructor");
            var allowsDirectSuper = isConstructor && constructorAllowsSuper;
            if (isConstructor && kind !== "method") {
              this.raise(node3.key.start, "Constructor can't have get/set modifier");
            }
            node3.kind = isConstructor ? "constructor" : kind;
            this.parseClassMethod(node3, isGenerator, isAsync, allowsDirectSuper);
          } else {
            this.parseClassField(node3);
          }
          return node3;
        };
        pp$82.isClassElementNameStart = function() {
          return this.type === types$12.name || this.type === types$12.privateId || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword;
        };
        pp$82.parseClassElementName = function(element2) {
          if (this.type === types$12.privateId) {
            if (this.value === "constructor") {
              this.raise(this.start, "Classes can't have an element named '#constructor'");
            }
            element2.computed = false;
            element2.key = this.parsePrivateIdent();
          } else {
            this.parsePropertyName(element2);
          }
        };
        pp$82.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
          var key = method.key;
          if (method.kind === "constructor") {
            if (isGenerator) {
              this.raise(key.start, "Constructor can't be a generator");
            }
            if (isAsync) {
              this.raise(key.start, "Constructor can't be an async method");
            }
          } else if (method.static && checkKeyName2(method, "prototype")) {
            this.raise(key.start, "Classes may not have a static property named prototype");
          }
          var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
          if (method.kind === "get" && value.params.length !== 0) {
            this.raiseRecoverable(value.start, "getter should have no params");
          }
          if (method.kind === "set" && value.params.length !== 1) {
            this.raiseRecoverable(value.start, "setter should have exactly one param");
          }
          if (method.kind === "set" && value.params[0].type === "RestElement") {
            this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
          }
          return this.finishNode(method, "MethodDefinition");
        };
        pp$82.parseClassField = function(field) {
          if (checkKeyName2(field, "constructor")) {
            this.raise(field.key.start, "Classes can't have a field named 'constructor'");
          } else if (field.static && checkKeyName2(field, "prototype")) {
            this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
          }
          if (this.eat(types$12.eq)) {
            var scope = this.currentThisScope();
            var inClassFieldInit = scope.inClassFieldInit;
            scope.inClassFieldInit = true;
            field.value = this.parseMaybeAssign();
            scope.inClassFieldInit = inClassFieldInit;
          } else {
            field.value = null;
          }
          this.semicolon();
          return this.finishNode(field, "PropertyDefinition");
        };
        pp$82.parseClassStaticBlock = function(node3) {
          node3.body = [];
          var oldLabels = this.labels;
          this.labels = [];
          this.enterScope(SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_SUPER2);
          while (this.type !== types$12.braceR) {
            var stmt = this.parseStatement(null);
            node3.body.push(stmt);
          }
          this.next();
          this.exitScope();
          this.labels = oldLabels;
          return this.finishNode(node3, "StaticBlock");
        };
        pp$82.parseClassId = function(node3, isStatement) {
          if (this.type === types$12.name) {
            node3.id = this.parseIdent();
            if (isStatement) {
              this.checkLValSimple(node3.id, BIND_LEXICAL2, false);
            }
          } else {
            if (isStatement === true) {
              this.unexpected();
            }
            node3.id = null;
          }
        };
        pp$82.parseClassSuper = function(node3) {
          node3.superClass = this.eat(types$12._extends) ? this.parseExprSubscripts(null, false) : null;
        };
        pp$82.enterClassBody = function() {
          var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
          this.privateNameStack.push(element2);
          return element2.declared;
        };
        pp$82.exitClassBody = function() {
          var ref3 = this.privateNameStack.pop();
          var declared = ref3.declared;
          var used = ref3.used;
          if (!this.options.checkPrivateFields) {
            return;
          }
          var len = this.privateNameStack.length;
          var parent = len === 0 ? null : this.privateNameStack[len - 1];
          for (var i2 = 0; i2 < used.length; ++i2) {
            var id = used[i2];
            if (!hasOwn2(declared, id.name)) {
              if (parent) {
                parent.used.push(id);
              } else {
                this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
              }
            }
          }
        };
        function isPrivateNameConflicted2(privateNameMap, element2) {
          var name2 = element2.key.name;
          var curr = privateNameMap[name2];
          var next = "true";
          if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
            next = (element2.static ? "s" : "i") + element2.kind;
          }
          if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
            privateNameMap[name2] = "true";
            return false;
          } else if (!curr) {
            privateNameMap[name2] = next;
            return false;
          } else {
            return true;
          }
        }
        function checkKeyName2(node3, name2) {
          var computed = node3.computed;
          var key = node3.key;
          return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
        }
        pp$82.parseExportAllDeclaration = function(node3, exports5) {
          if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node3.exported = this.parseModuleExportName();
              this.checkExport(exports5, node3.exported, this.lastTokStart);
            } else {
              node3.exported = null;
            }
          }
          this.expectContextual("from");
          if (this.type !== types$12.string) {
            this.unexpected();
          }
          node3.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node3, "ExportAllDeclaration");
        };
        pp$82.parseExport = function(node3, exports5) {
          this.next();
          if (this.eat(types$12.star)) {
            return this.parseExportAllDeclaration(node3, exports5);
          }
          if (this.eat(types$12._default)) {
            this.checkExport(exports5, "default", this.lastTokStart);
            node3.declaration = this.parseExportDefaultDeclaration();
            return this.finishNode(node3, "ExportDefaultDeclaration");
          }
          if (this.shouldParseExportStatement()) {
            node3.declaration = this.parseExportDeclaration(node3);
            if (node3.declaration.type === "VariableDeclaration") {
              this.checkVariableExport(exports5, node3.declaration.declarations);
            } else {
              this.checkExport(exports5, node3.declaration.id, node3.declaration.id.start);
            }
            node3.specifiers = [];
            node3.source = null;
          } else {
            node3.declaration = null;
            node3.specifiers = this.parseExportSpecifiers(exports5);
            if (this.eatContextual("from")) {
              if (this.type !== types$12.string) {
                this.unexpected();
              }
              node3.source = this.parseExprAtom();
            } else {
              for (var i2 = 0, list5 = node3.specifiers; i2 < list5.length; i2 += 1) {
                var spec = list5[i2];
                this.checkUnreserved(spec.local);
                this.checkLocalExport(spec.local);
                if (spec.local.type === "Literal") {
                  this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
                }
              }
              node3.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node3, "ExportNamedDeclaration");
        };
        pp$82.parseExportDeclaration = function(node3) {
          return this.parseStatement(null);
        };
        pp$82.parseExportDefaultDeclaration = function() {
          var isAsync;
          if (this.type === types$12._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            return this.parseFunction(fNode, FUNC_STATEMENT2 | FUNC_NULLABLE_ID2, false, isAsync);
          } else if (this.type === types$12._class) {
            var cNode = this.startNode();
            return this.parseClass(cNode, "nullableID");
          } else {
            var declaration = this.parseMaybeAssign();
            this.semicolon();
            return declaration;
          }
        };
        pp$82.checkExport = function(exports5, name2, pos) {
          if (!exports5) {
            return;
          }
          if (typeof name2 !== "string") {
            name2 = name2.type === "Identifier" ? name2.name : name2.value;
          }
          if (hasOwn2(exports5, name2)) {
            this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
          }
          exports5[name2] = true;
        };
        pp$82.checkPatternExport = function(exports5, pat) {
          var type = pat.type;
          if (type === "Identifier") {
            this.checkExport(exports5, pat, pat.start);
          } else if (type === "ObjectPattern") {
            for (var i2 = 0, list5 = pat.properties; i2 < list5.length; i2 += 1) {
              var prop = list5[i2];
              this.checkPatternExport(exports5, prop);
            }
          } else if (type === "ArrayPattern") {
            for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
              var elt = list$1[i$1];
              if (elt) {
                this.checkPatternExport(exports5, elt);
              }
            }
          } else if (type === "Property") {
            this.checkPatternExport(exports5, pat.value);
          } else if (type === "AssignmentPattern") {
            this.checkPatternExport(exports5, pat.left);
          } else if (type === "RestElement") {
            this.checkPatternExport(exports5, pat.argument);
          }
        };
        pp$82.checkVariableExport = function(exports5, decls) {
          if (!exports5) {
            return;
          }
          for (var i2 = 0, list5 = decls; i2 < list5.length; i2 += 1) {
            var decl = list5[i2];
            this.checkPatternExport(exports5, decl.id);
          }
        };
        pp$82.shouldParseExportStatement = function() {
          return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
        };
        pp$82.parseExportSpecifier = function(exports5) {
          var node3 = this.startNode();
          node3.local = this.parseModuleExportName();
          node3.exported = this.eatContextual("as") ? this.parseModuleExportName() : node3.local;
          this.checkExport(
            exports5,
            node3.exported,
            node3.exported.start
          );
          return this.finishNode(node3, "ExportSpecifier");
        };
        pp$82.parseExportSpecifiers = function(exports5) {
          var nodes = [], first = true;
          this.expect(types$12.braceL);
          while (!this.eat(types$12.braceR)) {
            if (!first) {
              this.expect(types$12.comma);
              if (this.afterTrailingComma(types$12.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            nodes.push(this.parseExportSpecifier(exports5));
          }
          return nodes;
        };
        pp$82.parseImport = function(node3) {
          this.next();
          if (this.type === types$12.string) {
            node3.specifiers = empty$12;
            node3.source = this.parseExprAtom();
          } else {
            node3.specifiers = this.parseImportSpecifiers();
            this.expectContextual("from");
            node3.source = this.type === types$12.string ? this.parseExprAtom() : this.unexpected();
          }
          this.semicolon();
          return this.finishNode(node3, "ImportDeclaration");
        };
        pp$82.parseImportSpecifier = function() {
          var node3 = this.startNode();
          node3.imported = this.parseModuleExportName();
          if (this.eatContextual("as")) {
            node3.local = this.parseIdent();
          } else {
            this.checkUnreserved(node3.imported);
            node3.local = node3.imported;
          }
          this.checkLValSimple(node3.local, BIND_LEXICAL2);
          return this.finishNode(node3, "ImportSpecifier");
        };
        pp$82.parseImportDefaultSpecifier = function() {
          var node3 = this.startNode();
          node3.local = this.parseIdent();
          this.checkLValSimple(node3.local, BIND_LEXICAL2);
          return this.finishNode(node3, "ImportDefaultSpecifier");
        };
        pp$82.parseImportNamespaceSpecifier = function() {
          var node3 = this.startNode();
          this.next();
          this.expectContextual("as");
          node3.local = this.parseIdent();
          this.checkLValSimple(node3.local, BIND_LEXICAL2);
          return this.finishNode(node3, "ImportNamespaceSpecifier");
        };
        pp$82.parseImportSpecifiers = function() {
          var nodes = [], first = true;
          if (this.type === types$12.name) {
            nodes.push(this.parseImportDefaultSpecifier());
            if (!this.eat(types$12.comma)) {
              return nodes;
            }
          }
          if (this.type === types$12.star) {
            nodes.push(this.parseImportNamespaceSpecifier());
            return nodes;
          }
          this.expect(types$12.braceL);
          while (!this.eat(types$12.braceR)) {
            if (!first) {
              this.expect(types$12.comma);
              if (this.afterTrailingComma(types$12.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            nodes.push(this.parseImportSpecifier());
          }
          return nodes;
        };
        pp$82.parseModuleExportName = function() {
          if (this.options.ecmaVersion >= 13 && this.type === types$12.string) {
            var stringLiteral = this.parseLiteral(this.value);
            if (loneSurrogate2.test(stringLiteral.value)) {
              this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
            }
            return stringLiteral;
          }
          return this.parseIdent(true);
        };
        pp$82.adaptDirectivePrologue = function(statements) {
          for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
            statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
          }
        };
        pp$82.isDirectiveCandidate = function(statement) {
          return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
          (this.input[statement.start] === '"' || this.input[statement.start] === "'");
        };
        var pp$72 = Parser3.prototype;
        pp$72.toAssignable = function(node3, isBinding, refDestructuringErrors) {
          if (this.options.ecmaVersion >= 6 && node3) {
            switch (node3.type) {
              case "Identifier":
                if (this.inAsync && node3.name === "await") {
                  this.raise(node3.start, "Cannot use 'await' as identifier inside an async function");
                }
                break;
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                node3.type = "ObjectPattern";
                if (refDestructuringErrors) {
                  this.checkPatternErrors(refDestructuringErrors, true);
                }
                for (var i2 = 0, list5 = node3.properties; i2 < list5.length; i2 += 1) {
                  var prop = list5[i2];
                  this.toAssignable(prop, isBinding);
                  if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                    this.raise(prop.argument.start, "Unexpected token");
                  }
                }
                break;
              case "Property":
                if (node3.kind !== "init") {
                  this.raise(node3.key.start, "Object pattern can't contain getter or setter");
                }
                this.toAssignable(node3.value, isBinding);
                break;
              case "ArrayExpression":
                node3.type = "ArrayPattern";
                if (refDestructuringErrors) {
                  this.checkPatternErrors(refDestructuringErrors, true);
                }
                this.toAssignableList(node3.elements, isBinding);
                break;
              case "SpreadElement":
                node3.type = "RestElement";
                this.toAssignable(node3.argument, isBinding);
                if (node3.argument.type === "AssignmentPattern") {
                  this.raise(node3.argument.start, "Rest elements cannot have a default value");
                }
                break;
              case "AssignmentExpression":
                if (node3.operator !== "=") {
                  this.raise(node3.left.end, "Only '=' operator can be used for specifying default value.");
                }
                node3.type = "AssignmentPattern";
                delete node3.operator;
                this.toAssignable(node3.left, isBinding);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(node3.expression, isBinding, refDestructuringErrors);
                break;
              case "ChainExpression":
                this.raiseRecoverable(node3.start, "Optional chaining cannot appear in left-hand side");
                break;
              case "MemberExpression":
                if (!isBinding) {
                  break;
                }
              default:
                this.raise(node3.start, "Assigning to rvalue");
            }
          } else if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          return node3;
        };
        pp$72.toAssignableList = function(exprList, isBinding) {
          var end = exprList.length;
          for (var i2 = 0; i2 < end; i2++) {
            var elt = exprList[i2];
            if (elt) {
              this.toAssignable(elt, isBinding);
            }
          }
          if (end) {
            var last = exprList[end - 1];
            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
              this.unexpected(last.argument.start);
            }
          }
          return exprList;
        };
        pp$72.parseSpread = function(refDestructuringErrors) {
          var node3 = this.startNode();
          this.next();
          node3.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          return this.finishNode(node3, "SpreadElement");
        };
        pp$72.parseRestBinding = function() {
          var node3 = this.startNode();
          this.next();
          if (this.options.ecmaVersion === 6 && this.type !== types$12.name) {
            this.unexpected();
          }
          node3.argument = this.parseBindingAtom();
          return this.finishNode(node3, "RestElement");
        };
        pp$72.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6) {
            switch (this.type) {
              case types$12.bracketL:
                var node3 = this.startNode();
                this.next();
                node3.elements = this.parseBindingList(types$12.bracketR, true, true);
                return this.finishNode(node3, "ArrayPattern");
              case types$12.braceL:
                return this.parseObj(true);
            }
          }
          return this.parseIdent();
        };
        pp$72.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
          var elts = [], first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(types$12.comma);
            }
            if (allowEmpty && this.type === types$12.comma) {
              elts.push(null);
            } else if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            } else if (this.type === types$12.ellipsis) {
              var rest = this.parseRestBinding();
              this.parseBindingListItem(rest);
              elts.push(rest);
              if (this.type === types$12.comma) {
                this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
              }
              this.expect(close);
              break;
            } else {
              elts.push(this.parseAssignableListItem(allowModifiers));
            }
          }
          return elts;
        };
        pp$72.parseAssignableListItem = function(allowModifiers) {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          return elem;
        };
        pp$72.parseBindingListItem = function(param) {
          return param;
        };
        pp$72.parseMaybeDefault = function(startPos, startLoc, left) {
          left = left || this.parseBindingAtom();
          if (this.options.ecmaVersion < 6 || !this.eat(types$12.eq)) {
            return left;
          }
          var node3 = this.startNodeAt(startPos, startLoc);
          node3.left = left;
          node3.right = this.parseMaybeAssign();
          return this.finishNode(node3, "AssignmentPattern");
        };
        pp$72.checkLValSimple = function(expr, bindingType, checkClashes) {
          if (bindingType === void 0)
            bindingType = BIND_NONE2;
          var isBind = bindingType !== BIND_NONE2;
          switch (expr.type) {
            case "Identifier":
              if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
                this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
              }
              if (isBind) {
                if (bindingType === BIND_LEXICAL2 && expr.name === "let") {
                  this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
                }
                if (checkClashes) {
                  if (hasOwn2(checkClashes, expr.name)) {
                    this.raiseRecoverable(expr.start, "Argument name clash");
                  }
                  checkClashes[expr.name] = true;
                }
                if (bindingType !== BIND_OUTSIDE2) {
                  this.declareName(expr.name, bindingType, expr.start);
                }
              }
              break;
            case "ChainExpression":
              this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (isBind) {
                this.raiseRecoverable(expr.start, "Binding member expression");
              }
              break;
            case "ParenthesizedExpression":
              if (isBind) {
                this.raiseRecoverable(expr.start, "Binding parenthesized expression");
              }
              return this.checkLValSimple(expr.expression, bindingType, checkClashes);
            default:
              this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
          }
        };
        pp$72.checkLValPattern = function(expr, bindingType, checkClashes) {
          if (bindingType === void 0)
            bindingType = BIND_NONE2;
          switch (expr.type) {
            case "ObjectPattern":
              for (var i2 = 0, list5 = expr.properties; i2 < list5.length; i2 += 1) {
                var prop = list5[i2];
                this.checkLValInnerPattern(prop, bindingType, checkClashes);
              }
              break;
            case "ArrayPattern":
              for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
                var elem = list$1[i$1];
                if (elem) {
                  this.checkLValInnerPattern(elem, bindingType, checkClashes);
                }
              }
              break;
            default:
              this.checkLValSimple(expr, bindingType, checkClashes);
          }
        };
        pp$72.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
          if (bindingType === void 0)
            bindingType = BIND_NONE2;
          switch (expr.type) {
            case "Property":
              this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(expr.left, bindingType, checkClashes);
              break;
            case "RestElement":
              this.checkLValPattern(expr.argument, bindingType, checkClashes);
              break;
            default:
              this.checkLValPattern(expr, bindingType, checkClashes);
          }
        };
        var TokContext3 = function TokContext4(token, isExpr, preserveSpace, override, generator) {
          this.token = token;
          this.isExpr = !!isExpr;
          this.preserveSpace = !!preserveSpace;
          this.override = override;
          this.generator = !!generator;
        };
        var types2 = {
          b_stat: new TokContext3("{", false),
          b_expr: new TokContext3("{", true),
          b_tmpl: new TokContext3("${", false),
          p_stat: new TokContext3("(", false),
          p_expr: new TokContext3("(", true),
          q_tmpl: new TokContext3("`", true, true, function(p) {
            return p.tryReadTemplateToken();
          }),
          f_stat: new TokContext3("function", false),
          f_expr: new TokContext3("function", true),
          f_expr_gen: new TokContext3("function", true, false, null, true),
          f_gen: new TokContext3("function", false, false, null, true)
        };
        var pp$62 = Parser3.prototype;
        pp$62.initialContext = function() {
          return [types2.b_stat];
        };
        pp$62.curContext = function() {
          return this.context[this.context.length - 1];
        };
        pp$62.braceIsBlock = function(prevType) {
          var parent = this.curContext();
          if (parent === types2.f_expr || parent === types2.f_stat) {
            return true;
          }
          if (prevType === types$12.colon && (parent === types2.b_stat || parent === types2.b_expr)) {
            return !parent.isExpr;
          }
          if (prevType === types$12._return || prevType === types$12.name && this.exprAllowed) {
            return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
          }
          if (prevType === types$12._else || prevType === types$12.semi || prevType === types$12.eof || prevType === types$12.parenR || prevType === types$12.arrow) {
            return true;
          }
          if (prevType === types$12.braceL) {
            return parent === types2.b_stat;
          }
          if (prevType === types$12._var || prevType === types$12._const || prevType === types$12.name) {
            return false;
          }
          return !this.exprAllowed;
        };
        pp$62.inGeneratorContext = function() {
          for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
            var context = this.context[i2];
            if (context.token === "function") {
              return context.generator;
            }
          }
          return false;
        };
        pp$62.updateContext = function(prevType) {
          var update, type = this.type;
          if (type.keyword && prevType === types$12.dot) {
            this.exprAllowed = false;
          } else if (update = type.updateContext) {
            update.call(this, prevType);
          } else {
            this.exprAllowed = type.beforeExpr;
          }
        };
        pp$62.overrideContext = function(tokenCtx) {
          if (this.curContext() !== tokenCtx) {
            this.context[this.context.length - 1] = tokenCtx;
          }
        };
        types$12.parenR.updateContext = types$12.braceR.updateContext = function() {
          if (this.context.length === 1) {
            this.exprAllowed = true;
            return;
          }
          var out = this.context.pop();
          if (out === types2.b_stat && this.curContext().token === "function") {
            out = this.context.pop();
          }
          this.exprAllowed = !out.isExpr;
        };
        types$12.braceL.updateContext = function(prevType) {
          this.context.push(this.braceIsBlock(prevType) ? types2.b_stat : types2.b_expr);
          this.exprAllowed = true;
        };
        types$12.dollarBraceL.updateContext = function() {
          this.context.push(types2.b_tmpl);
          this.exprAllowed = true;
        };
        types$12.parenL.updateContext = function(prevType) {
          var statementParens = prevType === types$12._if || prevType === types$12._for || prevType === types$12._with || prevType === types$12._while;
          this.context.push(statementParens ? types2.p_stat : types2.p_expr);
          this.exprAllowed = true;
        };
        types$12.incDec.updateContext = function() {
        };
        types$12._function.updateContext = types$12._class.updateContext = function(prevType) {
          if (prevType.beforeExpr && prevType !== types$12._else && !(prevType === types$12.semi && this.curContext() !== types2.p_stat) && !(prevType === types$12._return && lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$12.colon || prevType === types$12.braceL) && this.curContext() === types2.b_stat)) {
            this.context.push(types2.f_expr);
          } else {
            this.context.push(types2.f_stat);
          }
          this.exprAllowed = false;
        };
        types$12.colon.updateContext = function() {
          if (this.curContext().token === "function") {
            this.context.pop();
          }
          this.exprAllowed = true;
        };
        types$12.backQuote.updateContext = function() {
          if (this.curContext() === types2.q_tmpl) {
            this.context.pop();
          } else {
            this.context.push(types2.q_tmpl);
          }
          this.exprAllowed = false;
        };
        types$12.star.updateContext = function(prevType) {
          if (prevType === types$12._function) {
            var index4 = this.context.length - 1;
            if (this.context[index4] === types2.f_expr) {
              this.context[index4] = types2.f_expr_gen;
            } else {
              this.context[index4] = types2.f_gen;
            }
          }
          this.exprAllowed = true;
        };
        types$12.name.updateContext = function(prevType) {
          var allowed = false;
          if (this.options.ecmaVersion >= 6 && prevType !== types$12.dot) {
            if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
              allowed = true;
            }
          }
          this.exprAllowed = allowed;
        };
        var pp$52 = Parser3.prototype;
        pp$52.checkPropClash = function(prop, propHash, refDestructuringErrors) {
          if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
            return;
          }
          if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
            return;
          }
          var key = prop.key;
          var name2;
          switch (key.type) {
            case "Identifier":
              name2 = key.name;
              break;
            case "Literal":
              name2 = String(key.value);
              break;
            default:
              return;
          }
          var kind = prop.kind;
          if (this.options.ecmaVersion >= 6) {
            if (name2 === "__proto__" && kind === "init") {
              if (propHash.proto) {
                if (refDestructuringErrors) {
                  if (refDestructuringErrors.doubleProto < 0) {
                    refDestructuringErrors.doubleProto = key.start;
                  }
                } else {
                  this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
                }
              }
              propHash.proto = true;
            }
            return;
          }
          name2 = "$" + name2;
          var other = propHash[name2];
          if (other) {
            var redefinition;
            if (kind === "init") {
              redefinition = this.strict && other.init || other.get || other.set;
            } else {
              redefinition = other.init || other[kind];
            }
            if (redefinition) {
              this.raiseRecoverable(key.start, "Redefinition of property");
            }
          } else {
            other = propHash[name2] = {
              init: false,
              get: false,
              set: false
            };
          }
          other[kind] = true;
        };
        pp$52.parseExpression = function(forInit, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
          if (this.type === types$12.comma) {
            var node3 = this.startNodeAt(startPos, startLoc);
            node3.expressions = [expr];
            while (this.eat(types$12.comma)) {
              node3.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
            }
            return this.finishNode(node3, "SequenceExpression");
          }
          return expr;
        };
        pp$52.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
          if (this.isContextual("yield")) {
            if (this.inGenerator) {
              return this.parseYield(forInit);
            } else {
              this.exprAllowed = false;
            }
          }
          var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
          if (refDestructuringErrors) {
            oldParenAssign = refDestructuringErrors.parenthesizedAssign;
            oldTrailingComma = refDestructuringErrors.trailingComma;
            oldDoubleProto = refDestructuringErrors.doubleProto;
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
          } else {
            refDestructuringErrors = new DestructuringErrors3();
            ownDestructuringErrors = true;
          }
          var startPos = this.start, startLoc = this.startLoc;
          if (this.type === types$12.parenL || this.type === types$12.name) {
            this.potentialArrowAt = this.start;
            this.potentialArrowInForAwait = forInit === "await";
          }
          var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
          }
          if (this.type.isAssign) {
            var node3 = this.startNodeAt(startPos, startLoc);
            node3.operator = this.value;
            if (this.type === types$12.eq) {
              left = this.toAssignable(left, false, refDestructuringErrors);
            }
            if (!ownDestructuringErrors) {
              refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
            }
            if (refDestructuringErrors.shorthandAssign >= left.start) {
              refDestructuringErrors.shorthandAssign = -1;
            }
            if (this.type === types$12.eq) {
              this.checkLValPattern(left);
            } else {
              this.checkLValSimple(left);
            }
            node3.left = left;
            this.next();
            node3.right = this.parseMaybeAssign(forInit);
            if (oldDoubleProto > -1) {
              refDestructuringErrors.doubleProto = oldDoubleProto;
            }
            return this.finishNode(node3, "AssignmentExpression");
          } else {
            if (ownDestructuringErrors) {
              this.checkExpressionErrors(refDestructuringErrors, true);
            }
          }
          if (oldParenAssign > -1) {
            refDestructuringErrors.parenthesizedAssign = oldParenAssign;
          }
          if (oldTrailingComma > -1) {
            refDestructuringErrors.trailingComma = oldTrailingComma;
          }
          return left;
        };
        pp$52.parseMaybeConditional = function(forInit, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseExprOps(forInit, refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          if (this.eat(types$12.question)) {
            var node3 = this.startNodeAt(startPos, startLoc);
            node3.test = expr;
            node3.consequent = this.parseMaybeAssign();
            this.expect(types$12.colon);
            node3.alternate = this.parseMaybeAssign(forInit);
            return this.finishNode(node3, "ConditionalExpression");
          }
          return expr;
        };
        pp$52.parseExprOps = function(forInit, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
        };
        pp$52.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
          var prec = this.type.binop;
          if (prec != null && (!forInit || this.type !== types$12._in)) {
            if (prec > minPrec) {
              var logical = this.type === types$12.logicalOR || this.type === types$12.logicalAND;
              var coalesce = this.type === types$12.coalesce;
              if (coalesce) {
                prec = types$12.logicalAND.binop;
              }
              var op = this.value;
              this.next();
              var startPos = this.start, startLoc = this.startLoc;
              var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
              var node3 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
              if (logical && this.type === types$12.coalesce || coalesce && (this.type === types$12.logicalOR || this.type === types$12.logicalAND)) {
                this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
              }
              return this.parseExprOp(node3, leftStartPos, leftStartLoc, minPrec, forInit);
            }
          }
          return left;
        };
        pp$52.buildBinary = function(startPos, startLoc, left, right, op, logical) {
          if (right.type === "PrivateIdentifier") {
            this.raise(right.start, "Private identifier can only be left side of binary expression");
          }
          var node3 = this.startNodeAt(startPos, startLoc);
          node3.left = left;
          node3.operator = op;
          node3.right = right;
          return this.finishNode(node3, logical ? "LogicalExpression" : "BinaryExpression");
        };
        pp$52.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
          var startPos = this.start, startLoc = this.startLoc, expr;
          if (this.isContextual("await") && this.canAwait) {
            expr = this.parseAwait(forInit);
            sawUnary = true;
          } else if (this.type.prefix) {
            var node3 = this.startNode(), update = this.type === types$12.incDec;
            node3.operator = this.value;
            node3.prefix = true;
            this.next();
            node3.argument = this.parseMaybeUnary(null, true, update, forInit);
            this.checkExpressionErrors(refDestructuringErrors, true);
            if (update) {
              this.checkLValSimple(node3.argument);
            } else if (this.strict && node3.operator === "delete" && isLocalVariableAccess2(node3.argument)) {
              this.raiseRecoverable(node3.start, "Deleting local variable in strict mode");
            } else if (node3.operator === "delete" && isPrivateFieldAccess2(node3.argument)) {
              this.raiseRecoverable(node3.start, "Private fields can not be deleted");
            } else {
              sawUnary = true;
            }
            expr = this.finishNode(node3, update ? "UpdateExpression" : "UnaryExpression");
          } else if (!sawUnary && this.type === types$12.privateId) {
            if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
              this.unexpected();
            }
            expr = this.parsePrivateIdent();
            if (this.type !== types$12._in) {
              this.unexpected();
            }
          } else {
            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
            if (this.checkExpressionErrors(refDestructuringErrors)) {
              return expr;
            }
            while (this.type.postfix && !this.canInsertSemicolon()) {
              var node$1 = this.startNodeAt(startPos, startLoc);
              node$1.operator = this.value;
              node$1.prefix = false;
              node$1.argument = expr;
              this.checkLValSimple(expr);
              this.next();
              expr = this.finishNode(node$1, "UpdateExpression");
            }
          }
          if (!incDec && this.eat(types$12.starstar)) {
            if (sawUnary) {
              this.unexpected(this.lastTokStart);
            } else {
              return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
            }
          } else {
            return expr;
          }
        };
        function isLocalVariableAccess2(node3) {
          return node3.type === "Identifier" || node3.type === "ParenthesizedExpression" && isLocalVariableAccess2(node3.expression);
        }
        function isPrivateFieldAccess2(node3) {
          return node3.type === "MemberExpression" && node3.property.type === "PrivateIdentifier" || node3.type === "ChainExpression" && isPrivateFieldAccess2(node3.expression) || node3.type === "ParenthesizedExpression" && isPrivateFieldAccess2(node3.expression);
        }
        pp$52.parseExprSubscripts = function(refDestructuringErrors, forInit) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseExprAtom(refDestructuringErrors, forInit);
          if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
            return expr;
          }
          var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
          if (refDestructuringErrors && result.type === "MemberExpression") {
            if (refDestructuringErrors.parenthesizedAssign >= result.start) {
              refDestructuringErrors.parenthesizedAssign = -1;
            }
            if (refDestructuringErrors.parenthesizedBind >= result.start) {
              refDestructuringErrors.parenthesizedBind = -1;
            }
            if (refDestructuringErrors.trailingComma >= result.start) {
              refDestructuringErrors.trailingComma = -1;
            }
          }
          return result;
        };
        pp$52.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
          var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
          var optionalChained = false;
          while (true) {
            var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
            if (element2.optional) {
              optionalChained = true;
            }
            if (element2 === base || element2.type === "ArrowFunctionExpression") {
              if (optionalChained) {
                var chainNode = this.startNodeAt(startPos, startLoc);
                chainNode.expression = element2;
                element2 = this.finishNode(chainNode, "ChainExpression");
              }
              return element2;
            }
            base = element2;
          }
        };
        pp$52.shouldParseAsyncArrow = function() {
          return !this.canInsertSemicolon() && this.eat(types$12.arrow);
        };
        pp$52.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
        };
        pp$52.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
          var optionalSupported = this.options.ecmaVersion >= 11;
          var optional = optionalSupported && this.eat(types$12.questionDot);
          if (noCalls && optional) {
            this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          }
          var computed = this.eat(types$12.bracketL);
          if (computed || optional && this.type !== types$12.parenL && this.type !== types$12.backQuote || this.eat(types$12.dot)) {
            var node3 = this.startNodeAt(startPos, startLoc);
            node3.object = base;
            if (computed) {
              node3.property = this.parseExpression();
              this.expect(types$12.bracketR);
            } else if (this.type === types$12.privateId && base.type !== "Super") {
              node3.property = this.parsePrivateIdent();
            } else {
              node3.property = this.parseIdent(this.options.allowReserved !== "never");
            }
            node3.computed = !!computed;
            if (optionalSupported) {
              node3.optional = optional;
            }
            base = this.finishNode(node3, "MemberExpression");
          } else if (!noCalls && this.eat(types$12.parenL)) {
            var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
            this.yieldPos = 0;
            this.awaitPos = 0;
            this.awaitIdentPos = 0;
            var exprList = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
            if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
              this.checkPatternErrors(refDestructuringErrors, false);
              this.checkYieldAwaitInDefaultParams();
              if (this.awaitIdentPos > 0) {
                this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
              }
              this.yieldPos = oldYieldPos;
              this.awaitPos = oldAwaitPos;
              this.awaitIdentPos = oldAwaitIdentPos;
              return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.callee = base;
            node$1.arguments = exprList;
            if (optionalSupported) {
              node$1.optional = optional;
            }
            base = this.finishNode(node$1, "CallExpression");
          } else if (this.type === types$12.backQuote) {
            if (optional || optionalChained) {
              this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            }
            var node$2 = this.startNodeAt(startPos, startLoc);
            node$2.tag = base;
            node$2.quasi = this.parseTemplate({ isTagged: true });
            base = this.finishNode(node$2, "TaggedTemplateExpression");
          }
          return base;
        };
        pp$52.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
          if (this.type === types$12.slash) {
            this.readRegexp();
          }
          var node3, canBeArrow = this.potentialArrowAt === this.start;
          switch (this.type) {
            case types$12._super:
              if (!this.allowSuper) {
                this.raise(this.start, "'super' keyword outside a method");
              }
              node3 = this.startNode();
              this.next();
              if (this.type === types$12.parenL && !this.allowDirectSuper) {
                this.raise(node3.start, "super() call outside constructor of a subclass");
              }
              if (this.type !== types$12.dot && this.type !== types$12.bracketL && this.type !== types$12.parenL) {
                this.unexpected();
              }
              return this.finishNode(node3, "Super");
            case types$12._this:
              node3 = this.startNode();
              this.next();
              return this.finishNode(node3, "ThisExpression");
            case types$12.name:
              var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
              var id = this.parseIdent(false);
              if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$12._function)) {
                this.overrideContext(types2.f_expr);
                return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
              }
              if (canBeArrow && !this.canInsertSemicolon()) {
                if (this.eat(types$12.arrow)) {
                  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
                }
                if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$12.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                  id = this.parseIdent(false);
                  if (this.canInsertSemicolon() || !this.eat(types$12.arrow)) {
                    this.unexpected();
                  }
                  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
                }
              }
              return id;
            case types$12.regexp:
              var value = this.value;
              node3 = this.parseLiteral(value.value);
              node3.regex = { pattern: value.pattern, flags: value.flags };
              return node3;
            case types$12.num:
            case types$12.string:
              return this.parseLiteral(this.value);
            case types$12._null:
            case types$12._true:
            case types$12._false:
              node3 = this.startNode();
              node3.value = this.type === types$12._null ? null : this.type === types$12._true;
              node3.raw = this.type.keyword;
              this.next();
              return this.finishNode(node3, "Literal");
            case types$12.parenL:
              var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
              if (refDestructuringErrors) {
                if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                  refDestructuringErrors.parenthesizedAssign = start2;
                }
                if (refDestructuringErrors.parenthesizedBind < 0) {
                  refDestructuringErrors.parenthesizedBind = start2;
                }
              }
              return expr;
            case types$12.bracketL:
              node3 = this.startNode();
              this.next();
              node3.elements = this.parseExprList(types$12.bracketR, true, true, refDestructuringErrors);
              return this.finishNode(node3, "ArrayExpression");
            case types$12.braceL:
              this.overrideContext(types2.b_expr);
              return this.parseObj(false, refDestructuringErrors);
            case types$12._function:
              node3 = this.startNode();
              this.next();
              return this.parseFunction(node3, 0);
            case types$12._class:
              return this.parseClass(this.startNode(), false);
            case types$12._new:
              return this.parseNew();
            case types$12.backQuote:
              return this.parseTemplate();
            case types$12._import:
              if (this.options.ecmaVersion >= 11) {
                return this.parseExprImport(forNew);
              } else {
                return this.unexpected();
              }
            default:
              return this.parseExprAtomDefault();
          }
        };
        pp$52.parseExprAtomDefault = function() {
          this.unexpected();
        };
        pp$52.parseExprImport = function(forNew) {
          var node3 = this.startNode();
          if (this.containsEsc) {
            this.raiseRecoverable(this.start, "Escape sequence in keyword import");
          }
          this.next();
          if (this.type === types$12.parenL && !forNew) {
            return this.parseDynamicImport(node3);
          } else if (this.type === types$12.dot) {
            var meta = this.startNodeAt(node3.start, node3.loc && node3.loc.start);
            meta.name = "import";
            node3.meta = this.finishNode(meta, "Identifier");
            return this.parseImportMeta(node3);
          } else {
            this.unexpected();
          }
        };
        pp$52.parseDynamicImport = function(node3) {
          this.next();
          node3.source = this.parseMaybeAssign();
          if (!this.eat(types$12.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$12.comma) && this.eat(types$12.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
          return this.finishNode(node3, "ImportExpression");
        };
        pp$52.parseImportMeta = function(node3) {
          this.next();
          var containsEsc = this.containsEsc;
          node3.property = this.parseIdent(true);
          if (node3.property.name !== "meta") {
            this.raiseRecoverable(node3.property.start, "The only valid meta property for import is 'import.meta'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node3.start, "'import.meta' must not contain escaped characters");
          }
          if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
            this.raiseRecoverable(node3.start, "Cannot use 'import.meta' outside a module");
          }
          return this.finishNode(node3, "MetaProperty");
        };
        pp$52.parseLiteral = function(value) {
          var node3 = this.startNode();
          node3.value = value;
          node3.raw = this.input.slice(this.start, this.end);
          if (node3.raw.charCodeAt(node3.raw.length - 1) === 110) {
            node3.bigint = node3.raw.slice(0, -1).replace(/_/g, "");
          }
          this.next();
          return this.finishNode(node3, "Literal");
        };
        pp$52.parseParenExpression = function() {
          this.expect(types$12.parenL);
          var val = this.parseExpression();
          this.expect(types$12.parenR);
          return val;
        };
        pp$52.shouldParseArrow = function(exprList) {
          return !this.canInsertSemicolon();
        };
        pp$52.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
          var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var innerStartPos = this.start, innerStartLoc = this.startLoc;
            var exprList = [], first = true, lastIsComma = false;
            var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
            this.yieldPos = 0;
            this.awaitPos = 0;
            while (this.type !== types$12.parenR) {
              first ? first = false : this.expect(types$12.comma);
              if (allowTrailingComma && this.afterTrailingComma(types$12.parenR, true)) {
                lastIsComma = true;
                break;
              } else if (this.type === types$12.ellipsis) {
                spreadStart = this.start;
                exprList.push(this.parseParenItem(this.parseRestBinding()));
                if (this.type === types$12.comma) {
                  this.raiseRecoverable(
                    this.start,
                    "Comma is not permitted after the rest element"
                  );
                }
                break;
              } else {
                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
              }
            }
            var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
            this.expect(types$12.parenR);
            if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$12.arrow)) {
              this.checkPatternErrors(refDestructuringErrors, false);
              this.checkYieldAwaitInDefaultParams();
              this.yieldPos = oldYieldPos;
              this.awaitPos = oldAwaitPos;
              return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
            }
            if (!exprList.length || lastIsComma) {
              this.unexpected(this.lastTokStart);
            }
            if (spreadStart) {
              this.unexpected(spreadStart);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            if (exprList.length > 1) {
              val = this.startNodeAt(innerStartPos, innerStartLoc);
              val.expressions = exprList;
              this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else {
              val = exprList[0];
            }
          } else {
            val = this.parseParenExpression();
          }
          if (this.options.preserveParens) {
            var par = this.startNodeAt(startPos, startLoc);
            par.expression = val;
            return this.finishNode(par, "ParenthesizedExpression");
          } else {
            return val;
          }
        };
        pp$52.parseParenItem = function(item) {
          return item;
        };
        pp$52.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
        };
        var empty4 = [];
        pp$52.parseNew = function() {
          if (this.containsEsc) {
            this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          }
          var node3 = this.startNode();
          this.next();
          if (this.options.ecmaVersion >= 6 && this.type === types$12.dot) {
            var meta = this.startNodeAt(node3.start, node3.loc && node3.loc.start);
            meta.name = "new";
            node3.meta = this.finishNode(meta, "Identifier");
            this.next();
            var containsEsc = this.containsEsc;
            node3.property = this.parseIdent(true);
            if (node3.property.name !== "target") {
              this.raiseRecoverable(node3.property.start, "The only valid meta property for new is 'new.target'");
            }
            if (containsEsc) {
              this.raiseRecoverable(node3.start, "'new.target' must not contain escaped characters");
            }
            if (!this.allowNewDotTarget) {
              this.raiseRecoverable(node3.start, "'new.target' can only be used in functions and class static block");
            }
            return this.finishNode(node3, "MetaProperty");
          }
          var startPos = this.start, startLoc = this.startLoc;
          node3.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
          if (this.eat(types$12.parenL)) {
            node3.arguments = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false);
          } else {
            node3.arguments = empty4;
          }
          return this.finishNode(node3, "NewExpression");
        };
        pp$52.parseTemplateElement = function(ref3) {
          var isTagged = ref3.isTagged;
          var elem = this.startNode();
          if (this.type === types$12.invalidTemplate) {
            if (!isTagged) {
              this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
            }
            elem.value = {
              raw: this.value.replace(/\r\n?/g, "\n"),
              cooked: null
            };
          } else {
            elem.value = {
              raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
              cooked: this.value
            };
          }
          this.next();
          elem.tail = this.type === types$12.backQuote;
          return this.finishNode(elem, "TemplateElement");
        };
        pp$52.parseTemplate = function(ref3) {
          if (ref3 === void 0)
            ref3 = {};
          var isTagged = ref3.isTagged;
          if (isTagged === void 0)
            isTagged = false;
          var node3 = this.startNode();
          this.next();
          node3.expressions = [];
          var curElt = this.parseTemplateElement({ isTagged });
          node3.quasis = [curElt];
          while (!curElt.tail) {
            if (this.type === types$12.eof) {
              this.raise(this.pos, "Unterminated template literal");
            }
            this.expect(types$12.dollarBraceL);
            node3.expressions.push(this.parseExpression());
            this.expect(types$12.braceR);
            node3.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
          }
          this.next();
          return this.finishNode(node3, "TemplateLiteral");
        };
        pp$52.isAsyncProp = function(prop) {
          return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$12.name || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$12.star) && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
        };
        pp$52.parseObj = function(isPattern, refDestructuringErrors) {
          var node3 = this.startNode(), first = true, propHash = {};
          node3.properties = [];
          this.next();
          while (!this.eat(types$12.braceR)) {
            if (!first) {
              this.expect(types$12.comma);
              if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$12.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            var prop = this.parseProperty(isPattern, refDestructuringErrors);
            if (!isPattern) {
              this.checkPropClash(prop, propHash, refDestructuringErrors);
            }
            node3.properties.push(prop);
          }
          return this.finishNode(node3, isPattern ? "ObjectPattern" : "ObjectExpression");
        };
        pp$52.parseProperty = function(isPattern, refDestructuringErrors) {
          var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
          if (this.options.ecmaVersion >= 9 && this.eat(types$12.ellipsis)) {
            if (isPattern) {
              prop.argument = this.parseIdent(false);
              if (this.type === types$12.comma) {
                this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
              }
              return this.finishNode(prop, "RestElement");
            }
            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
            if (this.type === types$12.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
            return this.finishNode(prop, "SpreadElement");
          }
          if (this.options.ecmaVersion >= 6) {
            prop.method = false;
            prop.shorthand = false;
            if (isPattern || refDestructuringErrors) {
              startPos = this.start;
              startLoc = this.startLoc;
            }
            if (!isPattern) {
              isGenerator = this.eat(types$12.star);
            }
          }
          var containsEsc = this.containsEsc;
          this.parsePropertyName(prop);
          if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$12.star);
            this.parsePropertyName(prop);
          } else {
            isAsync = false;
          }
          this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
          return this.finishNode(prop, "Property");
        };
        pp$52.parseGetterSetter = function(prop) {
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start2 = prop.value.start;
            if (prop.kind === "get") {
              this.raiseRecoverable(start2, "getter should have no params");
            } else {
              this.raiseRecoverable(start2, "setter should have exactly one param");
            }
          } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
              this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
            }
          }
        };
        pp$52.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
          if ((isGenerator || isAsync) && this.type === types$12.colon) {
            this.unexpected();
          }
          if (this.eat(types$12.colon)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
            prop.kind = "init";
          } else if (this.options.ecmaVersion >= 6 && this.type === types$12.parenL) {
            if (isPattern) {
              this.unexpected();
            }
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator, isAsync);
          } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$12.comma && this.type !== types$12.braceR && this.type !== types$12.eq)) {
            if (isGenerator || isAsync) {
              this.unexpected();
            }
            this.parseGetterSetter(prop);
          } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            if (isGenerator || isAsync) {
              this.unexpected();
            }
            this.checkUnreserved(prop.key);
            if (prop.key.name === "await" && !this.awaitIdentPos) {
              this.awaitIdentPos = startPos;
            }
            prop.kind = "init";
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else if (this.type === types$12.eq && refDestructuringErrors) {
              if (refDestructuringErrors.shorthandAssign < 0) {
                refDestructuringErrors.shorthandAssign = this.start;
              }
              prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else {
              prop.value = this.copyNode(prop.key);
            }
            prop.shorthand = true;
          } else {
            this.unexpected();
          }
        };
        pp$52.parsePropertyName = function(prop) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(types$12.bracketL)) {
              prop.computed = true;
              prop.key = this.parseMaybeAssign();
              this.expect(types$12.bracketR);
              return prop.key;
            } else {
              prop.computed = false;
            }
          }
          return prop.key = this.type === types$12.num || this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        };
        pp$52.initFunction = function(node3) {
          node3.id = null;
          if (this.options.ecmaVersion >= 6) {
            node3.generator = node3.expression = false;
          }
          if (this.options.ecmaVersion >= 8) {
            node3.async = false;
          }
        };
        pp$52.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
          var node3 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.initFunction(node3);
          if (this.options.ecmaVersion >= 6) {
            node3.generator = isGenerator;
          }
          if (this.options.ecmaVersion >= 8) {
            node3.async = !!isAsync;
          }
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          this.enterScope(functionFlags2(isAsync, node3.generator) | SCOPE_SUPER2 | (allowDirectSuper ? SCOPE_DIRECT_SUPER2 : 0));
          this.expect(types$12.parenL);
          node3.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
          this.checkYieldAwaitInDefaultParams();
          this.parseFunctionBody(node3, false, true, false);
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node3, "FunctionExpression");
        };
        pp$52.parseArrowExpression = function(node3, params, isAsync, forInit) {
          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.enterScope(functionFlags2(isAsync, false) | SCOPE_ARROW2);
          this.initFunction(node3);
          if (this.options.ecmaVersion >= 8) {
            node3.async = !!isAsync;
          }
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          node3.params = this.toAssignableList(params, true);
          this.parseFunctionBody(node3, true, false, forInit);
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node3, "ArrowFunctionExpression");
        };
        pp$52.parseFunctionBody = function(node3, isArrowFunction, isMethod, forInit) {
          var isExpression = isArrowFunction && this.type !== types$12.braceL;
          var oldStrict = this.strict, useStrict = false;
          if (isExpression) {
            node3.body = this.parseMaybeAssign(forInit);
            node3.expression = true;
            this.checkParams(node3, false);
          } else {
            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node3.params);
            if (!oldStrict || nonSimple) {
              useStrict = this.strictDirective(this.end);
              if (useStrict && nonSimple) {
                this.raiseRecoverable(node3.start, "Illegal 'use strict' directive in function with non-simple parameter list");
              }
            }
            var oldLabels = this.labels;
            this.labels = [];
            if (useStrict) {
              this.strict = true;
            }
            this.checkParams(node3, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node3.params));
            if (this.strict && node3.id) {
              this.checkLValSimple(node3.id, BIND_OUTSIDE2);
            }
            node3.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
            node3.expression = false;
            this.adaptDirectivePrologue(node3.body.body);
            this.labels = oldLabels;
          }
          this.exitScope();
        };
        pp$52.isSimpleParamList = function(params) {
          for (var i2 = 0, list5 = params; i2 < list5.length; i2 += 1) {
            var param = list5[i2];
            if (param.type !== "Identifier") {
              return false;
            }
          }
          return true;
        };
        pp$52.checkParams = function(node3, allowDuplicates) {
          var nameHash = /* @__PURE__ */ Object.create(null);
          for (var i2 = 0, list5 = node3.params; i2 < list5.length; i2 += 1) {
            var param = list5[i2];
            this.checkLValInnerPattern(param, BIND_VAR2, allowDuplicates ? null : nameHash);
          }
        };
        pp$52.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
          var elts = [], first = true;
          while (!this.eat(close)) {
            if (!first) {
              this.expect(types$12.comma);
              if (allowTrailingComma && this.afterTrailingComma(close)) {
                break;
              }
            } else {
              first = false;
            }
            var elt = void 0;
            if (allowEmpty && this.type === types$12.comma) {
              elt = null;
            } else if (this.type === types$12.ellipsis) {
              elt = this.parseSpread(refDestructuringErrors);
              if (refDestructuringErrors && this.type === types$12.comma && refDestructuringErrors.trailingComma < 0) {
                refDestructuringErrors.trailingComma = this.start;
              }
            } else {
              elt = this.parseMaybeAssign(false, refDestructuringErrors);
            }
            elts.push(elt);
          }
          return elts;
        };
        pp$52.checkUnreserved = function(ref3) {
          var start2 = ref3.start;
          var end = ref3.end;
          var name2 = ref3.name;
          if (this.inGenerator && name2 === "yield") {
            this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
          }
          if (this.inAsync && name2 === "await") {
            this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
          }
          if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
            this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
          }
          if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
            this.raise(start2, "Cannot use " + name2 + " in class static initialization block");
          }
          if (this.keywords.test(name2)) {
            this.raise(start2, "Unexpected keyword '" + name2 + "'");
          }
          if (this.options.ecmaVersion < 6 && this.input.slice(start2, end).indexOf("\\") !== -1) {
            return;
          }
          var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
          if (re.test(name2)) {
            if (!this.inAsync && name2 === "await") {
              this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
            }
            this.raiseRecoverable(start2, "The keyword '" + name2 + "' is reserved");
          }
        };
        pp$52.parseIdent = function(liberal) {
          var node3 = this.parseIdentNode();
          this.next(!!liberal);
          this.finishNode(node3, "Identifier");
          if (!liberal) {
            this.checkUnreserved(node3);
            if (node3.name === "await" && !this.awaitIdentPos) {
              this.awaitIdentPos = node3.start;
            }
          }
          return node3;
        };
        pp$52.parseIdentNode = function() {
          var node3 = this.startNode();
          if (this.type === types$12.name) {
            node3.name = this.value;
          } else if (this.type.keyword) {
            node3.name = this.type.keyword;
            if ((node3.name === "class" || node3.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
              this.context.pop();
            }
            this.type = types$12.name;
          } else {
            this.unexpected();
          }
          return node3;
        };
        pp$52.parsePrivateIdent = function() {
          var node3 = this.startNode();
          if (this.type === types$12.privateId) {
            node3.name = this.value;
          } else {
            this.unexpected();
          }
          this.next();
          this.finishNode(node3, "PrivateIdentifier");
          if (this.options.checkPrivateFields) {
            if (this.privateNameStack.length === 0) {
              this.raise(node3.start, "Private field '#" + node3.name + "' must be declared in an enclosing class");
            } else {
              this.privateNameStack[this.privateNameStack.length - 1].used.push(node3);
            }
          }
          return node3;
        };
        pp$52.parseYield = function(forInit) {
          if (!this.yieldPos) {
            this.yieldPos = this.start;
          }
          var node3 = this.startNode();
          this.next();
          if (this.type === types$12.semi || this.canInsertSemicolon() || this.type !== types$12.star && !this.type.startsExpr) {
            node3.delegate = false;
            node3.argument = null;
          } else {
            node3.delegate = this.eat(types$12.star);
            node3.argument = this.parseMaybeAssign(forInit);
          }
          return this.finishNode(node3, "YieldExpression");
        };
        pp$52.parseAwait = function(forInit) {
          if (!this.awaitPos) {
            this.awaitPos = this.start;
          }
          var node3 = this.startNode();
          this.next();
          node3.argument = this.parseMaybeUnary(null, true, false, forInit);
          return this.finishNode(node3, "AwaitExpression");
        };
        var pp$42 = Parser3.prototype;
        pp$42.raise = function(pos, message) {
          var loc = getLineInfo2(this.input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          err.pos = pos;
          err.loc = loc;
          err.raisedAt = this.pos;
          throw err;
        };
        pp$42.raiseRecoverable = pp$42.raise;
        pp$42.curPosition = function() {
          if (this.options.locations) {
            return new Position4(this.curLine, this.pos - this.lineStart);
          }
        };
        var pp$32 = Parser3.prototype;
        var Scope4 = function Scope5(flags) {
          this.flags = flags;
          this.var = [];
          this.lexical = [];
          this.functions = [];
          this.inClassFieldInit = false;
        };
        pp$32.enterScope = function(flags) {
          this.scopeStack.push(new Scope4(flags));
        };
        pp$32.exitScope = function() {
          this.scopeStack.pop();
        };
        pp$32.treatFunctionsAsVarInScope = function(scope) {
          return scope.flags & SCOPE_FUNCTION2 || !this.inModule && scope.flags & SCOPE_TOP2;
        };
        pp$32.declareName = function(name2, bindingType, pos) {
          var redeclared = false;
          if (bindingType === BIND_LEXICAL2) {
            var scope = this.currentScope();
            redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
            scope.lexical.push(name2);
            if (this.inModule && scope.flags & SCOPE_TOP2) {
              delete this.undefinedExports[name2];
            }
          } else if (bindingType === BIND_SIMPLE_CATCH2) {
            var scope$1 = this.currentScope();
            scope$1.lexical.push(name2);
          } else if (bindingType === BIND_FUNCTION2) {
            var scope$2 = this.currentScope();
            if (this.treatFunctionsAsVar) {
              redeclared = scope$2.lexical.indexOf(name2) > -1;
            } else {
              redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
            }
            scope$2.functions.push(name2);
          } else {
            for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
              var scope$3 = this.scopeStack[i2];
              if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH2 && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
                redeclared = true;
                break;
              }
              scope$3.var.push(name2);
              if (this.inModule && scope$3.flags & SCOPE_TOP2) {
                delete this.undefinedExports[name2];
              }
              if (scope$3.flags & SCOPE_VAR2) {
                break;
              }
            }
          }
          if (redeclared) {
            this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
          }
        };
        pp$32.checkLocalExport = function(id) {
          if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
            this.undefinedExports[id.name] = id;
          }
        };
        pp$32.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1];
        };
        pp$32.currentVarScope = function() {
          for (var i2 = this.scopeStack.length - 1; ; i2--) {
            var scope = this.scopeStack[i2];
            if (scope.flags & SCOPE_VAR2) {
              return scope;
            }
          }
        };
        pp$32.currentThisScope = function() {
          for (var i2 = this.scopeStack.length - 1; ; i2--) {
            var scope = this.scopeStack[i2];
            if (scope.flags & SCOPE_VAR2 && !(scope.flags & SCOPE_ARROW2)) {
              return scope;
            }
          }
        };
        var Node4 = function Node5(parser, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          if (parser.options.locations) {
            this.loc = new SourceLocation3(parser, loc);
          }
          if (parser.options.directSourceFile) {
            this.sourceFile = parser.options.directSourceFile;
          }
          if (parser.options.ranges) {
            this.range = [pos, 0];
          }
        };
        var pp$22 = Parser3.prototype;
        pp$22.startNode = function() {
          return new Node4(this, this.start, this.startLoc);
        };
        pp$22.startNodeAt = function(pos, loc) {
          return new Node4(this, pos, loc);
        };
        function finishNodeAt2(node3, type, pos, loc) {
          node3.type = type;
          node3.end = pos;
          if (this.options.locations) {
            node3.loc.end = loc;
          }
          if (this.options.ranges) {
            node3.range[1] = pos;
          }
          return node3;
        }
        pp$22.finishNode = function(node3, type) {
          return finishNodeAt2.call(this, node3, type, this.lastTokEnd, this.lastTokEndLoc);
        };
        pp$22.finishNodeAt = function(node3, type, pos, loc) {
          return finishNodeAt2.call(this, node3, type, pos, loc);
        };
        pp$22.copyNode = function(node3) {
          var newNode = new Node4(this, node3.start, this.startLoc);
          for (var prop in node3) {
            newNode[prop] = node3[prop];
          }
          return newNode;
        };
        var ecma9BinaryProperties2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
        var ecma10BinaryProperties2 = ecma9BinaryProperties2 + " Extended_Pictographic";
        var ecma11BinaryProperties2 = ecma10BinaryProperties2;
        var ecma12BinaryProperties2 = ecma11BinaryProperties2 + " EBase EComp EMod EPres ExtPict";
        var ecma13BinaryProperties2 = ecma12BinaryProperties2;
        var ecma14BinaryProperties2 = ecma13BinaryProperties2;
        var unicodeBinaryProperties2 = {
          9: ecma9BinaryProperties2,
          10: ecma10BinaryProperties2,
          11: ecma11BinaryProperties2,
          12: ecma12BinaryProperties2,
          13: ecma13BinaryProperties2,
          14: ecma14BinaryProperties2
        };
        var ecma14BinaryPropertiesOfStrings2 = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
        var unicodeBinaryPropertiesOfStrings2 = {
          9: "",
          10: "",
          11: "",
          12: "",
          13: "",
          14: ecma14BinaryPropertiesOfStrings2
        };
        var unicodeGeneralCategoryValues2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
        var ecma9ScriptValues2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
        var ecma10ScriptValues2 = ecma9ScriptValues2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
        var ecma11ScriptValues2 = ecma10ScriptValues2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
        var ecma12ScriptValues2 = ecma11ScriptValues2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
        var ecma13ScriptValues2 = ecma12ScriptValues2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
        var ecma14ScriptValues2 = ecma13ScriptValues2 + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
        var unicodeScriptValues2 = {
          9: ecma9ScriptValues2,
          10: ecma10ScriptValues2,
          11: ecma11ScriptValues2,
          12: ecma12ScriptValues2,
          13: ecma13ScriptValues2,
          14: ecma14ScriptValues2
        };
        var data2 = {};
        function buildUnicodeData2(ecmaVersion2) {
          var d = data2[ecmaVersion2] = {
            binary: wordsRegexp2(unicodeBinaryProperties2[ecmaVersion2] + " " + unicodeGeneralCategoryValues2),
            binaryOfStrings: wordsRegexp2(unicodeBinaryPropertiesOfStrings2[ecmaVersion2]),
            nonBinary: {
              General_Category: wordsRegexp2(unicodeGeneralCategoryValues2),
              Script: wordsRegexp2(unicodeScriptValues2[ecmaVersion2])
            }
          };
          d.nonBinary.Script_Extensions = d.nonBinary.Script;
          d.nonBinary.gc = d.nonBinary.General_Category;
          d.nonBinary.sc = d.nonBinary.Script;
          d.nonBinary.scx = d.nonBinary.Script_Extensions;
        }
        for (var i = 0, list4 = [9, 10, 11, 12, 13, 14]; i < list4.length; i += 1) {
          var ecmaVersion = list4[i];
          buildUnicodeData2(ecmaVersion);
        }
        var pp$12 = Parser3.prototype;
        var BranchID3 = function BranchID4(parent, base) {
          this.parent = parent;
          this.base = base || this;
        };
        BranchID3.prototype.separatedFrom = function separatedFrom2(alt) {
          for (var self2 = this; self2; self2 = self2.parent) {
            for (var other = alt; other; other = other.parent) {
              if (self2.base === other.base && self2 !== other) {
                return true;
              }
            }
          }
          return false;
        };
        BranchID3.prototype.sibling = function sibling2() {
          return new BranchID3(this.parent, this.base);
        };
        var RegExpValidationState3 = function RegExpValidationState4(parser) {
          this.parser = parser;
          this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
          this.unicodeProperties = data2[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
          this.source = "";
          this.flags = "";
          this.start = 0;
          this.switchU = false;
          this.switchV = false;
          this.switchN = false;
          this.pos = 0;
          this.lastIntValue = 0;
          this.lastStringValue = "";
          this.lastAssertionIsQuantifiable = false;
          this.numCapturingParens = 0;
          this.maxBackReference = 0;
          this.groupNames = /* @__PURE__ */ Object.create(null);
          this.backReferenceNames = [];
          this.branchID = null;
        };
        RegExpValidationState3.prototype.reset = function reset2(start2, pattern, flags) {
          var unicodeSets = flags.indexOf("v") !== -1;
          var unicode = flags.indexOf("u") !== -1;
          this.start = start2 | 0;
          this.source = pattern + "";
          this.flags = flags;
          if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
            this.switchU = true;
            this.switchV = true;
            this.switchN = true;
          } else {
            this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
            this.switchV = false;
            this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
          }
        };
        RegExpValidationState3.prototype.raise = function raise2(message) {
          this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
        };
        RegExpValidationState3.prototype.at = function at2(i2, forceU) {
          if (forceU === void 0)
            forceU = false;
          var s = this.source;
          var l = s.length;
          if (i2 >= l) {
            return -1;
          }
          var c = s.charCodeAt(i2);
          if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
            return c;
          }
          var next = s.charCodeAt(i2 + 1);
          return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
        };
        RegExpValidationState3.prototype.nextIndex = function nextIndex2(i2, forceU) {
          if (forceU === void 0)
            forceU = false;
          var s = this.source;
          var l = s.length;
          if (i2 >= l) {
            return l;
          }
          var c = s.charCodeAt(i2), next;
          if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
            return i2 + 1;
          }
          return i2 + 2;
        };
        RegExpValidationState3.prototype.current = function current2(forceU) {
          if (forceU === void 0)
            forceU = false;
          return this.at(this.pos, forceU);
        };
        RegExpValidationState3.prototype.lookahead = function lookahead2(forceU) {
          if (forceU === void 0)
            forceU = false;
          return this.at(this.nextIndex(this.pos, forceU), forceU);
        };
        RegExpValidationState3.prototype.advance = function advance2(forceU) {
          if (forceU === void 0)
            forceU = false;
          this.pos = this.nextIndex(this.pos, forceU);
        };
        RegExpValidationState3.prototype.eat = function eat2(ch, forceU) {
          if (forceU === void 0)
            forceU = false;
          if (this.current(forceU) === ch) {
            this.advance(forceU);
            return true;
          }
          return false;
        };
        RegExpValidationState3.prototype.eatChars = function eatChars2(chs, forceU) {
          if (forceU === void 0)
            forceU = false;
          var pos = this.pos;
          for (var i2 = 0, list5 = chs; i2 < list5.length; i2 += 1) {
            var ch = list5[i2];
            var current2 = this.at(pos, forceU);
            if (current2 === -1 || current2 !== ch) {
              return false;
            }
            pos = this.nextIndex(pos, forceU);
          }
          this.pos = pos;
          return true;
        };
        pp$12.validateRegExpFlags = function(state) {
          var validFlags = state.validFlags;
          var flags = state.flags;
          var u = false;
          var v = false;
          for (var i2 = 0; i2 < flags.length; i2++) {
            var flag = flags.charAt(i2);
            if (validFlags.indexOf(flag) === -1) {
              this.raise(state.start, "Invalid regular expression flag");
            }
            if (flags.indexOf(flag, i2 + 1) > -1) {
              this.raise(state.start, "Duplicate regular expression flag");
            }
            if (flag === "u") {
              u = true;
            }
            if (flag === "v") {
              v = true;
            }
          }
          if (this.options.ecmaVersion >= 15 && u && v) {
            this.raise(state.start, "Invalid regular expression flag");
          }
        };
        function hasProp2(obj) {
          for (var _ in obj) {
            return true;
          }
          return false;
        }
        pp$12.validateRegExpPattern = function(state) {
          this.regexp_pattern(state);
          if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp2(state.groupNames)) {
            state.switchN = true;
            this.regexp_pattern(state);
          }
        };
        pp$12.regexp_pattern = function(state) {
          state.pos = 0;
          state.lastIntValue = 0;
          state.lastStringValue = "";
          state.lastAssertionIsQuantifiable = false;
          state.numCapturingParens = 0;
          state.maxBackReference = 0;
          state.groupNames = /* @__PURE__ */ Object.create(null);
          state.backReferenceNames.length = 0;
          state.branchID = null;
          this.regexp_disjunction(state);
          if (state.pos !== state.source.length) {
            if (state.eat(
              41
              /* ) */
            )) {
              state.raise("Unmatched ')'");
            }
            if (state.eat(
              93
              /* ] */
            ) || state.eat(
              125
              /* } */
            )) {
              state.raise("Lone quantifier brackets");
            }
          }
          if (state.maxBackReference > state.numCapturingParens) {
            state.raise("Invalid escape");
          }
          for (var i2 = 0, list5 = state.backReferenceNames; i2 < list5.length; i2 += 1) {
            var name2 = list5[i2];
            if (!state.groupNames[name2]) {
              state.raise("Invalid named capture referenced");
            }
          }
        };
        pp$12.regexp_disjunction = function(state) {
          var trackDisjunction = this.options.ecmaVersion >= 16;
          if (trackDisjunction) {
            state.branchID = new BranchID3(state.branchID, null);
          }
          this.regexp_alternative(state);
          while (state.eat(
            124
            /* | */
          )) {
            if (trackDisjunction) {
              state.branchID = state.branchID.sibling();
            }
            this.regexp_alternative(state);
          }
          if (trackDisjunction) {
            state.branchID = state.branchID.parent;
          }
          if (this.regexp_eatQuantifier(state, true)) {
            state.raise("Nothing to repeat");
          }
          if (state.eat(
            123
            /* { */
          )) {
            state.raise("Lone quantifier brackets");
          }
        };
        pp$12.regexp_alternative = function(state) {
          while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
          }
        };
        pp$12.regexp_eatTerm = function(state) {
          if (this.regexp_eatAssertion(state)) {
            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
              if (state.switchU) {
                state.raise("Invalid quantifier");
              }
            }
            return true;
          }
          if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
            this.regexp_eatQuantifier(state);
            return true;
          }
          return false;
        };
        pp$12.regexp_eatAssertion = function(state) {
          var start2 = state.pos;
          state.lastAssertionIsQuantifiable = false;
          if (state.eat(
            94
            /* ^ */
          ) || state.eat(
            36
            /* $ */
          )) {
            return true;
          }
          if (state.eat(
            92
            /* \ */
          )) {
            if (state.eat(
              66
              /* B */
            ) || state.eat(
              98
              /* b */
            )) {
              return true;
            }
            state.pos = start2;
          }
          if (state.eat(
            40
            /* ( */
          ) && state.eat(
            63
            /* ? */
          )) {
            var lookbehind = false;
            if (this.options.ecmaVersion >= 9) {
              lookbehind = state.eat(
                60
                /* < */
              );
            }
            if (state.eat(
              61
              /* = */
            ) || state.eat(
              33
              /* ! */
            )) {
              this.regexp_disjunction(state);
              if (!state.eat(
                41
                /* ) */
              )) {
                state.raise("Unterminated group");
              }
              state.lastAssertionIsQuantifiable = !lookbehind;
              return true;
            }
          }
          state.pos = start2;
          return false;
        };
        pp$12.regexp_eatQuantifier = function(state, noError) {
          if (noError === void 0)
            noError = false;
          if (this.regexp_eatQuantifierPrefix(state, noError)) {
            state.eat(
              63
              /* ? */
            );
            return true;
          }
          return false;
        };
        pp$12.regexp_eatQuantifierPrefix = function(state, noError) {
          return state.eat(
            42
            /* * */
          ) || state.eat(
            43
            /* + */
          ) || state.eat(
            63
            /* ? */
          ) || this.regexp_eatBracedQuantifier(state, noError);
        };
        pp$12.regexp_eatBracedQuantifier = function(state, noError) {
          var start2 = state.pos;
          if (state.eat(
            123
            /* { */
          )) {
            var min = 0, max = -1;
            if (this.regexp_eatDecimalDigits(state)) {
              min = state.lastIntValue;
              if (state.eat(
                44
                /* , */
              ) && this.regexp_eatDecimalDigits(state)) {
                max = state.lastIntValue;
              }
              if (state.eat(
                125
                /* } */
              )) {
                if (max !== -1 && max < min && !noError) {
                  state.raise("numbers out of order in {} quantifier");
                }
                return true;
              }
            }
            if (state.switchU && !noError) {
              state.raise("Incomplete quantifier");
            }
            state.pos = start2;
          }
          return false;
        };
        pp$12.regexp_eatAtom = function(state) {
          return this.regexp_eatPatternCharacters(state) || state.eat(
            46
            /* . */
          ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
        };
        pp$12.regexp_eatReverseSolidusAtomEscape = function(state) {
          var start2 = state.pos;
          if (state.eat(
            92
            /* \ */
          )) {
            if (this.regexp_eatAtomEscape(state)) {
              return true;
            }
            state.pos = start2;
          }
          return false;
        };
        pp$12.regexp_eatUncapturingGroup = function(state) {
          var start2 = state.pos;
          if (state.eat(
            40
            /* ( */
          )) {
            if (state.eat(
              63
              /* ? */
            ) && state.eat(
              58
              /* : */
            )) {
              this.regexp_disjunction(state);
              if (state.eat(
                41
                /* ) */
              )) {
                return true;
              }
              state.raise("Unterminated group");
            }
            state.pos = start2;
          }
          return false;
        };
        pp$12.regexp_eatCapturingGroup = function(state) {
          if (state.eat(
            40
            /* ( */
          )) {
            if (this.options.ecmaVersion >= 9) {
              this.regexp_groupSpecifier(state);
            } else if (state.current() === 63) {
              state.raise("Invalid group");
            }
            this.regexp_disjunction(state);
            if (state.eat(
              41
              /* ) */
            )) {
              state.numCapturingParens += 1;
              return true;
            }
            state.raise("Unterminated group");
          }
          return false;
        };
        pp$12.regexp_eatExtendedAtom = function(state) {
          return state.eat(
            46
            /* . */
          ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
        };
        pp$12.regexp_eatInvalidBracedQuantifier = function(state) {
          if (this.regexp_eatBracedQuantifier(state, true)) {
            state.raise("Nothing to repeat");
          }
          return false;
        };
        pp$12.regexp_eatSyntaxCharacter = function(state) {
          var ch = state.current();
          if (isSyntaxCharacter2(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
          }
          return false;
        };
        function isSyntaxCharacter2(ch) {
          return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
        }
        pp$12.regexp_eatPatternCharacters = function(state) {
          var start2 = state.pos;
          var ch = 0;
          while ((ch = state.current()) !== -1 && !isSyntaxCharacter2(ch)) {
            state.advance();
          }
          return state.pos !== start2;
        };
        pp$12.regexp_eatExtendedPatternCharacter = function(state) {
          var ch = state.current();
          if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
            state.advance();
            return true;
          }
          return false;
        };
        pp$12.regexp_groupSpecifier = function(state) {
          if (state.eat(
            63
            /* ? */
          )) {
            if (!this.regexp_eatGroupName(state)) {
              state.raise("Invalid group");
            }
            var trackDisjunction = this.options.ecmaVersion >= 16;
            var known = state.groupNames[state.lastStringValue];
            if (known) {
              if (trackDisjunction) {
                for (var i2 = 0, list5 = known; i2 < list5.length; i2 += 1) {
                  var altID = list5[i2];
                  if (!altID.separatedFrom(state.branchID)) {
                    state.raise("Duplicate capture group name");
                  }
                }
              } else {
                state.raise("Duplicate capture group name");
              }
            }
            if (trackDisjunction) {
              (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
            } else {
              state.groupNames[state.lastStringValue] = true;
            }
          }
        };
        pp$12.regexp_eatGroupName = function(state) {
          state.lastStringValue = "";
          if (state.eat(
            60
            /* < */
          )) {
            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
              62
              /* > */
            )) {
              return true;
            }
            state.raise("Invalid capture group name");
          }
          return false;
        };
        pp$12.regexp_eatRegExpIdentifierName = function(state) {
          state.lastStringValue = "";
          if (this.regexp_eatRegExpIdentifierStart(state)) {
            state.lastStringValue += codePointToString2(state.lastIntValue);
            while (this.regexp_eatRegExpIdentifierPart(state)) {
              state.lastStringValue += codePointToString2(state.lastIntValue);
            }
            return true;
          }
          return false;
        };
        pp$12.regexp_eatRegExpIdentifierStart = function(state) {
          var start2 = state.pos;
          var forceU = this.options.ecmaVersion >= 11;
          var ch = state.current(forceU);
          state.advance(forceU);
          if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
            ch = state.lastIntValue;
          }
          if (isRegExpIdentifierStart2(ch)) {
            state.lastIntValue = ch;
            return true;
          }
          state.pos = start2;
          return false;
        };
        function isRegExpIdentifierStart2(ch) {
          return isIdentifierStart2(ch, true) || ch === 36 || ch === 95;
        }
        pp$12.regexp_eatRegExpIdentifierPart = function(state) {
          var start2 = state.pos;
          var forceU = this.options.ecmaVersion >= 11;
          var ch = state.current(forceU);
          state.advance(forceU);
          if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
            ch = state.lastIntValue;
          }
          if (isRegExpIdentifierPart2(ch)) {
            state.lastIntValue = ch;
            return true;
          }
          state.pos = start2;
          return false;
        };
        function isRegExpIdentifierPart2(ch) {
          return isIdentifierChar2(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
        }
        pp$12.regexp_eatAtomEscape = function(state) {
          if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
            return true;
          }
          if (state.switchU) {
            if (state.current() === 99) {
              state.raise("Invalid unicode escape");
            }
            state.raise("Invalid escape");
          }
          return false;
        };
        pp$12.regexp_eatBackReference = function(state) {
          var start2 = state.pos;
          if (this.regexp_eatDecimalEscape(state)) {
            var n = state.lastIntValue;
            if (state.switchU) {
              if (n > state.maxBackReference) {
                state.maxBackReference = n;
              }
              return true;
            }
            if (n <= state.numCapturingParens) {
              return true;
            }
            state.pos = start2;
          }
          return false;
        };
        pp$12.regexp_eatKGroupName = function(state) {
          if (state.eat(
            107
            /* k */
          )) {
            if (this.regexp_eatGroupName(state)) {
              state.backReferenceNames.push(state.lastStringValue);
              return true;
            }
            state.raise("Invalid named reference");
          }
          return false;
        };
        pp$12.regexp_eatCharacterEscape = function(state) {
          return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
        };
        pp$12.regexp_eatCControlLetter = function(state) {
          var start2 = state.pos;
          if (state.eat(
            99
            /* c */
          )) {
            if (this.regexp_eatControlLetter(state)) {
              return true;
            }
            state.pos = start2;
          }
          return false;
        };
        pp$12.regexp_eatZero = function(state) {
          if (state.current() === 48 && !isDecimalDigit2(state.lookahead())) {
            state.lastIntValue = 0;
            state.advance();
            return true;
          }
          return false;
        };
        pp$12.regexp_eatControlEscape = function(state) {
          var ch = state.current();
          if (ch === 116) {
            state.lastIntValue = 9;
            state.advance();
            return true;
          }
          if (ch === 110) {
            state.lastIntValue = 10;
            state.advance();
            return true;
          }
          if (ch === 118) {
            state.lastIntValue = 11;
            state.advance();
            return true;
          }
          if (ch === 102) {
            state.lastIntValue = 12;
            state.advance();
            return true;
          }
          if (ch === 114) {
            state.lastIntValue = 13;
            state.advance();
            return true;
          }
          return false;
        };
        pp$12.regexp_eatControlLetter = function(state) {
          var ch = state.current();
          if (isControlLetter2(ch)) {
            state.lastIntValue = ch % 32;
            state.advance();
            return true;
          }
          return false;
        };
        function isControlLetter2(ch) {
          return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
        }
        pp$12.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
          if (forceU === void 0)
            forceU = false;
          var start2 = state.pos;
          var switchU = forceU || state.switchU;
          if (state.eat(
            117
            /* u */
          )) {
            if (this.regexp_eatFixedHexDigits(state, 4)) {
              var lead = state.lastIntValue;
              if (switchU && lead >= 55296 && lead <= 56319) {
                var leadSurrogateEnd = state.pos;
                if (state.eat(
                  92
                  /* \ */
                ) && state.eat(
                  117
                  /* u */
                ) && this.regexp_eatFixedHexDigits(state, 4)) {
                  var trail = state.lastIntValue;
                  if (trail >= 56320 && trail <= 57343) {
                    state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                    return true;
                  }
                }
                state.pos = leadSurrogateEnd;
                state.lastIntValue = lead;
              }
              return true;
            }
            if (switchU && state.eat(
              123
              /* { */
            ) && this.regexp_eatHexDigits(state) && state.eat(
              125
              /* } */
            ) && isValidUnicode2(state.lastIntValue)) {
              return true;
            }
            if (switchU) {
              state.raise("Invalid unicode escape");
            }
            state.pos = start2;
          }
          return false;
        };
        function isValidUnicode2(ch) {
          return ch >= 0 && ch <= 1114111;
        }
        pp$12.regexp_eatIdentityEscape = function(state) {
          if (state.switchU) {
            if (this.regexp_eatSyntaxCharacter(state)) {
              return true;
            }
            if (state.eat(
              47
              /* / */
            )) {
              state.lastIntValue = 47;
              return true;
            }
            return false;
          }
          var ch = state.current();
          if (ch !== 99 && (!state.switchN || ch !== 107)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
          }
          return false;
        };
        pp$12.regexp_eatDecimalEscape = function(state) {
          state.lastIntValue = 0;
          var ch = state.current();
          if (ch >= 49 && ch <= 57) {
            do {
              state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
              state.advance();
            } while ((ch = state.current()) >= 48 && ch <= 57);
            return true;
          }
          return false;
        };
        var CharSetNone2 = 0;
        var CharSetOk2 = 1;
        var CharSetString2 = 2;
        pp$12.regexp_eatCharacterClassEscape = function(state) {
          var ch = state.current();
          if (isCharacterClassEscape2(ch)) {
            state.lastIntValue = -1;
            state.advance();
            return CharSetOk2;
          }
          var negate = false;
          if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
            state.lastIntValue = -1;
            state.advance();
            var result;
            if (state.eat(
              123
              /* { */
            ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
              125
              /* } */
            )) {
              if (negate && result === CharSetString2) {
                state.raise("Invalid property name");
              }
              return result;
            }
            state.raise("Invalid property name");
          }
          return CharSetNone2;
        };
        function isCharacterClassEscape2(ch) {
          return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
        }
        pp$12.regexp_eatUnicodePropertyValueExpression = function(state) {
          var start2 = state.pos;
          if (this.regexp_eatUnicodePropertyName(state) && state.eat(
            61
            /* = */
          )) {
            var name2 = state.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(state)) {
              var value = state.lastStringValue;
              this.regexp_validateUnicodePropertyNameAndValue(state, name2, value);
              return CharSetOk2;
            }
          }
          state.pos = start2;
          if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
            var nameOrValue = state.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          }
          return CharSetNone2;
        };
        pp$12.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value) {
          if (!hasOwn2(state.unicodeProperties.nonBinary, name2)) {
            state.raise("Invalid property name");
          }
          if (!state.unicodeProperties.nonBinary[name2].test(value)) {
            state.raise("Invalid property value");
          }
        };
        pp$12.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
          if (state.unicodeProperties.binary.test(nameOrValue)) {
            return CharSetOk2;
          }
          if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
            return CharSetString2;
          }
          state.raise("Invalid property name");
        };
        pp$12.regexp_eatUnicodePropertyName = function(state) {
          var ch = 0;
          state.lastStringValue = "";
          while (isUnicodePropertyNameCharacter2(ch = state.current())) {
            state.lastStringValue += codePointToString2(ch);
            state.advance();
          }
          return state.lastStringValue !== "";
        };
        function isUnicodePropertyNameCharacter2(ch) {
          return isControlLetter2(ch) || ch === 95;
        }
        pp$12.regexp_eatUnicodePropertyValue = function(state) {
          var ch = 0;
          state.lastStringValue = "";
          while (isUnicodePropertyValueCharacter2(ch = state.current())) {
            state.lastStringValue += codePointToString2(ch);
            state.advance();
          }
          return state.lastStringValue !== "";
        };
        function isUnicodePropertyValueCharacter2(ch) {
          return isUnicodePropertyNameCharacter2(ch) || isDecimalDigit2(ch);
        }
        pp$12.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
          return this.regexp_eatUnicodePropertyValue(state);
        };
        pp$12.regexp_eatCharacterClass = function(state) {
          if (state.eat(
            91
            /* [ */
          )) {
            var negate = state.eat(
              94
              /* ^ */
            );
            var result = this.regexp_classContents(state);
            if (!state.eat(
              93
              /* ] */
            )) {
              state.raise("Unterminated character class");
            }
            if (negate && result === CharSetString2) {
              state.raise("Negated character class may contain strings");
            }
            return true;
          }
          return false;
        };
        pp$12.regexp_classContents = function(state) {
          if (state.current() === 93) {
            return CharSetOk2;
          }
          if (state.switchV) {
            return this.regexp_classSetExpression(state);
          }
          this.regexp_nonEmptyClassRanges(state);
          return CharSetOk2;
        };
        pp$12.regexp_nonEmptyClassRanges = function(state) {
          while (this.regexp_eatClassAtom(state)) {
            var left = state.lastIntValue;
            if (state.eat(
              45
              /* - */
            ) && this.regexp_eatClassAtom(state)) {
              var right = state.lastIntValue;
              if (state.switchU && (left === -1 || right === -1)) {
                state.raise("Invalid character class");
              }
              if (left !== -1 && right !== -1 && left > right) {
                state.raise("Range out of order in character class");
              }
            }
          }
        };
        pp$12.regexp_eatClassAtom = function(state) {
          var start2 = state.pos;
          if (state.eat(
            92
            /* \ */
          )) {
            if (this.regexp_eatClassEscape(state)) {
              return true;
            }
            if (state.switchU) {
              var ch$1 = state.current();
              if (ch$1 === 99 || isOctalDigit2(ch$1)) {
                state.raise("Invalid class escape");
              }
              state.raise("Invalid escape");
            }
            state.pos = start2;
          }
          var ch = state.current();
          if (ch !== 93) {
            state.lastIntValue = ch;
            state.advance();
            return true;
          }
          return false;
        };
        pp$12.regexp_eatClassEscape = function(state) {
          var start2 = state.pos;
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          if (state.switchU && state.eat(
            45
            /* - */
          )) {
            state.lastIntValue = 45;
            return true;
          }
          if (!state.switchU && state.eat(
            99
            /* c */
          )) {
            if (this.regexp_eatClassControlLetter(state)) {
              return true;
            }
            state.pos = start2;
          }
          return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
        };
        pp$12.regexp_classSetExpression = function(state) {
          var result = CharSetOk2, subResult;
          if (this.regexp_eatClassSetRange(state))
            ;
          else if (subResult = this.regexp_eatClassSetOperand(state)) {
            if (subResult === CharSetString2) {
              result = CharSetString2;
            }
            var start2 = state.pos;
            while (state.eatChars(
              [38, 38]
              /* && */
            )) {
              if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
                if (subResult !== CharSetString2) {
                  result = CharSetOk2;
                }
                continue;
              }
              state.raise("Invalid character in character class");
            }
            if (start2 !== state.pos) {
              return result;
            }
            while (state.eatChars(
              [45, 45]
              /* -- */
            )) {
              if (this.regexp_eatClassSetOperand(state)) {
                continue;
              }
              state.raise("Invalid character in character class");
            }
            if (start2 !== state.pos) {
              return result;
            }
          } else {
            state.raise("Invalid character in character class");
          }
          for (; ; ) {
            if (this.regexp_eatClassSetRange(state)) {
              continue;
            }
            subResult = this.regexp_eatClassSetOperand(state);
            if (!subResult) {
              return result;
            }
            if (subResult === CharSetString2) {
              result = CharSetString2;
            }
          }
        };
        pp$12.regexp_eatClassSetRange = function(state) {
          var start2 = state.pos;
          if (this.regexp_eatClassSetCharacter(state)) {
            var left = state.lastIntValue;
            if (state.eat(
              45
              /* - */
            ) && this.regexp_eatClassSetCharacter(state)) {
              var right = state.lastIntValue;
              if (left !== -1 && right !== -1 && left > right) {
                state.raise("Range out of order in character class");
              }
              return true;
            }
            state.pos = start2;
          }
          return false;
        };
        pp$12.regexp_eatClassSetOperand = function(state) {
          if (this.regexp_eatClassSetCharacter(state)) {
            return CharSetOk2;
          }
          return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
        };
        pp$12.regexp_eatNestedClass = function(state) {
          var start2 = state.pos;
          if (state.eat(
            91
            /* [ */
          )) {
            var negate = state.eat(
              94
              /* ^ */
            );
            var result = this.regexp_classContents(state);
            if (state.eat(
              93
              /* ] */
            )) {
              if (negate && result === CharSetString2) {
                state.raise("Negated character class may contain strings");
              }
              return result;
            }
            state.pos = start2;
          }
          if (state.eat(
            92
            /* \ */
          )) {
            var result$1 = this.regexp_eatCharacterClassEscape(state);
            if (result$1) {
              return result$1;
            }
            state.pos = start2;
          }
          return null;
        };
        pp$12.regexp_eatClassStringDisjunction = function(state) {
          var start2 = state.pos;
          if (state.eatChars(
            [92, 113]
            /* \q */
          )) {
            if (state.eat(
              123
              /* { */
            )) {
              var result = this.regexp_classStringDisjunctionContents(state);
              if (state.eat(
                125
                /* } */
              )) {
                return result;
              }
            } else {
              state.raise("Invalid escape");
            }
            state.pos = start2;
          }
          return null;
        };
        pp$12.regexp_classStringDisjunctionContents = function(state) {
          var result = this.regexp_classString(state);
          while (state.eat(
            124
            /* | */
          )) {
            if (this.regexp_classString(state) === CharSetString2) {
              result = CharSetString2;
            }
          }
          return result;
        };
        pp$12.regexp_classString = function(state) {
          var count = 0;
          while (this.regexp_eatClassSetCharacter(state)) {
            count++;
          }
          return count === 1 ? CharSetOk2 : CharSetString2;
        };
        pp$12.regexp_eatClassSetCharacter = function(state) {
          var start2 = state.pos;
          if (state.eat(
            92
            /* \ */
          )) {
            if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
              return true;
            }
            if (state.eat(
              98
              /* b */
            )) {
              state.lastIntValue = 8;
              return true;
            }
            state.pos = start2;
            return false;
          }
          var ch = state.current();
          if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter2(ch)) {
            return false;
          }
          if (isClassSetSyntaxCharacter2(ch)) {
            return false;
          }
          state.advance();
          state.lastIntValue = ch;
          return true;
        };
        function isClassSetReservedDoublePunctuatorCharacter2(ch) {
          return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
        }
        function isClassSetSyntaxCharacter2(ch) {
          return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
        }
        pp$12.regexp_eatClassSetReservedPunctuator = function(state) {
          var ch = state.current();
          if (isClassSetReservedPunctuator2(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
          }
          return false;
        };
        function isClassSetReservedPunctuator2(ch) {
          return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
        }
        pp$12.regexp_eatClassControlLetter = function(state) {
          var ch = state.current();
          if (isDecimalDigit2(ch) || ch === 95) {
            state.lastIntValue = ch % 32;
            state.advance();
            return true;
          }
          return false;
        };
        pp$12.regexp_eatHexEscapeSequence = function(state) {
          var start2 = state.pos;
          if (state.eat(
            120
            /* x */
          )) {
            if (this.regexp_eatFixedHexDigits(state, 2)) {
              return true;
            }
            if (state.switchU) {
              state.raise("Invalid escape");
            }
            state.pos = start2;
          }
          return false;
        };
        pp$12.regexp_eatDecimalDigits = function(state) {
          var start2 = state.pos;
          var ch = 0;
          state.lastIntValue = 0;
          while (isDecimalDigit2(ch = state.current())) {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          }
          return state.pos !== start2;
        };
        function isDecimalDigit2(ch) {
          return ch >= 48 && ch <= 57;
        }
        pp$12.regexp_eatHexDigits = function(state) {
          var start2 = state.pos;
          var ch = 0;
          state.lastIntValue = 0;
          while (isHexDigit2(ch = state.current())) {
            state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
            state.advance();
          }
          return state.pos !== start2;
        };
        function isHexDigit2(ch) {
          return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
        }
        function hexToInt2(ch) {
          if (ch >= 65 && ch <= 70) {
            return 10 + (ch - 65);
          }
          if (ch >= 97 && ch <= 102) {
            return 10 + (ch - 97);
          }
          return ch - 48;
        }
        pp$12.regexp_eatLegacyOctalEscapeSequence = function(state) {
          if (this.regexp_eatOctalDigit(state)) {
            var n1 = state.lastIntValue;
            if (this.regexp_eatOctalDigit(state)) {
              var n2 = state.lastIntValue;
              if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
              } else {
                state.lastIntValue = n1 * 8 + n2;
              }
            } else {
              state.lastIntValue = n1;
            }
            return true;
          }
          return false;
        };
        pp$12.regexp_eatOctalDigit = function(state) {
          var ch = state.current();
          if (isOctalDigit2(ch)) {
            state.lastIntValue = ch - 48;
            state.advance();
            return true;
          }
          state.lastIntValue = 0;
          return false;
        };
        function isOctalDigit2(ch) {
          return ch >= 48 && ch <= 55;
        }
        pp$12.regexp_eatFixedHexDigits = function(state, length) {
          var start2 = state.pos;
          state.lastIntValue = 0;
          for (var i2 = 0; i2 < length; ++i2) {
            var ch = state.current();
            if (!isHexDigit2(ch)) {
              state.pos = start2;
              return false;
            }
            state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
            state.advance();
          }
          return true;
        };
        var Token4 = function Token5(p) {
          this.type = p.type;
          this.value = p.value;
          this.start = p.start;
          this.end = p.end;
          if (p.options.locations) {
            this.loc = new SourceLocation3(p, p.startLoc, p.endLoc);
          }
          if (p.options.ranges) {
            this.range = [p.start, p.end];
          }
        };
        var pp2 = Parser3.prototype;
        pp2.next = function(ignoreEscapeSequenceInKeyword) {
          if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
            this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
          }
          if (this.options.onToken) {
            this.options.onToken(new Token4(this));
          }
          this.lastTokEnd = this.end;
          this.lastTokStart = this.start;
          this.lastTokEndLoc = this.endLoc;
          this.lastTokStartLoc = this.startLoc;
          this.nextToken();
        };
        pp2.getToken = function() {
          this.next();
          return new Token4(this);
        };
        if (typeof Symbol !== "undefined") {
          pp2[Symbol.iterator] = function() {
            var this$1$1 = this;
            return {
              next: function() {
                var token = this$1$1.getToken();
                return {
                  done: token.type === types$12.eof,
                  value: token
                };
              }
            };
          };
        }
        pp2.nextToken = function() {
          var curContext = this.curContext();
          if (!curContext || !curContext.preserveSpace) {
            this.skipSpace();
          }
          this.start = this.pos;
          if (this.options.locations) {
            this.startLoc = this.curPosition();
          }
          if (this.pos >= this.input.length) {
            return this.finishToken(types$12.eof);
          }
          if (curContext.override) {
            return curContext.override(this);
          } else {
            this.readToken(this.fullCharCodeAtPos());
          }
        };
        pp2.readToken = function(code2) {
          if (isIdentifierStart2(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
            return this.readWord();
          }
          return this.getTokenFromCode(code2);
        };
        pp2.fullCharCodeAtPos = function() {
          var code2 = this.input.charCodeAt(this.pos);
          if (code2 <= 55295 || code2 >= 56320) {
            return code2;
          }
          var next = this.input.charCodeAt(this.pos + 1);
          return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
        };
        pp2.skipBlockComment = function() {
          var startLoc = this.options.onComment && this.curPosition();
          var start2 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
          if (end === -1) {
            this.raise(this.pos - 2, "Unterminated comment");
          }
          this.pos = end + 2;
          if (this.options.locations) {
            for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
              ++this.curLine;
              pos = this.lineStart = nextBreak;
            }
          }
          if (this.options.onComment) {
            this.options.onComment(
              true,
              this.input.slice(start2 + 2, end),
              start2,
              this.pos,
              startLoc,
              this.curPosition()
            );
          }
        };
        pp2.skipLineComment = function(startSkip) {
          var start2 = this.pos;
          var startLoc = this.options.onComment && this.curPosition();
          var ch = this.input.charCodeAt(this.pos += startSkip);
          while (this.pos < this.input.length && !isNewLine2(ch)) {
            ch = this.input.charCodeAt(++this.pos);
          }
          if (this.options.onComment) {
            this.options.onComment(
              false,
              this.input.slice(start2 + startSkip, this.pos),
              start2,
              this.pos,
              startLoc,
              this.curPosition()
            );
          }
        };
        pp2.skipSpace = function() {
          loop:
            while (this.pos < this.input.length) {
              var ch = this.input.charCodeAt(this.pos);
              switch (ch) {
                case 32:
                case 160:
                  ++this.pos;
                  break;
                case 13:
                  if (this.input.charCodeAt(this.pos + 1) === 10) {
                    ++this.pos;
                  }
                case 10:
                case 8232:
                case 8233:
                  ++this.pos;
                  if (this.options.locations) {
                    ++this.curLine;
                    this.lineStart = this.pos;
                  }
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.pos + 1)) {
                    case 42:
                      this.skipBlockComment();
                      break;
                    case 47:
                      this.skipLineComment(2);
                      break;
                    default:
                      break loop;
                  }
                  break;
                default:
                  if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace2.test(String.fromCharCode(ch))) {
                    ++this.pos;
                  } else {
                    break loop;
                  }
              }
            }
        };
        pp2.finishToken = function(type, val) {
          this.end = this.pos;
          if (this.options.locations) {
            this.endLoc = this.curPosition();
          }
          var prevType = this.type;
          this.type = type;
          this.value = val;
          this.updateContext(prevType);
        };
        pp2.readToken_dot = function() {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next >= 48 && next <= 57) {
            return this.readNumber(true);
          }
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
            this.pos += 3;
            return this.finishToken(types$12.ellipsis);
          } else {
            ++this.pos;
            return this.finishToken(types$12.dot);
          }
        };
        pp2.readToken_slash = function() {
          var next = this.input.charCodeAt(this.pos + 1);
          if (this.exprAllowed) {
            ++this.pos;
            return this.readRegexp();
          }
          if (next === 61) {
            return this.finishOp(types$12.assign, 2);
          }
          return this.finishOp(types$12.slash, 1);
        };
        pp2.readToken_mult_modulo_exp = function(code2) {
          var next = this.input.charCodeAt(this.pos + 1);
          var size = 1;
          var tokentype = code2 === 42 ? types$12.star : types$12.modulo;
          if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
            ++size;
            tokentype = types$12.starstar;
            next = this.input.charCodeAt(this.pos + 2);
          }
          if (next === 61) {
            return this.finishOp(types$12.assign, size + 1);
          }
          return this.finishOp(tokentype, size);
        };
        pp2.readToken_pipe_amp = function(code2) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === code2) {
            if (this.options.ecmaVersion >= 12) {
              var next2 = this.input.charCodeAt(this.pos + 2);
              if (next2 === 61) {
                return this.finishOp(types$12.assign, 3);
              }
            }
            return this.finishOp(code2 === 124 ? types$12.logicalOR : types$12.logicalAND, 2);
          }
          if (next === 61) {
            return this.finishOp(types$12.assign, 2);
          }
          return this.finishOp(code2 === 124 ? types$12.bitwiseOR : types$12.bitwiseAND, 1);
        };
        pp2.readToken_caret = function() {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 61) {
            return this.finishOp(types$12.assign, 2);
          }
          return this.finishOp(types$12.bitwiseXOR, 1);
        };
        pp2.readToken_plus_min = function(code2) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === code2) {
            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak2.test(this.input.slice(this.lastTokEnd, this.pos)))) {
              this.skipLineComment(3);
              this.skipSpace();
              return this.nextToken();
            }
            return this.finishOp(types$12.incDec, 2);
          }
          if (next === 61) {
            return this.finishOp(types$12.assign, 2);
          }
          return this.finishOp(types$12.plusMin, 1);
        };
        pp2.readToken_lt_gt = function(code2) {
          var next = this.input.charCodeAt(this.pos + 1);
          var size = 1;
          if (next === code2) {
            size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(this.pos + size) === 61) {
              return this.finishOp(types$12.assign, size + 1);
            }
            return this.finishOp(types$12.bitShift, size);
          }
          if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
            this.skipLineComment(4);
            this.skipSpace();
            return this.nextToken();
          }
          if (next === 61) {
            size = 2;
          }
          return this.finishOp(types$12.relational, size);
        };
        pp2.readToken_eq_excl = function(code2) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 61) {
            return this.finishOp(types$12.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
          }
          if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
            this.pos += 2;
            return this.finishToken(types$12.arrow);
          }
          return this.finishOp(code2 === 61 ? types$12.eq : types$12.prefix, 1);
        };
        pp2.readToken_question = function() {
          var ecmaVersion2 = this.options.ecmaVersion;
          if (ecmaVersion2 >= 11) {
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 46) {
              var next2 = this.input.charCodeAt(this.pos + 2);
              if (next2 < 48 || next2 > 57) {
                return this.finishOp(types$12.questionDot, 2);
              }
            }
            if (next === 63) {
              if (ecmaVersion2 >= 12) {
                var next2$1 = this.input.charCodeAt(this.pos + 2);
                if (next2$1 === 61) {
                  return this.finishOp(types$12.assign, 3);
                }
              }
              return this.finishOp(types$12.coalesce, 2);
            }
          }
          return this.finishOp(types$12.question, 1);
        };
        pp2.readToken_numberSign = function() {
          var ecmaVersion2 = this.options.ecmaVersion;
          var code2 = 35;
          if (ecmaVersion2 >= 13) {
            ++this.pos;
            code2 = this.fullCharCodeAtPos();
            if (isIdentifierStart2(code2, true) || code2 === 92) {
              return this.finishToken(types$12.privateId, this.readWord1());
            }
          }
          this.raise(this.pos, "Unexpected character '" + codePointToString2(code2) + "'");
        };
        pp2.getTokenFromCode = function(code2) {
          switch (code2) {
            case 46:
              return this.readToken_dot();
            case 40:
              ++this.pos;
              return this.finishToken(types$12.parenL);
            case 41:
              ++this.pos;
              return this.finishToken(types$12.parenR);
            case 59:
              ++this.pos;
              return this.finishToken(types$12.semi);
            case 44:
              ++this.pos;
              return this.finishToken(types$12.comma);
            case 91:
              ++this.pos;
              return this.finishToken(types$12.bracketL);
            case 93:
              ++this.pos;
              return this.finishToken(types$12.bracketR);
            case 123:
              ++this.pos;
              return this.finishToken(types$12.braceL);
            case 125:
              ++this.pos;
              return this.finishToken(types$12.braceR);
            case 58:
              ++this.pos;
              return this.finishToken(types$12.colon);
            case 96:
              if (this.options.ecmaVersion < 6) {
                break;
              }
              ++this.pos;
              return this.finishToken(types$12.backQuote);
            case 48:
              var next = this.input.charCodeAt(this.pos + 1);
              if (next === 120 || next === 88) {
                return this.readRadixNumber(16);
              }
              if (this.options.ecmaVersion >= 6) {
                if (next === 111 || next === 79) {
                  return this.readRadixNumber(8);
                }
                if (next === 98 || next === 66) {
                  return this.readRadixNumber(2);
                }
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(false);
            case 34:
            case 39:
              return this.readString(code2);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(code2);
            case 124:
            case 38:
              return this.readToken_pipe_amp(code2);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(code2);
            case 60:
            case 62:
              return this.readToken_lt_gt(code2);
            case 61:
            case 33:
              return this.readToken_eq_excl(code2);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(types$12.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + codePointToString2(code2) + "'");
        };
        pp2.finishOp = function(type, size) {
          var str = this.input.slice(this.pos, this.pos + size);
          this.pos += size;
          return this.finishToken(type, str);
        };
        pp2.readRegexp = function() {
          var escaped, inClass, start2 = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length) {
              this.raise(start2, "Unterminated regular expression");
            }
            var ch = this.input.charAt(this.pos);
            if (lineBreak2.test(ch)) {
              this.raise(start2, "Unterminated regular expression");
            }
            if (!escaped) {
              if (ch === "[") {
                inClass = true;
              } else if (ch === "]" && inClass) {
                inClass = false;
              } else if (ch === "/" && !inClass) {
                break;
              }
              escaped = ch === "\\";
            } else {
              escaped = false;
            }
            ++this.pos;
          }
          var pattern = this.input.slice(start2, this.pos);
          ++this.pos;
          var flagsStart = this.pos;
          var flags = this.readWord1();
          if (this.containsEsc) {
            this.unexpected(flagsStart);
          }
          var state = this.regexpState || (this.regexpState = new RegExpValidationState3(this));
          state.reset(start2, pattern, flags);
          this.validateRegExpFlags(state);
          this.validateRegExpPattern(state);
          var value = null;
          try {
            value = new RegExp(pattern, flags);
          } catch (e) {
          }
          return this.finishToken(types$12.regexp, { pattern, flags, value });
        };
        pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
          var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
          var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
          var start2 = this.pos, total = 0, lastCode = 0;
          for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
            var code2 = this.input.charCodeAt(this.pos), val = void 0;
            if (allowSeparators && code2 === 95) {
              if (isLegacyOctalNumericLiteral) {
                this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
              }
              if (lastCode === 95) {
                this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
              }
              if (i2 === 0) {
                this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
              }
              lastCode = code2;
              continue;
            }
            if (code2 >= 97) {
              val = code2 - 97 + 10;
            } else if (code2 >= 65) {
              val = code2 - 65 + 10;
            } else if (code2 >= 48 && code2 <= 57) {
              val = code2 - 48;
            } else {
              val = Infinity;
            }
            if (val >= radix) {
              break;
            }
            lastCode = code2;
            total = total * radix + val;
          }
          if (allowSeparators && lastCode === 95) {
            this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
          }
          if (this.pos === start2 || len != null && this.pos - start2 !== len) {
            return null;
          }
          return total;
        };
        function stringToNumber2(str, isLegacyOctalNumericLiteral) {
          if (isLegacyOctalNumericLiteral) {
            return parseInt(str, 8);
          }
          return parseFloat(str.replace(/_/g, ""));
        }
        function stringToBigInt2(str) {
          if (typeof BigInt !== "function") {
            return null;
          }
          return BigInt(str.replace(/_/g, ""));
        }
        pp2.readRadixNumber = function(radix) {
          var start2 = this.pos;
          this.pos += 2;
          var val = this.readInt(radix);
          if (val == null) {
            this.raise(this.start + 2, "Expected number in radix " + radix);
          }
          if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
            val = stringToBigInt2(this.input.slice(start2, this.pos));
            ++this.pos;
          } else if (isIdentifierStart2(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$12.num, val);
        };
        pp2.readNumber = function(startsWithDot) {
          var start2 = this.pos;
          if (!startsWithDot && this.readInt(10, void 0, true) === null) {
            this.raise(start2, "Invalid number");
          }
          var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
          if (octal && this.strict) {
            this.raise(start2, "Invalid number");
          }
          var next = this.input.charCodeAt(this.pos);
          if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
            var val$1 = stringToBigInt2(this.input.slice(start2, this.pos));
            ++this.pos;
            if (isIdentifierStart2(this.fullCharCodeAtPos())) {
              this.raise(this.pos, "Identifier directly after number");
            }
            return this.finishToken(types$12.num, val$1);
          }
          if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
            octal = false;
          }
          if (next === 46 && !octal) {
            ++this.pos;
            this.readInt(10);
            next = this.input.charCodeAt(this.pos);
          }
          if ((next === 69 || next === 101) && !octal) {
            next = this.input.charCodeAt(++this.pos);
            if (next === 43 || next === 45) {
              ++this.pos;
            }
            if (this.readInt(10) === null) {
              this.raise(start2, "Invalid number");
            }
          }
          if (isIdentifierStart2(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          var val = stringToNumber2(this.input.slice(start2, this.pos), octal);
          return this.finishToken(types$12.num, val);
        };
        pp2.readCodePoint = function() {
          var ch = this.input.charCodeAt(this.pos), code2;
          if (ch === 123) {
            if (this.options.ecmaVersion < 6) {
              this.unexpected();
            }
            var codePos = ++this.pos;
            code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
            ++this.pos;
            if (code2 > 1114111) {
              this.invalidStringToken(codePos, "Code point out of bounds");
            }
          } else {
            code2 = this.readHexChar(4);
          }
          return code2;
        };
        pp2.readString = function(quote) {
          var out = "", chunkStart = ++this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length) {
              this.raise(this.start, "Unterminated string constant");
            }
            var ch = this.input.charCodeAt(this.pos);
            if (ch === quote) {
              break;
            }
            if (ch === 92) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.readEscapedChar(false);
              chunkStart = this.pos;
            } else if (ch === 8232 || ch === 8233) {
              if (this.options.ecmaVersion < 10) {
                this.raise(this.start, "Unterminated string constant");
              }
              ++this.pos;
              if (this.options.locations) {
                this.curLine++;
                this.lineStart = this.pos;
              }
            } else {
              if (isNewLine2(ch)) {
                this.raise(this.start, "Unterminated string constant");
              }
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(types$12.string, out);
        };
        var INVALID_TEMPLATE_ESCAPE_ERROR2 = {};
        pp2.tryReadTemplateToken = function() {
          this.inTemplateElement = true;
          try {
            this.readTmplToken();
          } catch (err) {
            if (err === INVALID_TEMPLATE_ESCAPE_ERROR2) {
              this.readInvalidTemplateToken();
            } else {
              throw err;
            }
          }
          this.inTemplateElement = false;
        };
        pp2.invalidStringToken = function(position4, message) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
            throw INVALID_TEMPLATE_ESCAPE_ERROR2;
          } else {
            this.raise(position4, message);
          }
        };
        pp2.readTmplToken = function() {
          var out = "", chunkStart = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length) {
              this.raise(this.start, "Unterminated template");
            }
            var ch = this.input.charCodeAt(this.pos);
            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
              if (this.pos === this.start && (this.type === types$12.template || this.type === types$12.invalidTemplate)) {
                if (ch === 36) {
                  this.pos += 2;
                  return this.finishToken(types$12.dollarBraceL);
                } else {
                  ++this.pos;
                  return this.finishToken(types$12.backQuote);
                }
              }
              out += this.input.slice(chunkStart, this.pos);
              return this.finishToken(types$12.template, out);
            }
            if (ch === 92) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.readEscapedChar(true);
              chunkStart = this.pos;
            } else if (isNewLine2(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              ++this.pos;
              switch (ch) {
                case 13:
                  if (this.input.charCodeAt(this.pos) === 10) {
                    ++this.pos;
                  }
                case 10:
                  out += "\n";
                  break;
                default:
                  out += String.fromCharCode(ch);
                  break;
              }
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
        };
        pp2.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++) {
            switch (this.input[this.pos]) {
              case "\\":
                ++this.pos;
                break;
              case "$":
                if (this.input[this.pos + 1] !== "{") {
                  break;
                }
              case "`":
                return this.finishToken(types$12.invalidTemplate, this.input.slice(this.start, this.pos));
              case "\r":
                if (this.input[this.pos + 1] === "\n") {
                  ++this.pos;
                }
              case "\n":
              case "\u2028":
              case "\u2029":
                ++this.curLine;
                this.lineStart = this.pos + 1;
                break;
            }
          }
          this.raise(this.start, "Unterminated template");
        };
        pp2.readEscapedChar = function(inTemplate) {
          var ch = this.input.charCodeAt(++this.pos);
          ++this.pos;
          switch (ch) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return codePointToString2(this.readCodePoint());
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            case 56:
            case 57:
              if (this.strict) {
                this.invalidStringToken(
                  this.pos - 1,
                  "Invalid escape sequence"
                );
              }
              if (inTemplate) {
                var codePos = this.pos - 1;
                this.invalidStringToken(
                  codePos,
                  "Invalid escape sequence in template string"
                );
              }
            default:
              if (ch >= 48 && ch <= 55) {
                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                var octal = parseInt(octalStr, 8);
                if (octal > 255) {
                  octalStr = octalStr.slice(0, -1);
                  octal = parseInt(octalStr, 8);
                }
                this.pos += octalStr.length - 1;
                ch = this.input.charCodeAt(this.pos);
                if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                  this.invalidStringToken(
                    this.pos - 1 - octalStr.length,
                    inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                  );
                }
                return String.fromCharCode(octal);
              }
              if (isNewLine2(ch)) {
                if (this.options.locations) {
                  this.lineStart = this.pos;
                  ++this.curLine;
                }
                return "";
              }
              return String.fromCharCode(ch);
          }
        };
        pp2.readHexChar = function(len) {
          var codePos = this.pos;
          var n = this.readInt(16, len);
          if (n === null) {
            this.invalidStringToken(codePos, "Bad character escape sequence");
          }
          return n;
        };
        pp2.readWord1 = function() {
          this.containsEsc = false;
          var word = "", first = true, chunkStart = this.pos;
          var astral = this.options.ecmaVersion >= 6;
          while (this.pos < this.input.length) {
            var ch = this.fullCharCodeAtPos();
            if (isIdentifierChar2(ch, astral)) {
              this.pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
              this.containsEsc = true;
              word += this.input.slice(chunkStart, this.pos);
              var escStart = this.pos;
              if (this.input.charCodeAt(++this.pos) !== 117) {
                this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
              }
              ++this.pos;
              var esc = this.readCodePoint();
              if (!(first ? isIdentifierStart2 : isIdentifierChar2)(esc, astral)) {
                this.invalidStringToken(escStart, "Invalid Unicode escape");
              }
              word += codePointToString2(esc);
              chunkStart = this.pos;
            } else {
              break;
            }
            first = false;
          }
          return word + this.input.slice(chunkStart, this.pos);
        };
        pp2.readWord = function() {
          var word = this.readWord1();
          var type = types$12.name;
          if (this.keywords.test(word)) {
            type = keywords2[word];
          }
          return this.finishToken(type, word);
        };
        var version2 = "8.12.1";
        Parser3.acorn = {
          Parser: Parser3,
          version: version2,
          defaultOptions: defaultOptions2,
          Position: Position4,
          SourceLocation: SourceLocation3,
          getLineInfo: getLineInfo2,
          Node: Node4,
          TokenType: TokenType3,
          tokTypes: types$12,
          keywordTypes: keywords2,
          TokContext: TokContext3,
          tokContexts: types2,
          isIdentifierChar: isIdentifierChar2,
          isIdentifierStart: isIdentifierStart2,
          Token: Token4,
          isNewLine: isNewLine2,
          lineBreak: lineBreak2,
          lineBreakG: lineBreakG2,
          nonASCIIwhitespace: nonASCIIwhitespace2
        };
        function parse5(input, options) {
          return Parser3.parse(input, options);
        }
        function parseExpressionAt2(input, pos, options) {
          return Parser3.parseExpressionAt(input, pos, options);
        }
        function tokenizer2(input, options) {
          return Parser3.tokenizer(input, options);
        }
        exports4.Node = Node4;
        exports4.Parser = Parser3;
        exports4.Position = Position4;
        exports4.SourceLocation = SourceLocation3;
        exports4.TokContext = TokContext3;
        exports4.Token = Token4;
        exports4.TokenType = TokenType3;
        exports4.defaultOptions = defaultOptions2;
        exports4.getLineInfo = getLineInfo2;
        exports4.isIdentifierChar = isIdentifierChar2;
        exports4.isIdentifierStart = isIdentifierStart2;
        exports4.isNewLine = isNewLine2;
        exports4.keywordTypes = keywords2;
        exports4.lineBreak = lineBreak2;
        exports4.lineBreakG = lineBreakG2;
        exports4.nonASCIIwhitespace = nonASCIIwhitespace2;
        exports4.parse = parse5;
        exports4.parseExpressionAt = parseExpressionAt2;
        exports4.tokContexts = types2;
        exports4.tokTypes = types$12;
        exports4.tokenizer = tokenizer2;
        exports4.version = version2;
      });
    }
  });

  // node_modules/acorn-jsx/index.js
  var require_acorn_jsx = __commonJS({
    "node_modules/acorn-jsx/index.js"(exports3, module) {
      "use strict";
      var XHTMLEntities = require_xhtml();
      var hexNumber = /^[\da-fA-F]+$/;
      var decimalNumber = /^\d+$/;
      var acornJsxMap = /* @__PURE__ */ new WeakMap();
      function getJsxTokens(acorn) {
        acorn = acorn.Parser.acorn || acorn;
        let acornJsx2 = acornJsxMap.get(acorn);
        if (!acornJsx2) {
          const tt = acorn.tokTypes;
          const TokContext3 = acorn.TokContext;
          const TokenType3 = acorn.TokenType;
          const tc_oTag = new TokContext3("<tag", false);
          const tc_cTag = new TokContext3("</tag", false);
          const tc_expr = new TokContext3("<tag>...</tag>", true, true);
          const tokContexts = {
            tc_oTag,
            tc_cTag,
            tc_expr
          };
          const tokTypes = {
            jsxName: new TokenType3("jsxName"),
            jsxText: new TokenType3("jsxText", { beforeExpr: true }),
            jsxTagStart: new TokenType3("jsxTagStart", { startsExpr: true }),
            jsxTagEnd: new TokenType3("jsxTagEnd")
          };
          tokTypes.jsxTagStart.updateContext = function() {
            this.context.push(tc_expr);
            this.context.push(tc_oTag);
            this.exprAllowed = false;
          };
          tokTypes.jsxTagEnd.updateContext = function(prevType) {
            let out = this.context.pop();
            if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
              this.context.pop();
              this.exprAllowed = this.curContext() === tc_expr;
            } else {
              this.exprAllowed = true;
            }
          };
          acornJsx2 = { tokContexts, tokTypes };
          acornJsxMap.set(acorn, acornJsx2);
        }
        return acornJsx2;
      }
      function getQualifiedJSXName(object) {
        if (!object)
          return object;
        if (object.type === "JSXIdentifier")
          return object.name;
        if (object.type === "JSXNamespacedName")
          return object.namespace.name + ":" + object.name.name;
        if (object.type === "JSXMemberExpression")
          return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      module.exports = function(options) {
        options = options || {};
        return function(Parser3) {
          return plugin({
            allowNamespaces: options.allowNamespaces !== false,
            allowNamespacedObjects: !!options.allowNamespacedObjects
          }, Parser3);
        };
      };
      Object.defineProperty(module.exports, "tokTypes", {
        get: function get_tokTypes() {
          return getJsxTokens(require_acorn()).tokTypes;
        },
        configurable: true,
        enumerable: true
      });
      function plugin(options, Parser3) {
        const acorn = Parser3.acorn || require_acorn();
        const acornJsx2 = getJsxTokens(acorn);
        const tt = acorn.tokTypes;
        const tok = acornJsx2.tokTypes;
        const tokContexts = acorn.tokContexts;
        const tc_oTag = acornJsx2.tokContexts.tc_oTag;
        const tc_cTag = acornJsx2.tokContexts.tc_cTag;
        const tc_expr = acornJsx2.tokContexts.tc_expr;
        const isNewLine2 = acorn.isNewLine;
        const isIdentifierStart2 = acorn.isIdentifierStart;
        const isIdentifierChar2 = acorn.isIdentifierChar;
        return class extends Parser3 {
          // Expose actual `tokTypes` and `tokContexts` to other plugins.
          static get acornJsx() {
            return acornJsx2;
          }
          // Reads inline JSX contents token.
          jsx_readToken() {
            let out = "", chunkStart = this.pos;
            for (; ; ) {
              if (this.pos >= this.input.length)
                this.raise(this.start, "Unterminated JSX contents");
              let ch = this.input.charCodeAt(this.pos);
              switch (ch) {
                case 60:
                case 123:
                  if (this.pos === this.start) {
                    if (ch === 60 && this.exprAllowed) {
                      ++this.pos;
                      return this.finishToken(tok.jsxTagStart);
                    }
                    return this.getTokenFromCode(ch);
                  }
                  out += this.input.slice(chunkStart, this.pos);
                  return this.finishToken(tok.jsxText, out);
                case 38:
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.jsx_readEntity();
                  chunkStart = this.pos;
                  break;
                case 62:
                case 125:
                  this.raise(
                    this.pos,
                    "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                  );
                default:
                  if (isNewLine2(ch)) {
                    out += this.input.slice(chunkStart, this.pos);
                    out += this.jsx_readNewLine(true);
                    chunkStart = this.pos;
                  } else {
                    ++this.pos;
                  }
              }
            }
          }
          jsx_readNewLine(normalizeCRLF) {
            let ch = this.input.charCodeAt(this.pos);
            let out;
            ++this.pos;
            if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
              out = normalizeCRLF ? "\n" : "\r\n";
            } else {
              out = String.fromCharCode(ch);
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            return out;
          }
          jsx_readString(quote) {
            let out = "", chunkStart = ++this.pos;
            for (; ; ) {
              if (this.pos >= this.input.length)
                this.raise(this.start, "Unterminated string constant");
              let ch = this.input.charCodeAt(this.pos);
              if (ch === quote)
                break;
              if (ch === 38) {
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readEntity();
                chunkStart = this.pos;
              } else if (isNewLine2(ch)) {
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readNewLine(false);
                chunkStart = this.pos;
              } else {
                ++this.pos;
              }
            }
            out += this.input.slice(chunkStart, this.pos++);
            return this.finishToken(tt.string, out);
          }
          jsx_readEntity() {
            let str = "", count = 0, entity;
            let ch = this.input[this.pos];
            if (ch !== "&")
              this.raise(this.pos, "Entity must start with an ampersand");
            let startPos = ++this.pos;
            while (this.pos < this.input.length && count++ < 10) {
              ch = this.input[this.pos++];
              if (ch === ";") {
                if (str[0] === "#") {
                  if (str[1] === "x") {
                    str = str.substr(2);
                    if (hexNumber.test(str))
                      entity = String.fromCharCode(parseInt(str, 16));
                  } else {
                    str = str.substr(1);
                    if (decimalNumber.test(str))
                      entity = String.fromCharCode(parseInt(str, 10));
                  }
                } else {
                  entity = XHTMLEntities[str];
                }
                break;
              }
              str += ch;
            }
            if (!entity) {
              this.pos = startPos;
              return "&";
            }
            return entity;
          }
          // Read a JSX identifier (valid tag or attribute name).
          //
          // Optimized version since JSX identifiers can't contain
          // escape characters and so can be read as single slice.
          // Also assumes that first character was already checked
          // by isIdentifierStart in readToken.
          jsx_readWord() {
            let ch, start2 = this.pos;
            do {
              ch = this.input.charCodeAt(++this.pos);
            } while (isIdentifierChar2(ch) || ch === 45);
            return this.finishToken(tok.jsxName, this.input.slice(start2, this.pos));
          }
          // Parse next token as JSX identifier
          jsx_parseIdentifier() {
            let node3 = this.startNode();
            if (this.type === tok.jsxName)
              node3.name = this.value;
            else if (this.type.keyword)
              node3.name = this.type.keyword;
            else
              this.unexpected();
            this.next();
            return this.finishNode(node3, "JSXIdentifier");
          }
          // Parse namespaced identifier.
          jsx_parseNamespacedName() {
            let startPos = this.start, startLoc = this.startLoc;
            let name2 = this.jsx_parseIdentifier();
            if (!options.allowNamespaces || !this.eat(tt.colon))
              return name2;
            var node3 = this.startNodeAt(startPos, startLoc);
            node3.namespace = name2;
            node3.name = this.jsx_parseIdentifier();
            return this.finishNode(node3, "JSXNamespacedName");
          }
          // Parses element name in any form - namespaced, member
          // or single identifier.
          jsx_parseElementName() {
            if (this.type === tok.jsxTagEnd)
              return "";
            let startPos = this.start, startLoc = this.startLoc;
            let node3 = this.jsx_parseNamespacedName();
            if (this.type === tt.dot && node3.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
              this.unexpected();
            }
            while (this.eat(tt.dot)) {
              let newNode = this.startNodeAt(startPos, startLoc);
              newNode.object = node3;
              newNode.property = this.jsx_parseIdentifier();
              node3 = this.finishNode(newNode, "JSXMemberExpression");
            }
            return node3;
          }
          // Parses any type of JSX attribute value.
          jsx_parseAttributeValue() {
            switch (this.type) {
              case tt.braceL:
                let node3 = this.jsx_parseExpressionContainer();
                if (node3.expression.type === "JSXEmptyExpression")
                  this.raise(node3.start, "JSX attributes must only be assigned a non-empty expression");
                return node3;
              case tok.jsxTagStart:
              case tt.string:
                return this.parseExprAtom();
              default:
                this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
            }
          }
          // JSXEmptyExpression is unique type since it doesn't actually parse anything,
          // and so it should start at the end of last read token (left brace) and finish
          // at the beginning of the next one (right brace).
          jsx_parseEmptyExpression() {
            let node3 = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
            return this.finishNodeAt(node3, "JSXEmptyExpression", this.start, this.startLoc);
          }
          // Parses JSX expression enclosed into curly brackets.
          jsx_parseExpressionContainer() {
            let node3 = this.startNode();
            this.next();
            node3.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
            this.expect(tt.braceR);
            return this.finishNode(node3, "JSXExpressionContainer");
          }
          // Parses following JSX attribute name-value pair.
          jsx_parseAttribute() {
            let node3 = this.startNode();
            if (this.eat(tt.braceL)) {
              this.expect(tt.ellipsis);
              node3.argument = this.parseMaybeAssign();
              this.expect(tt.braceR);
              return this.finishNode(node3, "JSXSpreadAttribute");
            }
            node3.name = this.jsx_parseNamespacedName();
            node3.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
            return this.finishNode(node3, "JSXAttribute");
          }
          // Parses JSX opening tag starting after '<'.
          jsx_parseOpeningElementAt(startPos, startLoc) {
            let node3 = this.startNodeAt(startPos, startLoc);
            node3.attributes = [];
            let nodeName = this.jsx_parseElementName();
            if (nodeName)
              node3.name = nodeName;
            while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
              node3.attributes.push(this.jsx_parseAttribute());
            node3.selfClosing = this.eat(tt.slash);
            this.expect(tok.jsxTagEnd);
            return this.finishNode(node3, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
          }
          // Parses JSX closing tag starting after '</'.
          jsx_parseClosingElementAt(startPos, startLoc) {
            let node3 = this.startNodeAt(startPos, startLoc);
            let nodeName = this.jsx_parseElementName();
            if (nodeName)
              node3.name = nodeName;
            this.expect(tok.jsxTagEnd);
            return this.finishNode(node3, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
          }
          // Parses entire JSX element, including it's opening tag
          // (starting after '<'), attributes, contents and closing tag.
          jsx_parseElementAt(startPos, startLoc) {
            let node3 = this.startNodeAt(startPos, startLoc);
            let children = [];
            let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
            let closingElement = null;
            if (!openingElement.selfClosing) {
              contents:
                for (; ; ) {
                  switch (this.type) {
                    case tok.jsxTagStart:
                      startPos = this.start;
                      startLoc = this.startLoc;
                      this.next();
                      if (this.eat(tt.slash)) {
                        closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                        break contents;
                      }
                      children.push(this.jsx_parseElementAt(startPos, startLoc));
                      break;
                    case tok.jsxText:
                      children.push(this.parseExprAtom());
                      break;
                    case tt.braceL:
                      children.push(this.jsx_parseExpressionContainer());
                      break;
                    default:
                      this.unexpected();
                  }
                }
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(
                  closingElement.start,
                  "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
                );
              }
            }
            let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
            node3["opening" + fragmentOrElement] = openingElement;
            node3["closing" + fragmentOrElement] = closingElement;
            node3.children = children;
            if (this.type === tt.relational && this.value === "<") {
              this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
            }
            return this.finishNode(node3, "JSX" + fragmentOrElement);
          }
          // Parse JSX text
          jsx_parseText() {
            let node3 = this.parseLiteral(this.value);
            node3.type = "JSXText";
            return node3;
          }
          // Parses entire JSX element from current position.
          jsx_parseElement() {
            let startPos = this.start, startLoc = this.startLoc;
            this.next();
            return this.jsx_parseElementAt(startPos, startLoc);
          }
          parseExprAtom(refShortHandDefaultPos) {
            if (this.type === tok.jsxText)
              return this.jsx_parseText();
            else if (this.type === tok.jsxTagStart)
              return this.jsx_parseElement();
            else
              return super.parseExprAtom(refShortHandDefaultPos);
          }
          readToken(code2) {
            let context = this.curContext();
            if (context === tc_expr)
              return this.jsx_readToken();
            if (context === tc_oTag || context === tc_cTag) {
              if (isIdentifierStart2(code2))
                return this.jsx_readWord();
              if (code2 == 62) {
                ++this.pos;
                return this.finishToken(tok.jsxTagEnd);
              }
              if ((code2 === 34 || code2 === 39) && context == tc_oTag)
                return this.jsx_readString(code2);
            }
            if (code2 === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
              ++this.pos;
              return this.finishToken(tok.jsxTagStart);
            }
            return super.readToken(code2);
          }
          updateContext(prevType) {
            if (this.type == tt.braceL) {
              var curContext = this.curContext();
              if (curContext == tc_oTag)
                this.context.push(tokContexts.b_expr);
              else if (curContext == tc_expr)
                this.context.push(tokContexts.b_tmpl);
              else
                super.updateContext(prevType);
              this.exprAllowed = true;
            } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
              this.context.length -= 2;
              this.context.push(tc_cTag);
              this.exprAllowed = false;
            } else {
              return super.updateContext(prevType);
            }
          }
        };
      }
    }
  });

  // node_modules/extend/index.js
  var require_extend = __commonJS({
    "node_modules/extend/index.js"(exports3, module) {
      "use strict";
      var hasOwn2 = Object.prototype.hasOwnProperty;
      var toStr = Object.prototype.toString;
      var defineProperty = Object.defineProperty;
      var gOPD = Object.getOwnPropertyDescriptor;
      var isArray2 = function isArray3(arr) {
        if (typeof Array.isArray === "function") {
          return Array.isArray(arr);
        }
        return toStr.call(arr) === "[object Array]";
      };
      var isPlainObject2 = function isPlainObject3(obj) {
        if (!obj || toStr.call(obj) !== "[object Object]") {
          return false;
        }
        var hasOwnConstructor = hasOwn2.call(obj, "constructor");
        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
          return false;
        }
        var key;
        for (key in obj) {
        }
        return typeof key === "undefined" || hasOwn2.call(obj, key);
      };
      var setProperty = function setProperty2(target, options) {
        if (defineProperty && options.name === "__proto__") {
          defineProperty(target, options.name, {
            enumerable: true,
            configurable: true,
            value: options.newValue,
            writable: true
          });
        } else {
          target[options.name] = options.newValue;
        }
      };
      var getProperty = function getProperty2(obj, name2) {
        if (name2 === "__proto__") {
          if (!hasOwn2.call(obj, name2)) {
            return void 0;
          } else if (gOPD) {
            return gOPD(obj, name2).value;
          }
        }
        return obj[name2];
      };
      module.exports = function extend3() {
        var options, name2, src, copy, copyIsArray, clone;
        var target = arguments[0];
        var i = 1;
        var length = arguments.length;
        var deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[1] || {};
          i = 2;
        }
        if (target == null || typeof target !== "object" && typeof target !== "function") {
          target = {};
        }
        for (; i < length; ++i) {
          options = arguments[i];
          if (options != null) {
            for (name2 in options) {
              src = getProperty(target, name2);
              copy = getProperty(options, name2);
              if (target !== copy) {
                if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray2(copy)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && isArray2(src) ? src : [];
                  } else {
                    clone = src && isPlainObject2(src) ? src : {};
                  }
                  setProperty(target, { name: name2, newValue: extend3(deep, clone, copy) });
                } else if (typeof copy !== "undefined") {
                  setProperty(target, { name: name2, newValue: copy });
                }
              }
            }
          }
        }
        return target;
      };
    }
  });

  // src/worker/fix.js
  var import_he = __toESM(require_he(), 1);
  var __innerHTML;
  var document2 = {
    createElement(tag) {
      return {
        set innerHTML(val) {
          __innerHTML = val;
        },
        get innerHTML() {
          return __innerHTML;
        },
        get textContent() {
          return (0, import_he.decode)(__innerHTML);
        }
      };
    }
  };
  globalThis.document = document2;

  // node_modules/monaco-editor-core/esm/vs/base/common/errors.js
  var ErrorHandler = class {
    constructor() {
      this.listeners = [];
      this.unexpectedErrorHandler = function(e) {
        setTimeout(() => {
          if (e.stack) {
            if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
              throw new ErrorNoTelemetry(e.message + "\n\n" + e.stack);
            }
            throw new Error(e.message + "\n\n" + e.stack);
          }
          throw e;
        }, 0);
      };
    }
    emit(e) {
      this.listeners.forEach((listener) => {
        listener(e);
      });
    }
    onUnexpectedError(e) {
      this.unexpectedErrorHandler(e);
      this.emit(e);
    }
    // For external errors, we don't want the listeners to be called
    onUnexpectedExternalError(e) {
      this.unexpectedErrorHandler(e);
    }
  };
  var errorHandler = new ErrorHandler();
  function onUnexpectedError(e) {
    if (!isCancellationError(e)) {
      errorHandler.onUnexpectedError(e);
    }
    return void 0;
  }
  function transformErrorForSerialization(error) {
    if (error instanceof Error) {
      const { name: name2, message } = error;
      const stack = error.stacktrace || error.stack;
      return {
        $isError: true,
        name: name2,
        message,
        stack,
        noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
      };
    }
    return error;
  }
  var canceledName = "Canceled";
  function isCancellationError(error) {
    if (error instanceof CancellationError) {
      return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  var CancellationError = class extends Error {
    constructor() {
      super(canceledName);
      this.name = this.message;
    }
  };
  var ErrorNoTelemetry = class extends Error {
    constructor(msg) {
      super(msg);
      this.name = "CodeExpectedError";
    }
    static fromError(err) {
      if (err instanceof ErrorNoTelemetry) {
        return err;
      }
      const result = new ErrorNoTelemetry();
      result.message = err.message;
      result.stack = err.stack;
      return result;
    }
    static isErrorNoTelemetry(err) {
      return err.name === "CodeExpectedError";
    }
  };
  var BugIndicatingError = class extends Error {
    constructor(message) {
      super(message || "An unexpected bug occurred.");
      Object.setPrototypeOf(this, BugIndicatingError.prototype);
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/functional.js
  function createSingleCallFunction(fn, fnDidRunCallback) {
    const _this = this;
    let didCall = false;
    let result;
    return function() {
      if (didCall) {
        return result;
      }
      didCall = true;
      if (fnDidRunCallback) {
        try {
          result = fn.apply(_this, arguments);
        } finally {
          fnDidRunCallback();
        }
      } else {
        result = fn.apply(_this, arguments);
      }
      return result;
    };
  }

  // node_modules/monaco-editor-core/esm/vs/base/common/iterator.js
  var Iterable;
  (function(Iterable2) {
    function is2(thing) {
      return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
    }
    Iterable2.is = is2;
    const _empty2 = Object.freeze([]);
    function empty4() {
      return _empty2;
    }
    Iterable2.empty = empty4;
    function* single(element2) {
      yield element2;
    }
    Iterable2.single = single;
    function wrap2(iterableOrElement) {
      if (is2(iterableOrElement)) {
        return iterableOrElement;
      } else {
        return single(iterableOrElement);
      }
    }
    Iterable2.wrap = wrap2;
    function from(iterable) {
      return iterable || _empty2;
    }
    Iterable2.from = from;
    function* reverse(array) {
      for (let i = array.length - 1; i >= 0; i--) {
        yield array[i];
      }
    }
    Iterable2.reverse = reverse;
    function isEmpty(iterable) {
      return !iterable || iterable[Symbol.iterator]().next().done === true;
    }
    Iterable2.isEmpty = isEmpty;
    function first(iterable) {
      return iterable[Symbol.iterator]().next().value;
    }
    Iterable2.first = first;
    function some(iterable, predicate) {
      for (const element2 of iterable) {
        if (predicate(element2)) {
          return true;
        }
      }
      return false;
    }
    Iterable2.some = some;
    function find(iterable, predicate) {
      for (const element2 of iterable) {
        if (predicate(element2)) {
          return element2;
        }
      }
      return void 0;
    }
    Iterable2.find = find;
    function* filter(iterable, predicate) {
      for (const element2 of iterable) {
        if (predicate(element2)) {
          yield element2;
        }
      }
    }
    Iterable2.filter = filter;
    function* map4(iterable, fn) {
      let index4 = 0;
      for (const element2 of iterable) {
        yield fn(element2, index4++);
      }
    }
    Iterable2.map = map4;
    function* concat(...iterables) {
      for (const iterable of iterables) {
        yield* iterable;
      }
    }
    Iterable2.concat = concat;
    function reduce(iterable, reducer, initialValue) {
      let value = initialValue;
      for (const element2 of iterable) {
        value = reducer(value, element2);
      }
      return value;
    }
    Iterable2.reduce = reduce;
    function* slice(arr, from2, to = arr.length) {
      if (from2 < 0) {
        from2 += arr.length;
      }
      if (to < 0) {
        to += arr.length;
      } else if (to > arr.length) {
        to = arr.length;
      }
      for (; from2 < to; from2++) {
        yield arr[from2];
      }
    }
    Iterable2.slice = slice;
    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
      const consumed = [];
      if (atMost === 0) {
        return [consumed, iterable];
      }
      const iterator = iterable[Symbol.iterator]();
      for (let i = 0; i < atMost; i++) {
        const next = iterator.next();
        if (next.done) {
          return [consumed, Iterable2.empty()];
        }
        consumed.push(next.value);
      }
      return [consumed, { [Symbol.iterator]() {
        return iterator;
      } }];
    }
    Iterable2.consume = consume;
    async function asyncToArray(iterable) {
      const result = [];
      for await (const item of iterable) {
        result.push(item);
      }
      return Promise.resolve(result);
    }
    Iterable2.asyncToArray = asyncToArray;
  })(Iterable || (Iterable = {}));

  // node_modules/monaco-editor-core/esm/vs/base/common/lifecycle.js
  var TRACK_DISPOSABLES = false;
  var disposableTracker = null;
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  if (TRACK_DISPOSABLES) {
    const __is_disposable_tracked__ = "__is_disposable_tracked__";
    setDisposableTracker(new class {
      trackDisposable(x) {
        const stack = new Error("Potentially leaked disposable").stack;
        setTimeout(() => {
          if (!x[__is_disposable_tracked__]) {
            console.log(stack);
          }
        }, 3e3);
      }
      setParent(child, parent) {
        if (child && child !== Disposable.None) {
          try {
            child[__is_disposable_tracked__] = true;
          } catch (_a4) {
          }
        }
      }
      markAsDisposed(disposable) {
        if (disposable && disposable !== Disposable.None) {
          try {
            disposable[__is_disposable_tracked__] = true;
          } catch (_a4) {
          }
        }
      }
      markAsSingleton(disposable) {
      }
    }());
  }
  function trackDisposable(x) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
    return x;
  }
  function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
      return;
    }
    for (const child of children) {
      disposableTracker.setParent(child, parent);
    }
  }
  function dispose(arg) {
    if (Iterable.is(arg)) {
      const errors = [];
      for (const d of arg) {
        if (d) {
          try {
            d.dispose();
          } catch (e) {
            errors.push(e);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else if (errors.length > 1) {
        throw new AggregateError(errors, "Encountered errors while disposing of store");
      }
      return Array.isArray(arg) ? [] : arg;
    } else if (arg) {
      arg.dispose();
      return arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn) {
    const self2 = trackDisposable({
      dispose: createSingleCallFunction(() => {
        markAsDisposed(self2);
        fn();
      })
    });
    return self2;
  }
  var DisposableStore = class {
    constructor() {
      this._toDispose = /* @__PURE__ */ new Set();
      this._isDisposed = false;
      trackDisposable(this);
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
      if (this._isDisposed) {
        return;
      }
      markAsDisposed(this);
      this._isDisposed = true;
      this.clear();
    }
    /**
     * @return `true` if this object has been disposed of.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
      if (this._toDispose.size === 0) {
        return;
      }
      try {
        dispose(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
    }
    /**
     * Add a new {@link IDisposable disposable} to the collection.
     */
    add(o) {
      if (!o) {
        return o;
      }
      if (o === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      setParentOfDisposable(o, this);
      if (this._isDisposed) {
        if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
          console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
        }
      } else {
        this._toDispose.add(o);
      }
      return o;
    }
    /**
     * Deletes the value from the store, but does not dispose it.
     */
    deleteAndLeak(o) {
      if (!o) {
        return;
      }
      if (this._toDispose.has(o)) {
        this._toDispose.delete(o);
        setParentOfDisposable(o, null);
      }
    }
  };
  DisposableStore.DISABLE_DISPOSED_WARNING = false;
  var Disposable = class {
    constructor() {
      this._store = new DisposableStore();
      trackDisposable(this);
      setParentOfDisposable(this._store, this);
    }
    dispose() {
      markAsDisposed(this);
      this._store.dispose();
    }
    /**
     * Adds `o` to the collection of disposables managed by this object.
     */
    _register(o) {
      if (o === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      return this._store.add(o);
    }
  };
  Disposable.None = Object.freeze({ dispose() {
  } });
  var DisposableMap = class {
    constructor() {
      this._store = /* @__PURE__ */ new Map();
      this._isDisposed = false;
      trackDisposable(this);
    }
    /**
     * Disposes of all stored values and mark this object as disposed.
     *
     * Trying to use this object after it has been disposed of is an error.
     */
    dispose() {
      markAsDisposed(this);
      this._isDisposed = true;
      this.clearAndDisposeAll();
    }
    /**
     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
     */
    clearAndDisposeAll() {
      if (!this._store.size) {
        return;
      }
      try {
        dispose(this._store.values());
      } finally {
        this._store.clear();
      }
    }
    get(key) {
      return this._store.get(key);
    }
    set(key, value, skipDisposeOnOverwrite = false) {
      var _a4;
      if (this._isDisposed) {
        console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack);
      }
      if (!skipDisposeOnOverwrite) {
        (_a4 = this._store.get(key)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
      }
      this._store.set(key, value);
    }
    /**
     * Delete the value stored for `key` from this map and also dispose of it.
     */
    deleteAndDispose(key) {
      var _a4;
      (_a4 = this._store.get(key)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
      this._store.delete(key);
    }
    [Symbol.iterator]() {
      return this._store[Symbol.iterator]();
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/linkedList.js
  var Node = class {
    constructor(element2) {
      this.element = element2;
      this.next = Node.Undefined;
      this.prev = Node.Undefined;
    }
  };
  Node.Undefined = new Node(void 0);
  var LinkedList = class {
    constructor() {
      this._first = Node.Undefined;
      this._last = Node.Undefined;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    isEmpty() {
      return this._first === Node.Undefined;
    }
    clear() {
      let node3 = this._first;
      while (node3 !== Node.Undefined) {
        const next = node3.next;
        node3.prev = Node.Undefined;
        node3.next = Node.Undefined;
        node3 = next;
      }
      this._first = Node.Undefined;
      this._last = Node.Undefined;
      this._size = 0;
    }
    unshift(element2) {
      return this._insert(element2, false);
    }
    push(element2) {
      return this._insert(element2, true);
    }
    _insert(element2, atTheEnd) {
      const newNode = new Node(element2);
      if (this._first === Node.Undefined) {
        this._first = newNode;
        this._last = newNode;
      } else if (atTheEnd) {
        const oldLast = this._last;
        this._last = newNode;
        newNode.prev = oldLast;
        oldLast.next = newNode;
      } else {
        const oldFirst = this._first;
        this._first = newNode;
        newNode.next = oldFirst;
        oldFirst.prev = newNode;
      }
      this._size += 1;
      let didRemove = false;
      return () => {
        if (!didRemove) {
          didRemove = true;
          this._remove(newNode);
        }
      };
    }
    shift() {
      if (this._first === Node.Undefined) {
        return void 0;
      } else {
        const res = this._first.element;
        this._remove(this._first);
        return res;
      }
    }
    pop() {
      if (this._last === Node.Undefined) {
        return void 0;
      } else {
        const res = this._last.element;
        this._remove(this._last);
        return res;
      }
    }
    _remove(node3) {
      if (node3.prev !== Node.Undefined && node3.next !== Node.Undefined) {
        const anchor = node3.prev;
        anchor.next = node3.next;
        node3.next.prev = anchor;
      } else if (node3.prev === Node.Undefined && node3.next === Node.Undefined) {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
      } else if (node3.next === Node.Undefined) {
        this._last = this._last.prev;
        this._last.next = Node.Undefined;
      } else if (node3.prev === Node.Undefined) {
        this._first = this._first.next;
        this._first.prev = Node.Undefined;
      }
      this._size -= 1;
    }
    *[Symbol.iterator]() {
      let node3 = this._first;
      while (node3 !== Node.Undefined) {
        yield node3.element;
        node3 = node3.next;
      }
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/stopwatch.js
  var hasPerformanceNow = globalThis.performance && typeof globalThis.performance.now === "function";
  var StopWatch = class {
    static create(highResolution) {
      return new StopWatch(highResolution);
    }
    constructor(highResolution) {
      this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
      this._startTime = this._now();
      this._stopTime = -1;
    }
    stop() {
      this._stopTime = this._now();
    }
    reset() {
      this._startTime = this._now();
      this._stopTime = -1;
    }
    elapsed() {
      if (this._stopTime !== -1) {
        return this._stopTime - this._startTime;
      }
      return this._now() - this._startTime;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/event.js
  var _enableListenerGCedWarning = false;
  var _enableDisposeWithListenerWarning = false;
  var _enableSnapshotPotentialLeakWarning = false;
  var Event;
  (function(Event2) {
    Event2.None = () => Disposable.None;
    function _addLeakageTraceLogic(options) {
      if (_enableSnapshotPotentialLeakWarning) {
        const { onDidAddListener: origListenerDidAdd } = options;
        const stack = Stacktrace.create();
        let count = 0;
        options.onDidAddListener = () => {
          if (++count === 2) {
            console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
            stack.print();
          }
          origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
        };
      }
    }
    function defer(event, disposable) {
      return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
    }
    Event2.defer = defer;
    function once(event) {
      return (listener, thisArgs = null, disposables) => {
        let didFire = false;
        let result = void 0;
        result = event((e) => {
          if (didFire) {
            return;
          } else if (result) {
            result.dispose();
          } else {
            didFire = true;
          }
          return listener.call(thisArgs, e);
        }, null, disposables);
        if (didFire) {
          result.dispose();
        }
        return result;
      };
    }
    Event2.once = once;
    function map4(event, map5, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map5(i)), null, disposables), disposable);
    }
    Event2.map = map4;
    function forEach(event, each, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i) => {
        each(i);
        listener.call(thisArgs, i);
      }, null, disposables), disposable);
    }
    Event2.forEach = forEach;
    function filter(event, filter2, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
    }
    Event2.filter = filter;
    function signal(event) {
      return event;
    }
    Event2.signal = signal;
    function any(...events) {
      return (listener, thisArgs = null, disposables) => {
        const disposable = combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e))));
        return addAndReturnDisposable(disposable, disposables);
      };
    }
    Event2.any = any;
    function reduce(event, merge, initial, disposable) {
      let output = initial;
      return map4(event, (e) => {
        output = merge(output, e);
        return output;
      }, disposable);
    }
    Event2.reduce = reduce;
    function snapshot(event, disposable) {
      let listener;
      const options = {
        onWillAddFirstListener() {
          listener = event(emitter.fire, emitter);
        },
        onDidRemoveLastListener() {
          listener === null || listener === void 0 ? void 0 : listener.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
      return emitter.event;
    }
    function addAndReturnDisposable(d, store) {
      if (store instanceof Array) {
        store.push(d);
      } else if (store) {
        store.add(d);
      }
      return d;
    }
    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
      let subscription;
      let output = void 0;
      let handle2 = void 0;
      let numDebouncedCalls = 0;
      let doFire;
      const options = {
        leakWarningThreshold,
        onWillAddFirstListener() {
          subscription = event((cur) => {
            numDebouncedCalls++;
            output = merge(output, cur);
            if (leading && !handle2) {
              emitter.fire(output);
              output = void 0;
            }
            doFire = () => {
              const _output = output;
              output = void 0;
              handle2 = void 0;
              if (!leading || numDebouncedCalls > 1) {
                emitter.fire(_output);
              }
              numDebouncedCalls = 0;
            };
            if (typeof delay === "number") {
              clearTimeout(handle2);
              handle2 = setTimeout(doFire, delay);
            } else {
              if (handle2 === void 0) {
                handle2 = 0;
                queueMicrotask(doFire);
              }
            }
          });
        },
        onWillRemoveListener() {
          if (flushOnListenerRemove && numDebouncedCalls > 0) {
            doFire === null || doFire === void 0 ? void 0 : doFire();
          }
        },
        onDidRemoveLastListener() {
          doFire = void 0;
          subscription.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
      return emitter.event;
    }
    Event2.debounce = debounce;
    function accumulate(event, delay = 0, disposable) {
      return Event2.debounce(event, (last, e) => {
        if (!last) {
          return [e];
        }
        last.push(e);
        return last;
      }, delay, void 0, true, void 0, disposable);
    }
    Event2.accumulate = accumulate;
    function latch(event, equals3 = (a, b) => a === b, disposable) {
      let firstCall = true;
      let cache;
      return filter(event, (value) => {
        const shouldEmit = firstCall || !equals3(value, cache);
        firstCall = false;
        cache = value;
        return shouldEmit;
      }, disposable);
    }
    Event2.latch = latch;
    function split(event, isT, disposable) {
      return [
        Event2.filter(event, isT, disposable),
        Event2.filter(event, (e) => !isT(e), disposable)
      ];
    }
    Event2.split = split;
    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {
      let buffer2 = _buffer.slice();
      let listener = event((e) => {
        if (buffer2) {
          buffer2.push(e);
        } else {
          emitter.fire(e);
        }
      });
      if (disposable) {
        disposable.add(listener);
      }
      const flush = () => {
        buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.forEach((e) => emitter.fire(e));
        buffer2 = null;
      };
      const emitter = new Emitter({
        onWillAddFirstListener() {
          if (!listener) {
            listener = event((e) => emitter.fire(e));
            if (disposable) {
              disposable.add(listener);
            }
          }
        },
        onDidAddFirstListener() {
          if (buffer2) {
            if (flushAfterTimeout) {
              setTimeout(flush);
            } else {
              flush();
            }
          }
        },
        onDidRemoveLastListener() {
          if (listener) {
            listener.dispose();
          }
          listener = null;
        }
      });
      if (disposable) {
        disposable.add(emitter);
      }
      return emitter.event;
    }
    Event2.buffer = buffer;
    function chain(event, sythensize) {
      const fn = (listener, thisArgs, disposables) => {
        const cs = sythensize(new ChainableSynthesis());
        return event(function(value) {
          const result = cs.evaluate(value);
          if (result !== HaltChainable) {
            listener.call(thisArgs, result);
          }
        }, void 0, disposables);
      };
      return fn;
    }
    Event2.chain = chain;
    const HaltChainable = Symbol("HaltChainable");
    class ChainableSynthesis {
      constructor() {
        this.steps = [];
      }
      map(fn) {
        this.steps.push(fn);
        return this;
      }
      forEach(fn) {
        this.steps.push((v) => {
          fn(v);
          return v;
        });
        return this;
      }
      filter(fn) {
        this.steps.push((v) => fn(v) ? v : HaltChainable);
        return this;
      }
      reduce(merge, initial) {
        let last = initial;
        this.steps.push((v) => {
          last = merge(last, v);
          return last;
        });
        return this;
      }
      latch(equals3 = (a, b) => a === b) {
        let firstCall = true;
        let cache;
        this.steps.push((value) => {
          const shouldEmit = firstCall || !equals3(value, cache);
          firstCall = false;
          cache = value;
          return shouldEmit ? value : HaltChainable;
        });
        return this;
      }
      evaluate(value) {
        for (const step of this.steps) {
          value = step(value);
          if (value === HaltChainable) {
            break;
          }
        }
        return value;
      }
    }
    function fromNodeEventEmitter(emitter, eventName, map5 = (id) => id) {
      const fn = (...args) => result.fire(map5(...args));
      const onFirstListenerAdd = () => emitter.on(eventName, fn);
      const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromNodeEventEmitter = fromNodeEventEmitter;
    function fromDOMEventEmitter(emitter, eventName, map5 = (id) => id) {
      const fn = (...args) => result.fire(map5(...args));
      const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
      const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromDOMEventEmitter = fromDOMEventEmitter;
    function toPromise(event) {
      return new Promise((resolve3) => once(event)(resolve3));
    }
    Event2.toPromise = toPromise;
    function fromPromise(promise) {
      const result = new Emitter();
      promise.then((res) => {
        result.fire(res);
      }, () => {
        result.fire(void 0);
      }).finally(() => {
        result.dispose();
      });
      return result.event;
    }
    Event2.fromPromise = fromPromise;
    function runAndSubscribe(event, handler, initial) {
      handler(initial);
      return event((e) => handler(e));
    }
    Event2.runAndSubscribe = runAndSubscribe;
    class EmitterObserver {
      constructor(_observable, store) {
        this._observable = _observable;
        this._counter = 0;
        this._hasChanged = false;
        const options = {
          onWillAddFirstListener: () => {
            _observable.addObserver(this);
          },
          onDidRemoveLastListener: () => {
            _observable.removeObserver(this);
          }
        };
        if (!store) {
          _addLeakageTraceLogic(options);
        }
        this.emitter = new Emitter(options);
        if (store) {
          store.add(this.emitter);
        }
      }
      beginUpdate(_observable) {
        this._counter++;
      }
      handlePossibleChange(_observable) {
      }
      handleChange(_observable, _change) {
        this._hasChanged = true;
      }
      endUpdate(_observable) {
        this._counter--;
        if (this._counter === 0) {
          this._observable.reportChanges();
          if (this._hasChanged) {
            this._hasChanged = false;
            this.emitter.fire(this._observable.get());
          }
        }
      }
    }
    function fromObservable(obs, store) {
      const observer = new EmitterObserver(obs, store);
      return observer.emitter.event;
    }
    Event2.fromObservable = fromObservable;
    function fromObservableLight(observable) {
      return (listener, thisArgs, disposables) => {
        let count = 0;
        let didChange = false;
        const observer = {
          beginUpdate() {
            count++;
          },
          endUpdate() {
            count--;
            if (count === 0) {
              observable.reportChanges();
              if (didChange) {
                didChange = false;
                listener.call(thisArgs);
              }
            }
          },
          handlePossibleChange() {
          },
          handleChange() {
            didChange = true;
          }
        };
        observable.addObserver(observer);
        observable.reportChanges();
        const disposable = {
          dispose() {
            observable.removeObserver(observer);
          }
        };
        if (disposables instanceof DisposableStore) {
          disposables.add(disposable);
        } else if (Array.isArray(disposables)) {
          disposables.push(disposable);
        }
        return disposable;
      };
    }
    Event2.fromObservableLight = fromObservableLight;
  })(Event || (Event = {}));
  var EventProfiling = class {
    constructor(name2) {
      this.listenerCount = 0;
      this.invocationCount = 0;
      this.elapsedOverall = 0;
      this.durations = [];
      this.name = `${name2}_${EventProfiling._idPool++}`;
      EventProfiling.all.add(this);
    }
    start(listenerCount) {
      this._stopWatch = new StopWatch();
      this.listenerCount = listenerCount;
    }
    stop() {
      if (this._stopWatch) {
        const elapsed = this._stopWatch.elapsed();
        this.durations.push(elapsed);
        this.elapsedOverall += elapsed;
        this.invocationCount += 1;
        this._stopWatch = void 0;
      }
    }
  };
  EventProfiling.all = /* @__PURE__ */ new Set();
  EventProfiling._idPool = 0;
  var _globalLeakWarningThreshold = -1;
  var LeakageMonitor = class {
    constructor(_errorHandler, threshold, name2 = Math.random().toString(18).slice(2, 5)) {
      this._errorHandler = _errorHandler;
      this.threshold = threshold;
      this.name = name2;
      this._warnCountdown = 0;
    }
    dispose() {
      var _a4;
      (_a4 = this._stacks) === null || _a4 === void 0 ? void 0 : _a4.clear();
    }
    check(stack, listenerCount) {
      const threshold = this.threshold;
      if (threshold <= 0 || listenerCount < threshold) {
        return void 0;
      }
      if (!this._stacks) {
        this._stacks = /* @__PURE__ */ new Map();
      }
      const count = this._stacks.get(stack.value) || 0;
      this._stacks.set(stack.value, count + 1);
      this._warnCountdown -= 1;
      if (this._warnCountdown <= 0) {
        this._warnCountdown = threshold * 0.5;
        const [topStack, topCount] = this.getMostFrequentStack();
        const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;
        console.warn(message);
        console.warn(topStack);
        const error = new ListenerLeakError(message, topStack);
        this._errorHandler(error);
      }
      return () => {
        const count2 = this._stacks.get(stack.value) || 0;
        this._stacks.set(stack.value, count2 - 1);
      };
    }
    getMostFrequentStack() {
      if (!this._stacks) {
        return void 0;
      }
      let topStack;
      let topCount = 0;
      for (const [stack, count] of this._stacks) {
        if (!topStack || topCount < count) {
          topStack = [stack, count];
          topCount = count;
        }
      }
      return topStack;
    }
  };
  var Stacktrace = class {
    static create() {
      var _a4;
      const err = new Error();
      return new Stacktrace((_a4 = err.stack) !== null && _a4 !== void 0 ? _a4 : "");
    }
    constructor(value) {
      this.value = value;
    }
    print() {
      console.warn(this.value.split("\n").slice(2).join("\n"));
    }
  };
  var ListenerLeakError = class extends Error {
    constructor(message, stack) {
      super(message);
      this.name = "ListenerLeakError";
      this.stack = stack;
    }
  };
  var ListenerRefusalError = class extends Error {
    constructor(message, stack) {
      super(message);
      this.name = "ListenerRefusalError";
      this.stack = stack;
    }
  };
  var UniqueContainer = class {
    constructor(value) {
      this.value = value;
    }
  };
  var compactionThreshold = 2;
  var forEachListener = (listeners, fn) => {
    if (listeners instanceof UniqueContainer) {
      fn(listeners);
    } else {
      for (let i = 0; i < listeners.length; i++) {
        const l = listeners[i];
        if (l) {
          fn(l);
        }
      }
    }
  };
  var _listenerFinalizers = _enableListenerGCedWarning ? new FinalizationRegistry((heldValue) => {
    if (typeof heldValue === "string") {
      console.warn("[LEAKING LISTENER] GC'ed a listener that was NOT yet disposed. This is where is was created:");
      console.warn(heldValue);
    }
  }) : void 0;
  var Emitter = class {
    constructor(options) {
      var _a4, _b3, _c, _d, _e, _f;
      this._size = 0;
      this._options = options;
      this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.leakWarningThreshold) ? new LeakageMonitor((_b3 = options === null || options === void 0 ? void 0 : options.onListenerError) !== null && _b3 !== void 0 ? _b3 : onUnexpectedError, (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.leakWarningThreshold) !== null && _d !== void 0 ? _d : _globalLeakWarningThreshold) : void 0;
      this._perfMon = ((_e = this._options) === null || _e === void 0 ? void 0 : _e._profName) ? new EventProfiling(this._options._profName) : void 0;
      this._deliveryQueue = (_f = this._options) === null || _f === void 0 ? void 0 : _f.deliveryQueue;
    }
    dispose() {
      var _a4, _b3, _c, _d;
      if (!this._disposed) {
        this._disposed = true;
        if (((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) === this) {
          this._deliveryQueue.reset();
        }
        if (this._listeners) {
          if (_enableDisposeWithListenerWarning) {
            const listeners = this._listeners;
            queueMicrotask(() => {
              forEachListener(listeners, (l) => {
                var _a5;
                return (_a5 = l.stack) === null || _a5 === void 0 ? void 0 : _a5.print();
              });
            });
          }
          this._listeners = void 0;
          this._size = 0;
        }
        (_c = (_b3 = this._options) === null || _b3 === void 0 ? void 0 : _b3.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b3);
        (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
      }
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
      var _a4;
      (_a4 = this._event) !== null && _a4 !== void 0 ? _a4 : this._event = (callback, thisArgs, disposables) => {
        var _a5, _b3, _c, _d, _e, _f, _g;
        if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
          const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
          console.warn(message);
          const tuple = (_a5 = this._leakageMon.getMostFrequentStack()) !== null && _a5 !== void 0 ? _a5 : ["UNKNOWN stack", -1];
          const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);
          const errorHandler2 = ((_b3 = this._options) === null || _b3 === void 0 ? void 0 : _b3.onListenerError) || onUnexpectedError;
          errorHandler2(error);
          return Disposable.None;
        }
        if (this._disposed) {
          return Disposable.None;
        }
        if (thisArgs) {
          callback = callback.bind(thisArgs);
        }
        const contained = new UniqueContainer(callback);
        let removeMonitor;
        let stack;
        if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
          contained.stack = Stacktrace.create();
          removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
        }
        if (_enableDisposeWithListenerWarning) {
          contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
        }
        if (!this._listeners) {
          (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onWillAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
          this._listeners = contained;
          (_f = (_e = this._options) === null || _e === void 0 ? void 0 : _e.onDidAddFirstListener) === null || _f === void 0 ? void 0 : _f.call(_e, this);
        } else if (this._listeners instanceof UniqueContainer) {
          (_g = this._deliveryQueue) !== null && _g !== void 0 ? _g : this._deliveryQueue = new EventDeliveryQueuePrivate();
          this._listeners = [this._listeners, contained];
        } else {
          this._listeners.push(contained);
        }
        this._size++;
        const result = toDisposable(() => {
          _listenerFinalizers === null || _listenerFinalizers === void 0 ? void 0 : _listenerFinalizers.unregister(result);
          removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();
          this._removeListener(contained);
        });
        if (disposables instanceof DisposableStore) {
          disposables.add(result);
        } else if (Array.isArray(disposables)) {
          disposables.push(result);
        }
        if (_listenerFinalizers) {
          const stack2 = new Error().stack.split("\n").slice(2).join("\n").trim();
          _listenerFinalizers.register(result, stack2, result);
        }
        return result;
      };
      return this._event;
    }
    _removeListener(listener) {
      var _a4, _b3, _c, _d;
      (_b3 = (_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onWillRemoveListener) === null || _b3 === void 0 ? void 0 : _b3.call(_a4, this);
      if (!this._listeners) {
        return;
      }
      if (this._size === 1) {
        this._listeners = void 0;
        (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this._size = 0;
        return;
      }
      const listeners = this._listeners;
      const index4 = listeners.indexOf(listener);
      if (index4 === -1) {
        console.log("disposed?", this._disposed);
        console.log("size?", this._size);
        console.log("arr?", JSON.stringify(this._listeners));
        throw new Error("Attempted to dispose unknown listener");
      }
      this._size--;
      listeners[index4] = void 0;
      const adjustDeliveryQueue = this._deliveryQueue.current === this;
      if (this._size * compactionThreshold <= listeners.length) {
        let n = 0;
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i]) {
            listeners[n++] = listeners[i];
          } else if (adjustDeliveryQueue) {
            this._deliveryQueue.end--;
            if (n < this._deliveryQueue.i) {
              this._deliveryQueue.i--;
            }
          }
        }
        listeners.length = n;
      }
    }
    _deliver(listener, value) {
      var _a4;
      if (!listener) {
        return;
      }
      const errorHandler2 = ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onListenerError) || onUnexpectedError;
      if (!errorHandler2) {
        listener.value(value);
        return;
      }
      try {
        listener.value(value);
      } catch (e) {
        errorHandler2(e);
      }
    }
    /** Delivers items in the queue. Assumes the queue is ready to go. */
    _deliverQueue(dq) {
      const listeners = dq.current._listeners;
      while (dq.i < dq.end) {
        this._deliver(listeners[dq.i++], dq.value);
      }
      dq.reset();
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
      var _a4, _b3, _c, _d;
      if ((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) {
        this._deliverQueue(this._deliveryQueue);
        (_b3 = this._perfMon) === null || _b3 === void 0 ? void 0 : _b3.stop();
      }
      (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);
      if (!this._listeners) {
      } else if (this._listeners instanceof UniqueContainer) {
        this._deliver(this._listeners, event);
      } else {
        const dq = this._deliveryQueue;
        dq.enqueue(this, event, this._listeners.length);
        this._deliverQueue(dq);
      }
      (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();
    }
    hasListeners() {
      return this._size > 0;
    }
  };
  var EventDeliveryQueuePrivate = class {
    constructor() {
      this.i = -1;
      this.end = 0;
    }
    enqueue(emitter, value, end) {
      this.i = 0;
      this.end = end;
      this.current = emitter;
      this.value = value;
    }
    reset() {
      this.i = this.end;
      this.current = void 0;
      this.value = void 0;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/types.js
  function isString(str) {
    return typeof str === "string";
  }

  // node_modules/monaco-editor-core/esm/vs/base/common/objects.js
  function getAllPropertyNames(obj) {
    let res = [];
    while (Object.prototype !== obj) {
      res = res.concat(Object.getOwnPropertyNames(obj));
      obj = Object.getPrototypeOf(obj);
    }
    return res;
  }
  function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
      if (typeof obj[prop] === "function") {
        methods.push(prop);
      }
    }
    return methods;
  }
  function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }

  // node_modules/monaco-editor-core/esm/vs/nls.js
  var isPseudo = typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
  function _format(message, args) {
    let result;
    if (args.length === 0) {
      result = message;
    } else {
      result = message.replace(/\{(\d+)\}/g, (match, rest) => {
        const index4 = rest[0];
        const arg = args[index4];
        let result2 = match;
        if (typeof arg === "string") {
          result2 = arg;
        } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
          result2 = String(arg);
        }
        return result2;
      });
    }
    if (isPseudo) {
      result = "\uFF3B" + result.replace(/[aouei]/g, "$&$&") + "\uFF3D";
    }
    return result;
  }
  function localize(data2, message, ...args) {
    return _format(message, args);
  }
  function getConfiguredDefaultLocale(_) {
    return void 0;
  }

  // node_modules/monaco-editor-core/esm/vs/base/common/platform.js
  var _a;
  var _b;
  var LANGUAGE_DEFAULT = "en";
  var _isWindows = false;
  var _isMacintosh = false;
  var _isLinux = false;
  var _isLinuxSnap = false;
  var _isNative = false;
  var _isWeb = false;
  var _isElectron = false;
  var _isIOS = false;
  var _isCI = false;
  var _isMobile = false;
  var _locale = void 0;
  var _language = LANGUAGE_DEFAULT;
  var _platformLocale = LANGUAGE_DEFAULT;
  var _translationsConfigFile = void 0;
  var _userAgent = void 0;
  var $globalThis = globalThis;
  var nodeProcess = void 0;
  if (typeof $globalThis.vscode !== "undefined" && typeof $globalThis.vscode.process !== "undefined") {
    nodeProcess = $globalThis.vscode.process;
  } else if (typeof process !== "undefined" && typeof ((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) === "string") {
    nodeProcess = process;
  }
  var isElectronProcess = typeof ((_b = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _b === void 0 ? void 0 : _b.electron) === "string";
  var isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
  if (typeof nodeProcess === "object") {
    _isWindows = nodeProcess.platform === "win32";
    _isMacintosh = nodeProcess.platform === "darwin";
    _isLinux = nodeProcess.platform === "linux";
    _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
    _isElectron = isElectronProcess;
    _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
    if (rawNlsConfig) {
      try {
        const nlsConfig = JSON.parse(rawNlsConfig);
        const resolved = nlsConfig.availableLanguages["*"];
        _locale = nlsConfig.locale;
        _platformLocale = nlsConfig.osLocale;
        _language = resolved ? resolved : LANGUAGE_DEFAULT;
        _translationsConfigFile = nlsConfig._translationsConfigFile;
      } catch (e) {
      }
    }
    _isNative = true;
  } else if (typeof navigator === "object" && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _isWindows = _userAgent.indexOf("Windows") >= 0;
    _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
    _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _isLinux = _userAgent.indexOf("Linux") >= 0;
    _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf("Mobi")) >= 0;
    _isWeb = true;
    const configuredLocale = getConfiguredDefaultLocale(
      // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
      // to ensure that the NLS AMD Loader plugin has been loaded and configured.
      // This is because the loader plugin decides what the default locale is based on
      // how it's able to resolve the strings.
      localize({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_")
    );
    _locale = configuredLocale || LANGUAGE_DEFAULT;
    _language = _locale;
    _platformLocale = navigator.language;
  } else {
    console.error("Unable to resolve platform.");
  }
  var _platform = 0;
  if (_isMacintosh) {
    _platform = 1;
  } else if (_isWindows) {
    _platform = 3;
  } else if (_isLinux) {
    _platform = 2;
  }
  var isWindows = _isWindows;
  var isMacintosh = _isMacintosh;
  var isWebWorker = _isWeb && typeof $globalThis.importScripts === "function";
  var webWorkerOrigin = isWebWorker ? $globalThis.origin : void 0;
  var userAgent = _userAgent;
  var setTimeout0IsFaster = typeof $globalThis.postMessage === "function" && !$globalThis.importScripts;
  var setTimeout0 = (() => {
    if (setTimeout0IsFaster) {
      const pending = [];
      $globalThis.addEventListener("message", (e) => {
        if (e.data && e.data.vscodeScheduleAsyncWork) {
          for (let i = 0, len = pending.length; i < len; i++) {
            const candidate = pending[i];
            if (candidate.id === e.data.vscodeScheduleAsyncWork) {
              pending.splice(i, 1);
              candidate.callback();
              return;
            }
          }
        }
      });
      let lastId = 0;
      return (callback) => {
        const myId = ++lastId;
        pending.push({
          id: myId,
          callback
        });
        $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
      };
    }
    return (callback) => setTimeout(callback);
  })();
  var isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
  var isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
  var isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
  var isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
  var isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

  // node_modules/monaco-editor-core/esm/vs/base/common/cache.js
  function identity(t) {
    return t;
  }
  var LRUCachedFunction = class {
    constructor(arg1, arg2) {
      this.lastCache = void 0;
      this.lastArgKey = void 0;
      if (typeof arg1 === "function") {
        this._fn = arg1;
        this._computeKey = identity;
      } else {
        this._fn = arg2;
        this._computeKey = arg1.getCacheKey;
      }
    }
    get(arg) {
      const key = this._computeKey(arg);
      if (this.lastArgKey !== key) {
        this.lastArgKey = key;
        this.lastCache = this._fn(arg);
      }
      return this.lastCache;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/lazy.js
  var Lazy = class {
    constructor(executor) {
      this.executor = executor;
      this._didRun = false;
    }
    /**
     * Get the wrapped value.
     *
     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
     */
    get value() {
      if (!this._didRun) {
        try {
          this._value = this.executor();
        } catch (err) {
          this._error = err;
        } finally {
          this._didRun = true;
        }
      }
      if (this._error) {
        throw this._error;
      }
      return this._value;
    }
    /**
     * Get the wrapped value without forcing evaluation.
     */
    get rawValue() {
      return this._value;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/strings.js
  var _a2;
  function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
  }
  function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function isUpperAsciiLetter(code2) {
    return code2 >= 65 && code2 <= 90;
  }
  function isHighSurrogate(charCode) {
    return 55296 <= charCode && charCode <= 56319;
  }
  function isLowSurrogate(charCode) {
    return 56320 <= charCode && charCode <= 57343;
  }
  function computeCodePoint(highSurrogate, lowSurrogate) {
    return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
  }
  function getNextCodePoint(str, len, offset2) {
    const charCode = str.charCodeAt(offset2);
    if (isHighSurrogate(charCode) && offset2 + 1 < len) {
      const nextCharCode = str.charCodeAt(offset2 + 1);
      if (isLowSurrogate(nextCharCode)) {
        return computeCodePoint(charCode, nextCharCode);
      }
    }
    return charCode;
  }
  var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
  function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
  }
  var UTF8_BOM_CHARACTER = String.fromCharCode(
    65279
    /* CharCode.UTF8_BOM */
  );
  var GraphemeBreakTree = class {
    static getInstance() {
      if (!GraphemeBreakTree._INSTANCE) {
        GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
      }
      return GraphemeBreakTree._INSTANCE;
    }
    constructor() {
      this._data = getGraphemeBreakRawData();
    }
    getGraphemeBreakType(codePoint) {
      if (codePoint < 32) {
        if (codePoint === 10) {
          return 3;
        }
        if (codePoint === 13) {
          return 2;
        }
        return 4;
      }
      if (codePoint < 127) {
        return 0;
      }
      const data2 = this._data;
      const nodeCount = data2.length / 3;
      let nodeIndex = 1;
      while (nodeIndex <= nodeCount) {
        if (codePoint < data2[3 * nodeIndex]) {
          nodeIndex = 2 * nodeIndex;
        } else if (codePoint > data2[3 * nodeIndex + 1]) {
          nodeIndex = 2 * nodeIndex + 1;
        } else {
          return data2[3 * nodeIndex + 2];
        }
      }
      return 0;
    }
  };
  GraphemeBreakTree._INSTANCE = null;
  function getGraphemeBreakRawData() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  var AmbiguousCharacters = class {
    static getInstance(locales) {
      return _a2.cache.get(Array.from(locales));
    }
    static getLocales() {
      return _a2._locales.value;
    }
    constructor(confusableDictionary) {
      this.confusableDictionary = confusableDictionary;
    }
    isAmbiguous(codePoint) {
      return this.confusableDictionary.has(codePoint);
    }
    /**
     * Returns the non basic ASCII code point that the given code point can be confused,
     * or undefined if such code point does note exist.
     */
    getPrimaryConfusable(codePoint) {
      return this.confusableDictionary.get(codePoint);
    }
    getConfusableCodePoints() {
      return new Set(this.confusableDictionary.keys());
    }
  };
  _a2 = AmbiguousCharacters;
  AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
    return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
  });
  AmbiguousCharacters.cache = new LRUCachedFunction({ getCacheKey: JSON.stringify }, (locales) => {
    function arrayToMap(arr) {
      const result = /* @__PURE__ */ new Map();
      for (let i = 0; i < arr.length; i += 2) {
        result.set(arr[i], arr[i + 1]);
      }
      return result;
    }
    function mergeMaps(map1, map22) {
      const result = new Map(map1);
      for (const [key, value] of map22) {
        result.set(key, value);
      }
      return result;
    }
    function intersectMaps(map1, map22) {
      if (!map1) {
        return map22;
      }
      const result = /* @__PURE__ */ new Map();
      for (const [key, value] of map1) {
        if (map22.has(key)) {
          result.set(key, value);
        }
      }
      return result;
    }
    const data2 = _a2.ambiguousCharacterData.value;
    let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data2);
    if (filteredLocales.length === 0) {
      filteredLocales = ["_default"];
    }
    let languageSpecificMap = void 0;
    for (const locale2 of filteredLocales) {
      const map5 = arrayToMap(data2[locale2]);
      languageSpecificMap = intersectMaps(languageSpecificMap, map5);
    }
    const commonMap = arrayToMap(data2["_common"]);
    const map4 = mergeMaps(commonMap, languageSpecificMap);
    return new _a2(map4);
  });
  AmbiguousCharacters._locales = new Lazy(() => Object.keys(_a2.ambiguousCharacterData.value).filter((k) => !k.startsWith("_")));
  var InvisibleCharacters = class {
    static getRawData() {
      return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
    }
    static getData() {
      if (!this._data) {
        this._data = new Set(InvisibleCharacters.getRawData());
      }
      return this._data;
    }
    static isInvisibleCharacter(codePoint) {
      return InvisibleCharacters.getData().has(codePoint);
    }
    static get codePoints() {
      return InvisibleCharacters.getData();
    }
  };
  InvisibleCharacters._data = void 0;

  // node_modules/monaco-editor-core/esm/vs/base/common/worker/simpleWorker.js
  var INITIALIZE = "$initialize";
  var RequestMessage = class {
    constructor(vsWorker, req, method, args) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.method = method;
      this.args = args;
      this.type = 0;
    }
  };
  var ReplyMessage = class {
    constructor(vsWorker, seq, res, err) {
      this.vsWorker = vsWorker;
      this.seq = seq;
      this.res = res;
      this.err = err;
      this.type = 1;
    }
  };
  var SubscribeEventMessage = class {
    constructor(vsWorker, req, eventName, arg) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.eventName = eventName;
      this.arg = arg;
      this.type = 2;
    }
  };
  var EventMessage = class {
    constructor(vsWorker, req, event) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.event = event;
      this.type = 3;
    }
  };
  var UnsubscribeEventMessage = class {
    constructor(vsWorker, req) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.type = 4;
    }
  };
  var SimpleWorkerProtocol = class {
    constructor(handler) {
      this._workerId = -1;
      this._handler = handler;
      this._lastSentReq = 0;
      this._pendingReplies = /* @__PURE__ */ Object.create(null);
      this._pendingEmitters = /* @__PURE__ */ new Map();
      this._pendingEvents = /* @__PURE__ */ new Map();
    }
    setWorkerId(workerId) {
      this._workerId = workerId;
    }
    sendMessage(method, args) {
      const req = String(++this._lastSentReq);
      return new Promise((resolve3, reject) => {
        this._pendingReplies[req] = {
          resolve: resolve3,
          reject
        };
        this._send(new RequestMessage(this._workerId, req, method, args));
      });
    }
    listen(eventName, arg) {
      let req = null;
      const emitter = new Emitter({
        onWillAddFirstListener: () => {
          req = String(++this._lastSentReq);
          this._pendingEmitters.set(req, emitter);
          this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
        },
        onDidRemoveLastListener: () => {
          this._pendingEmitters.delete(req);
          this._send(new UnsubscribeEventMessage(this._workerId, req));
          req = null;
        }
      });
      return emitter.event;
    }
    handleMessage(message) {
      if (!message || !message.vsWorker) {
        return;
      }
      if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
        return;
      }
      this._handleMessage(message);
    }
    _handleMessage(msg) {
      switch (msg.type) {
        case 1:
          return this._handleReplyMessage(msg);
        case 0:
          return this._handleRequestMessage(msg);
        case 2:
          return this._handleSubscribeEventMessage(msg);
        case 3:
          return this._handleEventMessage(msg);
        case 4:
          return this._handleUnsubscribeEventMessage(msg);
      }
    }
    _handleReplyMessage(replyMessage) {
      if (!this._pendingReplies[replyMessage.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      const reply = this._pendingReplies[replyMessage.seq];
      delete this._pendingReplies[replyMessage.seq];
      if (replyMessage.err) {
        let err = replyMessage.err;
        if (replyMessage.err.$isError) {
          err = new Error();
          err.name = replyMessage.err.name;
          err.message = replyMessage.err.message;
          err.stack = replyMessage.err.stack;
        }
        reply.reject(err);
        return;
      }
      reply.resolve(replyMessage.res);
    }
    _handleRequestMessage(requestMessage) {
      const req = requestMessage.req;
      const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
      result.then((r) => {
        this._send(new ReplyMessage(this._workerId, req, r, void 0));
      }, (e) => {
        if (e.detail instanceof Error) {
          e.detail = transformErrorForSerialization(e.detail);
        }
        this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));
      });
    }
    _handleSubscribeEventMessage(msg) {
      const req = msg.req;
      const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
        this._send(new EventMessage(this._workerId, req, event));
      });
      this._pendingEvents.set(req, disposable);
    }
    _handleEventMessage(msg) {
      if (!this._pendingEmitters.has(msg.req)) {
        console.warn("Got event for unknown req");
        return;
      }
      this._pendingEmitters.get(msg.req).fire(msg.event);
    }
    _handleUnsubscribeEventMessage(msg) {
      if (!this._pendingEvents.has(msg.req)) {
        console.warn("Got unsubscribe for unknown req");
        return;
      }
      this._pendingEvents.get(msg.req).dispose();
      this._pendingEvents.delete(msg.req);
    }
    _send(msg) {
      const transfer = [];
      if (msg.type === 0) {
        for (let i = 0; i < msg.args.length; i++) {
          if (msg.args[i] instanceof ArrayBuffer) {
            transfer.push(msg.args[i]);
          }
        }
      } else if (msg.type === 1) {
        if (msg.res instanceof ArrayBuffer) {
          transfer.push(msg.res);
        }
      }
      this._handler.sendMessage(msg, transfer);
    }
  };
  function propertyIsEvent(name2) {
    return name2[0] === "o" && name2[1] === "n" && isUpperAsciiLetter(name2.charCodeAt(2));
  }
  function propertyIsDynamicEvent(name2) {
    return /^onDynamic/.test(name2) && isUpperAsciiLetter(name2.charCodeAt(9));
  }
  function createProxyObject2(methodNames, invoke, proxyListen) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const createProxyDynamicEvent = (eventName) => {
      return function(arg) {
        return proxyListen(eventName, arg);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      if (propertyIsDynamicEvent(methodName)) {
        result[methodName] = createProxyDynamicEvent(methodName);
        continue;
      }
      if (propertyIsEvent(methodName)) {
        result[methodName] = proxyListen(methodName, void 0);
        continue;
      }
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  var SimpleWorkerServer = class {
    constructor(postMessage, requestHandlerFactory) {
      this._requestHandlerFactory = requestHandlerFactory;
      this._requestHandler = null;
      this._protocol = new SimpleWorkerProtocol({
        sendMessage: (msg, transfer) => {
          postMessage(msg, transfer);
        },
        handleMessage: (method, args) => this._handleMessage(method, args),
        handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)
      });
    }
    onmessage(msg) {
      this._protocol.handleMessage(msg);
    }
    _handleMessage(method, args) {
      if (method === INITIALIZE) {
        return this.initialize(args[0], args[1], args[2], args[3]);
      }
      if (!this._requestHandler || typeof this._requestHandler[method] !== "function") {
        return Promise.reject(new Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    _handleEvent(eventName, arg) {
      if (!this._requestHandler) {
        throw new Error(`Missing requestHandler`);
      }
      if (propertyIsDynamicEvent(eventName)) {
        const event = this._requestHandler[eventName].call(this._requestHandler, arg);
        if (typeof event !== "function") {
          throw new Error(`Missing dynamic event ${eventName} on request handler.`);
        }
        return event;
      }
      if (propertyIsEvent(eventName)) {
        const event = this._requestHandler[eventName];
        if (typeof event !== "function") {
          throw new Error(`Missing event ${eventName} on request handler.`);
        }
        return event;
      }
      throw new Error(`Malformed event name ${eventName}`);
    }
    initialize(workerId, loaderConfig, moduleId, hostMethods) {
      this._protocol.setWorkerId(workerId);
      const proxyMethodRequest = (method, args) => {
        return this._protocol.sendMessage(method, args);
      };
      const proxyListen = (eventName, arg) => {
        return this._protocol.listen(eventName, arg);
      };
      const hostProxy = createProxyObject2(hostMethods, proxyMethodRequest, proxyListen);
      if (this._requestHandlerFactory) {
        this._requestHandler = this._requestHandlerFactory(hostProxy);
        return Promise.resolve(getAllMethodNames(this._requestHandler));
      }
      if (loaderConfig) {
        if (typeof loaderConfig.baseUrl !== "undefined") {
          delete loaderConfig["baseUrl"];
        }
        if (typeof loaderConfig.paths !== "undefined") {
          if (typeof loaderConfig.paths.vs !== "undefined") {
            delete loaderConfig.paths["vs"];
          }
        }
        if (typeof loaderConfig.trustedTypesPolicy !== "undefined") {
          delete loaderConfig["trustedTypesPolicy"];
        }
        loaderConfig.catchError = true;
        globalThis.require.config(loaderConfig);
      }
      return new Promise((resolve3, reject) => {
        const req = globalThis.require;
        req([moduleId], (module) => {
          this._requestHandler = module.create(hostProxy);
          if (!this._requestHandler) {
            reject(new Error(`No RequestHandler!`));
            return;
          }
          resolve3(getAllMethodNames(this._requestHandler));
        }, reject);
      });
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/diff/diffChange.js
  var DiffChange = class {
    /**
     * Constructs a new DiffChange with the given sequence information
     * and content.
     */
    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
      this.originalStart = originalStart;
      this.originalLength = originalLength;
      this.modifiedStart = modifiedStart;
      this.modifiedLength = modifiedLength;
    }
    /**
     * The end point (exclusive) of the change in the original sequence.
     */
    getOriginalEnd() {
      return this.originalStart + this.originalLength;
    }
    /**
     * The end point (exclusive) of the change in the modified sequence.
     */
    getModifiedEnd() {
      return this.modifiedStart + this.modifiedLength;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/hash.js
  function numberHash(val, initialHashVal) {
    return (initialHashVal << 5) - initialHashVal + val | 0;
  }
  function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
      hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
  }
  function leftRotate(value, bits, totalBits = 32) {
    const delta = totalBits - bits;
    const mask = ~((1 << delta) - 1);
    return (value << bits | (mask & value) >>> delta) >>> 0;
  }
  function fill(dest, index4 = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
      dest[index4 + i] = value;
    }
  }
  function leftPad(value, length, char = "0") {
    while (value.length < length) {
      value = char + value;
    }
    return value;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  var StringSHA1 = class {
    constructor() {
      this._h0 = 1732584193;
      this._h1 = 4023233417;
      this._h2 = 2562383102;
      this._h3 = 271733878;
      this._h4 = 3285377520;
      this._buff = new Uint8Array(
        64 + 3
        /* to fit any utf-8 */
      );
      this._buffDV = new DataView(this._buff.buffer);
      this._buffLen = 0;
      this._totalLen = 0;
      this._leftoverHighSurrogate = 0;
      this._finished = false;
    }
    update(str) {
      const strLen = str.length;
      if (strLen === 0) {
        return;
      }
      const buff = this._buff;
      let buffLen = this._buffLen;
      let leftoverHighSurrogate = this._leftoverHighSurrogate;
      let charCode;
      let offset2;
      if (leftoverHighSurrogate !== 0) {
        charCode = leftoverHighSurrogate;
        offset2 = -1;
        leftoverHighSurrogate = 0;
      } else {
        charCode = str.charCodeAt(0);
        offset2 = 0;
      }
      while (true) {
        let codePoint = charCode;
        if (isHighSurrogate(charCode)) {
          if (offset2 + 1 < strLen) {
            const nextCharCode = str.charCodeAt(offset2 + 1);
            if (isLowSurrogate(nextCharCode)) {
              offset2++;
              codePoint = computeCodePoint(charCode, nextCharCode);
            } else {
              codePoint = 65533;
            }
          } else {
            leftoverHighSurrogate = charCode;
            break;
          }
        } else if (isLowSurrogate(charCode)) {
          codePoint = 65533;
        }
        buffLen = this._push(buff, buffLen, codePoint);
        offset2++;
        if (offset2 < strLen) {
          charCode = str.charCodeAt(offset2);
        } else {
          break;
        }
      }
      this._buffLen = buffLen;
      this._leftoverHighSurrogate = leftoverHighSurrogate;
    }
    _push(buff, buffLen, codePoint) {
      if (codePoint < 128) {
        buff[buffLen++] = codePoint;
      } else if (codePoint < 2048) {
        buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint < 65536) {
        buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else {
        buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
        buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      }
      if (buffLen >= 64) {
        this._step();
        buffLen -= 64;
        this._totalLen += 64;
        buff[0] = buff[64 + 0];
        buff[1] = buff[64 + 1];
        buff[2] = buff[64 + 2];
      }
      return buffLen;
    }
    digest() {
      if (!this._finished) {
        this._finished = true;
        if (this._leftoverHighSurrogate) {
          this._leftoverHighSurrogate = 0;
          this._buffLen = this._push(
            this._buff,
            this._buffLen,
            65533
            /* SHA1Constant.UNICODE_REPLACEMENT */
          );
        }
        this._totalLen += this._buffLen;
        this._wrapUp();
      }
      return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
    }
    _wrapUp() {
      this._buff[this._buffLen++] = 128;
      fill(this._buff, this._buffLen);
      if (this._buffLen > 56) {
        this._step();
        fill(this._buff);
      }
      const ml = 8 * this._totalLen;
      this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
      this._buffDV.setUint32(60, ml % 4294967296, false);
      this._step();
    }
    _step() {
      const bigBlock32 = StringSHA1._bigBlock32;
      const data2 = this._buffDV;
      for (let j = 0; j < 64; j += 4) {
        bigBlock32.setUint32(j, data2.getUint32(j, false), false);
      }
      for (let j = 64; j < 320; j += 4) {
        bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
      }
      let a = this._h0;
      let b = this._h1;
      let c = this._h2;
      let d = this._h3;
      let e = this._h4;
      let f, k;
      let temp;
      for (let j = 0; j < 80; j++) {
        if (j < 20) {
          f = b & c | ~b & d;
          k = 1518500249;
        } else if (j < 40) {
          f = b ^ c ^ d;
          k = 1859775393;
        } else if (j < 60) {
          f = b & c | b & d | c & d;
          k = 2400959708;
        } else {
          f = b ^ c ^ d;
          k = 3395469782;
        }
        temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
        e = d;
        d = c;
        c = leftRotate(b, 30);
        b = a;
        a = temp;
      }
      this._h0 = this._h0 + a & 4294967295;
      this._h1 = this._h1 + b & 4294967295;
      this._h2 = this._h2 + c & 4294967295;
      this._h3 = this._h3 + d & 4294967295;
      this._h4 = this._h4 + e & 4294967295;
    }
  };
  StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));

  // node_modules/monaco-editor-core/esm/vs/base/common/diff/diff.js
  var StringDiffSequence = class {
    constructor(source) {
      this.source = source;
    }
    getElements() {
      const source = this.source;
      const characters = new Int32Array(source.length);
      for (let i = 0, len = source.length; i < len; i++) {
        characters[i] = source.charCodeAt(i);
      }
      return characters;
    }
  };
  function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
  }
  var Debug = class {
    static Assert(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
  };
  var MyArray = class {
    /**
     * Copies a range of elements from an Array starting at the specified source index and pastes
     * them to another Array starting at the specified destination index. The length and the indexes
     * are specified as 64-bit integers.
     * sourceArray:
     *		The Array that contains the data to copy.
     * sourceIndex:
     *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
     * destinationArray:
     *		The Array that receives the data.
     * destinationIndex:
     *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
     * length:
     *		A 64-bit integer that represents the number of elements to copy.
     */
    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
      for (let i = 0; i < length; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
      for (let i = 0; i < length; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
  };
  var DiffChangeHelper = class {
    /**
     * Constructs a new DiffChangeHelper for the given DiffSequences.
     */
    constructor() {
      this.m_changes = [];
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
    }
    /**
     * Marks the beginning of the next change in the set of differences.
     */
    MarkNextChange() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
      }
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
    }
    /**
     * Adds the original element at the given position to the elements
     * affected by the current change. The modified index gives context
     * to the change position with respect to the original sequence.
     * @param originalIndex The index of the original element to add.
     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
     */
    AddOriginalElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_originalCount++;
    }
    /**
     * Adds the modified element at the given position to the elements
     * affected by the current change. The original index gives context
     * to the change position with respect to the modified sequence.
     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
     * @param modifiedIndex The index of the modified element to add.
     */
    AddModifiedElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_modifiedCount++;
    }
    /**
     * Retrieves all of the changes marked by the class.
     */
    getChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      return this.m_changes;
    }
    /**
     * Retrieves all of the changes marked by the class in the reverse order
     */
    getReverseChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      this.m_changes.reverse();
      return this.m_changes;
    }
  };
  var LcsDiff = class {
    /**
     * Constructs the DiffFinder
     */
    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
      this.ContinueProcessingPredicate = continueProcessingPredicate;
      this._originalSequence = originalSequence;
      this._modifiedSequence = modifiedSequence;
      const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);
      const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);
      this._hasStrings = originalHasStrings && modifiedHasStrings;
      this._originalStringElements = originalStringElements;
      this._originalElementsOrHash = originalElementsOrHash;
      this._modifiedStringElements = modifiedStringElements;
      this._modifiedElementsOrHash = modifiedElementsOrHash;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
    }
    static _isStringArray(arr) {
      return arr.length > 0 && typeof arr[0] === "string";
    }
    static _getElements(sequence) {
      const elements = sequence.getElements();
      if (LcsDiff._isStringArray(elements)) {
        const hashes = new Int32Array(elements.length);
        for (let i = 0, len = elements.length; i < len; i++) {
          hashes[i] = stringHash(elements[i], 0);
        }
        return [elements, hashes, true];
      }
      if (elements instanceof Int32Array) {
        return [[], elements, false];
      }
      return [[], new Int32Array(elements), false];
    }
    ElementsAreEqual(originalIndex, newIndex) {
      if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
    }
    ElementsAreStrictEqual(originalIndex, newIndex) {
      if (!this.ElementsAreEqual(originalIndex, newIndex)) {
        return false;
      }
      const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);
      const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
      return originalElement === modifiedElement;
    }
    static _getStrictElement(sequence, index4) {
      if (typeof sequence.getStrictElement === "function") {
        return sequence.getStrictElement(index4);
      }
      return null;
    }
    OriginalElementsAreEqual(index1, index22) {
      if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index22]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index22] : true;
    }
    ModifiedElementsAreEqual(index1, index22) {
      if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index22]) {
        return false;
      }
      return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index22] : true;
    }
    ComputeDiff(pretty) {
      return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    }
    /**
     * Computes the differences between the original and modified input
     * sequences on the bounded range.
     * @returns An array of the differences between the two input sequences.
     */
    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
      const quitEarlyArr = [false];
      let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
      if (pretty) {
        changes = this.PrettifyChanges(changes);
      }
      return {
        quitEarly: quitEarlyArr[0],
        changes
      };
    }
    /**
     * Private helper method which computes the differences on the bounded range
     * recursively.
     * @returns An array of the differences between the two input sequences.
     */
    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
      quitEarlyArr[0] = false;
      while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
        originalStart++;
        modifiedStart++;
      }
      while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
        originalEnd--;
        modifiedEnd--;
      }
      if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
        let changes;
        if (modifiedStart <= modifiedEnd) {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          changes = [
            new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        } else if (originalStart <= originalEnd) {
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
          ];
        } else {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [];
        }
        return changes;
      }
      const midOriginalArr = [0];
      const midModifiedArr = [0];
      const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
      const midOriginal = midOriginalArr[0];
      const midModified = midModifiedArr[0];
      if (result !== null) {
        return result;
      } else if (!quitEarlyArr[0]) {
        const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
        let rightChanges = [];
        if (!quitEarlyArr[0]) {
          rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
        } else {
          rightChanges = [
            new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
          ];
        }
        return this.ConcatenateChanges(leftChanges, rightChanges);
      }
      return [
        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
      ];
    }
    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
      let forwardChanges = null;
      let reverseChanges = null;
      let changeHelper = new DiffChangeHelper();
      let diagonalMin = diagonalForwardStart;
      let diagonalMax = diagonalForwardEnd;
      let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
      let lastOriginalIndex = -1073741824;
      let historyIndex = this.m_forwardHistory.length - 1;
      do {
        const diagonal = diagonalRelative + diagonalForwardBase;
        if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
          originalIndex = forwardPoints[diagonal + 1];
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex;
          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
          diagonalRelative = diagonal + 1 - diagonalForwardBase;
        } else {
          originalIndex = forwardPoints[diagonal - 1] + 1;
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex - 1;
          changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
          diagonalRelative = diagonal - 1 - diagonalForwardBase;
        }
        if (historyIndex >= 0) {
          forwardPoints = this.m_forwardHistory[historyIndex];
          diagonalForwardBase = forwardPoints[0];
          diagonalMin = 1;
          diagonalMax = forwardPoints.length - 1;
        }
      } while (--historyIndex >= -1);
      forwardChanges = changeHelper.getReverseChanges();
      if (quitEarlyArr[0]) {
        let originalStartPoint = midOriginalArr[0] + 1;
        let modifiedStartPoint = midModifiedArr[0] + 1;
        if (forwardChanges !== null && forwardChanges.length > 0) {
          const lastForwardChange = forwardChanges[forwardChanges.length - 1];
          originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
          modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
        }
        reverseChanges = [
          new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
        ];
      } else {
        changeHelper = new DiffChangeHelper();
        diagonalMin = diagonalReverseStart;
        diagonalMax = diagonalReverseEnd;
        diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
        lastOriginalIndex = 1073741824;
        historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
        do {
          const diagonal = diagonalRelative + diagonalReverseBase;
          if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex + 1;
            changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal + 1 - diagonalReverseBase;
          } else {
            originalIndex = reversePoints[diagonal - 1];
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex;
            changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal - 1 - diagonalReverseBase;
          }
          if (historyIndex >= 0) {
            reversePoints = this.m_reverseHistory[historyIndex];
            diagonalReverseBase = reversePoints[0];
            diagonalMin = 1;
            diagonalMax = reversePoints.length - 1;
          }
        } while (--historyIndex >= -1);
        reverseChanges = changeHelper.getChanges();
      }
      return this.ConcatenateChanges(forwardChanges, reverseChanges);
    }
    /**
     * Given the range to compute the diff on, this method finds the point:
     * (midOriginal, midModified)
     * that exists in the middle of the LCS of the two sequences and
     * is the point at which the LCS problem may be broken down recursively.
     * This method will try to keep the LCS trace in memory. If the LCS recursion
     * point is calculated and the full trace is available in memory, then this method
     * will return the change list.
     * @param originalStart The start bound of the original sequence range
     * @param originalEnd The end bound of the original sequence range
     * @param modifiedStart The start bound of the modified sequence range
     * @param modifiedEnd The end bound of the modified sequence range
     * @param midOriginal The middle point of the original sequence range
     * @param midModified The middle point of the modified sequence range
     * @returns The diff changes, if available, otherwise null
     */
    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
      let originalIndex = 0, modifiedIndex = 0;
      let diagonalForwardStart = 0, diagonalForwardEnd = 0;
      let diagonalReverseStart = 0, diagonalReverseEnd = 0;
      originalStart--;
      modifiedStart--;
      midOriginalArr[0] = 0;
      midModifiedArr[0] = 0;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
      const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
      const numDiagonals = maxDifferences + 1;
      const forwardPoints = new Int32Array(numDiagonals);
      const reversePoints = new Int32Array(numDiagonals);
      const diagonalForwardBase = modifiedEnd - modifiedStart;
      const diagonalReverseBase = originalEnd - originalStart;
      const diagonalForwardOffset = originalStart - modifiedStart;
      const diagonalReverseOffset = originalEnd - modifiedEnd;
      const delta = diagonalReverseBase - diagonalForwardBase;
      const deltaIsEven = delta % 2 === 0;
      forwardPoints[diagonalForwardBase] = originalStart;
      reversePoints[diagonalReverseBase] = originalEnd;
      quitEarlyArr[0] = false;
      for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
        let furthestOriginalIndex = 0;
        let furthestModifiedIndex = 0;
        diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
          if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
            originalIndex = forwardPoints[diagonal + 1];
          } else {
            originalIndex = forwardPoints[diagonal - 1] + 1;
          }
          modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
            originalIndex++;
            modifiedIndex++;
          }
          forwardPoints[diagonal] = originalIndex;
          if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
            furthestOriginalIndex = originalIndex;
            furthestModifiedIndex = modifiedIndex;
          }
          if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
            if (originalIndex >= reversePoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
        if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
          quitEarlyArr[0] = true;
          midOriginalArr[0] = furthestOriginalIndex;
          midModifiedArr[0] = furthestModifiedIndex;
          if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
          } else {
            originalStart++;
            modifiedStart++;
            return [
              new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
            ];
          }
        }
        diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
          if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
          } else {
            originalIndex = reversePoints[diagonal - 1];
          }
          modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
            originalIndex--;
            modifiedIndex--;
          }
          reversePoints[diagonal] = originalIndex;
          if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
            if (originalIndex <= forwardPoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        if (numDifferences <= 1447) {
          let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
          temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
          MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
          this.m_forwardHistory.push(temp);
          temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
          temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
          MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
          this.m_reverseHistory.push(temp);
        }
      }
      return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    }
    /**
     * Shifts the given changes to provide a more intuitive diff.
     * While the first element in a diff matches the first element after the diff,
     * we shift the diff down.
     *
     * @param changes The list of changes to shift
     * @returns The shifted changes
     */
    PrettifyChanges(changes) {
      for (let i = 0; i < changes.length; i++) {
        const change = changes[i];
        const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
        const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
          const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
          const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
          if (endStrictEqual && !startStrictEqual) {
            break;
          }
          change.originalStart++;
          change.modifiedStart++;
        }
        const mergedChangeArr = [null];
        if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
          changes[i] = mergedChangeArr[0];
          changes.splice(i + 1, 1);
          i--;
          continue;
        }
      }
      for (let i = changes.length - 1; i >= 0; i--) {
        const change = changes[i];
        let originalStop = 0;
        let modifiedStop = 0;
        if (i > 0) {
          const prevChange = changes[i - 1];
          originalStop = prevChange.originalStart + prevChange.originalLength;
          modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
        }
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        let bestDelta = 0;
        let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
        for (let delta = 1; ; delta++) {
          const originalStart = change.originalStart - delta;
          const modifiedStart = change.modifiedStart - delta;
          if (originalStart < originalStop || modifiedStart < modifiedStop) {
            break;
          }
          if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
            break;
          }
          if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
            break;
          }
          const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
          const score2 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
          if (score2 > bestScore) {
            bestScore = score2;
            bestDelta = delta;
          }
        }
        change.originalStart -= bestDelta;
        change.modifiedStart -= bestDelta;
        const mergedChangeArr = [null];
        if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
          changes[i - 1] = mergedChangeArr[0];
          changes.splice(i, 1);
          i++;
          continue;
        }
      }
      if (this._hasStrings) {
        for (let i = 1, len = changes.length; i < len; i++) {
          const aChange = changes[i - 1];
          const bChange = changes[i];
          const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
          const aOriginalStart = aChange.originalStart;
          const bOriginalEnd = bChange.originalStart + bChange.originalLength;
          const abOriginalLength = bOriginalEnd - aOriginalStart;
          const aModifiedStart = aChange.modifiedStart;
          const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
          const abModifiedLength = bModifiedEnd - aModifiedStart;
          if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
            const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
            if (t) {
              const [originalMatchStart, modifiedMatchStart] = t;
              if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                aChange.originalLength = originalMatchStart - aChange.originalStart;
                aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                bChange.originalStart = originalMatchStart + matchedLength;
                bChange.modifiedStart = modifiedMatchStart + matchedLength;
                bChange.originalLength = bOriginalEnd - bChange.originalStart;
                bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
              }
            }
          }
        }
      }
      return changes;
    }
    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
      if (originalLength < desiredLength || modifiedLength < desiredLength) {
        return null;
      }
      const originalMax = originalStart + originalLength - desiredLength + 1;
      const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
      let bestScore = 0;
      let bestOriginalStart = 0;
      let bestModifiedStart = 0;
      for (let i = originalStart; i < originalMax; i++) {
        for (let j = modifiedStart; j < modifiedMax; j++) {
          const score2 = this._contiguousSequenceScore(i, j, desiredLength);
          if (score2 > 0 && score2 > bestScore) {
            bestScore = score2;
            bestOriginalStart = i;
            bestModifiedStart = j;
          }
        }
      }
      if (bestScore > 0) {
        return [bestOriginalStart, bestModifiedStart];
      }
      return null;
    }
    _contiguousSequenceScore(originalStart, modifiedStart, length) {
      let score2 = 0;
      for (let l = 0; l < length; l++) {
        if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
          return 0;
        }
        score2 += this._originalStringElements[originalStart + l].length;
      }
      return score2;
    }
    _OriginalIsBoundary(index4) {
      if (index4 <= 0 || index4 >= this._originalElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._originalStringElements[index4]);
    }
    _OriginalRegionIsBoundary(originalStart, originalLength) {
      if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
        return true;
      }
      if (originalLength > 0) {
        const originalEnd = originalStart + originalLength;
        if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
          return true;
        }
      }
      return false;
    }
    _ModifiedIsBoundary(index4) {
      if (index4 <= 0 || index4 >= this._modifiedElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index4]);
    }
    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
      if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
        return true;
      }
      if (modifiedLength > 0) {
        const modifiedEnd = modifiedStart + modifiedLength;
        if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
          return true;
        }
      }
      return false;
    }
    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
      const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
      const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
      return originalScore + modifiedScore;
    }
    /**
     * Concatenates the two input DiffChange lists and returns the resulting
     * list.
     * @param The left changes
     * @param The right changes
     * @returns The concatenated list
     */
    ConcatenateChanges(left, right) {
      const mergedChangeArr = [];
      if (left.length === 0 || right.length === 0) {
        return right.length > 0 ? right : left;
      } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
        const result = new Array(left.length + right.length - 1);
        MyArray.Copy(left, 0, result, 0, left.length - 1);
        result[left.length - 1] = mergedChangeArr[0];
        MyArray.Copy(right, 1, result, left.length, right.length - 1);
        return result;
      } else {
        const result = new Array(left.length + right.length);
        MyArray.Copy(left, 0, result, 0, left.length);
        MyArray.Copy(right, 0, result, left.length, right.length);
        return result;
      }
    }
    /**
     * Returns true if the two changes overlap and can be merged into a single
     * change
     * @param left The left change
     * @param right The right change
     * @param mergedChange The merged change if the two overlap, null otherwise
     * @returns True if the two changes overlap
     */
    ChangesOverlap(left, right, mergedChangeArr) {
      Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
      Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
      if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        const originalStart = left.originalStart;
        let originalLength = left.originalLength;
        const modifiedStart = left.modifiedStart;
        let modifiedLength = left.modifiedLength;
        if (left.originalStart + left.originalLength >= right.originalStart) {
          originalLength = right.originalStart + right.originalLength - left.originalStart;
        }
        if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
          modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
        }
        mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
        return true;
      } else {
        mergedChangeArr[0] = null;
        return false;
      }
    }
    /**
     * Helper method used to clip a diagonal index to the range of valid
     * diagonals. This also decides whether or not the diagonal index,
     * if it exceeds the boundary, should be clipped to the boundary or clipped
     * one inside the boundary depending on the Even/Odd status of the boundary
     * and numDifferences.
     * @param diagonal The index of the diagonal to clip.
     * @param numDifferences The current number of differences being iterated upon.
     * @param diagonalBaseIndex The base reference diagonal.
     * @param numDiagonals The total number of diagonals.
     * @returns The clipped diagonal index.
     */
    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
      if (diagonal >= 0 && diagonal < numDiagonals) {
        return diagonal;
      }
      const diagonalsBelow = diagonalBaseIndex;
      const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
      const diffEven = numDifferences % 2 === 0;
      if (diagonal < 0) {
        const lowerBoundEven = diagonalsBelow % 2 === 0;
        return diffEven === lowerBoundEven ? 0 : 1;
      } else {
        const upperBoundEven = diagonalsAbove % 2 === 0;
        return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
      }
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/process.js
  var safeProcess;
  var vscodeGlobal = globalThis.vscode;
  if (typeof vscodeGlobal !== "undefined" && typeof vscodeGlobal.process !== "undefined") {
    const sandboxProcess = vscodeGlobal.process;
    safeProcess = {
      get platform() {
        return sandboxProcess.platform;
      },
      get arch() {
        return sandboxProcess.arch;
      },
      get env() {
        return sandboxProcess.env;
      },
      cwd() {
        return sandboxProcess.cwd();
      }
    };
  } else if (typeof process !== "undefined") {
    safeProcess = {
      get platform() {
        return process.platform;
      },
      get arch() {
        return process.arch;
      },
      get env() {
        return process.env;
      },
      cwd() {
        return process.env["VSCODE_CWD"] || process.cwd();
      }
    };
  } else {
    safeProcess = {
      // Supported
      get platform() {
        return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
      },
      get arch() {
        return void 0;
      },
      // Unsupported
      get env() {
        return {};
      },
      cwd() {
        return "/";
      }
    };
  }
  var cwd = safeProcess.cwd;
  var env = safeProcess.env;
  var platform = safeProcess.platform;

  // node_modules/monaco-editor-core/esm/vs/base/common/path.js
  var CHAR_UPPERCASE_A = 65;
  var CHAR_LOWERCASE_A = 97;
  var CHAR_UPPERCASE_Z = 90;
  var CHAR_LOWERCASE_Z = 122;
  var CHAR_DOT = 46;
  var CHAR_FORWARD_SLASH = 47;
  var CHAR_BACKWARD_SLASH = 92;
  var CHAR_COLON = 58;
  var CHAR_QUESTION_MARK = 63;
  var ErrorInvalidArgType = class extends Error {
    constructor(name2, expected, actual) {
      let determiner;
      if (typeof expected === "string" && expected.indexOf("not ") === 0) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      const type = name2.indexOf(".") !== -1 ? "property" : "argument";
      let msg = `The "${name2}" ${type} ${determiner} of type ${expected}`;
      msg += `. Received type ${typeof actual}`;
      super(msg);
      this.code = "ERR_INVALID_ARG_TYPE";
    }
  };
  function validateObject(pathObject, name2) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType(name2, "Object", pathObject);
    }
  }
  function validateString(value, name2) {
    if (typeof value !== "string") {
      throw new ErrorInvalidArgType(name2, "string", value);
    }
  }
  var platformIsWin32 = platform === "win32";
  function isPathSeparator(code2) {
    return code2 === CHAR_FORWARD_SLASH || code2 === CHAR_BACKWARD_SLASH;
  }
  function isPosixPathSeparator(code2) {
    return code2 === CHAR_FORWARD_SLASH;
  }
  function isWindowsDeviceRoot(code2) {
    return code2 >= CHAR_UPPERCASE_A && code2 <= CHAR_UPPERCASE_Z || code2 >= CHAR_LOWERCASE_A && code2 <= CHAR_LOWERCASE_Z;
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code2 = 0;
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code2 = path.charCodeAt(i);
      } else if (isPathSeparator2(code2)) {
        break;
      } else {
        code2 = CHAR_FORWARD_SLASH;
      }
      if (isPathSeparator2(code2)) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? `${separator}..` : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `${separator}${path.slice(lastSlash + 1, i)}`;
          } else {
            res = path.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code2 === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format2(sep3, pathObject) {
    validateObject(pathObject, "pathObject");
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
    if (!dir) {
      return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep3}${base}`;
  }
  var win32 = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedDevice = "";
      let resolvedTail = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1; i--) {
        let path;
        if (i >= 0) {
          path = pathSegments[i];
          validateString(path, "path");
          if (path.length === 0) {
            continue;
          }
        } else if (resolvedDevice.length === 0) {
          path = cwd();
        } else {
          path = env[`=${resolvedDevice}`] || cwd();
          if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            path = `${resolvedDevice}\\`;
          }
        }
        const len = path.length;
        let rootEnd = 0;
        let device = "";
        let isAbsolute2 = false;
        const code2 = path.charCodeAt(0);
        if (len === 1) {
          if (isPathSeparator(code2)) {
            rootEnd = 1;
            isAbsolute2 = true;
          }
        } else if (isPathSeparator(code2)) {
          isAbsolute2 = true;
          if (isPathSeparator(path.charCodeAt(1))) {
            let j = 2;
            let last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              const firstPart = path.slice(last, j);
              last = j;
              while (j < len && isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j === len || j !== last) {
                  device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                  rootEnd = j;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
            isAbsolute2 = true;
            rootEnd = 3;
          }
        }
        if (device.length > 0) {
          if (resolvedDevice.length > 0) {
            if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
              continue;
            }
          } else {
            resolvedDevice = device;
          }
        }
        if (resolvedAbsolute) {
          if (resolvedDevice.length > 0) {
            break;
          }
        } else {
          resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
          resolvedAbsolute = isAbsolute2;
          if (isAbsolute2 && resolvedDevice.length > 0) {
            break;
          }
        }
      }
      resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
      return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
    },
    normalize(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = 0;
      let device;
      let isAbsolute2 = false;
      const code2 = path.charCodeAt(0);
      if (len === 1) {
        return isPosixPathSeparator(code2) ? "\\" : path;
      }
      if (isPathSeparator(code2)) {
        isAbsolute2 = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len) {
                return `\\\\${firstPart}\\${path.slice(last)}\\`;
              }
              if (j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          isAbsolute2 = true;
          rootEnd = 3;
        }
      }
      let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator) : "";
      if (tail.length === 0 && !isAbsolute2) {
        tail = ".";
      }
      if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
      }
      if (device === void 0) {
        return isAbsolute2 ? `\\${tail}` : tail;
      }
      return isAbsolute2 ? `${device}\\${tail}` : `${device}${tail}`;
    },
    isAbsolute(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return false;
      }
      const code2 = path.charCodeAt(0);
      return isPathSeparator(code2) || // Possible device root
      len > 2 && isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      let firstPart;
      for (let i = 0; i < paths.length; ++i) {
        const arg = paths[i];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = firstPart = arg;
          } else {
            joined += `\\${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      let needsReplace = true;
      let slashCount = 0;
      if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
          ++slashCount;
          if (firstLen > 2) {
            if (isPathSeparator(firstPart.charCodeAt(2))) {
              ++slashCount;
            } else {
              needsReplace = false;
            }
          }
        }
      }
      if (needsReplace) {
        while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
          slashCount++;
        }
        if (slashCount >= 2) {
          joined = `\\${joined.slice(slashCount)}`;
        }
      }
      return win32.normalize(joined);
    },
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    relative(from, to) {
      validateString(from, "from");
      validateString(to, "to");
      if (from === to) {
        return "";
      }
      const fromOrig = win32.resolve(from);
      const toOrig = win32.resolve(to);
      if (fromOrig === toOrig) {
        return "";
      }
      from = fromOrig.toLowerCase();
      to = toOrig.toLowerCase();
      if (from === to) {
        return "";
      }
      let fromStart = 0;
      while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
        fromStart++;
      }
      let fromEnd = from.length;
      while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
        fromEnd--;
      }
      const fromLen = fromEnd - fromStart;
      let toStart = 0;
      while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        toStart++;
      }
      let toEnd = to.length;
      while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
        toEnd--;
      }
      const toLen = toEnd - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i < length; i++) {
        const fromCode = from.charCodeAt(fromStart + i);
        if (fromCode !== to.charCodeAt(toStart + i)) {
          break;
        } else if (fromCode === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      if (i !== length) {
        if (lastCommonSep === -1) {
          return toOrig;
        }
      } else {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
            return toOrig.slice(toStart + i + 1);
          }
          if (i === 2) {
            return toOrig.slice(toStart + i);
          }
        }
        if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
            lastCommonSep = i;
          } else if (i === 2) {
            lastCommonSep = 3;
          }
        }
        if (lastCommonSep === -1) {
          lastCommonSep = 0;
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
          out += out.length === 0 ? ".." : "\\..";
        }
      }
      toStart += lastCommonSep;
      if (out.length > 0) {
        return `${out}${toOrig.slice(toStart, toEnd)}`;
      }
      if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        ++toStart;
      }
      return toOrig.slice(toStart, toEnd);
    },
    toNamespacedPath(path) {
      if (typeof path !== "string" || path.length === 0) {
        return path;
      }
      const resolvedPath = win32.resolve(path);
      if (resolvedPath.length <= 2) {
        return path;
      }
      if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
        if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
          const code2 = resolvedPath.charCodeAt(2);
          if (code2 !== CHAR_QUESTION_MARK && code2 !== CHAR_DOT) {
            return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
          }
        }
      } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
      return path;
    },
    dirname(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = -1;
      let offset2 = 0;
      const code2 = path.charCodeAt(0);
      if (len === 1) {
        return isPathSeparator(code2) ? path : ".";
      }
      if (isPathSeparator(code2)) {
        rootEnd = offset2 = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len) {
                return path;
              }
              if (j !== last) {
                rootEnd = offset2 = j + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON) {
        rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
        offset2 = rootEnd;
      }
      let end = -1;
      let matchedSlash = true;
      for (let i = len - 1; i >= offset2; --i) {
        if (isPathSeparator(path.charCodeAt(i))) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        if (rootEnd === -1) {
          return ".";
        }
        end = rootEnd;
      }
      return path.slice(0, end);
    },
    basename(path, ext) {
      if (ext !== void 0) {
        validateString(ext, "ext");
      }
      validateString(path, "path");
      let start2 = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
        start2 = 2;
      }
      if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
        if (ext === path) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= start2; --i) {
          const code2 = path.charCodeAt(i);
          if (isPathSeparator(code2)) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code2 === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start2 === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path.length;
        }
        return path.slice(start2, end);
      }
      for (i = path.length - 1; i >= start2; --i) {
        if (isPathSeparator(path.charCodeAt(i))) {
          if (!matchedSlash) {
            start2 = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path.slice(start2, end);
    },
    extname(path) {
      validateString(path, "path");
      let start2 = 0;
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start2 = startPart = 2;
      }
      for (let i = path.length - 1; i >= start2; --i) {
        const code2 = path.charCodeAt(i);
        if (isPathSeparator(code2)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code2 === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    },
    format: _format2.bind(null, "\\"),
    parse(path) {
      validateString(path, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path.length === 0) {
        return ret;
      }
      const len = path.length;
      let rootEnd = 0;
      let code2 = path.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code2)) {
          ret.root = ret.dir = path;
          return ret;
        }
        ret.base = ret.name = path;
        return ret;
      }
      if (isPathSeparator(code2)) {
        rootEnd = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len) {
                rootEnd = j;
              } else if (j !== last) {
                rootEnd = j + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON) {
        if (len <= 2) {
          ret.root = ret.dir = path;
          return ret;
        }
        rootEnd = 2;
        if (isPathSeparator(path.charCodeAt(2))) {
          if (len === 3) {
            ret.root = ret.dir = path;
            return ret;
          }
          rootEnd = 3;
        }
      }
      if (rootEnd > 0) {
        ret.root = path.slice(0, rootEnd);
      }
      let startDot = -1;
      let startPart = rootEnd;
      let end = -1;
      let matchedSlash = true;
      let i = path.length - 1;
      let preDotState = 0;
      for (; i >= rootEnd; --i) {
        code2 = path.charCodeAt(i);
        if (isPathSeparator(code2)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code2 === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path.slice(startPart, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
          ret.ext = path.slice(startDot, end);
        }
      }
      if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
      } else {
        ret.dir = ret.root;
      }
      return ret;
    },
    sep: "\\",
    delimiter: ";",
    win32: null,
    posix: null
  };
  var posixCwd = (() => {
    if (platformIsWin32) {
      const regexp = /\\/g;
      return () => {
        const cwd3 = cwd().replace(regexp, "/");
        return cwd3.slice(cwd3.indexOf("/"));
      };
    }
    return () => cwd();
  })();
  var posix = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        const path = i >= 0 ? pathSegments[i] : posixCwd();
        validateString(path, "path");
        if (path.length === 0) {
          continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      }
      resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
      if (resolvedAbsolute) {
        return `/${resolvedPath}`;
      }
      return resolvedPath.length > 0 ? resolvedPath : ".";
    },
    normalize(path) {
      validateString(path, "path");
      if (path.length === 0) {
        return ".";
      }
      const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
      path = normalizeString(path, !isAbsolute2, "/", isPosixPathSeparator);
      if (path.length === 0) {
        if (isAbsolute2) {
          return "/";
        }
        return trailingSeparator ? "./" : ".";
      }
      if (trailingSeparator) {
        path += "/";
      }
      return isAbsolute2 ? `/${path}` : path;
    },
    isAbsolute(path) {
      validateString(path, "path");
      return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0; i < paths.length; ++i) {
        const arg = paths[i];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = arg;
          } else {
            joined += `/${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return posix.normalize(joined);
    },
    relative(from, to) {
      validateString(from, "from");
      validateString(to, "to");
      if (from === to) {
        return "";
      }
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) {
        return "";
      }
      const fromStart = 1;
      const fromEnd = from.length;
      const fromLen = fromEnd - fromStart;
      const toStart = 1;
      const toLen = to.length - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i < length; i++) {
        const fromCode = from.charCodeAt(fromStart + i);
        if (fromCode !== to.charCodeAt(toStart + i)) {
          break;
        } else if (fromCode === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
            return to.slice(toStart + i + 1);
          }
          if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          out += out.length === 0 ? ".." : "/..";
        }
      }
      return `${out}${to.slice(toStart + lastCommonSep)}`;
    },
    toNamespacedPath(path) {
      return path;
    },
    dirname(path) {
      validateString(path, "path");
      if (path.length === 0) {
        return ".";
      }
      const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let end = -1;
      let matchedSlash = true;
      for (let i = path.length - 1; i >= 1; --i) {
        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        return hasRoot ? "/" : ".";
      }
      if (hasRoot && end === 1) {
        return "//";
      }
      return path.slice(0, end);
    },
    basename(path, ext) {
      if (ext !== void 0) {
        validateString(ext, "ext");
      }
      validateString(path, "path");
      let start2 = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
        if (ext === path) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= 0; --i) {
          const code2 = path.charCodeAt(i);
          if (code2 === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code2 === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start2 === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path.length;
        }
        return path.slice(start2, end);
      }
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start2 = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path.slice(start2, end);
    },
    extname(path) {
      validateString(path, "path");
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path.length - 1; i >= 0; --i) {
        const code2 = path.charCodeAt(i);
        if (code2 === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code2 === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    },
    format: _format2.bind(null, "/"),
    parse(path) {
      validateString(path, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path.length === 0) {
        return ret;
      }
      const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let start2;
      if (isAbsolute2) {
        ret.root = "/";
        start2 = 1;
      } else {
        start2 = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i = path.length - 1;
      let preDotState = 0;
      for (; i >= start2; --i) {
        const code2 = path.charCodeAt(i);
        if (code2 === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code2 === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        const start3 = startPart === 0 && isAbsolute2 ? 1 : startPart;
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path.slice(start3, end);
        } else {
          ret.name = path.slice(start3, startDot);
          ret.base = path.slice(start3, end);
          ret.ext = path.slice(startDot, end);
        }
      }
      if (startPart > 0) {
        ret.dir = path.slice(0, startPart - 1);
      } else if (isAbsolute2) {
        ret.dir = "/";
      }
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.win32 = win32.win32 = win32;
  posix.posix = win32.posix = posix;
  var normalize = platformIsWin32 ? win32.normalize : posix.normalize;
  var resolve = platformIsWin32 ? win32.resolve : posix.resolve;
  var relative = platformIsWin32 ? win32.relative : posix.relative;
  var dirname = platformIsWin32 ? win32.dirname : posix.dirname;
  var basename = platformIsWin32 ? win32.basename : posix.basename;
  var extname = platformIsWin32 ? win32.extname : posix.extname;
  var sep = platformIsWin32 ? win32.sep : posix.sep;

  // node_modules/monaco-editor-core/esm/vs/base/common/uri.js
  var _schemePattern = /^\w[\w\d+.-]*$/;
  var _singleSlashStart = /^\//;
  var _doubleSlashStart = /^\/\//;
  function _validateUri(ret, _strict) {
    if (!ret.scheme && _strict) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (ret.path) {
      if (ret.authority) {
        if (!_singleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        }
      } else {
        if (_doubleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
    }
  }
  function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
      return "file";
    }
    return scheme;
  }
  function _referenceResolution(scheme, path) {
    switch (scheme) {
      case "https":
      case "http":
      case "file":
        if (!path) {
          path = _slash;
        } else if (path[0] !== _slash) {
          path = _slash + path;
        }
        break;
    }
    return path;
  }
  var _empty = "";
  var _slash = "/";
  var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  var URI = class {
    static isUri(thing) {
      if (thing instanceof URI) {
        return true;
      }
      if (!thing) {
        return false;
      }
      return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
    }
    /**
     * @internal
     */
    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
      if (typeof schemeOrData === "object") {
        this.scheme = schemeOrData.scheme || _empty;
        this.authority = schemeOrData.authority || _empty;
        this.path = schemeOrData.path || _empty;
        this.query = schemeOrData.query || _empty;
        this.fragment = schemeOrData.fragment || _empty;
      } else {
        this.scheme = _schemeFix(schemeOrData, _strict);
        this.authority = authority || _empty;
        this.path = _referenceResolution(this.scheme, path || _empty);
        this.query = query || _empty;
        this.fragment = fragment || _empty;
        _validateUri(this, _strict);
      }
    }
    // ---- filesystem path -----------------------
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath() {
      return uriToFsPath(this, false);
    }
    // ---- modify to new -------------------------
    with(change) {
      if (!change) {
        return this;
      }
      let { scheme, authority, path, query, fragment } = change;
      if (scheme === void 0) {
        scheme = this.scheme;
      } else if (scheme === null) {
        scheme = _empty;
      }
      if (authority === void 0) {
        authority = this.authority;
      } else if (authority === null) {
        authority = _empty;
      }
      if (path === void 0) {
        path = this.path;
      } else if (path === null) {
        path = _empty;
      }
      if (query === void 0) {
        query = this.query;
      } else if (query === null) {
        query = _empty;
      }
      if (fragment === void 0) {
        fragment = this.fragment;
      } else if (fragment === null) {
        fragment = _empty;
      }
      if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
        return this;
      }
      return new Uri(scheme, authority, path, query, fragment);
    }
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value, _strict = false) {
      const match = _regexp.exec(value);
      if (!match) {
        return new Uri(_empty, _empty, _empty, _empty, _empty);
      }
      return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    }
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path) {
      let authority = _empty;
      if (isWindows) {
        path = path.replace(/\\/g, _slash);
      }
      if (path[0] === _slash && path[1] === _slash) {
        const idx = path.indexOf(_slash, 2);
        if (idx === -1) {
          authority = path.substring(2);
          path = _slash;
        } else {
          authority = path.substring(2, idx);
          path = path.substring(idx) || _slash;
        }
      }
      return new Uri("file", authority, path, _empty, _empty);
    }
    /**
     * Creates new URI from uri components.
     *
     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
     * validation and should be used for untrusted uri components retrieved from storage,
     * user input, command arguments etc
     */
    static from(components, strict) {
      const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
      return result;
    }
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri, ...pathFragment) {
      if (!uri.path) {
        throw new Error(`[UriError]: cannot call joinPath on URI without path`);
      }
      let newPath;
      if (isWindows && uri.scheme === "file") {
        newPath = URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
      } else {
        newPath = posix.join(uri.path, ...pathFragment);
      }
      return uri.with({ path: newPath });
    }
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding = false) {
      return _asFormatted(this, skipEncoding);
    }
    toJSON() {
      return this;
    }
    static revive(data2) {
      var _a4, _b3;
      if (!data2) {
        return data2;
      } else if (data2 instanceof URI) {
        return data2;
      } else {
        const result = new Uri(data2);
        result._formatted = (_a4 = data2.external) !== null && _a4 !== void 0 ? _a4 : null;
        result._fsPath = data2._sep === _pathSepMarker ? (_b3 = data2.fsPath) !== null && _b3 !== void 0 ? _b3 : null : null;
        return result;
      }
    }
  };
  var _pathSepMarker = isWindows ? 1 : void 0;
  var Uri = class extends URI {
    constructor() {
      super(...arguments);
      this._formatted = null;
      this._fsPath = null;
    }
    get fsPath() {
      if (!this._fsPath) {
        this._fsPath = uriToFsPath(this, false);
      }
      return this._fsPath;
    }
    toString(skipEncoding = false) {
      if (!skipEncoding) {
        if (!this._formatted) {
          this._formatted = _asFormatted(this, false);
        }
        return this._formatted;
      } else {
        return _asFormatted(this, true);
      }
    }
    toJSON() {
      const res = {
        $mid: 1
        /* MarshalledId.Uri */
      };
      if (this._fsPath) {
        res.fsPath = this._fsPath;
        res._sep = _pathSepMarker;
      }
      if (this._formatted) {
        res.external = this._formatted;
      }
      if (this.path) {
        res.path = this.path;
      }
      if (this.scheme) {
        res.scheme = this.scheme;
      }
      if (this.authority) {
        res.authority = this.authority;
      }
      if (this.query) {
        res.query = this.query;
      }
      if (this.fragment) {
        res.fragment = this.fragment;
      }
      return res;
    }
  };
  var encodeTable = {
    [
      58
      /* CharCode.Colon */
    ]: "%3A",
    // gen-delims
    [
      47
      /* CharCode.Slash */
    ]: "%2F",
    [
      63
      /* CharCode.QuestionMark */
    ]: "%3F",
    [
      35
      /* CharCode.Hash */
    ]: "%23",
    [
      91
      /* CharCode.OpenSquareBracket */
    ]: "%5B",
    [
      93
      /* CharCode.CloseSquareBracket */
    ]: "%5D",
    [
      64
      /* CharCode.AtSign */
    ]: "%40",
    [
      33
      /* CharCode.ExclamationMark */
    ]: "%21",
    // sub-delims
    [
      36
      /* CharCode.DollarSign */
    ]: "%24",
    [
      38
      /* CharCode.Ampersand */
    ]: "%26",
    [
      39
      /* CharCode.SingleQuote */
    ]: "%27",
    [
      40
      /* CharCode.OpenParen */
    ]: "%28",
    [
      41
      /* CharCode.CloseParen */
    ]: "%29",
    [
      42
      /* CharCode.Asterisk */
    ]: "%2A",
    [
      43
      /* CharCode.Plus */
    ]: "%2B",
    [
      44
      /* CharCode.Comma */
    ]: "%2C",
    [
      59
      /* CharCode.Semicolon */
    ]: "%3B",
    [
      61
      /* CharCode.Equals */
    ]: "%3D",
    [
      32
      /* CharCode.Space */
    ]: "%20"
  };
  function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
    let res = void 0;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
      const code2 = uriComponent.charCodeAt(pos);
      if (code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90 || code2 >= 48 && code2 <= 57 || code2 === 45 || code2 === 46 || code2 === 95 || code2 === 126 || isPath && code2 === 47 || isAuthority && code2 === 91 || isAuthority && code2 === 93 || isAuthority && code2 === 58) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        if (res !== void 0) {
          res += uriComponent.charAt(pos);
        }
      } else {
        if (res === void 0) {
          res = uriComponent.substr(0, pos);
        }
        const escaped = encodeTable[code2];
        if (escaped !== void 0) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          res += escaped;
        } else if (nativeEncodePos === -1) {
          nativeEncodePos = pos;
        }
      }
    }
    if (nativeEncodePos !== -1) {
      res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== void 0 ? res : uriComponent;
  }
  function encodeURIComponentMinimal(path) {
    let res = void 0;
    for (let pos = 0; pos < path.length; pos++) {
      const code2 = path.charCodeAt(pos);
      if (code2 === 35 || code2 === 63) {
        if (res === void 0) {
          res = path.substr(0, pos);
        }
        res += encodeTable[code2];
      } else {
        if (res !== void 0) {
          res += path[pos];
        }
      }
    }
    return res !== void 0 ? res : path;
  }
  function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
      value = `//${uri.authority}${uri.path}`;
    } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
      if (!keepDriveLetterCasing) {
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
      } else {
        value = uri.path.substr(1);
      }
    } else {
      value = uri.path;
    }
    if (isWindows) {
      value = value.replace(/\//g, "\\");
    }
    return value;
  }
  function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
    let res = "";
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
      res += scheme;
      res += ":";
    }
    if (authority || scheme === "file") {
      res += _slash;
      res += _slash;
    }
    if (authority) {
      let idx = authority.indexOf("@");
      if (idx !== -1) {
        const userinfo = authority.substr(0, idx);
        authority = authority.substr(idx + 1);
        idx = userinfo.lastIndexOf(":");
        if (idx === -1) {
          res += encoder(userinfo, false, false);
        } else {
          res += encoder(userinfo.substr(0, idx), false, false);
          res += ":";
          res += encoder(userinfo.substr(idx + 1), false, true);
        }
        res += "@";
      }
      authority = authority.toLowerCase();
      idx = authority.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(authority, false, true);
      } else {
        res += encoder(authority.substr(0, idx), false, true);
        res += authority.substr(idx);
      }
    }
    if (path) {
      if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
        const code2 = path.charCodeAt(1);
        if (code2 >= 65 && code2 <= 90) {
          path = `/${String.fromCharCode(code2 + 32)}:${path.substr(3)}`;
        }
      } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
        const code2 = path.charCodeAt(0);
        if (code2 >= 65 && code2 <= 90) {
          path = `${String.fromCharCode(code2 + 32)}:${path.substr(2)}`;
        }
      }
      res += encoder(path, true, false);
    }
    if (query) {
      res += "?";
      res += encoder(query, false, false);
    }
    if (fragment) {
      res += "#";
      res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
    }
    return res;
  }
  function decodeURIComponentGraceful(str) {
    try {
      return decodeURIComponent(str);
    } catch (_a4) {
      if (str.length > 3) {
        return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
      } else {
        return str;
      }
    }
  }
  var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
      return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/position.js
  var Position = class {
    constructor(lineNumber, column) {
      this.lineNumber = lineNumber;
      this.column = column;
    }
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber = this.lineNumber, newColumn = this.column) {
      if (newLineNumber === this.lineNumber && newColumn === this.column) {
        return this;
      } else {
        return new Position(newLineNumber, newColumn);
      }
    }
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber = 0, deltaColumn = 0) {
      return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
    }
    /**
     * Test if this position equals other position
     */
    equals(other) {
      return Position.equals(this, other);
    }
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a, b) {
      if (!a && !b) {
        return true;
      }
      return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other) {
      return Position.isBefore(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a, b) {
      if (a.lineNumber < b.lineNumber) {
        return true;
      }
      if (b.lineNumber < a.lineNumber) {
        return false;
      }
      return a.column < b.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other) {
      return Position.isBeforeOrEqual(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a, b) {
      if (a.lineNumber < b.lineNumber) {
        return true;
      }
      if (b.lineNumber < a.lineNumber) {
        return false;
      }
      return a.column <= b.column;
    }
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a, b) {
      const aLineNumber = a.lineNumber | 0;
      const bLineNumber = b.lineNumber | 0;
      if (aLineNumber === bLineNumber) {
        const aColumn = a.column | 0;
        const bColumn = b.column | 0;
        return aColumn - bColumn;
      }
      return aLineNumber - bLineNumber;
    }
    /**
     * Clone this position.
     */
    clone() {
      return new Position(this.lineNumber, this.column);
    }
    /**
     * Convert to a human-readable representation.
     */
    toString() {
      return "(" + this.lineNumber + "," + this.column + ")";
    }
    // ---
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos) {
      return new Position(pos.lineNumber, pos.column);
    }
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj) {
      return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
    }
    toJSON() {
      return {
        lineNumber: this.lineNumber,
        column: this.column
      };
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/range.js
  var Range = class {
    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
      if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
        this.startLineNumber = endLineNumber;
        this.startColumn = endColumn;
        this.endLineNumber = startLineNumber;
        this.endColumn = startColumn;
      } else {
        this.startLineNumber = startLineNumber;
        this.startColumn = startColumn;
        this.endLineNumber = endLineNumber;
        this.endColumn = endColumn;
      }
    }
    /**
     * Test if this range is empty.
     */
    isEmpty() {
      return Range.isEmpty(this);
    }
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range) {
      return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
    }
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position4) {
      return Range.containsPosition(this, position4);
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range, position4) {
      if (position4.lineNumber < range.startLineNumber || position4.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position4.lineNumber === range.startLineNumber && position4.column < range.startColumn) {
        return false;
      }
      if (position4.lineNumber === range.endLineNumber && position4.column > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range, position4) {
      if (position4.lineNumber < range.startLineNumber || position4.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position4.lineNumber === range.startLineNumber && position4.column <= range.startColumn) {
        return false;
      }
      if (position4.lineNumber === range.endLineNumber && position4.column >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range) {
      return Range.containsRange(this, range);
    }
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range) {
      return Range.strictContainsRange(this, range);
    }
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range) {
      return Range.plusRange(this, range);
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a, b) {
      let startLineNumber;
      let startColumn;
      let endLineNumber;
      let endColumn;
      if (b.startLineNumber < a.startLineNumber) {
        startLineNumber = b.startLineNumber;
        startColumn = b.startColumn;
      } else if (b.startLineNumber === a.startLineNumber) {
        startLineNumber = b.startLineNumber;
        startColumn = Math.min(b.startColumn, a.startColumn);
      } else {
        startLineNumber = a.startLineNumber;
        startColumn = a.startColumn;
      }
      if (b.endLineNumber > a.endLineNumber) {
        endLineNumber = b.endLineNumber;
        endColumn = b.endColumn;
      } else if (b.endLineNumber === a.endLineNumber) {
        endLineNumber = b.endLineNumber;
        endColumn = Math.max(b.endColumn, a.endColumn);
      } else {
        endLineNumber = a.endLineNumber;
        endColumn = a.endColumn;
      }
      return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range) {
      return Range.intersectRanges(this, range);
    }
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a, b) {
      let resultStartLineNumber = a.startLineNumber;
      let resultStartColumn = a.startColumn;
      let resultEndLineNumber = a.endLineNumber;
      let resultEndColumn = a.endColumn;
      const otherStartLineNumber = b.startLineNumber;
      const otherStartColumn = b.startColumn;
      const otherEndLineNumber = b.endLineNumber;
      const otherEndColumn = b.endColumn;
      if (resultStartLineNumber < otherStartLineNumber) {
        resultStartLineNumber = otherStartLineNumber;
        resultStartColumn = otherStartColumn;
      } else if (resultStartLineNumber === otherStartLineNumber) {
        resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
      }
      if (resultEndLineNumber > otherEndLineNumber) {
        resultEndLineNumber = otherEndLineNumber;
        resultEndColumn = otherEndColumn;
      } else if (resultEndLineNumber === otherEndLineNumber) {
        resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
      }
      if (resultStartLineNumber > resultEndLineNumber) {
        return null;
      }
      if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
        return null;
      }
      return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
    }
    /**
     * Test if this range equals other.
     */
    equalsRange(other) {
      return Range.equalsRange(this, other);
    }
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a, b) {
      if (!a && !b) {
        return true;
      }
      return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition() {
      return Range.getEndPosition(this);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range) {
      return new Position(range.endLineNumber, range.endColumn);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition() {
      return Range.getStartPosition(this);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range) {
      return new Position(range.startLineNumber, range.startColumn);
    }
    /**
     * Transform to a user presentable string representation.
     */
    toString() {
      return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
    }
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber, endColumn) {
      return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber, startColumn) {
      return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart() {
      return Range.collapseToStart(this);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range) {
      return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    collapseToEnd() {
      return Range.collapseToEnd(this);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    static collapseToEnd(range) {
      return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Moves the range by the given amount of lines.
     */
    delta(lineCount) {
      return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
    }
    // ---
    static fromPositions(start2, end = start2) {
      return new Range(start2.lineNumber, start2.column, end.lineNumber, end.column);
    }
    static lift(range) {
      if (!range) {
        return null;
      }
      return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj) {
      return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
    }
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a, b) {
      if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
        return false;
      }
      if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a, b) {
      if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
        return false;
      }
      if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a, b) {
      if (a && b) {
        const aStartLineNumber = a.startLineNumber | 0;
        const bStartLineNumber = b.startLineNumber | 0;
        if (aStartLineNumber === bStartLineNumber) {
          const aStartColumn = a.startColumn | 0;
          const bStartColumn = b.startColumn | 0;
          if (aStartColumn === bStartColumn) {
            const aEndLineNumber = a.endLineNumber | 0;
            const bEndLineNumber = b.endLineNumber | 0;
            if (aEndLineNumber === bEndLineNumber) {
              const aEndColumn = a.endColumn | 0;
              const bEndColumn = b.endColumn | 0;
              return aEndColumn - bEndColumn;
            }
            return aEndLineNumber - bEndLineNumber;
          }
          return aStartColumn - bStartColumn;
        }
        return aStartLineNumber - bStartLineNumber;
      }
      const aExists = a ? 1 : 0;
      const bExists = b ? 1 : 0;
      return aExists - bExists;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a, b) {
      if (a.endLineNumber === b.endLineNumber) {
        if (a.endColumn === b.endColumn) {
          if (a.startLineNumber === b.startLineNumber) {
            return a.startColumn - b.startColumn;
          }
          return a.startLineNumber - b.startLineNumber;
        }
        return a.endColumn - b.endColumn;
      }
      return a.endLineNumber - b.endLineNumber;
    }
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range) {
      return range.endLineNumber > range.startLineNumber;
    }
    toJSON() {
      return this;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/arrays.js
  function equals(one3, other, itemEquals = (a, b) => a === b) {
    if (one3 === other) {
      return true;
    }
    if (!one3 || !other) {
      return false;
    }
    if (one3.length !== other.length) {
      return false;
    }
    for (let i = 0, len = one3.length; i < len; i++) {
      if (!itemEquals(one3[i], other[i])) {
        return false;
      }
    }
    return true;
  }
  function* groupAdjacentBy(items, shouldBeGrouped) {
    let currentGroup;
    let last;
    for (const item of items) {
      if (last !== void 0 && shouldBeGrouped(last, item)) {
        currentGroup.push(item);
      } else {
        if (currentGroup) {
          yield currentGroup;
        }
        currentGroup = [item];
      }
      last = item;
    }
    if (currentGroup) {
      yield currentGroup;
    }
  }
  function forEachAdjacent(arr, f) {
    for (let i = 0; i <= arr.length; i++) {
      f(i === 0 ? void 0 : arr[i - 1], i === arr.length ? void 0 : arr[i]);
    }
  }
  function forEachWithNeighbors(arr, f) {
    for (let i = 0; i < arr.length; i++) {
      f(i === 0 ? void 0 : arr[i - 1], arr[i], i + 1 === arr.length ? void 0 : arr[i + 1]);
    }
  }
  function pushMany(arr, items) {
    for (const item of items) {
      arr.push(item);
    }
  }
  var CompareResult;
  (function(CompareResult2) {
    function isLessThan(result) {
      return result < 0;
    }
    CompareResult2.isLessThan = isLessThan;
    function isLessThanOrEqual(result) {
      return result <= 0;
    }
    CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
    function isGreaterThan(result) {
      return result > 0;
    }
    CompareResult2.isGreaterThan = isGreaterThan;
    function isNeitherLessOrGreaterThan(result) {
      return result === 0;
    }
    CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
    CompareResult2.greaterThan = 1;
    CompareResult2.lessThan = -1;
    CompareResult2.neitherLessOrGreaterThan = 0;
  })(CompareResult || (CompareResult = {}));
  function compareBy(selector, comparator) {
    return (a, b) => comparator(selector(a), selector(b));
  }
  var numberComparator = (a, b) => a - b;
  function reverseOrder(comparator) {
    return (a, b) => -comparator(a, b);
  }
  var CallbackIterable = class {
    constructor(iterate) {
      this.iterate = iterate;
    }
    toArray() {
      const result = [];
      this.iterate((item) => {
        result.push(item);
        return true;
      });
      return result;
    }
    filter(predicate) {
      return new CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
    }
    map(mapFn) {
      return new CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
    }
    findLast(predicate) {
      let result;
      this.iterate((item) => {
        if (predicate(item)) {
          result = item;
        }
        return true;
      });
      return result;
    }
    findLastMaxBy(comparator) {
      let result;
      let first = true;
      this.iterate((item) => {
        if (first || CompareResult.isGreaterThan(comparator(item, result))) {
          first = false;
          result = item;
        }
        return true;
      });
      return result;
    }
  };
  CallbackIterable.empty = new CallbackIterable((_callback) => {
  });

  // node_modules/monaco-editor-core/esm/vs/base/common/uint.js
  function toUint8(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 255) {
      return 255;
    }
    return v | 0;
  }
  function toUint32(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 4294967295) {
      return 4294967295;
    }
    return v | 0;
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/model/prefixSumComputer.js
  var PrefixSumComputer = class {
    constructor(values) {
      this.values = values;
      this.prefixSum = new Uint32Array(values.length);
      this.prefixSumValidIndex = new Int32Array(1);
      this.prefixSumValidIndex[0] = -1;
    }
    insertValues(insertIndex, insertValues) {
      insertIndex = toUint32(insertIndex);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      const insertValuesLen = insertValues.length;
      if (insertValuesLen === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length + insertValuesLen);
      this.values.set(oldValues.subarray(0, insertIndex), 0);
      this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
      this.values.set(insertValues, insertIndex);
      if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = insertIndex - 1;
      }
      this.prefixSum = new Uint32Array(this.values.length);
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    setValue(index4, value) {
      index4 = toUint32(index4);
      value = toUint32(value);
      if (this.values[index4] === value) {
        return false;
      }
      this.values[index4] = value;
      if (index4 - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = index4 - 1;
      }
      return true;
    }
    removeValues(startIndex, count) {
      startIndex = toUint32(startIndex);
      count = toUint32(count);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      if (startIndex >= oldValues.length) {
        return false;
      }
      const maxCount = oldValues.length - startIndex;
      if (count >= maxCount) {
        count = maxCount;
      }
      if (count === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length - count);
      this.values.set(oldValues.subarray(0, startIndex), 0);
      this.values.set(oldValues.subarray(startIndex + count), startIndex);
      this.prefixSum = new Uint32Array(this.values.length);
      if (startIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = startIndex - 1;
      }
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    getTotalSum() {
      if (this.values.length === 0) {
        return 0;
      }
      return this._getPrefixSum(this.values.length - 1);
    }
    /**
     * Returns the sum of the first `index + 1` many items.
     * @returns `SUM(0 <= j <= index, values[j])`.
     */
    getPrefixSum(index4) {
      if (index4 < 0) {
        return 0;
      }
      index4 = toUint32(index4);
      return this._getPrefixSum(index4);
    }
    _getPrefixSum(index4) {
      if (index4 <= this.prefixSumValidIndex[0]) {
        return this.prefixSum[index4];
      }
      let startIndex = this.prefixSumValidIndex[0] + 1;
      if (startIndex === 0) {
        this.prefixSum[0] = this.values[0];
        startIndex++;
      }
      if (index4 >= this.values.length) {
        index4 = this.values.length - 1;
      }
      for (let i = startIndex; i <= index4; i++) {
        this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
      }
      this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index4);
      return this.prefixSum[index4];
    }
    getIndexOf(sum) {
      sum = Math.floor(sum);
      this.getTotalSum();
      let low = 0;
      let high = this.values.length - 1;
      let mid = 0;
      let midStop = 0;
      let midStart = 0;
      while (low <= high) {
        mid = low + (high - low) / 2 | 0;
        midStop = this.prefixSum[mid];
        midStart = midStop - this.values[mid];
        if (sum < midStart) {
          high = mid - 1;
        } else if (sum >= midStop) {
          low = mid + 1;
        } else {
          break;
        }
      }
      return new PrefixSumIndexOfResult(mid, sum - midStart);
    }
  };
  var PrefixSumIndexOfResult = class {
    constructor(index4, remainder) {
      this.index = index4;
      this.remainder = remainder;
      this._prefixSumIndexOfResultBrand = void 0;
      this.index = index4;
      this.remainder = remainder;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/model/mirrorTextModel.js
  var MirrorTextModel = class {
    constructor(uri, lines, eol2, versionId) {
      this._uri = uri;
      this._lines = lines;
      this._eol = eol2;
      this._versionId = versionId;
      this._lineStarts = null;
      this._cachedTextValue = null;
    }
    dispose() {
      this._lines.length = 0;
    }
    get version() {
      return this._versionId;
    }
    getText() {
      if (this._cachedTextValue === null) {
        this._cachedTextValue = this._lines.join(this._eol);
      }
      return this._cachedTextValue;
    }
    onEvents(e) {
      if (e.eol && e.eol !== this._eol) {
        this._eol = e.eol;
        this._lineStarts = null;
      }
      const changes = e.changes;
      for (const change of changes) {
        this._acceptDeleteRange(change.range);
        this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
      }
      this._versionId = e.versionId;
      this._cachedTextValue = null;
    }
    _ensureLineStarts() {
      if (!this._lineStarts) {
        const eolLength = this._eol.length;
        const linesLength = this._lines.length;
        const lineStartValues = new Uint32Array(linesLength);
        for (let i = 0; i < linesLength; i++) {
          lineStartValues[i] = this._lines[i].length + eolLength;
        }
        this._lineStarts = new PrefixSumComputer(lineStartValues);
      }
    }
    /**
     * All changes to a line's text go through this method
     */
    _setLineText(lineIndex, newValue) {
      this._lines[lineIndex] = newValue;
      if (this._lineStarts) {
        this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
      }
    }
    _acceptDeleteRange(range) {
      if (range.startLineNumber === range.endLineNumber) {
        if (range.startColumn === range.endColumn) {
          return;
        }
        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
        return;
      }
      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
      this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      if (this._lineStarts) {
        this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      }
    }
    _acceptInsertText(position4, insertText) {
      if (insertText.length === 0) {
        return;
      }
      const insertLines = splitLines(insertText);
      if (insertLines.length === 1) {
        this._setLineText(position4.lineNumber - 1, this._lines[position4.lineNumber - 1].substring(0, position4.column - 1) + insertLines[0] + this._lines[position4.lineNumber - 1].substring(position4.column - 1));
        return;
      }
      insertLines[insertLines.length - 1] += this._lines[position4.lineNumber - 1].substring(position4.column - 1);
      this._setLineText(position4.lineNumber - 1, this._lines[position4.lineNumber - 1].substring(0, position4.column - 1) + insertLines[0]);
      const newLengths = new Uint32Array(insertLines.length - 1);
      for (let i = 1; i < insertLines.length; i++) {
        this._lines.splice(position4.lineNumber + i - 1, 0, insertLines[i]);
        newLengths[i - 1] = insertLines[i].length + this._eol.length;
      }
      if (this._lineStarts) {
        this._lineStarts.insertValues(position4.lineNumber, newLengths);
      }
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/wordHelper.js
  var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
  function createWordRegExp(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep3 of USUAL_WORD_SEPARATORS) {
      if (allowInWords.indexOf(sep3) >= 0) {
        continue;
      }
      source += "\\" + sep3;
    }
    source += "\\s]+)";
    return new RegExp(source, "g");
  }
  var DEFAULT_WORD_REGEXP = createWordRegExp();
  function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && wordDefinition instanceof RegExp) {
      if (!wordDefinition.global) {
        let flags = "g";
        if (wordDefinition.ignoreCase) {
          flags += "i";
        }
        if (wordDefinition.multiline) {
          flags += "m";
        }
        if (wordDefinition.unicode) {
          flags += "u";
        }
        result = new RegExp(wordDefinition.source, flags);
      } else {
        result = wordDefinition;
      }
    }
    result.lastIndex = 0;
    return result;
  }
  var _defaultConfig = new LinkedList();
  _defaultConfig.unshift({
    maxLen: 1e3,
    windowSize: 15,
    timeBudget: 150
  });
  function getWordAtText(column, wordDefinition, text4, textOffset, config) {
    wordDefinition = ensureValidWordDefinition(wordDefinition);
    if (!config) {
      config = Iterable.first(_defaultConfig);
    }
    if (text4.length > config.maxLen) {
      let start2 = column - config.maxLen / 2;
      if (start2 < 0) {
        start2 = 0;
      } else {
        textOffset += start2;
      }
      text4 = text4.substring(start2, column + config.maxLen / 2);
      return getWordAtText(column, wordDefinition, text4, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1; ; i++) {
      if (Date.now() - t1 >= config.timeBudget) {
        break;
      }
      const regexIndex = pos - config.windowSize * i;
      wordDefinition.lastIndex = Math.max(0, regexIndex);
      const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text4, pos, prevRegexIndex);
      if (!thisMatch && match) {
        break;
      }
      match = thisMatch;
      if (regexIndex <= 0) {
        break;
      }
      prevRegexIndex = regexIndex;
    }
    if (match) {
      const result = {
        word: match[0],
        startColumn: textOffset + 1 + match.index,
        endColumn: textOffset + 1 + match.index + match[0].length
      };
      wordDefinition.lastIndex = 0;
      return result;
    }
    return null;
  }
  function _findRegexMatchEnclosingPosition(wordDefinition, text4, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text4)) {
      const matchIndex = match.index || 0;
      if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
        return match;
      } else if (stopPos > 0 && matchIndex > stopPos) {
        return null;
      }
    }
    return null;
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/characterClassifier.js
  var CharacterClassifier = class {
    constructor(_defaultValue) {
      const defaultValue = toUint8(_defaultValue);
      this._defaultValue = defaultValue;
      this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
      this._map = /* @__PURE__ */ new Map();
    }
    static _createAsciiMap(defaultValue) {
      const asciiMap = new Uint8Array(256);
      asciiMap.fill(defaultValue);
      return asciiMap;
    }
    set(charCode, _value) {
      const value = toUint8(_value);
      if (charCode >= 0 && charCode < 256) {
        this._asciiMap[charCode] = value;
      } else {
        this._map.set(charCode, value);
      }
    }
    get(charCode) {
      if (charCode >= 0 && charCode < 256) {
        return this._asciiMap[charCode];
      } else {
        return this._map.get(charCode) || this._defaultValue;
      }
    }
    clear() {
      this._asciiMap.fill(this._defaultValue);
      this._map.clear();
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/languages/linkComputer.js
  var Uint8Matrix = class {
    constructor(rows, cols, defaultValue) {
      const data2 = new Uint8Array(rows * cols);
      for (let i = 0, len = rows * cols; i < len; i++) {
        data2[i] = defaultValue;
      }
      this._data = data2;
      this.rows = rows;
      this.cols = cols;
    }
    get(row, col) {
      return this._data[row * this.cols + col];
    }
    set(row, col, value) {
      this._data[row * this.cols + col] = value;
    }
  };
  var StateMachine = class {
    constructor(edges) {
      let maxCharCode = 0;
      let maxState = 0;
      for (let i = 0, len = edges.length; i < len; i++) {
        const [from, chCode, to] = edges[i];
        if (chCode > maxCharCode) {
          maxCharCode = chCode;
        }
        if (from > maxState) {
          maxState = from;
        }
        if (to > maxState) {
          maxState = to;
        }
      }
      maxCharCode++;
      maxState++;
      const states = new Uint8Matrix(
        maxState,
        maxCharCode,
        0
        /* State.Invalid */
      );
      for (let i = 0, len = edges.length; i < len; i++) {
        const [from, chCode, to] = edges[i];
        states.set(from, chCode, to);
      }
      this._states = states;
      this._maxCharCode = maxCharCode;
    }
    nextState(currentState, chCode) {
      if (chCode < 0 || chCode >= this._maxCharCode) {
        return 0;
      }
      return this._states.get(currentState, chCode);
    }
  };
  var _stateMachine = null;
  function getStateMachine() {
    if (_stateMachine === null) {
      _stateMachine = new StateMachine([
        [
          1,
          104,
          2
          /* State.H */
        ],
        [
          1,
          72,
          2
          /* State.H */
        ],
        [
          1,
          102,
          6
          /* State.F */
        ],
        [
          1,
          70,
          6
          /* State.F */
        ],
        [
          2,
          116,
          3
          /* State.HT */
        ],
        [
          2,
          84,
          3
          /* State.HT */
        ],
        [
          3,
          116,
          4
          /* State.HTT */
        ],
        [
          3,
          84,
          4
          /* State.HTT */
        ],
        [
          4,
          112,
          5
          /* State.HTTP */
        ],
        [
          4,
          80,
          5
          /* State.HTTP */
        ],
        [
          5,
          115,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          83,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          58,
          10
          /* State.AfterColon */
        ],
        [
          6,
          105,
          7
          /* State.FI */
        ],
        [
          6,
          73,
          7
          /* State.FI */
        ],
        [
          7,
          108,
          8
          /* State.FIL */
        ],
        [
          7,
          76,
          8
          /* State.FIL */
        ],
        [
          8,
          101,
          9
          /* State.BeforeColon */
        ],
        [
          8,
          69,
          9
          /* State.BeforeColon */
        ],
        [
          9,
          58,
          10
          /* State.AfterColon */
        ],
        [
          10,
          47,
          11
          /* State.AlmostThere */
        ],
        [
          11,
          47,
          12
          /* State.End */
        ]
      ]);
    }
    return _stateMachine;
  }
  var _classifier = null;
  function getClassifier() {
    if (_classifier === null) {
      _classifier = new CharacterClassifier(
        0
        /* CharacterClass.None */
      );
      const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
      for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
        _classifier.set(
          FORCE_TERMINATION_CHARACTERS.charCodeAt(i),
          1
          /* CharacterClass.ForceTermination */
        );
      }
      const CANNOT_END_WITH_CHARACTERS = ".,;:";
      for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
        _classifier.set(
          CANNOT_END_WITH_CHARACTERS.charCodeAt(i),
          2
          /* CharacterClass.CannotEndIn */
        );
      }
    }
    return _classifier;
  }
  var LinkComputer = class {
    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
      let lastIncludedCharIndex = linkEndIndex - 1;
      do {
        const chCode = line.charCodeAt(lastIncludedCharIndex);
        const chClass = classifier.get(chCode);
        if (chClass !== 2) {
          break;
        }
        lastIncludedCharIndex--;
      } while (lastIncludedCharIndex > linkBeginIndex);
      if (linkBeginIndex > 0) {
        const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
        const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
        if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
          lastIncludedCharIndex--;
        }
      }
      return {
        range: {
          startLineNumber: lineNumber,
          startColumn: linkBeginIndex + 1,
          endLineNumber: lineNumber,
          endColumn: lastIncludedCharIndex + 2
        },
        url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
      };
    }
    static computeLinks(model, stateMachine = getStateMachine()) {
      const classifier = getClassifier();
      const result = [];
      for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
        const line = model.getLineContent(i);
        const len = line.length;
        let j = 0;
        let linkBeginIndex = 0;
        let linkBeginChCode = 0;
        let state = 1;
        let hasOpenParens = false;
        let hasOpenSquareBracket = false;
        let inSquareBrackets = false;
        let hasOpenCurlyBracket = false;
        while (j < len) {
          let resetStateMachine = false;
          const chCode = line.charCodeAt(j);
          if (state === 13) {
            let chClass;
            switch (chCode) {
              case 40:
                hasOpenParens = true;
                chClass = 0;
                break;
              case 41:
                chClass = hasOpenParens ? 0 : 1;
                break;
              case 91:
                inSquareBrackets = true;
                hasOpenSquareBracket = true;
                chClass = 0;
                break;
              case 93:
                inSquareBrackets = false;
                chClass = hasOpenSquareBracket ? 0 : 1;
                break;
              case 123:
                hasOpenCurlyBracket = true;
                chClass = 0;
                break;
              case 125:
                chClass = hasOpenCurlyBracket ? 0 : 1;
                break;
              case 39:
              case 34:
              case 96:
                if (linkBeginChCode === chCode) {
                  chClass = 1;
                } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                  chClass = 0;
                } else {
                  chClass = 1;
                }
                break;
              case 42:
                chClass = linkBeginChCode === 42 ? 1 : 0;
                break;
              case 124:
                chClass = linkBeginChCode === 124 ? 1 : 0;
                break;
              case 32:
                chClass = inSquareBrackets ? 0 : 1;
                break;
              default:
                chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
              resetStateMachine = true;
            }
          } else if (state === 12) {
            let chClass;
            if (chCode === 91) {
              hasOpenSquareBracket = true;
              chClass = 0;
            } else {
              chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              resetStateMachine = true;
            } else {
              state = 13;
            }
          } else {
            state = stateMachine.nextState(state, chCode);
            if (state === 0) {
              resetStateMachine = true;
            }
          }
          if (resetStateMachine) {
            state = 1;
            hasOpenParens = false;
            hasOpenSquareBracket = false;
            hasOpenCurlyBracket = false;
            linkBeginIndex = j + 1;
            linkBeginChCode = chCode;
          }
          j++;
        }
        if (state === 13) {
          result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
        }
      }
      return result;
    }
  };
  function computeLinks(model) {
    if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
      return [];
    }
    return LinkComputer.computeLinks(model);
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
  var BasicInplaceReplace = class {
    constructor() {
      this._defaultValueSet = [
        ["true", "false"],
        ["True", "False"],
        ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
        ["public", "protected", "private"]
      ];
    }
    navigateValueSet(range1, text1, range2, text22, up) {
      if (range1 && text1) {
        const result = this.doNavigateValueSet(text1, up);
        if (result) {
          return {
            range: range1,
            value: result
          };
        }
      }
      if (range2 && text22) {
        const result = this.doNavigateValueSet(text22, up);
        if (result) {
          return {
            range: range2,
            value: result
          };
        }
      }
      return null;
    }
    doNavigateValueSet(text4, up) {
      const numberResult = this.numberReplace(text4, up);
      if (numberResult !== null) {
        return numberResult;
      }
      return this.textReplace(text4, up);
    }
    numberReplace(value, up) {
      const precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
      let n1 = Number(value);
      const n2 = parseFloat(value);
      if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
        if (n1 === 0 && !up) {
          return null;
        } else {
          n1 = Math.floor(n1 * precision);
          n1 += up ? precision : -precision;
          return String(n1 / precision);
        }
      }
      return null;
    }
    textReplace(value, up) {
      return this.valueSetsReplace(this._defaultValueSet, value, up);
    }
    valueSetsReplace(valueSets, value, up) {
      let result = null;
      for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
        result = this.valueSetReplace(valueSets[i], value, up);
      }
      return result;
    }
    valueSetReplace(valueSet, value, up) {
      let idx = valueSet.indexOf(value);
      if (idx >= 0) {
        idx += up ? 1 : -1;
        if (idx < 0) {
          idx = valueSet.length - 1;
        } else {
          idx %= valueSet.length;
        }
        return valueSet[idx];
      }
      return null;
    }
  };
  BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();

  // node_modules/monaco-editor-core/esm/vs/base/common/cancellation.js
  var shortcutEvent = Object.freeze(function(callback, context) {
    const handle2 = setTimeout(callback.bind(context), 0);
    return { dispose() {
      clearTimeout(handle2);
    } };
  });
  var CancellationToken;
  (function(CancellationToken2) {
    function isCancellationToken(thing) {
      if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
        return true;
      }
      if (thing instanceof MutableToken) {
        return true;
      }
      if (!thing || typeof thing !== "object") {
        return false;
      }
      return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
    }
    CancellationToken2.isCancellationToken = isCancellationToken;
    CancellationToken2.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: Event.None
    });
    CancellationToken2.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: shortcutEvent
    });
  })(CancellationToken || (CancellationToken = {}));
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
      this._emitter = null;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = null;
      }
    }
  };
  var CancellationTokenSource = class {
    constructor(parent) {
      this._token = void 0;
      this._parentListener = void 0;
      this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
    }
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken.Cancelled;
      } else if (this._token instanceof MutableToken) {
        this._token.cancel();
      }
    }
    dispose(cancel = false) {
      var _a4;
      if (cancel) {
        this.cancel();
      }
      (_a4 = this._parentListener) === null || _a4 === void 0 ? void 0 : _a4.dispose();
      if (!this._token) {
        this._token = CancellationToken.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/keyCodes.js
  var KeyCodeStrMap = class {
    constructor() {
      this._keyCodeToStr = [];
      this._strToKeyCode = /* @__PURE__ */ Object.create(null);
    }
    define(keyCode, str) {
      this._keyCodeToStr[keyCode] = str;
      this._strToKeyCode[str.toLowerCase()] = keyCode;
    }
    keyCodeToStr(keyCode) {
      return this._keyCodeToStr[keyCode];
    }
    strToKeyCode(str) {
      return this._strToKeyCode[str.toLowerCase()] || 0;
    }
  };
  var uiMap = new KeyCodeStrMap();
  var userSettingsUSMap = new KeyCodeStrMap();
  var userSettingsGeneralMap = new KeyCodeStrMap();
  var EVENT_KEY_CODE_MAP = new Array(230);
  var NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
  var scanCodeIntToStr = [];
  var scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
  var scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
  var IMMUTABLE_CODE_TO_KEY_CODE = [];
  var IMMUTABLE_KEY_CODE_TO_CODE = [];
  for (let i = 0; i <= 193; i++) {
    IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
  }
  for (let i = 0; i <= 132; i++) {
    IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
  }
  (function() {
    const empty4 = "";
    const mappings = [
      // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
      [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty4, empty4],
      [1, 1, "Hyper", 0, empty4, 0, empty4, empty4, empty4],
      [1, 2, "Super", 0, empty4, 0, empty4, empty4, empty4],
      [1, 3, "Fn", 0, empty4, 0, empty4, empty4, empty4],
      [1, 4, "FnLock", 0, empty4, 0, empty4, empty4, empty4],
      [1, 5, "Suspend", 0, empty4, 0, empty4, empty4, empty4],
      [1, 6, "Resume", 0, empty4, 0, empty4, empty4, empty4],
      [1, 7, "Turbo", 0, empty4, 0, empty4, empty4, empty4],
      [1, 8, "Sleep", 0, empty4, 0, "VK_SLEEP", empty4, empty4],
      [1, 9, "WakeUp", 0, empty4, 0, empty4, empty4, empty4],
      [0, 10, "KeyA", 31, "A", 65, "VK_A", empty4, empty4],
      [0, 11, "KeyB", 32, "B", 66, "VK_B", empty4, empty4],
      [0, 12, "KeyC", 33, "C", 67, "VK_C", empty4, empty4],
      [0, 13, "KeyD", 34, "D", 68, "VK_D", empty4, empty4],
      [0, 14, "KeyE", 35, "E", 69, "VK_E", empty4, empty4],
      [0, 15, "KeyF", 36, "F", 70, "VK_F", empty4, empty4],
      [0, 16, "KeyG", 37, "G", 71, "VK_G", empty4, empty4],
      [0, 17, "KeyH", 38, "H", 72, "VK_H", empty4, empty4],
      [0, 18, "KeyI", 39, "I", 73, "VK_I", empty4, empty4],
      [0, 19, "KeyJ", 40, "J", 74, "VK_J", empty4, empty4],
      [0, 20, "KeyK", 41, "K", 75, "VK_K", empty4, empty4],
      [0, 21, "KeyL", 42, "L", 76, "VK_L", empty4, empty4],
      [0, 22, "KeyM", 43, "M", 77, "VK_M", empty4, empty4],
      [0, 23, "KeyN", 44, "N", 78, "VK_N", empty4, empty4],
      [0, 24, "KeyO", 45, "O", 79, "VK_O", empty4, empty4],
      [0, 25, "KeyP", 46, "P", 80, "VK_P", empty4, empty4],
      [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty4, empty4],
      [0, 27, "KeyR", 48, "R", 82, "VK_R", empty4, empty4],
      [0, 28, "KeyS", 49, "S", 83, "VK_S", empty4, empty4],
      [0, 29, "KeyT", 50, "T", 84, "VK_T", empty4, empty4],
      [0, 30, "KeyU", 51, "U", 85, "VK_U", empty4, empty4],
      [0, 31, "KeyV", 52, "V", 86, "VK_V", empty4, empty4],
      [0, 32, "KeyW", 53, "W", 87, "VK_W", empty4, empty4],
      [0, 33, "KeyX", 54, "X", 88, "VK_X", empty4, empty4],
      [0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty4, empty4],
      [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty4, empty4],
      [0, 36, "Digit1", 22, "1", 49, "VK_1", empty4, empty4],
      [0, 37, "Digit2", 23, "2", 50, "VK_2", empty4, empty4],
      [0, 38, "Digit3", 24, "3", 51, "VK_3", empty4, empty4],
      [0, 39, "Digit4", 25, "4", 52, "VK_4", empty4, empty4],
      [0, 40, "Digit5", 26, "5", 53, "VK_5", empty4, empty4],
      [0, 41, "Digit6", 27, "6", 54, "VK_6", empty4, empty4],
      [0, 42, "Digit7", 28, "7", 55, "VK_7", empty4, empty4],
      [0, 43, "Digit8", 29, "8", 56, "VK_8", empty4, empty4],
      [0, 44, "Digit9", 30, "9", 57, "VK_9", empty4, empty4],
      [0, 45, "Digit0", 21, "0", 48, "VK_0", empty4, empty4],
      [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty4, empty4],
      [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty4, empty4],
      [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty4, empty4],
      [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty4, empty4],
      [1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty4, empty4],
      [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
      [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
      [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
      [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
      [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
      [0, 56, "IntlHash", 0, empty4, 0, empty4, empty4, empty4],
      // has been dropped from the w3c spec
      [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
      [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
      [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
      [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
      [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
      [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
      [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty4, empty4],
      [1, 64, "F1", 59, "F1", 112, "VK_F1", empty4, empty4],
      [1, 65, "F2", 60, "F2", 113, "VK_F2", empty4, empty4],
      [1, 66, "F3", 61, "F3", 114, "VK_F3", empty4, empty4],
      [1, 67, "F4", 62, "F4", 115, "VK_F4", empty4, empty4],
      [1, 68, "F5", 63, "F5", 116, "VK_F5", empty4, empty4],
      [1, 69, "F6", 64, "F6", 117, "VK_F6", empty4, empty4],
      [1, 70, "F7", 65, "F7", 118, "VK_F7", empty4, empty4],
      [1, 71, "F8", 66, "F8", 119, "VK_F8", empty4, empty4],
      [1, 72, "F9", 67, "F9", 120, "VK_F9", empty4, empty4],
      [1, 73, "F10", 68, "F10", 121, "VK_F10", empty4, empty4],
      [1, 74, "F11", 69, "F11", 122, "VK_F11", empty4, empty4],
      [1, 75, "F12", 70, "F12", 123, "VK_F12", empty4, empty4],
      [1, 76, "PrintScreen", 0, empty4, 0, empty4, empty4, empty4],
      [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", empty4, empty4],
      [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty4, empty4],
      [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty4, empty4],
      [1, 80, "Home", 14, "Home", 36, "VK_HOME", empty4, empty4],
      [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty4, empty4],
      [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty4, empty4],
      [1, 83, "End", 13, "End", 35, "VK_END", empty4, empty4],
      [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty4, empty4],
      [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty4],
      [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty4],
      [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty4],
      [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty4],
      [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", empty4, empty4],
      [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", empty4, empty4],
      [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", empty4, empty4],
      [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", empty4, empty4],
      [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", empty4, empty4],
      [1, 94, "NumpadEnter", 3, empty4, 0, empty4, empty4, empty4],
      [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", empty4, empty4],
      [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", empty4, empty4],
      [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", empty4, empty4],
      [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", empty4, empty4],
      [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", empty4, empty4],
      [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", empty4, empty4],
      [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", empty4, empty4],
      [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", empty4, empty4],
      [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", empty4, empty4],
      [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", empty4, empty4],
      [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", empty4, empty4],
      [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", empty4, empty4],
      [1, 107, "ContextMenu", 58, "ContextMenu", 93, empty4, empty4, empty4],
      [1, 108, "Power", 0, empty4, 0, empty4, empty4, empty4],
      [1, 109, "NumpadEqual", 0, empty4, 0, empty4, empty4, empty4],
      [1, 110, "F13", 71, "F13", 124, "VK_F13", empty4, empty4],
      [1, 111, "F14", 72, "F14", 125, "VK_F14", empty4, empty4],
      [1, 112, "F15", 73, "F15", 126, "VK_F15", empty4, empty4],
      [1, 113, "F16", 74, "F16", 127, "VK_F16", empty4, empty4],
      [1, 114, "F17", 75, "F17", 128, "VK_F17", empty4, empty4],
      [1, 115, "F18", 76, "F18", 129, "VK_F18", empty4, empty4],
      [1, 116, "F19", 77, "F19", 130, "VK_F19", empty4, empty4],
      [1, 117, "F20", 78, "F20", 131, "VK_F20", empty4, empty4],
      [1, 118, "F21", 79, "F21", 132, "VK_F21", empty4, empty4],
      [1, 119, "F22", 80, "F22", 133, "VK_F22", empty4, empty4],
      [1, 120, "F23", 81, "F23", 134, "VK_F23", empty4, empty4],
      [1, 121, "F24", 82, "F24", 135, "VK_F24", empty4, empty4],
      [1, 122, "Open", 0, empty4, 0, empty4, empty4, empty4],
      [1, 123, "Help", 0, empty4, 0, empty4, empty4, empty4],
      [1, 124, "Select", 0, empty4, 0, empty4, empty4, empty4],
      [1, 125, "Again", 0, empty4, 0, empty4, empty4, empty4],
      [1, 126, "Undo", 0, empty4, 0, empty4, empty4, empty4],
      [1, 127, "Cut", 0, empty4, 0, empty4, empty4, empty4],
      [1, 128, "Copy", 0, empty4, 0, empty4, empty4, empty4],
      [1, 129, "Paste", 0, empty4, 0, empty4, empty4, empty4],
      [1, 130, "Find", 0, empty4, 0, empty4, empty4, empty4],
      [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty4, empty4],
      [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty4, empty4],
      [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty4, empty4],
      [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", empty4, empty4],
      [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", empty4, empty4],
      [1, 136, "KanaMode", 0, empty4, 0, empty4, empty4, empty4],
      [0, 137, "IntlYen", 0, empty4, 0, empty4, empty4, empty4],
      [1, 138, "Convert", 0, empty4, 0, empty4, empty4, empty4],
      [1, 139, "NonConvert", 0, empty4, 0, empty4, empty4, empty4],
      [1, 140, "Lang1", 0, empty4, 0, empty4, empty4, empty4],
      [1, 141, "Lang2", 0, empty4, 0, empty4, empty4, empty4],
      [1, 142, "Lang3", 0, empty4, 0, empty4, empty4, empty4],
      [1, 143, "Lang4", 0, empty4, 0, empty4, empty4, empty4],
      [1, 144, "Lang5", 0, empty4, 0, empty4, empty4, empty4],
      [1, 145, "Abort", 0, empty4, 0, empty4, empty4, empty4],
      [1, 146, "Props", 0, empty4, 0, empty4, empty4, empty4],
      [1, 147, "NumpadParenLeft", 0, empty4, 0, empty4, empty4, empty4],
      [1, 148, "NumpadParenRight", 0, empty4, 0, empty4, empty4, empty4],
      [1, 149, "NumpadBackspace", 0, empty4, 0, empty4, empty4, empty4],
      [1, 150, "NumpadMemoryStore", 0, empty4, 0, empty4, empty4, empty4],
      [1, 151, "NumpadMemoryRecall", 0, empty4, 0, empty4, empty4, empty4],
      [1, 152, "NumpadMemoryClear", 0, empty4, 0, empty4, empty4, empty4],
      [1, 153, "NumpadMemoryAdd", 0, empty4, 0, empty4, empty4, empty4],
      [1, 154, "NumpadMemorySubtract", 0, empty4, 0, empty4, empty4, empty4],
      [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", empty4, empty4],
      [1, 156, "NumpadClearEntry", 0, empty4, 0, empty4, empty4, empty4],
      [1, 0, empty4, 5, "Ctrl", 17, "VK_CONTROL", empty4, empty4],
      [1, 0, empty4, 4, "Shift", 16, "VK_SHIFT", empty4, empty4],
      [1, 0, empty4, 6, "Alt", 18, "VK_MENU", empty4, empty4],
      [1, 0, empty4, 57, "Meta", 91, "VK_COMMAND", empty4, empty4],
      [1, 157, "ControlLeft", 5, empty4, 0, "VK_LCONTROL", empty4, empty4],
      [1, 158, "ShiftLeft", 4, empty4, 0, "VK_LSHIFT", empty4, empty4],
      [1, 159, "AltLeft", 6, empty4, 0, "VK_LMENU", empty4, empty4],
      [1, 160, "MetaLeft", 57, empty4, 0, "VK_LWIN", empty4, empty4],
      [1, 161, "ControlRight", 5, empty4, 0, "VK_RCONTROL", empty4, empty4],
      [1, 162, "ShiftRight", 4, empty4, 0, "VK_RSHIFT", empty4, empty4],
      [1, 163, "AltRight", 6, empty4, 0, "VK_RMENU", empty4, empty4],
      [1, 164, "MetaRight", 57, empty4, 0, "VK_RWIN", empty4, empty4],
      [1, 165, "BrightnessUp", 0, empty4, 0, empty4, empty4, empty4],
      [1, 166, "BrightnessDown", 0, empty4, 0, empty4, empty4, empty4],
      [1, 167, "MediaPlay", 0, empty4, 0, empty4, empty4, empty4],
      [1, 168, "MediaRecord", 0, empty4, 0, empty4, empty4, empty4],
      [1, 169, "MediaFastForward", 0, empty4, 0, empty4, empty4, empty4],
      [1, 170, "MediaRewind", 0, empty4, 0, empty4, empty4, empty4],
      [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty4, empty4],
      [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty4, empty4],
      [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", empty4, empty4],
      [1, 174, "Eject", 0, empty4, 0, empty4, empty4, empty4],
      [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty4, empty4],
      [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty4, empty4],
      [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty4, empty4],
      [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty4, empty4],
      [1, 179, "LaunchApp1", 0, empty4, 0, "VK_MEDIA_LAUNCH_APP1", empty4, empty4],
      [1, 180, "SelectTask", 0, empty4, 0, empty4, empty4, empty4],
      [1, 181, "LaunchScreenSaver", 0, empty4, 0, empty4, empty4, empty4],
      [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty4, empty4],
      [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", empty4, empty4],
      [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", empty4, empty4],
      [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty4, empty4],
      [1, 186, "BrowserStop", 0, empty4, 0, "VK_BROWSER_STOP", empty4, empty4],
      [1, 187, "BrowserRefresh", 0, empty4, 0, "VK_BROWSER_REFRESH", empty4, empty4],
      [1, 188, "BrowserFavorites", 0, empty4, 0, "VK_BROWSER_FAVORITES", empty4, empty4],
      [1, 189, "ZoomToggle", 0, empty4, 0, empty4, empty4, empty4],
      [1, 190, "MailReply", 0, empty4, 0, empty4, empty4, empty4],
      [1, 191, "MailForward", 0, empty4, 0, empty4, empty4, empty4],
      [1, 192, "MailSend", 0, empty4, 0, empty4, empty4, empty4],
      // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
      // If an Input Method Editor is processing key input and the event is keydown, return 229.
      [1, 0, empty4, 114, "KeyInComposition", 229, empty4, empty4, empty4],
      [1, 0, empty4, 116, "ABNT_C2", 194, "VK_ABNT_C2", empty4, empty4],
      [1, 0, empty4, 96, "OEM_8", 223, "VK_OEM_8", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_KANA", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_HANGUL", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_JUNJA", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_FINAL", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_HANJA", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_KANJI", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_CONVERT", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_NONCONVERT", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_ACCEPT", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_MODECHANGE", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_SELECT", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_PRINT", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_EXECUTE", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_SNAPSHOT", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_HELP", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_APPS", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_PROCESSKEY", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_PACKET", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_DBE_SBCSCHAR", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_DBE_DBCSCHAR", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_ATTN", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_CRSEL", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_EXSEL", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_EREOF", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_PLAY", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_ZOOM", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_NONAME", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_PA1", empty4, empty4],
      [1, 0, empty4, 0, empty4, 0, "VK_OEM_CLEAR", empty4, empty4]
    ];
    const seenKeyCode = [];
    const seenScanCode = [];
    for (const mapping of mappings) {
      const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
      if (!seenScanCode[scanCode]) {
        seenScanCode[scanCode] = true;
        scanCodeIntToStr[scanCode] = scanCodeStr;
        scanCodeStrToInt[scanCodeStr] = scanCode;
        scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
        if (immutable) {
          IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
          if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
            IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
          }
        }
      }
      if (!seenKeyCode[keyCode]) {
        seenKeyCode[keyCode] = true;
        if (!keyCodeStr) {
          throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
        }
        uiMap.define(keyCode, keyCodeStr);
        userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
      }
      if (eventKeyCode) {
        EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
      }
      if (vkey) {
        NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
      }
    }
    IMMUTABLE_KEY_CODE_TO_CODE[
      3
      /* KeyCode.Enter */
    ] = 46;
  })();
  var KeyCodeUtils;
  (function(KeyCodeUtils2) {
    function toString4(keyCode) {
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toString = toString4;
    function fromString(key) {
      return uiMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromString = fromString;
    function toUserSettingsUS(keyCode) {
      return userSettingsUSMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
    function toUserSettingsGeneral(keyCode) {
      return userSettingsGeneralMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
    function fromUserSettings(key) {
      return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromUserSettings = fromUserSettings;
    function toElectronAccelerator(keyCode) {
      if (keyCode >= 98 && keyCode <= 113) {
        return null;
      }
      switch (keyCode) {
        case 16:
          return "Up";
        case 18:
          return "Down";
        case 15:
          return "Left";
        case 17:
          return "Right";
      }
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
  })(KeyCodeUtils || (KeyCodeUtils = {}));
  function KeyChord(firstPart, secondPart) {
    const chordPart = (secondPart & 65535) << 16 >>> 0;
    return (firstPart | chordPart) >>> 0;
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/selection.js
  var Selection = class extends Range {
    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
      super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
      this.selectionStartLineNumber = selectionStartLineNumber;
      this.selectionStartColumn = selectionStartColumn;
      this.positionLineNumber = positionLineNumber;
      this.positionColumn = positionColumn;
    }
    /**
     * Transform to a human-readable representation.
     */
    toString() {
      return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
    }
    /**
     * Test if equals other selection.
     */
    equalsSelection(other) {
      return Selection.selectionsEqual(this, other);
    }
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a, b) {
      return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
    }
    /**
     * Get directions (LTR or RTL).
     */
    getDirection() {
      if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
        return 0;
      }
      return 1;
    }
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber, endColumn) {
      if (this.getDirection() === 0) {
        return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
      }
      return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
    }
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition() {
      return new Position(this.positionLineNumber, this.positionColumn);
    }
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart() {
      return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
    }
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber, startColumn) {
      if (this.getDirection() === 0) {
        return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
      }
      return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
    }
    // ----
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start2, end = start2) {
      return new Selection(start2.lineNumber, start2.column, end.lineNumber, end.column);
    }
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range, direction) {
      if (direction === 0) {
        return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
      } else {
        return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
      }
    }
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel) {
      return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    }
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a, b) {
      if (a && !b || !a && b) {
        return false;
      }
      if (!a && !b) {
        return true;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0, len = a.length; i < len; i++) {
        if (!this.selectionsEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj) {
      return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
    }
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
      if (direction === 0) {
        return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/codiconsUtil.js
  var _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
  function register(id, fontCharacter) {
    if (isString(fontCharacter)) {
      const val = _codiconFontCharacters[fontCharacter];
      if (val === void 0) {
        throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);
      }
      fontCharacter = val;
    }
    _codiconFontCharacters[id] = fontCharacter;
    return { id };
  }

  // node_modules/monaco-editor-core/esm/vs/base/common/codiconsLibrary.js
  var codiconsLibrary = {
    add: register("add", 6e4),
    plus: register("plus", 6e4),
    gistNew: register("gist-new", 6e4),
    repoCreate: register("repo-create", 6e4),
    lightbulb: register("lightbulb", 60001),
    lightBulb: register("light-bulb", 60001),
    repo: register("repo", 60002),
    repoDelete: register("repo-delete", 60002),
    gistFork: register("gist-fork", 60003),
    repoForked: register("repo-forked", 60003),
    gitPullRequest: register("git-pull-request", 60004),
    gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
    recordKeys: register("record-keys", 60005),
    keyboard: register("keyboard", 60005),
    tag: register("tag", 60006),
    gitPullRequestLabel: register("git-pull-request-label", 60006),
    tagAdd: register("tag-add", 60006),
    tagRemove: register("tag-remove", 60006),
    person: register("person", 60007),
    personFollow: register("person-follow", 60007),
    personOutline: register("person-outline", 60007),
    personFilled: register("person-filled", 60007),
    gitBranch: register("git-branch", 60008),
    gitBranchCreate: register("git-branch-create", 60008),
    gitBranchDelete: register("git-branch-delete", 60008),
    sourceControl: register("source-control", 60008),
    mirror: register("mirror", 60009),
    mirrorPublic: register("mirror-public", 60009),
    star: register("star", 60010),
    starAdd: register("star-add", 60010),
    starDelete: register("star-delete", 60010),
    starEmpty: register("star-empty", 60010),
    comment: register("comment", 60011),
    commentAdd: register("comment-add", 60011),
    alert: register("alert", 60012),
    warning: register("warning", 60012),
    search: register("search", 60013),
    searchSave: register("search-save", 60013),
    logOut: register("log-out", 60014),
    signOut: register("sign-out", 60014),
    logIn: register("log-in", 60015),
    signIn: register("sign-in", 60015),
    eye: register("eye", 60016),
    eyeUnwatch: register("eye-unwatch", 60016),
    eyeWatch: register("eye-watch", 60016),
    circleFilled: register("circle-filled", 60017),
    primitiveDot: register("primitive-dot", 60017),
    closeDirty: register("close-dirty", 60017),
    debugBreakpoint: register("debug-breakpoint", 60017),
    debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
    debugHint: register("debug-hint", 60017),
    terminalDecorationSuccess: register("terminal-decoration-success", 60017),
    primitiveSquare: register("primitive-square", 60018),
    edit: register("edit", 60019),
    pencil: register("pencil", 60019),
    info: register("info", 60020),
    issueOpened: register("issue-opened", 60020),
    gistPrivate: register("gist-private", 60021),
    gitForkPrivate: register("git-fork-private", 60021),
    lock: register("lock", 60021),
    mirrorPrivate: register("mirror-private", 60021),
    close: register("close", 60022),
    removeClose: register("remove-close", 60022),
    x: register("x", 60022),
    repoSync: register("repo-sync", 60023),
    sync: register("sync", 60023),
    clone: register("clone", 60024),
    desktopDownload: register("desktop-download", 60024),
    beaker: register("beaker", 60025),
    microscope: register("microscope", 60025),
    vm: register("vm", 60026),
    deviceDesktop: register("device-desktop", 60026),
    file: register("file", 60027),
    fileText: register("file-text", 60027),
    more: register("more", 60028),
    ellipsis: register("ellipsis", 60028),
    kebabHorizontal: register("kebab-horizontal", 60028),
    mailReply: register("mail-reply", 60029),
    reply: register("reply", 60029),
    organization: register("organization", 60030),
    organizationFilled: register("organization-filled", 60030),
    organizationOutline: register("organization-outline", 60030),
    newFile: register("new-file", 60031),
    fileAdd: register("file-add", 60031),
    newFolder: register("new-folder", 60032),
    fileDirectoryCreate: register("file-directory-create", 60032),
    trash: register("trash", 60033),
    trashcan: register("trashcan", 60033),
    history: register("history", 60034),
    clock: register("clock", 60034),
    folder: register("folder", 60035),
    fileDirectory: register("file-directory", 60035),
    symbolFolder: register("symbol-folder", 60035),
    logoGithub: register("logo-github", 60036),
    markGithub: register("mark-github", 60036),
    github: register("github", 60036),
    terminal: register("terminal", 60037),
    console: register("console", 60037),
    repl: register("repl", 60037),
    zap: register("zap", 60038),
    symbolEvent: register("symbol-event", 60038),
    error: register("error", 60039),
    stop: register("stop", 60039),
    variable: register("variable", 60040),
    symbolVariable: register("symbol-variable", 60040),
    array: register("array", 60042),
    symbolArray: register("symbol-array", 60042),
    symbolModule: register("symbol-module", 60043),
    symbolPackage: register("symbol-package", 60043),
    symbolNamespace: register("symbol-namespace", 60043),
    symbolObject: register("symbol-object", 60043),
    symbolMethod: register("symbol-method", 60044),
    symbolFunction: register("symbol-function", 60044),
    symbolConstructor: register("symbol-constructor", 60044),
    symbolBoolean: register("symbol-boolean", 60047),
    symbolNull: register("symbol-null", 60047),
    symbolNumeric: register("symbol-numeric", 60048),
    symbolNumber: register("symbol-number", 60048),
    symbolStructure: register("symbol-structure", 60049),
    symbolStruct: register("symbol-struct", 60049),
    symbolParameter: register("symbol-parameter", 60050),
    symbolTypeParameter: register("symbol-type-parameter", 60050),
    symbolKey: register("symbol-key", 60051),
    symbolText: register("symbol-text", 60051),
    symbolReference: register("symbol-reference", 60052),
    goToFile: register("go-to-file", 60052),
    symbolEnum: register("symbol-enum", 60053),
    symbolValue: register("symbol-value", 60053),
    symbolRuler: register("symbol-ruler", 60054),
    symbolUnit: register("symbol-unit", 60054),
    activateBreakpoints: register("activate-breakpoints", 60055),
    archive: register("archive", 60056),
    arrowBoth: register("arrow-both", 60057),
    arrowDown: register("arrow-down", 60058),
    arrowLeft: register("arrow-left", 60059),
    arrowRight: register("arrow-right", 60060),
    arrowSmallDown: register("arrow-small-down", 60061),
    arrowSmallLeft: register("arrow-small-left", 60062),
    arrowSmallRight: register("arrow-small-right", 60063),
    arrowSmallUp: register("arrow-small-up", 60064),
    arrowUp: register("arrow-up", 60065),
    bell: register("bell", 60066),
    bold: register("bold", 60067),
    book: register("book", 60068),
    bookmark: register("bookmark", 60069),
    debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
    debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
    debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
    debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
    debugBreakpointData: register("debug-breakpoint-data", 60073),
    debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
    debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
    debugBreakpointLog: register("debug-breakpoint-log", 60075),
    debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
    briefcase: register("briefcase", 60076),
    broadcast: register("broadcast", 60077),
    browser: register("browser", 60078),
    bug: register("bug", 60079),
    calendar: register("calendar", 60080),
    caseSensitive: register("case-sensitive", 60081),
    check: register("check", 60082),
    checklist: register("checklist", 60083),
    chevronDown: register("chevron-down", 60084),
    chevronLeft: register("chevron-left", 60085),
    chevronRight: register("chevron-right", 60086),
    chevronUp: register("chevron-up", 60087),
    chromeClose: register("chrome-close", 60088),
    chromeMaximize: register("chrome-maximize", 60089),
    chromeMinimize: register("chrome-minimize", 60090),
    chromeRestore: register("chrome-restore", 60091),
    circleOutline: register("circle-outline", 60092),
    circle: register("circle", 60092),
    debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
    terminalDecorationIncomplete: register("terminal-decoration-incomplete", 60092),
    circleSlash: register("circle-slash", 60093),
    circuitBoard: register("circuit-board", 60094),
    clearAll: register("clear-all", 60095),
    clippy: register("clippy", 60096),
    closeAll: register("close-all", 60097),
    cloudDownload: register("cloud-download", 60098),
    cloudUpload: register("cloud-upload", 60099),
    code: register("code", 60100),
    collapseAll: register("collapse-all", 60101),
    colorMode: register("color-mode", 60102),
    commentDiscussion: register("comment-discussion", 60103),
    creditCard: register("credit-card", 60105),
    dash: register("dash", 60108),
    dashboard: register("dashboard", 60109),
    database: register("database", 60110),
    debugContinue: register("debug-continue", 60111),
    debugDisconnect: register("debug-disconnect", 60112),
    debugPause: register("debug-pause", 60113),
    debugRestart: register("debug-restart", 60114),
    debugStart: register("debug-start", 60115),
    debugStepInto: register("debug-step-into", 60116),
    debugStepOut: register("debug-step-out", 60117),
    debugStepOver: register("debug-step-over", 60118),
    debugStop: register("debug-stop", 60119),
    debug: register("debug", 60120),
    deviceCameraVideo: register("device-camera-video", 60121),
    deviceCamera: register("device-camera", 60122),
    deviceMobile: register("device-mobile", 60123),
    diffAdded: register("diff-added", 60124),
    diffIgnored: register("diff-ignored", 60125),
    diffModified: register("diff-modified", 60126),
    diffRemoved: register("diff-removed", 60127),
    diffRenamed: register("diff-renamed", 60128),
    diff: register("diff", 60129),
    diffSidebyside: register("diff-sidebyside", 60129),
    discard: register("discard", 60130),
    editorLayout: register("editor-layout", 60131),
    emptyWindow: register("empty-window", 60132),
    exclude: register("exclude", 60133),
    extensions: register("extensions", 60134),
    eyeClosed: register("eye-closed", 60135),
    fileBinary: register("file-binary", 60136),
    fileCode: register("file-code", 60137),
    fileMedia: register("file-media", 60138),
    filePdf: register("file-pdf", 60139),
    fileSubmodule: register("file-submodule", 60140),
    fileSymlinkDirectory: register("file-symlink-directory", 60141),
    fileSymlinkFile: register("file-symlink-file", 60142),
    fileZip: register("file-zip", 60143),
    files: register("files", 60144),
    filter: register("filter", 60145),
    flame: register("flame", 60146),
    foldDown: register("fold-down", 60147),
    foldUp: register("fold-up", 60148),
    fold: register("fold", 60149),
    folderActive: register("folder-active", 60150),
    folderOpened: register("folder-opened", 60151),
    gear: register("gear", 60152),
    gift: register("gift", 60153),
    gistSecret: register("gist-secret", 60154),
    gist: register("gist", 60155),
    gitCommit: register("git-commit", 60156),
    gitCompare: register("git-compare", 60157),
    compareChanges: register("compare-changes", 60157),
    gitMerge: register("git-merge", 60158),
    githubAction: register("github-action", 60159),
    githubAlt: register("github-alt", 60160),
    globe: register("globe", 60161),
    grabber: register("grabber", 60162),
    graph: register("graph", 60163),
    gripper: register("gripper", 60164),
    heart: register("heart", 60165),
    home: register("home", 60166),
    horizontalRule: register("horizontal-rule", 60167),
    hubot: register("hubot", 60168),
    inbox: register("inbox", 60169),
    issueReopened: register("issue-reopened", 60171),
    issues: register("issues", 60172),
    italic: register("italic", 60173),
    jersey: register("jersey", 60174),
    json: register("json", 60175),
    kebabVertical: register("kebab-vertical", 60176),
    key: register("key", 60177),
    law: register("law", 60178),
    lightbulbAutofix: register("lightbulb-autofix", 60179),
    linkExternal: register("link-external", 60180),
    link: register("link", 60181),
    listOrdered: register("list-ordered", 60182),
    listUnordered: register("list-unordered", 60183),
    liveShare: register("live-share", 60184),
    loading: register("loading", 60185),
    location: register("location", 60186),
    mailRead: register("mail-read", 60187),
    mail: register("mail", 60188),
    markdown: register("markdown", 60189),
    megaphone: register("megaphone", 60190),
    mention: register("mention", 60191),
    milestone: register("milestone", 60192),
    gitPullRequestMilestone: register("git-pull-request-milestone", 60192),
    mortarBoard: register("mortar-board", 60193),
    move: register("move", 60194),
    multipleWindows: register("multiple-windows", 60195),
    mute: register("mute", 60196),
    noNewline: register("no-newline", 60197),
    note: register("note", 60198),
    octoface: register("octoface", 60199),
    openPreview: register("open-preview", 60200),
    package: register("package", 60201),
    paintcan: register("paintcan", 60202),
    pin: register("pin", 60203),
    play: register("play", 60204),
    run: register("run", 60204),
    plug: register("plug", 60205),
    preserveCase: register("preserve-case", 60206),
    preview: register("preview", 60207),
    project: register("project", 60208),
    pulse: register("pulse", 60209),
    question: register("question", 60210),
    quote: register("quote", 60211),
    radioTower: register("radio-tower", 60212),
    reactions: register("reactions", 60213),
    references: register("references", 60214),
    refresh: register("refresh", 60215),
    regex: register("regex", 60216),
    remoteExplorer: register("remote-explorer", 60217),
    remote: register("remote", 60218),
    remove: register("remove", 60219),
    replaceAll: register("replace-all", 60220),
    replace: register("replace", 60221),
    repoClone: register("repo-clone", 60222),
    repoForcePush: register("repo-force-push", 60223),
    repoPull: register("repo-pull", 60224),
    repoPush: register("repo-push", 60225),
    report: register("report", 60226),
    requestChanges: register("request-changes", 60227),
    rocket: register("rocket", 60228),
    rootFolderOpened: register("root-folder-opened", 60229),
    rootFolder: register("root-folder", 60230),
    rss: register("rss", 60231),
    ruby: register("ruby", 60232),
    saveAll: register("save-all", 60233),
    saveAs: register("save-as", 60234),
    save: register("save", 60235),
    screenFull: register("screen-full", 60236),
    screenNormal: register("screen-normal", 60237),
    searchStop: register("search-stop", 60238),
    server: register("server", 60240),
    settingsGear: register("settings-gear", 60241),
    settings: register("settings", 60242),
    shield: register("shield", 60243),
    smiley: register("smiley", 60244),
    sortPrecedence: register("sort-precedence", 60245),
    splitHorizontal: register("split-horizontal", 60246),
    splitVertical: register("split-vertical", 60247),
    squirrel: register("squirrel", 60248),
    starFull: register("star-full", 60249),
    starHalf: register("star-half", 60250),
    symbolClass: register("symbol-class", 60251),
    symbolColor: register("symbol-color", 60252),
    symbolConstant: register("symbol-constant", 60253),
    symbolEnumMember: register("symbol-enum-member", 60254),
    symbolField: register("symbol-field", 60255),
    symbolFile: register("symbol-file", 60256),
    symbolInterface: register("symbol-interface", 60257),
    symbolKeyword: register("symbol-keyword", 60258),
    symbolMisc: register("symbol-misc", 60259),
    symbolOperator: register("symbol-operator", 60260),
    symbolProperty: register("symbol-property", 60261),
    wrench: register("wrench", 60261),
    wrenchSubaction: register("wrench-subaction", 60261),
    symbolSnippet: register("symbol-snippet", 60262),
    tasklist: register("tasklist", 60263),
    telescope: register("telescope", 60264),
    textSize: register("text-size", 60265),
    threeBars: register("three-bars", 60266),
    thumbsdown: register("thumbsdown", 60267),
    thumbsup: register("thumbsup", 60268),
    tools: register("tools", 60269),
    triangleDown: register("triangle-down", 60270),
    triangleLeft: register("triangle-left", 60271),
    triangleRight: register("triangle-right", 60272),
    triangleUp: register("triangle-up", 60273),
    twitter: register("twitter", 60274),
    unfold: register("unfold", 60275),
    unlock: register("unlock", 60276),
    unmute: register("unmute", 60277),
    unverified: register("unverified", 60278),
    verified: register("verified", 60279),
    versions: register("versions", 60280),
    vmActive: register("vm-active", 60281),
    vmOutline: register("vm-outline", 60282),
    vmRunning: register("vm-running", 60283),
    watch: register("watch", 60284),
    whitespace: register("whitespace", 60285),
    wholeWord: register("whole-word", 60286),
    window: register("window", 60287),
    wordWrap: register("word-wrap", 60288),
    zoomIn: register("zoom-in", 60289),
    zoomOut: register("zoom-out", 60290),
    listFilter: register("list-filter", 60291),
    listFlat: register("list-flat", 60292),
    listSelection: register("list-selection", 60293),
    selection: register("selection", 60293),
    listTree: register("list-tree", 60294),
    debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
    debugBreakpointFunction: register("debug-breakpoint-function", 60296),
    debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
    debugStackframeActive: register("debug-stackframe-active", 60297),
    circleSmallFilled: register("circle-small-filled", 60298),
    debugStackframeDot: register("debug-stackframe-dot", 60298),
    terminalDecorationMark: register("terminal-decoration-mark", 60298),
    debugStackframe: register("debug-stackframe", 60299),
    debugStackframeFocused: register("debug-stackframe-focused", 60299),
    debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
    symbolString: register("symbol-string", 60301),
    debugReverseContinue: register("debug-reverse-continue", 60302),
    debugStepBack: register("debug-step-back", 60303),
    debugRestartFrame: register("debug-restart-frame", 60304),
    debugAlt: register("debug-alt", 60305),
    callIncoming: register("call-incoming", 60306),
    callOutgoing: register("call-outgoing", 60307),
    menu: register("menu", 60308),
    expandAll: register("expand-all", 60309),
    feedback: register("feedback", 60310),
    gitPullRequestReviewer: register("git-pull-request-reviewer", 60310),
    groupByRefType: register("group-by-ref-type", 60311),
    ungroupByRefType: register("ungroup-by-ref-type", 60312),
    account: register("account", 60313),
    gitPullRequestAssignee: register("git-pull-request-assignee", 60313),
    bellDot: register("bell-dot", 60314),
    debugConsole: register("debug-console", 60315),
    library: register("library", 60316),
    output: register("output", 60317),
    runAll: register("run-all", 60318),
    syncIgnored: register("sync-ignored", 60319),
    pinned: register("pinned", 60320),
    githubInverted: register("github-inverted", 60321),
    serverProcess: register("server-process", 60322),
    serverEnvironment: register("server-environment", 60323),
    pass: register("pass", 60324),
    issueClosed: register("issue-closed", 60324),
    stopCircle: register("stop-circle", 60325),
    playCircle: register("play-circle", 60326),
    record: register("record", 60327),
    debugAltSmall: register("debug-alt-small", 60328),
    vmConnect: register("vm-connect", 60329),
    cloud: register("cloud", 60330),
    merge: register("merge", 60331),
    export: register("export", 60332),
    graphLeft: register("graph-left", 60333),
    magnet: register("magnet", 60334),
    notebook: register("notebook", 60335),
    redo: register("redo", 60336),
    checkAll: register("check-all", 60337),
    pinnedDirty: register("pinned-dirty", 60338),
    passFilled: register("pass-filled", 60339),
    circleLargeFilled: register("circle-large-filled", 60340),
    circleLarge: register("circle-large", 60341),
    circleLargeOutline: register("circle-large-outline", 60341),
    combine: register("combine", 60342),
    gather: register("gather", 60342),
    table: register("table", 60343),
    variableGroup: register("variable-group", 60344),
    typeHierarchy: register("type-hierarchy", 60345),
    typeHierarchySub: register("type-hierarchy-sub", 60346),
    typeHierarchySuper: register("type-hierarchy-super", 60347),
    gitPullRequestCreate: register("git-pull-request-create", 60348),
    runAbove: register("run-above", 60349),
    runBelow: register("run-below", 60350),
    notebookTemplate: register("notebook-template", 60351),
    debugRerun: register("debug-rerun", 60352),
    workspaceTrusted: register("workspace-trusted", 60353),
    workspaceUntrusted: register("workspace-untrusted", 60354),
    workspaceUnknown: register("workspace-unknown", 60355),
    terminalCmd: register("terminal-cmd", 60356),
    terminalDebian: register("terminal-debian", 60357),
    terminalLinux: register("terminal-linux", 60358),
    terminalPowershell: register("terminal-powershell", 60359),
    terminalTmux: register("terminal-tmux", 60360),
    terminalUbuntu: register("terminal-ubuntu", 60361),
    terminalBash: register("terminal-bash", 60362),
    arrowSwap: register("arrow-swap", 60363),
    copy: register("copy", 60364),
    personAdd: register("person-add", 60365),
    filterFilled: register("filter-filled", 60366),
    wand: register("wand", 60367),
    debugLineByLine: register("debug-line-by-line", 60368),
    inspect: register("inspect", 60369),
    layers: register("layers", 60370),
    layersDot: register("layers-dot", 60371),
    layersActive: register("layers-active", 60372),
    compass: register("compass", 60373),
    compassDot: register("compass-dot", 60374),
    compassActive: register("compass-active", 60375),
    azure: register("azure", 60376),
    issueDraft: register("issue-draft", 60377),
    gitPullRequestClosed: register("git-pull-request-closed", 60378),
    gitPullRequestDraft: register("git-pull-request-draft", 60379),
    debugAll: register("debug-all", 60380),
    debugCoverage: register("debug-coverage", 60381),
    runErrors: register("run-errors", 60382),
    folderLibrary: register("folder-library", 60383),
    debugContinueSmall: register("debug-continue-small", 60384),
    beakerStop: register("beaker-stop", 60385),
    graphLine: register("graph-line", 60386),
    graphScatter: register("graph-scatter", 60387),
    pieChart: register("pie-chart", 60388),
    bracket: register("bracket", 60175),
    bracketDot: register("bracket-dot", 60389),
    bracketError: register("bracket-error", 60390),
    lockSmall: register("lock-small", 60391),
    azureDevops: register("azure-devops", 60392),
    verifiedFilled: register("verified-filled", 60393),
    newline: register("newline", 60394),
    layout: register("layout", 60395),
    layoutActivitybarLeft: register("layout-activitybar-left", 60396),
    layoutActivitybarRight: register("layout-activitybar-right", 60397),
    layoutPanelLeft: register("layout-panel-left", 60398),
    layoutPanelCenter: register("layout-panel-center", 60399),
    layoutPanelJustify: register("layout-panel-justify", 60400),
    layoutPanelRight: register("layout-panel-right", 60401),
    layoutPanel: register("layout-panel", 60402),
    layoutSidebarLeft: register("layout-sidebar-left", 60403),
    layoutSidebarRight: register("layout-sidebar-right", 60404),
    layoutStatusbar: register("layout-statusbar", 60405),
    layoutMenubar: register("layout-menubar", 60406),
    layoutCentered: register("layout-centered", 60407),
    target: register("target", 60408),
    indent: register("indent", 60409),
    recordSmall: register("record-small", 60410),
    errorSmall: register("error-small", 60411),
    terminalDecorationError: register("terminal-decoration-error", 60411),
    arrowCircleDown: register("arrow-circle-down", 60412),
    arrowCircleLeft: register("arrow-circle-left", 60413),
    arrowCircleRight: register("arrow-circle-right", 60414),
    arrowCircleUp: register("arrow-circle-up", 60415),
    layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
    layoutPanelOff: register("layout-panel-off", 60417),
    layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
    blank: register("blank", 60419),
    heartFilled: register("heart-filled", 60420),
    map: register("map", 60421),
    mapHorizontal: register("map-horizontal", 60421),
    foldHorizontal: register("fold-horizontal", 60421),
    mapFilled: register("map-filled", 60422),
    mapHorizontalFilled: register("map-horizontal-filled", 60422),
    foldHorizontalFilled: register("fold-horizontal-filled", 60422),
    circleSmall: register("circle-small", 60423),
    bellSlash: register("bell-slash", 60424),
    bellSlashDot: register("bell-slash-dot", 60425),
    commentUnresolved: register("comment-unresolved", 60426),
    gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
    gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
    searchFuzzy: register("search-fuzzy", 60429),
    commentDraft: register("comment-draft", 60430),
    send: register("send", 60431),
    sparkle: register("sparkle", 60432),
    insert: register("insert", 60433),
    mic: register("mic", 60434),
    thumbsdownFilled: register("thumbsdown-filled", 60435),
    thumbsupFilled: register("thumbsup-filled", 60436),
    coffee: register("coffee", 60437),
    snake: register("snake", 60438),
    game: register("game", 60439),
    vr: register("vr", 60440),
    chip: register("chip", 60441),
    piano: register("piano", 60442),
    music: register("music", 60443),
    micFilled: register("mic-filled", 60444),
    repoFetch: register("repo-fetch", 60445),
    copilot: register("copilot", 60446),
    lightbulbSparkle: register("lightbulb-sparkle", 60447),
    robot: register("robot", 60448),
    sparkleFilled: register("sparkle-filled", 60449),
    diffSingle: register("diff-single", 60450),
    diffMultiple: register("diff-multiple", 60451),
    surroundWith: register("surround-with", 60452),
    share: register("share", 60453),
    gitStash: register("git-stash", 60454),
    gitStashApply: register("git-stash-apply", 60455),
    gitStashPop: register("git-stash-pop", 60456),
    vscode: register("vscode", 60457),
    vscodeInsiders: register("vscode-insiders", 60458),
    codeOss: register("code-oss", 60459),
    runCoverage: register("run-coverage", 60460),
    runAllCoverage: register("run-all-coverage", 60461),
    coverage: register("coverage", 60462),
    githubProject: register("github-project", 60463),
    mapVertical: register("map-vertical", 60464),
    foldVertical: register("fold-vertical", 60464),
    mapVerticalFilled: register("map-vertical-filled", 60465),
    foldVerticalFilled: register("fold-vertical-filled", 60465),
    goToSearch: register("go-to-search", 60466),
    percentage: register("percentage", 60467),
    sortPercentage: register("sort-percentage", 60467),
    attach: register("attach", 60468)
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/codicons.js
  var codiconsDerived = {
    dialogError: register("dialog-error", "error"),
    dialogWarning: register("dialog-warning", "warning"),
    dialogInfo: register("dialog-info", "info"),
    dialogClose: register("dialog-close", "close"),
    treeItemExpanded: register("tree-item-expanded", "chevron-down"),
    // collapsed is done with rotation
    treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
    treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
    treeFilterClear: register("tree-filter-clear", "close"),
    treeItemLoading: register("tree-item-loading", "loading"),
    menuSelection: register("menu-selection", "check"),
    menuSubmenu: register("menu-submenu", "chevron-right"),
    menuBarMore: register("menubar-more", "more"),
    scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
    scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
    scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
    scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
    toolBarMore: register("toolbar-more", "more"),
    quickInputBack: register("quick-input-back", "arrow-left"),
    dropDownButton: register("drop-down-button", 60084),
    symbolCustomColor: register("symbol-customcolor", 60252),
    exportIcon: register("export", 60332),
    workspaceUnspecified: register("workspace-unspecified", 60355),
    newLine: register("newline", 60394),
    thumbsDownFilled: register("thumbsdown-filled", 60435),
    thumbsUpFilled: register("thumbsup-filled", 60436),
    gitFetch: register("git-fetch", 60445),
    lightbulbSparkleAutofix: register("lightbulb-sparkle-autofix", 60447),
    debugBreakpointPending: register("debug-breakpoint-pending", 60377)
  };
  var Codicon = {
    ...codiconsLibrary,
    ...codiconsDerived
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/tokenizationRegistry.js
  var TokenizationRegistry = class {
    constructor() {
      this._tokenizationSupports = /* @__PURE__ */ new Map();
      this._factories = /* @__PURE__ */ new Map();
      this._onDidChange = new Emitter();
      this.onDidChange = this._onDidChange.event;
      this._colorMap = null;
    }
    handleChange(languageIds) {
      this._onDidChange.fire({
        changedLanguages: languageIds,
        changedColorMap: false
      });
    }
    register(languageId, support) {
      this._tokenizationSupports.set(languageId, support);
      this.handleChange([languageId]);
      return toDisposable(() => {
        if (this._tokenizationSupports.get(languageId) !== support) {
          return;
        }
        this._tokenizationSupports.delete(languageId);
        this.handleChange([languageId]);
      });
    }
    get(languageId) {
      return this._tokenizationSupports.get(languageId) || null;
    }
    registerFactory(languageId, factory) {
      var _a4;
      (_a4 = this._factories.get(languageId)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
      const myData = new TokenizationSupportFactoryData(this, languageId, factory);
      this._factories.set(languageId, myData);
      return toDisposable(() => {
        const v = this._factories.get(languageId);
        if (!v || v !== myData) {
          return;
        }
        this._factories.delete(languageId);
        v.dispose();
      });
    }
    async getOrCreate(languageId) {
      const tokenizationSupport = this.get(languageId);
      if (tokenizationSupport) {
        return tokenizationSupport;
      }
      const factory = this._factories.get(languageId);
      if (!factory || factory.isResolved) {
        return null;
      }
      await factory.resolve();
      return this.get(languageId);
    }
    isResolved(languageId) {
      const tokenizationSupport = this.get(languageId);
      if (tokenizationSupport) {
        return true;
      }
      const factory = this._factories.get(languageId);
      if (!factory || factory.isResolved) {
        return true;
      }
      return false;
    }
    setColorMap(colorMap) {
      this._colorMap = colorMap;
      this._onDidChange.fire({
        changedLanguages: Array.from(this._tokenizationSupports.keys()),
        changedColorMap: true
      });
    }
    getColorMap() {
      return this._colorMap;
    }
    getDefaultBackground() {
      if (this._colorMap && this._colorMap.length > 2) {
        return this._colorMap[
          2
          /* ColorId.DefaultBackground */
        ];
      }
      return null;
    }
  };
  var TokenizationSupportFactoryData = class extends Disposable {
    get isResolved() {
      return this._isResolved;
    }
    constructor(_registry, _languageId, _factory) {
      super();
      this._registry = _registry;
      this._languageId = _languageId;
      this._factory = _factory;
      this._isDisposed = false;
      this._resolvePromise = null;
      this._isResolved = false;
    }
    dispose() {
      this._isDisposed = true;
      super.dispose();
    }
    async resolve() {
      if (!this._resolvePromise) {
        this._resolvePromise = this._create();
      }
      return this._resolvePromise;
    }
    async _create() {
      const value = await this._factory.tokenizationSupport;
      this._isResolved = true;
      if (value && !this._isDisposed) {
        this._register(this._registry.register(this._languageId, value));
      }
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/languages.js
  var Token = class {
    constructor(offset2, type, language) {
      this.offset = offset2;
      this.type = type;
      this.language = language;
      this._tokenBrand = void 0;
    }
    toString() {
      return "(" + this.offset + ", " + this.type + ")";
    }
  };
  var HoverVerbosityAction;
  (function(HoverVerbosityAction3) {
    HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
    HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
  })(HoverVerbosityAction || (HoverVerbosityAction = {}));
  var CompletionItemKinds;
  (function(CompletionItemKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolMethod);
    byKind.set(1, Codicon.symbolFunction);
    byKind.set(2, Codicon.symbolConstructor);
    byKind.set(3, Codicon.symbolField);
    byKind.set(4, Codicon.symbolVariable);
    byKind.set(5, Codicon.symbolClass);
    byKind.set(6, Codicon.symbolStruct);
    byKind.set(7, Codicon.symbolInterface);
    byKind.set(8, Codicon.symbolModule);
    byKind.set(9, Codicon.symbolProperty);
    byKind.set(10, Codicon.symbolEvent);
    byKind.set(11, Codicon.symbolOperator);
    byKind.set(12, Codicon.symbolUnit);
    byKind.set(13, Codicon.symbolValue);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(14, Codicon.symbolConstant);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(16, Codicon.symbolEnumMember);
    byKind.set(17, Codicon.symbolKeyword);
    byKind.set(27, Codicon.symbolSnippet);
    byKind.set(18, Codicon.symbolText);
    byKind.set(19, Codicon.symbolColor);
    byKind.set(20, Codicon.symbolFile);
    byKind.set(21, Codicon.symbolReference);
    byKind.set(22, Codicon.symbolCustomColor);
    byKind.set(23, Codicon.symbolFolder);
    byKind.set(24, Codicon.symbolTypeParameter);
    byKind.set(25, Codicon.account);
    byKind.set(26, Codicon.issues);
    function toIcon(kind) {
      let codicon = byKind.get(kind);
      if (!codicon) {
        console.info("No codicon found for CompletionItemKind " + kind);
        codicon = Codicon.symbolProperty;
      }
      return codicon;
    }
    CompletionItemKinds2.toIcon = toIcon;
    const data2 = /* @__PURE__ */ new Map();
    data2.set(
      "method",
      0
      /* CompletionItemKind.Method */
    );
    data2.set(
      "function",
      1
      /* CompletionItemKind.Function */
    );
    data2.set(
      "constructor",
      2
      /* CompletionItemKind.Constructor */
    );
    data2.set(
      "field",
      3
      /* CompletionItemKind.Field */
    );
    data2.set(
      "variable",
      4
      /* CompletionItemKind.Variable */
    );
    data2.set(
      "class",
      5
      /* CompletionItemKind.Class */
    );
    data2.set(
      "struct",
      6
      /* CompletionItemKind.Struct */
    );
    data2.set(
      "interface",
      7
      /* CompletionItemKind.Interface */
    );
    data2.set(
      "module",
      8
      /* CompletionItemKind.Module */
    );
    data2.set(
      "property",
      9
      /* CompletionItemKind.Property */
    );
    data2.set(
      "event",
      10
      /* CompletionItemKind.Event */
    );
    data2.set(
      "operator",
      11
      /* CompletionItemKind.Operator */
    );
    data2.set(
      "unit",
      12
      /* CompletionItemKind.Unit */
    );
    data2.set(
      "value",
      13
      /* CompletionItemKind.Value */
    );
    data2.set(
      "constant",
      14
      /* CompletionItemKind.Constant */
    );
    data2.set(
      "enum",
      15
      /* CompletionItemKind.Enum */
    );
    data2.set(
      "enum-member",
      16
      /* CompletionItemKind.EnumMember */
    );
    data2.set(
      "enumMember",
      16
      /* CompletionItemKind.EnumMember */
    );
    data2.set(
      "keyword",
      17
      /* CompletionItemKind.Keyword */
    );
    data2.set(
      "snippet",
      27
      /* CompletionItemKind.Snippet */
    );
    data2.set(
      "text",
      18
      /* CompletionItemKind.Text */
    );
    data2.set(
      "color",
      19
      /* CompletionItemKind.Color */
    );
    data2.set(
      "file",
      20
      /* CompletionItemKind.File */
    );
    data2.set(
      "reference",
      21
      /* CompletionItemKind.Reference */
    );
    data2.set(
      "customcolor",
      22
      /* CompletionItemKind.Customcolor */
    );
    data2.set(
      "folder",
      23
      /* CompletionItemKind.Folder */
    );
    data2.set(
      "type-parameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data2.set(
      "typeParameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data2.set(
      "account",
      25
      /* CompletionItemKind.User */
    );
    data2.set(
      "issue",
      26
      /* CompletionItemKind.Issue */
    );
    function fromString(value, strict) {
      let res = data2.get(value);
      if (typeof res === "undefined" && !strict) {
        res = 9;
      }
      return res;
    }
    CompletionItemKinds2.fromString = fromString;
  })(CompletionItemKinds || (CompletionItemKinds = {}));
  var InlineCompletionTriggerKind;
  (function(InlineCompletionTriggerKind3) {
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
  var DocumentPasteTriggerKind;
  (function(DocumentPasteTriggerKind2) {
    DocumentPasteTriggerKind2[DocumentPasteTriggerKind2["Automatic"] = 0] = "Automatic";
    DocumentPasteTriggerKind2[DocumentPasteTriggerKind2["PasteAs"] = 1] = "PasteAs";
  })(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));
  var SignatureHelpTriggerKind;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
  var DocumentHighlightKind;
  (function(DocumentHighlightKind3) {
    DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
    DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
    DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
  })(DocumentHighlightKind || (DocumentHighlightKind = {}));
  var symbolKindNames = {
    [
      17
      /* SymbolKind.Array */
    ]: localize("Array", "array"),
    [
      16
      /* SymbolKind.Boolean */
    ]: localize("Boolean", "boolean"),
    [
      4
      /* SymbolKind.Class */
    ]: localize("Class", "class"),
    [
      13
      /* SymbolKind.Constant */
    ]: localize("Constant", "constant"),
    [
      8
      /* SymbolKind.Constructor */
    ]: localize("Constructor", "constructor"),
    [
      9
      /* SymbolKind.Enum */
    ]: localize("Enum", "enumeration"),
    [
      21
      /* SymbolKind.EnumMember */
    ]: localize("EnumMember", "enumeration member"),
    [
      23
      /* SymbolKind.Event */
    ]: localize("Event", "event"),
    [
      7
      /* SymbolKind.Field */
    ]: localize("Field", "field"),
    [
      0
      /* SymbolKind.File */
    ]: localize("File", "file"),
    [
      11
      /* SymbolKind.Function */
    ]: localize("Function", "function"),
    [
      10
      /* SymbolKind.Interface */
    ]: localize("Interface", "interface"),
    [
      19
      /* SymbolKind.Key */
    ]: localize("Key", "key"),
    [
      5
      /* SymbolKind.Method */
    ]: localize("Method", "method"),
    [
      1
      /* SymbolKind.Module */
    ]: localize("Module", "module"),
    [
      2
      /* SymbolKind.Namespace */
    ]: localize("Namespace", "namespace"),
    [
      20
      /* SymbolKind.Null */
    ]: localize("Null", "null"),
    [
      15
      /* SymbolKind.Number */
    ]: localize("Number", "number"),
    [
      18
      /* SymbolKind.Object */
    ]: localize("Object", "object"),
    [
      24
      /* SymbolKind.Operator */
    ]: localize("Operator", "operator"),
    [
      3
      /* SymbolKind.Package */
    ]: localize("Package", "package"),
    [
      6
      /* SymbolKind.Property */
    ]: localize("Property", "property"),
    [
      14
      /* SymbolKind.String */
    ]: localize("String", "string"),
    [
      22
      /* SymbolKind.Struct */
    ]: localize("Struct", "struct"),
    [
      25
      /* SymbolKind.TypeParameter */
    ]: localize("TypeParameter", "type parameter"),
    [
      12
      /* SymbolKind.Variable */
    ]: localize("Variable", "variable")
  };
  var SymbolKinds;
  (function(SymbolKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolFile);
    byKind.set(1, Codicon.symbolModule);
    byKind.set(2, Codicon.symbolNamespace);
    byKind.set(3, Codicon.symbolPackage);
    byKind.set(4, Codicon.symbolClass);
    byKind.set(5, Codicon.symbolMethod);
    byKind.set(6, Codicon.symbolProperty);
    byKind.set(7, Codicon.symbolField);
    byKind.set(8, Codicon.symbolConstructor);
    byKind.set(9, Codicon.symbolEnum);
    byKind.set(10, Codicon.symbolInterface);
    byKind.set(11, Codicon.symbolFunction);
    byKind.set(12, Codicon.symbolVariable);
    byKind.set(13, Codicon.symbolConstant);
    byKind.set(14, Codicon.symbolString);
    byKind.set(15, Codicon.symbolNumber);
    byKind.set(16, Codicon.symbolBoolean);
    byKind.set(17, Codicon.symbolArray);
    byKind.set(18, Codicon.symbolObject);
    byKind.set(19, Codicon.symbolKey);
    byKind.set(20, Codicon.symbolNull);
    byKind.set(21, Codicon.symbolEnumMember);
    byKind.set(22, Codicon.symbolStruct);
    byKind.set(23, Codicon.symbolEvent);
    byKind.set(24, Codicon.symbolOperator);
    byKind.set(25, Codicon.symbolTypeParameter);
    function toIcon(kind) {
      let icon = byKind.get(kind);
      if (!icon) {
        console.info("No codicon found for SymbolKind " + kind);
        icon = Codicon.symbolProperty;
      }
      return icon;
    }
    SymbolKinds2.toIcon = toIcon;
  })(SymbolKinds || (SymbolKinds = {}));
  var FoldingRangeKind = class {
    /**
     * Returns a {@link FoldingRangeKind} for the given value.
     *
     * @param value of the kind.
     */
    static fromValue(value) {
      switch (value) {
        case "comment":
          return FoldingRangeKind.Comment;
        case "imports":
          return FoldingRangeKind.Imports;
        case "region":
          return FoldingRangeKind.Region;
      }
      return new FoldingRangeKind(value);
    }
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value) {
      this.value = value;
    }
  };
  FoldingRangeKind.Comment = new FoldingRangeKind("comment");
  FoldingRangeKind.Imports = new FoldingRangeKind("imports");
  FoldingRangeKind.Region = new FoldingRangeKind("region");
  var NewSymbolNameTag;
  (function(NewSymbolNameTag3) {
    NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
  })(NewSymbolNameTag || (NewSymbolNameTag = {}));
  var NewSymbolNameTriggerKind;
  (function(NewSymbolNameTriggerKind3) {
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
  })(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));
  var Command;
  (function(Command2) {
    function is2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return typeof obj.id === "string" && typeof obj.title === "string";
    }
    Command2.is = is2;
  })(Command || (Command = {}));
  var InlayHintKind;
  (function(InlayHintKind3) {
    InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
    InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
  })(InlayHintKind || (InlayHintKind = {}));
  var TokenizationRegistry2 = new TokenizationRegistry();
  var InlineEditTriggerKind;
  (function(InlineEditTriggerKind3) {
    InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
  })(InlineEditTriggerKind || (InlineEditTriggerKind = {}));

  // node_modules/monaco-editor-core/esm/vs/editor/common/standalone/standaloneEnums.js
  var AccessibilitySupport;
  (function(AccessibilitySupport2) {
    AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
    AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
    AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
  })(AccessibilitySupport || (AccessibilitySupport = {}));
  var CodeActionTriggerType;
  (function(CodeActionTriggerType2) {
    CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
    CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
  })(CodeActionTriggerType || (CodeActionTriggerType = {}));
  var CompletionItemInsertTextRule;
  (function(CompletionItemInsertTextRule2) {
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
  })(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
  var CompletionItemKind;
  (function(CompletionItemKind2) {
    CompletionItemKind2[CompletionItemKind2["Method"] = 0] = "Method";
    CompletionItemKind2[CompletionItemKind2["Function"] = 1] = "Function";
    CompletionItemKind2[CompletionItemKind2["Constructor"] = 2] = "Constructor";
    CompletionItemKind2[CompletionItemKind2["Field"] = 3] = "Field";
    CompletionItemKind2[CompletionItemKind2["Variable"] = 4] = "Variable";
    CompletionItemKind2[CompletionItemKind2["Class"] = 5] = "Class";
    CompletionItemKind2[CompletionItemKind2["Struct"] = 6] = "Struct";
    CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
    CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
    CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
    CompletionItemKind2[CompletionItemKind2["Event"] = 10] = "Event";
    CompletionItemKind2[CompletionItemKind2["Operator"] = 11] = "Operator";
    CompletionItemKind2[CompletionItemKind2["Unit"] = 12] = "Unit";
    CompletionItemKind2[CompletionItemKind2["Value"] = 13] = "Value";
    CompletionItemKind2[CompletionItemKind2["Constant"] = 14] = "Constant";
    CompletionItemKind2[CompletionItemKind2["Enum"] = 15] = "Enum";
    CompletionItemKind2[CompletionItemKind2["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind2[CompletionItemKind2["Keyword"] = 17] = "Keyword";
    CompletionItemKind2[CompletionItemKind2["Text"] = 18] = "Text";
    CompletionItemKind2[CompletionItemKind2["Color"] = 19] = "Color";
    CompletionItemKind2[CompletionItemKind2["File"] = 20] = "File";
    CompletionItemKind2[CompletionItemKind2["Reference"] = 21] = "Reference";
    CompletionItemKind2[CompletionItemKind2["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind2[CompletionItemKind2["Folder"] = 23] = "Folder";
    CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
    CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
    CompletionItemKind2[CompletionItemKind2["Snippet"] = 27] = "Snippet";
  })(CompletionItemKind || (CompletionItemKind = {}));
  var CompletionItemTag;
  (function(CompletionItemTag2) {
    CompletionItemTag2[CompletionItemTag2["Deprecated"] = 1] = "Deprecated";
  })(CompletionItemTag || (CompletionItemTag = {}));
  var CompletionTriggerKind;
  (function(CompletionTriggerKind2) {
    CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
  })(CompletionTriggerKind || (CompletionTriggerKind = {}));
  var ContentWidgetPositionPreference;
  (function(ContentWidgetPositionPreference2) {
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
  })(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
  var CursorChangeReason;
  (function(CursorChangeReason2) {
    CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
    CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
    CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
    CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
    CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
    CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
  })(CursorChangeReason || (CursorChangeReason = {}));
  var DefaultEndOfLine;
  (function(DefaultEndOfLine2) {
    DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
    DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
  })(DefaultEndOfLine || (DefaultEndOfLine = {}));
  var DocumentHighlightKind2;
  (function(DocumentHighlightKind3) {
    DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
    DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
    DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
  })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
  var EditorAutoIndentStrategy;
  (function(EditorAutoIndentStrategy2) {
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
  })(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
  var EditorOption;
  (function(EditorOption2) {
    EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
    EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
    EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
    EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
    EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
    EditorOption2[EditorOption2["ariaRequired"] = 5] = "ariaRequired";
    EditorOption2[EditorOption2["autoClosingBrackets"] = 6] = "autoClosingBrackets";
    EditorOption2[EditorOption2["autoClosingComments"] = 7] = "autoClosingComments";
    EditorOption2[EditorOption2["screenReaderAnnounceInlineSuggestion"] = 8] = "screenReaderAnnounceInlineSuggestion";
    EditorOption2[EditorOption2["autoClosingDelete"] = 9] = "autoClosingDelete";
    EditorOption2[EditorOption2["autoClosingOvertype"] = 10] = "autoClosingOvertype";
    EditorOption2[EditorOption2["autoClosingQuotes"] = 11] = "autoClosingQuotes";
    EditorOption2[EditorOption2["autoIndent"] = 12] = "autoIndent";
    EditorOption2[EditorOption2["automaticLayout"] = 13] = "automaticLayout";
    EditorOption2[EditorOption2["autoSurround"] = 14] = "autoSurround";
    EditorOption2[EditorOption2["bracketPairColorization"] = 15] = "bracketPairColorization";
    EditorOption2[EditorOption2["guides"] = 16] = "guides";
    EditorOption2[EditorOption2["codeLens"] = 17] = "codeLens";
    EditorOption2[EditorOption2["codeLensFontFamily"] = 18] = "codeLensFontFamily";
    EditorOption2[EditorOption2["codeLensFontSize"] = 19] = "codeLensFontSize";
    EditorOption2[EditorOption2["colorDecorators"] = 20] = "colorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsLimit"] = 21] = "colorDecoratorsLimit";
    EditorOption2[EditorOption2["columnSelection"] = 22] = "columnSelection";
    EditorOption2[EditorOption2["comments"] = 23] = "comments";
    EditorOption2[EditorOption2["contextmenu"] = 24] = "contextmenu";
    EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 25] = "copyWithSyntaxHighlighting";
    EditorOption2[EditorOption2["cursorBlinking"] = 26] = "cursorBlinking";
    EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 27] = "cursorSmoothCaretAnimation";
    EditorOption2[EditorOption2["cursorStyle"] = 28] = "cursorStyle";
    EditorOption2[EditorOption2["cursorSurroundingLines"] = 29] = "cursorSurroundingLines";
    EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 30] = "cursorSurroundingLinesStyle";
    EditorOption2[EditorOption2["cursorWidth"] = 31] = "cursorWidth";
    EditorOption2[EditorOption2["disableLayerHinting"] = 32] = "disableLayerHinting";
    EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 33] = "disableMonospaceOptimizations";
    EditorOption2[EditorOption2["domReadOnly"] = 34] = "domReadOnly";
    EditorOption2[EditorOption2["dragAndDrop"] = 35] = "dragAndDrop";
    EditorOption2[EditorOption2["dropIntoEditor"] = 36] = "dropIntoEditor";
    EditorOption2[EditorOption2["emptySelectionClipboard"] = 37] = "emptySelectionClipboard";
    EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 38] = "experimentalWhitespaceRendering";
    EditorOption2[EditorOption2["extraEditorClassName"] = 39] = "extraEditorClassName";
    EditorOption2[EditorOption2["fastScrollSensitivity"] = 40] = "fastScrollSensitivity";
    EditorOption2[EditorOption2["find"] = 41] = "find";
    EditorOption2[EditorOption2["fixedOverflowWidgets"] = 42] = "fixedOverflowWidgets";
    EditorOption2[EditorOption2["folding"] = 43] = "folding";
    EditorOption2[EditorOption2["foldingStrategy"] = 44] = "foldingStrategy";
    EditorOption2[EditorOption2["foldingHighlight"] = 45] = "foldingHighlight";
    EditorOption2[EditorOption2["foldingImportsByDefault"] = 46] = "foldingImportsByDefault";
    EditorOption2[EditorOption2["foldingMaximumRegions"] = 47] = "foldingMaximumRegions";
    EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 48] = "unfoldOnClickAfterEndOfLine";
    EditorOption2[EditorOption2["fontFamily"] = 49] = "fontFamily";
    EditorOption2[EditorOption2["fontInfo"] = 50] = "fontInfo";
    EditorOption2[EditorOption2["fontLigatures"] = 51] = "fontLigatures";
    EditorOption2[EditorOption2["fontSize"] = 52] = "fontSize";
    EditorOption2[EditorOption2["fontWeight"] = 53] = "fontWeight";
    EditorOption2[EditorOption2["fontVariations"] = 54] = "fontVariations";
    EditorOption2[EditorOption2["formatOnPaste"] = 55] = "formatOnPaste";
    EditorOption2[EditorOption2["formatOnType"] = 56] = "formatOnType";
    EditorOption2[EditorOption2["glyphMargin"] = 57] = "glyphMargin";
    EditorOption2[EditorOption2["gotoLocation"] = 58] = "gotoLocation";
    EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 59] = "hideCursorInOverviewRuler";
    EditorOption2[EditorOption2["hover"] = 60] = "hover";
    EditorOption2[EditorOption2["inDiffEditor"] = 61] = "inDiffEditor";
    EditorOption2[EditorOption2["inlineSuggest"] = 62] = "inlineSuggest";
    EditorOption2[EditorOption2["inlineEdit"] = 63] = "inlineEdit";
    EditorOption2[EditorOption2["letterSpacing"] = 64] = "letterSpacing";
    EditorOption2[EditorOption2["lightbulb"] = 65] = "lightbulb";
    EditorOption2[EditorOption2["lineDecorationsWidth"] = 66] = "lineDecorationsWidth";
    EditorOption2[EditorOption2["lineHeight"] = 67] = "lineHeight";
    EditorOption2[EditorOption2["lineNumbers"] = 68] = "lineNumbers";
    EditorOption2[EditorOption2["lineNumbersMinChars"] = 69] = "lineNumbersMinChars";
    EditorOption2[EditorOption2["linkedEditing"] = 70] = "linkedEditing";
    EditorOption2[EditorOption2["links"] = 71] = "links";
    EditorOption2[EditorOption2["matchBrackets"] = 72] = "matchBrackets";
    EditorOption2[EditorOption2["minimap"] = 73] = "minimap";
    EditorOption2[EditorOption2["mouseStyle"] = 74] = "mouseStyle";
    EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 75] = "mouseWheelScrollSensitivity";
    EditorOption2[EditorOption2["mouseWheelZoom"] = 76] = "mouseWheelZoom";
    EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 77] = "multiCursorMergeOverlapping";
    EditorOption2[EditorOption2["multiCursorModifier"] = 78] = "multiCursorModifier";
    EditorOption2[EditorOption2["multiCursorPaste"] = 79] = "multiCursorPaste";
    EditorOption2[EditorOption2["multiCursorLimit"] = 80] = "multiCursorLimit";
    EditorOption2[EditorOption2["occurrencesHighlight"] = 81] = "occurrencesHighlight";
    EditorOption2[EditorOption2["overviewRulerBorder"] = 82] = "overviewRulerBorder";
    EditorOption2[EditorOption2["overviewRulerLanes"] = 83] = "overviewRulerLanes";
    EditorOption2[EditorOption2["padding"] = 84] = "padding";
    EditorOption2[EditorOption2["pasteAs"] = 85] = "pasteAs";
    EditorOption2[EditorOption2["parameterHints"] = 86] = "parameterHints";
    EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 87] = "peekWidgetDefaultFocus";
    EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 88] = "definitionLinkOpensInPeek";
    EditorOption2[EditorOption2["quickSuggestions"] = 89] = "quickSuggestions";
    EditorOption2[EditorOption2["quickSuggestionsDelay"] = 90] = "quickSuggestionsDelay";
    EditorOption2[EditorOption2["readOnly"] = 91] = "readOnly";
    EditorOption2[EditorOption2["readOnlyMessage"] = 92] = "readOnlyMessage";
    EditorOption2[EditorOption2["renameOnType"] = 93] = "renameOnType";
    EditorOption2[EditorOption2["renderControlCharacters"] = 94] = "renderControlCharacters";
    EditorOption2[EditorOption2["renderFinalNewline"] = 95] = "renderFinalNewline";
    EditorOption2[EditorOption2["renderLineHighlight"] = 96] = "renderLineHighlight";
    EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 97] = "renderLineHighlightOnlyWhenFocus";
    EditorOption2[EditorOption2["renderValidationDecorations"] = 98] = "renderValidationDecorations";
    EditorOption2[EditorOption2["renderWhitespace"] = 99] = "renderWhitespace";
    EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 100] = "revealHorizontalRightPadding";
    EditorOption2[EditorOption2["roundedSelection"] = 101] = "roundedSelection";
    EditorOption2[EditorOption2["rulers"] = 102] = "rulers";
    EditorOption2[EditorOption2["scrollbar"] = 103] = "scrollbar";
    EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 104] = "scrollBeyondLastColumn";
    EditorOption2[EditorOption2["scrollBeyondLastLine"] = 105] = "scrollBeyondLastLine";
    EditorOption2[EditorOption2["scrollPredominantAxis"] = 106] = "scrollPredominantAxis";
    EditorOption2[EditorOption2["selectionClipboard"] = 107] = "selectionClipboard";
    EditorOption2[EditorOption2["selectionHighlight"] = 108] = "selectionHighlight";
    EditorOption2[EditorOption2["selectOnLineNumbers"] = 109] = "selectOnLineNumbers";
    EditorOption2[EditorOption2["showFoldingControls"] = 110] = "showFoldingControls";
    EditorOption2[EditorOption2["showUnused"] = 111] = "showUnused";
    EditorOption2[EditorOption2["snippetSuggestions"] = 112] = "snippetSuggestions";
    EditorOption2[EditorOption2["smartSelect"] = 113] = "smartSelect";
    EditorOption2[EditorOption2["smoothScrolling"] = 114] = "smoothScrolling";
    EditorOption2[EditorOption2["stickyScroll"] = 115] = "stickyScroll";
    EditorOption2[EditorOption2["stickyTabStops"] = 116] = "stickyTabStops";
    EditorOption2[EditorOption2["stopRenderingLineAfter"] = 117] = "stopRenderingLineAfter";
    EditorOption2[EditorOption2["suggest"] = 118] = "suggest";
    EditorOption2[EditorOption2["suggestFontSize"] = 119] = "suggestFontSize";
    EditorOption2[EditorOption2["suggestLineHeight"] = 120] = "suggestLineHeight";
    EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 121] = "suggestOnTriggerCharacters";
    EditorOption2[EditorOption2["suggestSelection"] = 122] = "suggestSelection";
    EditorOption2[EditorOption2["tabCompletion"] = 123] = "tabCompletion";
    EditorOption2[EditorOption2["tabIndex"] = 124] = "tabIndex";
    EditorOption2[EditorOption2["unicodeHighlighting"] = 125] = "unicodeHighlighting";
    EditorOption2[EditorOption2["unusualLineTerminators"] = 126] = "unusualLineTerminators";
    EditorOption2[EditorOption2["useShadowDOM"] = 127] = "useShadowDOM";
    EditorOption2[EditorOption2["useTabStops"] = 128] = "useTabStops";
    EditorOption2[EditorOption2["wordBreak"] = 129] = "wordBreak";
    EditorOption2[EditorOption2["wordSegmenterLocales"] = 130] = "wordSegmenterLocales";
    EditorOption2[EditorOption2["wordSeparators"] = 131] = "wordSeparators";
    EditorOption2[EditorOption2["wordWrap"] = 132] = "wordWrap";
    EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 133] = "wordWrapBreakAfterCharacters";
    EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 134] = "wordWrapBreakBeforeCharacters";
    EditorOption2[EditorOption2["wordWrapColumn"] = 135] = "wordWrapColumn";
    EditorOption2[EditorOption2["wordWrapOverride1"] = 136] = "wordWrapOverride1";
    EditorOption2[EditorOption2["wordWrapOverride2"] = 137] = "wordWrapOverride2";
    EditorOption2[EditorOption2["wrappingIndent"] = 138] = "wrappingIndent";
    EditorOption2[EditorOption2["wrappingStrategy"] = 139] = "wrappingStrategy";
    EditorOption2[EditorOption2["showDeprecated"] = 140] = "showDeprecated";
    EditorOption2[EditorOption2["inlayHints"] = 141] = "inlayHints";
    EditorOption2[EditorOption2["editorClassName"] = 142] = "editorClassName";
    EditorOption2[EditorOption2["pixelRatio"] = 143] = "pixelRatio";
    EditorOption2[EditorOption2["tabFocusMode"] = 144] = "tabFocusMode";
    EditorOption2[EditorOption2["layoutInfo"] = 145] = "layoutInfo";
    EditorOption2[EditorOption2["wrappingInfo"] = 146] = "wrappingInfo";
    EditorOption2[EditorOption2["defaultColorDecorators"] = 147] = "defaultColorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsActivatedOn"] = 148] = "colorDecoratorsActivatedOn";
    EditorOption2[EditorOption2["inlineCompletionsAccessibilityVerbose"] = 149] = "inlineCompletionsAccessibilityVerbose";
  })(EditorOption || (EditorOption = {}));
  var EndOfLinePreference;
  (function(EndOfLinePreference2) {
    EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
    EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
    EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
  })(EndOfLinePreference || (EndOfLinePreference = {}));
  var EndOfLineSequence;
  (function(EndOfLineSequence2) {
    EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
    EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
  })(EndOfLineSequence || (EndOfLineSequence = {}));
  var GlyphMarginLane;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
  })(GlyphMarginLane || (GlyphMarginLane = {}));
  var HoverVerbosityAction2;
  (function(HoverVerbosityAction3) {
    HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
    HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
  })(HoverVerbosityAction2 || (HoverVerbosityAction2 = {}));
  var IndentAction;
  (function(IndentAction2) {
    IndentAction2[IndentAction2["None"] = 0] = "None";
    IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
    IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
    IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
  })(IndentAction || (IndentAction = {}));
  var InjectedTextCursorStops;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
  var InlayHintKind2;
  (function(InlayHintKind3) {
    InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
    InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
  })(InlayHintKind2 || (InlayHintKind2 = {}));
  var InlineCompletionTriggerKind2;
  (function(InlineCompletionTriggerKind3) {
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
  var InlineEditTriggerKind2;
  (function(InlineEditTriggerKind3) {
    InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
  })(InlineEditTriggerKind2 || (InlineEditTriggerKind2 = {}));
  var KeyCode;
  (function(KeyCode2) {
    KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
    KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
    KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
    KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
    KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
    KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
    KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
    KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
    KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
    KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
    KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
    KeyCode2[KeyCode2["Space"] = 10] = "Space";
    KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
    KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
    KeyCode2[KeyCode2["End"] = 13] = "End";
    KeyCode2[KeyCode2["Home"] = 14] = "Home";
    KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
    KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
    KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
    KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
    KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
    KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
    KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
    KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
    KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
    KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
    KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
    KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
    KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
    KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
    KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
    KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
    KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
    KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
    KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
    KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
    KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
    KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
    KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
    KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
    KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
    KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
    KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
    KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
    KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
    KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
    KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
    KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
    KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
    KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
    KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
    KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
    KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
    KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
    KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
    KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
    KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
    KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
    KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
    KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
    KeyCode2[KeyCode2["F1"] = 59] = "F1";
    KeyCode2[KeyCode2["F2"] = 60] = "F2";
    KeyCode2[KeyCode2["F3"] = 61] = "F3";
    KeyCode2[KeyCode2["F4"] = 62] = "F4";
    KeyCode2[KeyCode2["F5"] = 63] = "F5";
    KeyCode2[KeyCode2["F6"] = 64] = "F6";
    KeyCode2[KeyCode2["F7"] = 65] = "F7";
    KeyCode2[KeyCode2["F8"] = 66] = "F8";
    KeyCode2[KeyCode2["F9"] = 67] = "F9";
    KeyCode2[KeyCode2["F10"] = 68] = "F10";
    KeyCode2[KeyCode2["F11"] = 69] = "F11";
    KeyCode2[KeyCode2["F12"] = 70] = "F12";
    KeyCode2[KeyCode2["F13"] = 71] = "F13";
    KeyCode2[KeyCode2["F14"] = 72] = "F14";
    KeyCode2[KeyCode2["F15"] = 73] = "F15";
    KeyCode2[KeyCode2["F16"] = 74] = "F16";
    KeyCode2[KeyCode2["F17"] = 75] = "F17";
    KeyCode2[KeyCode2["F18"] = 76] = "F18";
    KeyCode2[KeyCode2["F19"] = 77] = "F19";
    KeyCode2[KeyCode2["F20"] = 78] = "F20";
    KeyCode2[KeyCode2["F21"] = 79] = "F21";
    KeyCode2[KeyCode2["F22"] = 80] = "F22";
    KeyCode2[KeyCode2["F23"] = 81] = "F23";
    KeyCode2[KeyCode2["F24"] = 82] = "F24";
    KeyCode2[KeyCode2["NumLock"] = 83] = "NumLock";
    KeyCode2[KeyCode2["ScrollLock"] = 84] = "ScrollLock";
    KeyCode2[KeyCode2["Semicolon"] = 85] = "Semicolon";
    KeyCode2[KeyCode2["Equal"] = 86] = "Equal";
    KeyCode2[KeyCode2["Comma"] = 87] = "Comma";
    KeyCode2[KeyCode2["Minus"] = 88] = "Minus";
    KeyCode2[KeyCode2["Period"] = 89] = "Period";
    KeyCode2[KeyCode2["Slash"] = 90] = "Slash";
    KeyCode2[KeyCode2["Backquote"] = 91] = "Backquote";
    KeyCode2[KeyCode2["BracketLeft"] = 92] = "BracketLeft";
    KeyCode2[KeyCode2["Backslash"] = 93] = "Backslash";
    KeyCode2[KeyCode2["BracketRight"] = 94] = "BracketRight";
    KeyCode2[KeyCode2["Quote"] = 95] = "Quote";
    KeyCode2[KeyCode2["OEM_8"] = 96] = "OEM_8";
    KeyCode2[KeyCode2["IntlBackslash"] = 97] = "IntlBackslash";
    KeyCode2[KeyCode2["Numpad0"] = 98] = "Numpad0";
    KeyCode2[KeyCode2["Numpad1"] = 99] = "Numpad1";
    KeyCode2[KeyCode2["Numpad2"] = 100] = "Numpad2";
    KeyCode2[KeyCode2["Numpad3"] = 101] = "Numpad3";
    KeyCode2[KeyCode2["Numpad4"] = 102] = "Numpad4";
    KeyCode2[KeyCode2["Numpad5"] = 103] = "Numpad5";
    KeyCode2[KeyCode2["Numpad6"] = 104] = "Numpad6";
    KeyCode2[KeyCode2["Numpad7"] = 105] = "Numpad7";
    KeyCode2[KeyCode2["Numpad8"] = 106] = "Numpad8";
    KeyCode2[KeyCode2["Numpad9"] = 107] = "Numpad9";
    KeyCode2[KeyCode2["NumpadMultiply"] = 108] = "NumpadMultiply";
    KeyCode2[KeyCode2["NumpadAdd"] = 109] = "NumpadAdd";
    KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 110] = "NUMPAD_SEPARATOR";
    KeyCode2[KeyCode2["NumpadSubtract"] = 111] = "NumpadSubtract";
    KeyCode2[KeyCode2["NumpadDecimal"] = 112] = "NumpadDecimal";
    KeyCode2[KeyCode2["NumpadDivide"] = 113] = "NumpadDivide";
    KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 114] = "KEY_IN_COMPOSITION";
    KeyCode2[KeyCode2["ABNT_C1"] = 115] = "ABNT_C1";
    KeyCode2[KeyCode2["ABNT_C2"] = 116] = "ABNT_C2";
    KeyCode2[KeyCode2["AudioVolumeMute"] = 117] = "AudioVolumeMute";
    KeyCode2[KeyCode2["AudioVolumeUp"] = 118] = "AudioVolumeUp";
    KeyCode2[KeyCode2["AudioVolumeDown"] = 119] = "AudioVolumeDown";
    KeyCode2[KeyCode2["BrowserSearch"] = 120] = "BrowserSearch";
    KeyCode2[KeyCode2["BrowserHome"] = 121] = "BrowserHome";
    KeyCode2[KeyCode2["BrowserBack"] = 122] = "BrowserBack";
    KeyCode2[KeyCode2["BrowserForward"] = 123] = "BrowserForward";
    KeyCode2[KeyCode2["MediaTrackNext"] = 124] = "MediaTrackNext";
    KeyCode2[KeyCode2["MediaTrackPrevious"] = 125] = "MediaTrackPrevious";
    KeyCode2[KeyCode2["MediaStop"] = 126] = "MediaStop";
    KeyCode2[KeyCode2["MediaPlayPause"] = 127] = "MediaPlayPause";
    KeyCode2[KeyCode2["LaunchMediaPlayer"] = 128] = "LaunchMediaPlayer";
    KeyCode2[KeyCode2["LaunchMail"] = 129] = "LaunchMail";
    KeyCode2[KeyCode2["LaunchApp2"] = 130] = "LaunchApp2";
    KeyCode2[KeyCode2["Clear"] = 131] = "Clear";
    KeyCode2[KeyCode2["MAX_VALUE"] = 132] = "MAX_VALUE";
  })(KeyCode || (KeyCode = {}));
  var MarkerSeverity;
  (function(MarkerSeverity2) {
    MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
    MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
    MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
    MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
  })(MarkerSeverity || (MarkerSeverity = {}));
  var MarkerTag;
  (function(MarkerTag2) {
    MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
  })(MarkerTag || (MarkerTag = {}));
  var MinimapPosition;
  (function(MinimapPosition2) {
    MinimapPosition2[MinimapPosition2["Inline"] = 1] = "Inline";
    MinimapPosition2[MinimapPosition2["Gutter"] = 2] = "Gutter";
  })(MinimapPosition || (MinimapPosition = {}));
  var MinimapSectionHeaderStyle;
  (function(MinimapSectionHeaderStyle2) {
    MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Normal"] = 1] = "Normal";
    MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Underlined"] = 2] = "Underlined";
  })(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));
  var MouseTargetType;
  (function(MouseTargetType2) {
    MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
    MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
    MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
    MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
  })(MouseTargetType || (MouseTargetType = {}));
  var NewSymbolNameTag2;
  (function(NewSymbolNameTag3) {
    NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
  })(NewSymbolNameTag2 || (NewSymbolNameTag2 = {}));
  var NewSymbolNameTriggerKind2;
  (function(NewSymbolNameTriggerKind3) {
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
  })(NewSymbolNameTriggerKind2 || (NewSymbolNameTriggerKind2 = {}));
  var OverlayWidgetPositionPreference;
  (function(OverlayWidgetPositionPreference2) {
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
  })(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
  var OverviewRulerLane;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane || (OverviewRulerLane = {}));
  var PartialAcceptTriggerKind;
  (function(PartialAcceptTriggerKind2) {
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Word"] = 0] = "Word";
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Line"] = 1] = "Line";
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Suggest"] = 2] = "Suggest";
  })(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));
  var PositionAffinity;
  (function(PositionAffinity2) {
    PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
    PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
    PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
    PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
    PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
  })(PositionAffinity || (PositionAffinity = {}));
  var RenderLineNumbersType;
  (function(RenderLineNumbersType2) {
    RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
    RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
    RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
    RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
    RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
  })(RenderLineNumbersType || (RenderLineNumbersType = {}));
  var RenderMinimap;
  (function(RenderMinimap2) {
    RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
    RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
    RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
  })(RenderMinimap || (RenderMinimap = {}));
  var ScrollType;
  (function(ScrollType2) {
    ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
    ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
  })(ScrollType || (ScrollType = {}));
  var ScrollbarVisibility;
  (function(ScrollbarVisibility2) {
    ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
    ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
  })(ScrollbarVisibility || (ScrollbarVisibility = {}));
  var SelectionDirection;
  (function(SelectionDirection2) {
    SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
    SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
  })(SelectionDirection || (SelectionDirection = {}));
  var ShowLightbulbIconMode;
  (function(ShowLightbulbIconMode2) {
    ShowLightbulbIconMode2["Off"] = "off";
    ShowLightbulbIconMode2["OnCode"] = "onCode";
    ShowLightbulbIconMode2["On"] = "on";
  })(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));
  var SignatureHelpTriggerKind2;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
  var SymbolKind;
  (function(SymbolKind2) {
    SymbolKind2[SymbolKind2["File"] = 0] = "File";
    SymbolKind2[SymbolKind2["Module"] = 1] = "Module";
    SymbolKind2[SymbolKind2["Namespace"] = 2] = "Namespace";
    SymbolKind2[SymbolKind2["Package"] = 3] = "Package";
    SymbolKind2[SymbolKind2["Class"] = 4] = "Class";
    SymbolKind2[SymbolKind2["Method"] = 5] = "Method";
    SymbolKind2[SymbolKind2["Property"] = 6] = "Property";
    SymbolKind2[SymbolKind2["Field"] = 7] = "Field";
    SymbolKind2[SymbolKind2["Constructor"] = 8] = "Constructor";
    SymbolKind2[SymbolKind2["Enum"] = 9] = "Enum";
    SymbolKind2[SymbolKind2["Interface"] = 10] = "Interface";
    SymbolKind2[SymbolKind2["Function"] = 11] = "Function";
    SymbolKind2[SymbolKind2["Variable"] = 12] = "Variable";
    SymbolKind2[SymbolKind2["Constant"] = 13] = "Constant";
    SymbolKind2[SymbolKind2["String"] = 14] = "String";
    SymbolKind2[SymbolKind2["Number"] = 15] = "Number";
    SymbolKind2[SymbolKind2["Boolean"] = 16] = "Boolean";
    SymbolKind2[SymbolKind2["Array"] = 17] = "Array";
    SymbolKind2[SymbolKind2["Object"] = 18] = "Object";
    SymbolKind2[SymbolKind2["Key"] = 19] = "Key";
    SymbolKind2[SymbolKind2["Null"] = 20] = "Null";
    SymbolKind2[SymbolKind2["EnumMember"] = 21] = "EnumMember";
    SymbolKind2[SymbolKind2["Struct"] = 22] = "Struct";
    SymbolKind2[SymbolKind2["Event"] = 23] = "Event";
    SymbolKind2[SymbolKind2["Operator"] = 24] = "Operator";
    SymbolKind2[SymbolKind2["TypeParameter"] = 25] = "TypeParameter";
  })(SymbolKind || (SymbolKind = {}));
  var SymbolTag;
  (function(SymbolTag2) {
    SymbolTag2[SymbolTag2["Deprecated"] = 1] = "Deprecated";
  })(SymbolTag || (SymbolTag = {}));
  var TextEditorCursorBlinkingStyle;
  (function(TextEditorCursorBlinkingStyle2) {
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
  })(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
  var TextEditorCursorStyle;
  (function(TextEditorCursorStyle2) {
    TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
    TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
  })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
  var TrackedRangeStickiness;
  (function(TrackedRangeStickiness2) {
    TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
  })(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
  var WrappingIndent;
  (function(WrappingIndent2) {
    WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
    WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
    WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
    WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
  })(WrappingIndent || (WrappingIndent = {}));

  // node_modules/monaco-editor-core/esm/vs/editor/common/services/editorBaseApi.js
  var KeyMod = class {
    static chord(firstPart, secondPart) {
      return KeyChord(firstPart, secondPart);
    }
  };
  KeyMod.CtrlCmd = 2048;
  KeyMod.Shift = 1024;
  KeyMod.Alt = 512;
  KeyMod.WinCtrl = 256;
  function createMonacoBaseAPI() {
    return {
      editor: void 0,
      // undefined override expected here
      languages: void 0,
      // undefined override expected here
      CancellationTokenSource,
      Emitter,
      KeyCode,
      KeyMod,
      Position,
      Range,
      Selection,
      SelectionDirection,
      MarkerSeverity,
      MarkerTag,
      Uri: URI,
      Token
    };
  }

  // node_modules/monaco-editor-core/esm/vs/base/common/map.js
  var _a3;
  var _b2;
  var ResourceMapEntry = class {
    constructor(uri, value) {
      this.uri = uri;
      this.value = value;
    }
  };
  function isEntries(arg) {
    return Array.isArray(arg);
  }
  var ResourceMap = class {
    constructor(arg, toKey) {
      this[_a3] = "ResourceMap";
      if (arg instanceof ResourceMap) {
        this.map = new Map(arg.map);
        this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;
      } else if (isEntries(arg)) {
        this.map = /* @__PURE__ */ new Map();
        this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;
        for (const [resource, value] of arg) {
          this.set(resource, value);
        }
      } else {
        this.map = /* @__PURE__ */ new Map();
        this.toKey = arg !== null && arg !== void 0 ? arg : ResourceMap.defaultToKey;
      }
    }
    set(resource, value) {
      this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
      return this;
    }
    get(resource) {
      var _c;
      return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;
    }
    has(resource) {
      return this.map.has(this.toKey(resource));
    }
    get size() {
      return this.map.size;
    }
    clear() {
      this.map.clear();
    }
    delete(resource) {
      return this.map.delete(this.toKey(resource));
    }
    forEach(clb, thisArg) {
      if (typeof thisArg !== "undefined") {
        clb = clb.bind(thisArg);
      }
      for (const [_, entry] of this.map) {
        clb(entry.value, entry.uri, this);
      }
    }
    *values() {
      for (const entry of this.map.values()) {
        yield entry.value;
      }
    }
    *keys() {
      for (const entry of this.map.values()) {
        yield entry.uri;
      }
    }
    *entries() {
      for (const entry of this.map.values()) {
        yield [entry.uri, entry.value];
      }
    }
    *[(_a3 = Symbol.toStringTag, Symbol.iterator)]() {
      for (const [, entry] of this.map) {
        yield [entry.uri, entry.value];
      }
    }
  };
  ResourceMap.defaultToKey = (resource) => resource.toString();
  var LinkedMap = class {
    constructor() {
      this[_b2] = "LinkedMap";
      this._map = /* @__PURE__ */ new Map();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state = 0;
    }
    clear() {
      this._map.clear();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      var _c;
      return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;
    }
    get last() {
      var _c;
      return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key, touch = 0) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      if (touch !== 0) {
        this.touch(item, touch);
      }
      return item.value;
    }
    set(key, value, touch = 0) {
      let item = this._map.get(key);
      if (item) {
        item.value = value;
        if (touch !== 0) {
          this.touch(item, touch);
        }
      } else {
        item = { key, value, next: void 0, previous: void 0 };
        switch (touch) {
          case 0:
            this.addItemLast(item);
            break;
          case 1:
            this.addItemFirst(item);
            break;
          case 2:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
      return this;
    }
    delete(key) {
      return !!this.remove(key);
    }
    remove(key) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    shift() {
      if (!this._head && !this._tail) {
        return void 0;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      const state = this._state;
      let current2 = this._head;
      while (current2) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current2.value, current2.key, this);
        } else {
          callbackfn(current2.value, current2.key, this);
        }
        if (this._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        current2 = current2.next;
      }
    }
    keys() {
      const map4 = this;
      const state = this._state;
      let current2 = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map4._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current2) {
            const result = { value: current2.key, done: false };
            current2 = current2.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    values() {
      const map4 = this;
      const state = this._state;
      let current2 = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map4._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current2) {
            const result = { value: current2.value, done: false };
            current2 = current2.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    entries() {
      const map4 = this;
      const state = this._state;
      let current2 = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map4._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current2) {
            const result = { value: [current2.key, current2.value], done: false };
            current2 = current2.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    [(_b2 = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current2 = this._head;
      let currentSize = this.size;
      while (current2 && currentSize > newSize) {
        this._map.delete(current2.key);
        current2 = current2.next;
        currentSize--;
      }
      this._head = current2;
      this._size = currentSize;
      if (current2) {
        current2.previous = void 0;
      }
      this._state++;
    }
    trimNew(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current2 = this._tail;
      let currentSize = this.size;
      while (current2 && currentSize > newSize) {
        this._map.delete(current2.key);
        current2 = current2.previous;
        currentSize--;
      }
      this._tail = current2;
      this._size = currentSize;
      if (current2) {
        current2.next = void 0;
      }
      this._state++;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
      this._state++;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
      this._state++;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = void 0;
        this._tail = void 0;
      } else if (item === this._head) {
        if (!item.next) {
          throw new Error("Invalid list");
        }
        item.next.previous = void 0;
        this._head = item.next;
      } else if (item === this._tail) {
        if (!item.previous) {
          throw new Error("Invalid list");
        }
        item.previous.next = void 0;
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous2 = item.previous;
        if (!next || !previous2) {
          throw new Error("Invalid list");
        }
        next.previous = previous2;
        previous2.next = next;
      }
      item.next = void 0;
      item.previous = void 0;
      this._state++;
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== 1 && touch !== 2) {
        return;
      }
      if (touch === 1) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous2 = item.previous;
        if (item === this._tail) {
          previous2.next = void 0;
          this._tail = previous2;
        } else {
          next.previous = previous2;
          previous2.next = next;
        }
        item.previous = void 0;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
        this._state++;
      } else if (touch === 2) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous2 = item.previous;
        if (item === this._head) {
          next.previous = void 0;
          this._head = next;
        } else {
          next.previous = previous2;
          previous2.next = next;
        }
        item.next = void 0;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
        this._state++;
      }
    }
    toJSON() {
      const data2 = [];
      this.forEach((value, key) => {
        data2.push([key, value]);
      });
      return data2;
    }
    fromJSON(data2) {
      this.clear();
      for (const [key, value] of data2) {
        this.set(key, value);
      }
    }
  };
  var Cache = class extends LinkedMap {
    constructor(limit, ratio = 1) {
      super();
      this._limit = limit;
      this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(limit) {
      this._limit = limit;
      this.checkTrim();
    }
    get(key, touch = 2) {
      return super.get(key, touch);
    }
    peek(key) {
      return super.get(
        key,
        0
        /* Touch.None */
      );
    }
    set(key, value) {
      super.set(
        key,
        value,
        2
        /* Touch.AsNew */
      );
      return this;
    }
    checkTrim() {
      if (this.size > this._limit) {
        this.trim(Math.round(this._limit * this._ratio));
      }
    }
  };
  var LRUCache = class extends Cache {
    constructor(limit, ratio = 1) {
      super(limit, ratio);
    }
    trim(newSize) {
      this.trimOld(newSize);
    }
    set(key, value) {
      super.set(key, value);
      this.checkTrim();
      return this;
    }
  };
  var SetMap = class {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    add(key, value) {
      let values = this.map.get(key);
      if (!values) {
        values = /* @__PURE__ */ new Set();
        this.map.set(key, values);
      }
      values.add(value);
    }
    delete(key, value) {
      const values = this.map.get(key);
      if (!values) {
        return;
      }
      values.delete(value);
      if (values.size === 0) {
        this.map.delete(key);
      }
    }
    forEach(key, fn) {
      const values = this.map.get(key);
      if (!values) {
        return;
      }
      values.forEach(fn);
    }
    get(key) {
      const values = this.map.get(key);
      if (!values) {
        return /* @__PURE__ */ new Set();
      }
      return values;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/wordCharacterClassifier.js
  var wordClassifierCache = new LRUCache(10);

  // node_modules/monaco-editor-core/esm/vs/editor/common/model.js
  var OverviewRulerLane2;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
  var GlyphMarginLane2;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
  })(GlyphMarginLane2 || (GlyphMarginLane2 = {}));
  var InjectedTextCursorStops2;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));

  // node_modules/monaco-editor-core/esm/vs/editor/common/model/textModelSearch.js
  function leftIsWordBounday(wordSeparators, text4, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
      return true;
    }
    const charBefore = text4.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0) {
      return true;
    }
    if (charBefore === 13 || charBefore === 10) {
      return true;
    }
    if (matchLength > 0) {
      const firstCharInMatch = text4.charCodeAt(matchStartIndex);
      if (wordSeparators.get(firstCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function rightIsWordBounday(wordSeparators, text4, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
      return true;
    }
    const charAfter = text4.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0) {
      return true;
    }
    if (charAfter === 13 || charAfter === 10) {
      return true;
    }
    if (matchLength > 0) {
      const lastCharInMatch = text4.charCodeAt(matchStartIndex + matchLength - 1);
      if (wordSeparators.get(lastCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function isValidMatch(wordSeparators, text4, textLength, matchStartIndex, matchLength) {
    return leftIsWordBounday(wordSeparators, text4, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text4, textLength, matchStartIndex, matchLength);
  }
  var Searcher = class {
    constructor(wordSeparators, searchRegex) {
      this._wordSeparators = wordSeparators;
      this._searchRegex = searchRegex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    reset(lastIndex) {
      this._searchRegex.lastIndex = lastIndex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    next(text4) {
      const textLength = text4.length;
      let m;
      do {
        if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
          return null;
        }
        m = this._searchRegex.exec(text4);
        if (!m) {
          return null;
        }
        const matchStartIndex = m.index;
        const matchLength = m[0].length;
        if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
          if (matchLength === 0) {
            if (getNextCodePoint(text4, textLength, this._searchRegex.lastIndex) > 65535) {
              this._searchRegex.lastIndex += 2;
            } else {
              this._searchRegex.lastIndex += 1;
            }
            continue;
          }
          return null;
        }
        this._prevMatchStartIndex = matchStartIndex;
        this._prevMatchLength = matchLength;
        if (!this._wordSeparators || isValidMatch(this._wordSeparators, text4, textLength, matchStartIndex, matchLength)) {
          return m;
        }
      } while (m);
      return null;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/assert.js
  function assertNever(value, message = "Unreachable") {
    throw new Error(message);
  }
  function assertFn(condition) {
    if (!condition()) {
      debugger;
      condition();
      onUnexpectedError(new BugIndicatingError("Assertion Failed"));
    }
  }
  function checkAdjacentItems(items, predicate) {
    let i = 0;
    while (i < items.length - 1) {
      const a = items[i];
      const b = items[i + 1];
      if (!predicate(a, b)) {
        return false;
      }
      i++;
    }
    return true;
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
  var UnicodeTextModelHighlighter = class {
    static computeUnicodeHighlights(model, options, range) {
      const startLine = range ? range.startLineNumber : 1;
      const endLine = range ? range.endLineNumber : model.getLineCount();
      const codePointHighlighter = new CodePointHighlighter(options);
      const candidates = codePointHighlighter.getCandidateCodePoints();
      let regex;
      if (candidates === "allNonBasicAscii") {
        regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
      } else {
        regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
      }
      const searcher = new Searcher(null, regex);
      const ranges = [];
      let hasMore = false;
      let m;
      let ambiguousCharacterCount = 0;
      let invisibleCharacterCount = 0;
      let nonBasicAsciiCharacterCount = 0;
      forLoop:
        for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
          const lineContent = model.getLineContent(lineNumber);
          const lineLength = lineContent.length;
          searcher.reset(0);
          do {
            m = searcher.next(lineContent);
            if (m) {
              let startIndex = m.index;
              let endIndex = m.index + m[0].length;
              if (startIndex > 0) {
                const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
                if (isHighSurrogate(charCodeBefore)) {
                  startIndex--;
                }
              }
              if (endIndex + 1 < lineLength) {
                const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
                if (isHighSurrogate(charCodeBefore)) {
                  endIndex++;
                }
              }
              const str = lineContent.substring(startIndex, endIndex);
              let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
              if (word && word.endColumn <= startIndex + 1) {
                word = null;
              }
              const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
              if (highlightReason !== 0) {
                if (highlightReason === 3) {
                  ambiguousCharacterCount++;
                } else if (highlightReason === 2) {
                  invisibleCharacterCount++;
                } else if (highlightReason === 1) {
                  nonBasicAsciiCharacterCount++;
                } else {
                  assertNever(highlightReason);
                }
                const MAX_RESULT_LENGTH = 1e3;
                if (ranges.length >= MAX_RESULT_LENGTH) {
                  hasMore = true;
                  break forLoop;
                }
                ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
              }
            }
          } while (m);
        }
      return {
        ranges,
        hasMore,
        ambiguousCharacterCount,
        invisibleCharacterCount,
        nonBasicAsciiCharacterCount
      };
    }
    static computeUnicodeHighlightReason(char, options) {
      const codePointHighlighter = new CodePointHighlighter(options);
      const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
      switch (reason) {
        case 0:
          return null;
        case 2:
          return {
            kind: 1
            /* UnicodeHighlighterReasonKind.Invisible */
          };
        case 3: {
          const codePoint = char.codePointAt(0);
          const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
          const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
          return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
        }
        case 1:
          return {
            kind: 2
            /* UnicodeHighlighterReasonKind.NonBasicAscii */
          };
      }
    }
  };
  function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
    return src;
  }
  var CodePointHighlighter = class {
    constructor(options) {
      this.options = options;
      this.allowedCodePoints = new Set(options.allowedCodePoints);
      this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
    }
    getCandidateCodePoints() {
      if (this.options.nonBasicASCII) {
        return "allNonBasicAscii";
      }
      const set = /* @__PURE__ */ new Set();
      if (this.options.invisibleCharacters) {
        for (const cp of InvisibleCharacters.codePoints) {
          if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
            set.add(cp);
          }
        }
      }
      if (this.options.ambiguousCharacters) {
        for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
          set.add(cp);
        }
      }
      for (const cp of this.allowedCodePoints) {
        set.delete(cp);
      }
      return set;
    }
    shouldHighlightNonBasicASCII(character, wordContext) {
      const codePoint = character.codePointAt(0);
      if (this.allowedCodePoints.has(codePoint)) {
        return 0;
      }
      if (this.options.nonBasicASCII) {
        return 1;
      }
      let hasBasicASCIICharacters = false;
      let hasNonConfusableNonBasicAsciiCharacter = false;
      if (wordContext) {
        for (const char of wordContext) {
          const codePoint2 = char.codePointAt(0);
          const isBasicASCII2 = isBasicASCII(char);
          hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
          if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
            hasNonConfusableNonBasicAsciiCharacter = true;
          }
        }
      }
      if (
        /* Don't allow mixing weird looking characters with ASCII */
        !hasBasicASCIICharacters && /* Is there an obviously weird looking character? */
        hasNonConfusableNonBasicAsciiCharacter
      ) {
        return 0;
      }
      if (this.options.invisibleCharacters) {
        if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
          return 2;
        }
      }
      if (this.options.ambiguousCharacters) {
        if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
          return 3;
        }
      }
      return 0;
    }
  };
  function isAllowedInvisibleCharacter(character) {
    return character === " " || character === "\n" || character === "	";
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/linesDiffComputer.js
  var LinesDiff = class {
    constructor(changes, moves, hitTimeout) {
      this.changes = changes;
      this.moves = moves;
      this.hitTimeout = hitTimeout;
    }
  };
  var MovedText = class {
    constructor(lineRangeMapping, changes) {
      this.lineRangeMapping = lineRangeMapping;
      this.changes = changes;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/offsetRange.js
  var OffsetRange = class {
    static addRange(range, sortedRanges) {
      let i = 0;
      while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {
        i++;
      }
      let j = i;
      while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {
        j++;
      }
      if (i === j) {
        sortedRanges.splice(i, 0, range);
      } else {
        const start2 = Math.min(range.start, sortedRanges[i].start);
        const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);
        sortedRanges.splice(i, j - i, new OffsetRange(start2, end));
      }
    }
    static tryCreate(start2, endExclusive) {
      if (start2 > endExclusive) {
        return void 0;
      }
      return new OffsetRange(start2, endExclusive);
    }
    static ofLength(length) {
      return new OffsetRange(0, length);
    }
    static ofStartAndLength(start2, length) {
      return new OffsetRange(start2, start2 + length);
    }
    constructor(start2, endExclusive) {
      this.start = start2;
      this.endExclusive = endExclusive;
      if (start2 > endExclusive) {
        throw new BugIndicatingError(`Invalid range: ${this.toString()}`);
      }
    }
    get isEmpty() {
      return this.start === this.endExclusive;
    }
    delta(offset2) {
      return new OffsetRange(this.start + offset2, this.endExclusive + offset2);
    }
    deltaStart(offset2) {
      return new OffsetRange(this.start + offset2, this.endExclusive);
    }
    deltaEnd(offset2) {
      return new OffsetRange(this.start, this.endExclusive + offset2);
    }
    get length() {
      return this.endExclusive - this.start;
    }
    toString() {
      return `[${this.start}, ${this.endExclusive})`;
    }
    contains(offset2) {
      return this.start <= offset2 && offset2 < this.endExclusive;
    }
    /**
     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
     * The joined range is the smallest range that contains both ranges.
     */
    join(other) {
      return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
    }
    /**
     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
     *
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const start2 = Math.max(this.start, other.start);
      const end = Math.min(this.endExclusive, other.endExclusive);
      if (start2 <= end) {
        return new OffsetRange(start2, end);
      }
      return void 0;
    }
    intersects(other) {
      const start2 = Math.max(this.start, other.start);
      const end = Math.min(this.endExclusive, other.endExclusive);
      return start2 < end;
    }
    isBefore(other) {
      return this.endExclusive <= other.start;
    }
    isAfter(other) {
      return this.start >= other.endExclusive;
    }
    slice(arr) {
      return arr.slice(this.start, this.endExclusive);
    }
    substring(str) {
      return str.substring(this.start, this.endExclusive);
    }
    /**
     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
     * The range must not be empty.
     */
    clip(value) {
      if (this.isEmpty) {
        throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      return Math.max(this.start, Math.min(this.endExclusive - 1, value));
    }
    /**
     * Returns `r := value + k * length` such that `r` is contained in this range.
     * The range must not be empty.
     *
     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
     */
    clipCyclic(value) {
      if (this.isEmpty) {
        throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      if (value < this.start) {
        return this.endExclusive - (this.start - value) % this.length;
      }
      if (value >= this.endExclusive) {
        return this.start + (value - this.start) % this.length;
      }
      return value;
    }
    forEach(f) {
      for (let i = this.start; i < this.endExclusive; i++) {
        f(i);
      }
    }
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/arraysFind.js
  function findLastMonotonous(array, predicate) {
    const idx = findLastIdxMonotonous(array, predicate);
    return idx === -1 ? void 0 : array[idx];
  }
  function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i = startIdx;
    let j = endIdxEx;
    while (i < j) {
      const k = Math.floor((i + j) / 2);
      if (predicate(array[k])) {
        i = k + 1;
      } else {
        j = k;
      }
    }
    return i - 1;
  }
  function findFirstMonotonous(array, predicate) {
    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);
    return idx === array.length ? void 0 : array[idx];
  }
  function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i = startIdx;
    let j = endIdxEx;
    while (i < j) {
      const k = Math.floor((i + j) / 2);
      if (predicate(array[k])) {
        j = k;
      } else {
        i = k + 1;
      }
    }
    return i;
  }
  var MonotonousArray = class {
    constructor(_array) {
      this._array = _array;
      this._findLastMonotonousLastIdx = 0;
    }
    /**
     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
     */
    findLastMonotonous(predicate) {
      if (MonotonousArray.assertInvariants) {
        if (this._prevFindLastPredicate) {
          for (const item of this._array) {
            if (this._prevFindLastPredicate(item) && !predicate(item)) {
              throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
            }
          }
        }
        this._prevFindLastPredicate = predicate;
      }
      const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
      this._findLastMonotonousLastIdx = idx + 1;
      return idx === -1 ? void 0 : this._array[idx];
    }
  };
  MonotonousArray.assertInvariants = false;

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/lineRange.js
  var LineRange = class {
    static fromRangeInclusive(range) {
      return new LineRange(range.startLineNumber, range.endLineNumber + 1);
    }
    /**
     * @param lineRanges An array of sorted line ranges.
     */
    static joinMany(lineRanges) {
      if (lineRanges.length === 0) {
        return [];
      }
      let result = new LineRangeSet(lineRanges[0].slice());
      for (let i = 1; i < lineRanges.length; i++) {
        result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));
      }
      return result.ranges;
    }
    static join(lineRanges) {
      if (lineRanges.length === 0) {
        throw new BugIndicatingError("lineRanges cannot be empty");
      }
      let startLineNumber = lineRanges[0].startLineNumber;
      let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;
      for (let i = 1; i < lineRanges.length; i++) {
        startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);
        endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);
      }
      return new LineRange(startLineNumber, endLineNumberExclusive);
    }
    static ofLength(startLineNumber, length) {
      return new LineRange(startLineNumber, startLineNumber + length);
    }
    /**
     * @internal
     */
    static deserialize(lineRange) {
      return new LineRange(lineRange[0], lineRange[1]);
    }
    constructor(startLineNumber, endLineNumberExclusive) {
      if (startLineNumber > endLineNumberExclusive) {
        throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
      }
      this.startLineNumber = startLineNumber;
      this.endLineNumberExclusive = endLineNumberExclusive;
    }
    /**
     * Indicates if this line range contains the given line number.
     */
    contains(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Indicates if this line range is empty.
     */
    get isEmpty() {
      return this.startLineNumber === this.endLineNumberExclusive;
    }
    /**
     * Moves this line range by the given offset of line numbers.
     */
    delta(offset2) {
      return new LineRange(this.startLineNumber + offset2, this.endLineNumberExclusive + offset2);
    }
    deltaLength(offset2) {
      return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset2);
    }
    /**
     * The number of lines this line range spans.
     */
    get length() {
      return this.endLineNumberExclusive - this.startLineNumber;
    }
    /**
     * Creates a line range that combines this and the given line range.
     */
    join(other) {
      return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
    }
    toString() {
      return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
    }
    /**
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
      const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
      if (startLineNumber <= endLineNumberExclusive) {
        return new LineRange(startLineNumber, endLineNumberExclusive);
      }
      return void 0;
    }
    intersectsStrict(other) {
      return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
    }
    overlapOrTouch(other) {
      return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
    }
    equals(b) {
      return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
    }
    toInclusiveRange() {
      if (this.isEmpty) {
        return null;
      }
      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
    }
    /**
     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
    */
    toExclusiveRange() {
      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
    }
    mapToLineArray(f) {
      const result = [];
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        result.push(f(lineNumber));
      }
      return result;
    }
    forEach(f) {
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        f(lineNumber);
      }
    }
    /**
     * @internal
     */
    serialize() {
      return [this.startLineNumber, this.endLineNumberExclusive];
    }
    includes(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
     * @internal
     */
    toOffsetRange() {
      return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
    }
  };
  var LineRangeSet = class {
    constructor(_normalizedRanges = []) {
      this._normalizedRanges = _normalizedRanges;
    }
    get ranges() {
      return this._normalizedRanges;
    }
    addRange(range) {
      if (range.length === 0) {
        return;
      }
      const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);
      const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;
      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
        this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
      } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
        const joinRange = this._normalizedRanges[joinRangeStartIdx];
        this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);
      } else {
        const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
        this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
      }
    }
    contains(lineNumber) {
      const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= lineNumber);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
    }
    intersects(range) {
      const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber < range.endLineNumberExclusive);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;
    }
    getUnion(other) {
      if (this._normalizedRanges.length === 0) {
        return other;
      }
      if (other._normalizedRanges.length === 0) {
        return this;
      }
      const result = [];
      let i1 = 0;
      let i2 = 0;
      let current2 = null;
      while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {
        let next = null;
        if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
          const lineRange1 = this._normalizedRanges[i1];
          const lineRange2 = other._normalizedRanges[i2];
          if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
            next = lineRange1;
            i1++;
          } else {
            next = lineRange2;
            i2++;
          }
        } else if (i1 < this._normalizedRanges.length) {
          next = this._normalizedRanges[i1];
          i1++;
        } else {
          next = other._normalizedRanges[i2];
          i2++;
        }
        if (current2 === null) {
          current2 = next;
        } else {
          if (current2.endLineNumberExclusive >= next.startLineNumber) {
            current2 = new LineRange(current2.startLineNumber, Math.max(current2.endLineNumberExclusive, next.endLineNumberExclusive));
          } else {
            result.push(current2);
            current2 = next;
          }
        }
      }
      if (current2 !== null) {
        result.push(current2);
      }
      return new LineRangeSet(result);
    }
    /**
     * Subtracts all ranges in this set from `range` and returns the result.
     */
    subtractFrom(range) {
      const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);
      const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;
      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
        return new LineRangeSet([range]);
      }
      const result = [];
      let startLineNumber = range.startLineNumber;
      for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {
        const r = this._normalizedRanges[i];
        if (r.startLineNumber > startLineNumber) {
          result.push(new LineRange(startLineNumber, r.startLineNumber));
        }
        startLineNumber = r.endLineNumberExclusive;
      }
      if (startLineNumber < range.endLineNumberExclusive) {
        result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));
      }
      return new LineRangeSet(result);
    }
    toString() {
      return this._normalizedRanges.map((r) => r.toString()).join(", ");
    }
    getIntersection(other) {
      const result = [];
      let i1 = 0;
      let i2 = 0;
      while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
        const r1 = this._normalizedRanges[i1];
        const r2 = other._normalizedRanges[i2];
        const i = r1.intersect(r2);
        if (i && !i.isEmpty) {
          result.push(i);
        }
        if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {
          i1++;
        } else {
          i2++;
        }
      }
      return new LineRangeSet(result);
    }
    getWithDelta(value) {
      return new LineRangeSet(this._normalizedRanges.map((r) => r.delta(value)));
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/textLength.js
  var TextLength = class {
    static betweenPositions(position1, position22) {
      if (position1.lineNumber === position22.lineNumber) {
        return new TextLength(0, position22.column - position1.column);
      } else {
        return new TextLength(position22.lineNumber - position1.lineNumber, position22.column - 1);
      }
    }
    static ofRange(range) {
      return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());
    }
    static ofText(text4) {
      let line = 0;
      let column = 0;
      for (const c of text4) {
        if (c === "\n") {
          line++;
          column = 0;
        } else {
          column++;
        }
      }
      return new TextLength(line, column);
    }
    constructor(lineCount, columnCount) {
      this.lineCount = lineCount;
      this.columnCount = columnCount;
    }
    isGreaterThanOrEqualTo(other) {
      if (this.lineCount !== other.lineCount) {
        return this.lineCount > other.lineCount;
      }
      return this.columnCount >= other.columnCount;
    }
    createRange(startPosition) {
      if (this.lineCount === 0) {
        return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);
      } else {
        return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);
      }
    }
    addToPosition(position4) {
      if (this.lineCount === 0) {
        return new Position(position4.lineNumber, position4.column + this.columnCount);
      } else {
        return new Position(position4.lineNumber + this.lineCount, this.columnCount + 1);
      }
    }
    toString() {
      return `${this.lineCount},${this.columnCount}`;
    }
  };
  TextLength.zero = new TextLength(0, 0);

  // node_modules/monaco-editor-core/esm/vs/editor/common/core/textEdit.js
  var SingleTextEdit = class {
    constructor(range, text4) {
      this.range = range;
      this.text = text4;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/rangeMapping.js
  var LineRangeMapping = class {
    static inverse(mapping, originalLineCount, modifiedLineCount) {
      const result = [];
      let lastOriginalEndLineNumber = 1;
      let lastModifiedEndLineNumber = 1;
      for (const m of mapping) {
        const r2 = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));
        if (!r2.modified.isEmpty) {
          result.push(r2);
        }
        lastOriginalEndLineNumber = m.original.endLineNumberExclusive;
        lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;
      }
      const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));
      if (!r.modified.isEmpty) {
        result.push(r);
      }
      return result;
    }
    static clip(mapping, originalRange, modifiedRange) {
      const result = [];
      for (const m of mapping) {
        const original = m.original.intersect(originalRange);
        const modified = m.modified.intersect(modifiedRange);
        if (original && !original.isEmpty && modified && !modified.isEmpty) {
          result.push(new LineRangeMapping(original, modified));
        }
      }
      return result;
    }
    constructor(originalRange, modifiedRange) {
      this.original = originalRange;
      this.modified = modifiedRange;
    }
    toString() {
      return `{${this.original.toString()}->${this.modified.toString()}}`;
    }
    flip() {
      return new LineRangeMapping(this.modified, this.original);
    }
    join(other) {
      return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
    }
    /**
     * This method assumes that the LineRangeMapping describes a valid diff!
     * I.e. if one range is empty, the other range cannot be the entire document.
     * It avoids various problems when the line range points to non-existing line-numbers.
    */
    toRangeMapping() {
      const origInclusiveRange = this.original.toInclusiveRange();
      const modInclusiveRange = this.modified.toInclusiveRange();
      if (origInclusiveRange && modInclusiveRange) {
        return new RangeMapping(origInclusiveRange, modInclusiveRange);
      } else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
        if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {
          throw new BugIndicatingError("not a valid diff");
        }
        return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
      } else {
        return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
      }
    }
  };
  var DetailedLineRangeMapping = class extends LineRangeMapping {
    static fromRangeMappings(rangeMappings) {
      const originalRange = LineRange.join(rangeMappings.map((r) => LineRange.fromRangeInclusive(r.originalRange)));
      const modifiedRange = LineRange.join(rangeMappings.map((r) => LineRange.fromRangeInclusive(r.modifiedRange)));
      return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);
    }
    constructor(originalRange, modifiedRange, innerChanges) {
      super(originalRange, modifiedRange);
      this.innerChanges = innerChanges;
    }
    flip() {
      var _a4;
      return new DetailedLineRangeMapping(this.modified, this.original, (_a4 = this.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c) => c.flip()));
    }
    withInnerChangesFromLineRanges() {
      return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);
    }
  };
  var RangeMapping = class {
    constructor(originalRange, modifiedRange) {
      this.originalRange = originalRange;
      this.modifiedRange = modifiedRange;
    }
    toString() {
      return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
    }
    flip() {
      return new RangeMapping(this.modifiedRange, this.originalRange);
    }
    /**
     * Creates a single text edit that describes the change from the original to the modified text.
    */
    toTextEdit(modified) {
      const newText = modified.getValueOfRange(this.modifiedRange);
      return new SingleTextEdit(this.originalRange, newText);
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/legacyLinesDiffComputer.js
  var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
  var LegacyLinesDiffComputer = class {
    computeDiff(originalLines, modifiedLines, options) {
      var _a4;
      const diffComputer = new DiffComputer(originalLines, modifiedLines, {
        maxComputationTime: options.maxComputationTimeMs,
        shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
        shouldComputeCharChanges: true,
        shouldMakePrettyDiff: true,
        shouldPostProcessCharChanges: true
      });
      const result = diffComputer.computeDiff();
      const changes = [];
      let lastChange = null;
      for (const c of result.changes) {
        let originalRange;
        if (c.originalEndLineNumber === 0) {
          originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);
        } else {
          originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);
        }
        let modifiedRange;
        if (c.modifiedEndLineNumber === 0) {
          modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);
        } else {
          modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
        }
        let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a4 = c.charChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c2) => new RangeMapping(new Range(c2.originalStartLineNumber, c2.originalStartColumn, c2.originalEndLineNumber, c2.originalEndColumn), new Range(c2.modifiedStartLineNumber, c2.modifiedStartColumn, c2.modifiedEndLineNumber, c2.modifiedEndColumn))));
        if (lastChange) {
          if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {
            change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
            changes.pop();
          }
        }
        changes.push(change);
        lastChange = change;
      }
      assertFn(() => {
        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
        m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
      });
      return new LinesDiff(changes, [], result.quitEarly);
    }
  };
  function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
  }
  var LineSequence = class {
    constructor(lines) {
      const startColumns = [];
      const endColumns = [];
      for (let i = 0, length = lines.length; i < length; i++) {
        startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
        endColumns[i] = getLastNonBlankColumn(lines[i], 1);
      }
      this.lines = lines;
      this._startColumns = startColumns;
      this._endColumns = endColumns;
    }
    getElements() {
      const elements = [];
      for (let i = 0, len = this.lines.length; i < len; i++) {
        elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
      }
      return elements;
    }
    getStrictElement(index4) {
      return this.lines[index4];
    }
    getStartLineNumber(i) {
      return i + 1;
    }
    getEndLineNumber(i) {
      return i + 1;
    }
    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
      const charCodes = [];
      const lineNumbers = [];
      const columns = [];
      let len = 0;
      for (let index4 = startIndex; index4 <= endIndex; index4++) {
        const lineContent = this.lines[index4];
        const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index4] : 1;
        const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index4] : lineContent.length + 1;
        for (let col = startColumn; col < endColumn; col++) {
          charCodes[len] = lineContent.charCodeAt(col - 1);
          lineNumbers[len] = index4 + 1;
          columns[len] = col;
          len++;
        }
        if (!shouldIgnoreTrimWhitespace && index4 < endIndex) {
          charCodes[len] = 10;
          lineNumbers[len] = index4 + 1;
          columns[len] = lineContent.length + 1;
          len++;
        }
      }
      return new CharSequence(charCodes, lineNumbers, columns);
    }
  };
  var CharSequence = class {
    constructor(charCodes, lineNumbers, columns) {
      this._charCodes = charCodes;
      this._lineNumbers = lineNumbers;
      this._columns = columns;
    }
    toString() {
      return "[" + this._charCodes.map((s, idx) => (s === 10 ? "\\n" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
    }
    _assertIndex(index4, arr) {
      if (index4 < 0 || index4 >= arr.length) {
        throw new Error(`Illegal index`);
      }
    }
    getElements() {
      return this._charCodes;
    }
    getStartLineNumber(i) {
      if (i > 0 && i === this._lineNumbers.length) {
        return this.getEndLineNumber(i - 1);
      }
      this._assertIndex(i, this._lineNumbers);
      return this._lineNumbers[i];
    }
    getEndLineNumber(i) {
      if (i === -1) {
        return this.getStartLineNumber(i + 1);
      }
      this._assertIndex(i, this._lineNumbers);
      if (this._charCodes[i] === 10) {
        return this._lineNumbers[i] + 1;
      }
      return this._lineNumbers[i];
    }
    getStartColumn(i) {
      if (i > 0 && i === this._columns.length) {
        return this.getEndColumn(i - 1);
      }
      this._assertIndex(i, this._columns);
      return this._columns[i];
    }
    getEndColumn(i) {
      if (i === -1) {
        return this.getStartColumn(i + 1);
      }
      this._assertIndex(i, this._columns);
      if (this._charCodes[i] === 10) {
        return 1;
      }
      return this._columns[i] + 1;
    }
  };
  var CharChange = class {
    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalStartColumn = originalStartColumn;
      this.originalEndLineNumber = originalEndLineNumber;
      this.originalEndColumn = originalEndColumn;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedStartColumn = modifiedStartColumn;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.modifiedEndColumn = modifiedEndColumn;
    }
    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
      const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
      const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
      const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
      const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
      const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
    }
  };
  function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
      return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
      const currChange = rawChanges[i];
      const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
      const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
      const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
      if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
        prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
        prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
      } else {
        result.push(currChange);
        prevChange = currChange;
      }
    }
    return result;
  }
  var LineChange = class {
    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalEndLineNumber = originalEndLineNumber;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.charChanges = charChanges;
    }
    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
      let originalStartLineNumber;
      let originalEndLineNumber;
      let modifiedStartLineNumber;
      let modifiedEndLineNumber;
      let charChanges = void 0;
      if (diffChange.originalLength === 0) {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
        originalEndLineNumber = 0;
      } else {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
        originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      }
      if (diffChange.modifiedLength === 0) {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
        modifiedEndLineNumber = 0;
      } else {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
        modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      }
      if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
        const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
        const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
        if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
          let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
          if (shouldPostProcessCharChanges) {
            rawChanges = postProcessCharChanges(rawChanges);
          }
          charChanges = [];
          for (let i = 0, length = rawChanges.length; i < length; i++) {
            charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
          }
        }
      }
      return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    }
  };
  var DiffComputer = class {
    constructor(originalLines, modifiedLines, opts) {
      this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
      this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
      this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
      this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
      this.originalLines = originalLines;
      this.modifiedLines = modifiedLines;
      this.original = new LineSequence(originalLines);
      this.modified = new LineSequence(modifiedLines);
      this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
      this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
    }
    computeDiff() {
      if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
          return {
            quitEarly: false,
            changes: []
          };
        }
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: 1,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: this.modified.lines.length,
            charChanges: void 0
          }]
        };
      }
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: this.original.lines.length,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: 1,
            charChanges: void 0
          }]
        };
      }
      const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
      const rawChanges = diffResult.changes;
      const quitEarly = diffResult.quitEarly;
      if (this.shouldIgnoreTrimWhitespace) {
        const lineChanges = [];
        for (let i = 0, length = rawChanges.length; i < length; i++) {
          lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        }
        return {
          quitEarly,
          changes: lineChanges
        };
      }
      const result = [];
      let originalLineIndex = 0;
      let modifiedLineIndex = 0;
      for (let i = -1, len = rawChanges.length; i < len; i++) {
        const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
        const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
        const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
        while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
          const originalLine = this.originalLines[originalLineIndex];
          const modifiedLine = this.modifiedLines[modifiedLineIndex];
          if (originalLine !== modifiedLine) {
            {
              let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
              let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
              while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalStartColumn--;
                modifiedStartColumn--;
              }
              if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
              }
            }
            {
              let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
              let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
              const originalMaxColumn = originalLine.length + 1;
              const modifiedMaxColumn = modifiedLine.length + 1;
              while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalEndColumn++;
                modifiedEndColumn++;
              }
              if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
              }
            }
          }
          originalLineIndex++;
          modifiedLineIndex++;
        }
        if (nextChange) {
          result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
          originalLineIndex += nextChange.originalLength;
          modifiedLineIndex += nextChange.modifiedLength;
        }
      }
      return {
        quitEarly,
        changes: result
      };
    }
    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
        return;
      }
      let charChanges = void 0;
      if (this.shouldComputeCharChanges) {
        charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
      }
      result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
    }
    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      const len = result.length;
      if (len === 0) {
        return false;
      }
      const prevChange = result[len - 1];
      if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
        return false;
      }
      if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
        prevChange.originalEndLineNumber = originalLineNumber;
        prevChange.modifiedEndLineNumber = modifiedLineNumber;
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      return false;
    }
  };
  function getFirstNonBlankColumn(txt, defaultValue) {
    const r = firstNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 1;
  }
  function getLastNonBlankColumn(txt, defaultValue) {
    const r = lastNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 2;
  }
  function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
      return () => true;
    }
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime < maximumRuntime;
    };
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js
  var DiffAlgorithmResult = class {
    static trivial(seq1, seq2) {
      return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);
    }
    static trivialTimedOut(seq1, seq2) {
      return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);
    }
    constructor(diffs, hitTimeout) {
      this.diffs = diffs;
      this.hitTimeout = hitTimeout;
    }
  };
  var SequenceDiff = class {
    static invert(sequenceDiffs, doc1Length) {
      const result = [];
      forEachAdjacent(sequenceDiffs, (a, b) => {
        result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));
      });
      return result;
    }
    static fromOffsetPairs(start2, endExclusive) {
      return new SequenceDiff(new OffsetRange(start2.offset1, endExclusive.offset1), new OffsetRange(start2.offset2, endExclusive.offset2));
    }
    constructor(seq1Range, seq2Range) {
      this.seq1Range = seq1Range;
      this.seq2Range = seq2Range;
    }
    swap() {
      return new SequenceDiff(this.seq2Range, this.seq1Range);
    }
    toString() {
      return `${this.seq1Range} <-> ${this.seq2Range}`;
    }
    join(other) {
      return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
    }
    delta(offset2) {
      if (offset2 === 0) {
        return this;
      }
      return new SequenceDiff(this.seq1Range.delta(offset2), this.seq2Range.delta(offset2));
    }
    deltaStart(offset2) {
      if (offset2 === 0) {
        return this;
      }
      return new SequenceDiff(this.seq1Range.deltaStart(offset2), this.seq2Range.deltaStart(offset2));
    }
    deltaEnd(offset2) {
      if (offset2 === 0) {
        return this;
      }
      return new SequenceDiff(this.seq1Range.deltaEnd(offset2), this.seq2Range.deltaEnd(offset2));
    }
    intersect(other) {
      const i1 = this.seq1Range.intersect(other.seq1Range);
      const i2 = this.seq2Range.intersect(other.seq2Range);
      if (!i1 || !i2) {
        return void 0;
      }
      return new SequenceDiff(i1, i2);
    }
    getStarts() {
      return new OffsetPair(this.seq1Range.start, this.seq2Range.start);
    }
    getEndExclusives() {
      return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
    }
  };
  var OffsetPair = class {
    constructor(offset1, offset2) {
      this.offset1 = offset1;
      this.offset2 = offset2;
    }
    toString() {
      return `${this.offset1} <-> ${this.offset2}`;
    }
    delta(offset2) {
      if (offset2 === 0) {
        return this;
      }
      return new OffsetPair(this.offset1 + offset2, this.offset2 + offset2);
    }
    equals(other) {
      return this.offset1 === other.offset1 && this.offset2 === other.offset2;
    }
  };
  OffsetPair.zero = new OffsetPair(0, 0);
  OffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  var InfiniteTimeout = class {
    isValid() {
      return true;
    }
  };
  InfiniteTimeout.instance = new InfiniteTimeout();
  var DateTimeout = class {
    constructor(timeout) {
      this.timeout = timeout;
      this.startTime = Date.now();
      this.valid = true;
      if (timeout <= 0) {
        throw new BugIndicatingError("timeout must be positive");
      }
    }
    // Recommendation: Set a log-point `{this.disable()}` in the body
    isValid() {
      const valid = Date.now() - this.startTime < this.timeout;
      if (!valid && this.valid) {
        this.valid = false;
        debugger;
      }
      return this.valid;
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js
  var Array2D = class {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.array = [];
      this.array = new Array(width * height);
    }
    get(x, y) {
      return this.array[x + y * this.width];
    }
    set(x, y, value) {
      this.array[x + y * this.width] = value;
    }
  };
  function isSpace(charCode) {
    return charCode === 32 || charCode === 9;
  }
  var LineRangeFragment = class {
    static getKey(chr) {
      let key = this.chrKeys.get(chr);
      if (key === void 0) {
        key = this.chrKeys.size;
        this.chrKeys.set(chr, key);
      }
      return key;
    }
    constructor(range, lines, source) {
      this.range = range;
      this.lines = lines;
      this.source = source;
      this.histogram = [];
      let counter = 0;
      for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {
        const line = lines[i];
        for (let j = 0; j < line.length; j++) {
          counter++;
          const chr = line[j];
          const key2 = LineRangeFragment.getKey(chr);
          this.histogram[key2] = (this.histogram[key2] || 0) + 1;
        }
        counter++;
        const key = LineRangeFragment.getKey("\n");
        this.histogram[key] = (this.histogram[key] || 0) + 1;
      }
      this.totalCount = counter;
    }
    computeSimilarity(other) {
      var _a4, _b3;
      let sumDifferences = 0;
      const maxLength = Math.max(this.histogram.length, other.histogram.length);
      for (let i = 0; i < maxLength; i++) {
        sumDifferences += Math.abs(((_a4 = this.histogram[i]) !== null && _a4 !== void 0 ? _a4 : 0) - ((_b3 = other.histogram[i]) !== null && _b3 !== void 0 ? _b3 : 0));
      }
      return 1 - sumDifferences / (this.totalCount + other.totalCount);
    }
  };
  LineRangeFragment.chrKeys = /* @__PURE__ */ new Map();

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js
  var DynamicProgrammingDiffing = class {
    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {
      if (sequence1.length === 0 || sequence2.length === 0) {
        return DiffAlgorithmResult.trivial(sequence1, sequence2);
      }
      const lcsLengths = new Array2D(sequence1.length, sequence2.length);
      const directions = new Array2D(sequence1.length, sequence2.length);
      const lengths = new Array2D(sequence1.length, sequence2.length);
      for (let s12 = 0; s12 < sequence1.length; s12++) {
        for (let s22 = 0; s22 < sequence2.length; s22++) {
          if (!timeout.isValid()) {
            return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
          }
          const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);
          const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);
          let extendedSeqScore;
          if (sequence1.getElement(s12) === sequence2.getElement(s22)) {
            if (s12 === 0 || s22 === 0) {
              extendedSeqScore = 0;
            } else {
              extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);
            }
            if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {
              extendedSeqScore += lengths.get(s12 - 1, s22 - 1);
            }
            extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;
          } else {
            extendedSeqScore = -1;
          }
          const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
          if (newValue === extendedSeqScore) {
            const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;
            lengths.set(s12, s22, prevLen + 1);
            directions.set(s12, s22, 3);
          } else if (newValue === horizontalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 1);
          } else if (newValue === verticalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 2);
          }
          lcsLengths.set(s12, s22, newValue);
        }
      }
      const result = [];
      let lastAligningPosS1 = sequence1.length;
      let lastAligningPosS2 = sequence2.length;
      function reportDecreasingAligningPositions(s12, s22) {
        if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));
        }
        lastAligningPosS1 = s12;
        lastAligningPosS2 = s22;
      }
      let s1 = sequence1.length - 1;
      let s2 = sequence2.length - 1;
      while (s1 >= 0 && s2 >= 0) {
        if (directions.get(s1, s2) === 3) {
          reportDecreasingAligningPositions(s1, s2);
          s1--;
          s2--;
        } else {
          if (directions.get(s1, s2) === 1) {
            s1--;
          } else {
            s2--;
          }
        }
      }
      reportDecreasingAligningPositions(-1, -1);
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js
  var MyersDiffAlgorithm = class {
    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {
      if (seq1.length === 0 || seq2.length === 0) {
        return DiffAlgorithmResult.trivial(seq1, seq2);
      }
      const seqX = seq1;
      const seqY = seq2;
      function getXAfterSnake(x, y) {
        while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {
          x++;
          y++;
        }
        return x;
      }
      let d = 0;
      const V = new FastInt32Array();
      V.set(0, getXAfterSnake(0, 0));
      const paths = new FastArrayNegativeIndices();
      paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));
      let k = 0;
      loop:
        while (true) {
          d++;
          if (!timeout.isValid()) {
            return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);
          }
          const lowerBound = -Math.min(d, seqY.length + d % 2);
          const upperBound = Math.min(d, seqX.length + d % 2);
          for (k = lowerBound; k <= upperBound; k += 2) {
            let step = 0;
            const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1);
            const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1;
            step++;
            const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);
            const y = x - k;
            step++;
            if (x > seqX.length || y > seqY.length) {
              continue;
            }
            const newMaxX = getXAfterSnake(x, y);
            V.set(k, newMaxX);
            const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);
            paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);
            if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {
              break loop;
            }
          }
        }
      let path = paths.get(k);
      const result = [];
      let lastAligningPosS1 = seqX.length;
      let lastAligningPosS2 = seqY.length;
      while (true) {
        const endX = path ? path.x + path.length : 0;
        const endY = path ? path.y + path.length : 0;
        if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));
        }
        if (!path) {
          break;
        }
        lastAligningPosS1 = path.x;
        lastAligningPosS2 = path.y;
        path = path.prev;
      }
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };
  var SnakePath = class {
    constructor(prev, x, y, length) {
      this.prev = prev;
      this.x = x;
      this.y = y;
      this.length = length;
    }
  };
  var FastInt32Array = class {
    constructor() {
      this.positiveArr = new Int32Array(10);
      this.negativeArr = new Int32Array(10);
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value) {
      if (idx < 0) {
        idx = -idx - 1;
        if (idx >= this.negativeArr.length) {
          const arr = this.negativeArr;
          this.negativeArr = new Int32Array(arr.length * 2);
          this.negativeArr.set(arr);
        }
        this.negativeArr[idx] = value;
      } else {
        if (idx >= this.positiveArr.length) {
          const arr = this.positiveArr;
          this.positiveArr = new Int32Array(arr.length * 2);
          this.positiveArr.set(arr);
        }
        this.positiveArr[idx] = value;
      }
    }
  };
  var FastArrayNegativeIndices = class {
    constructor() {
      this.positiveArr = [];
      this.negativeArr = [];
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value) {
      if (idx < 0) {
        idx = -idx - 1;
        this.negativeArr[idx] = value;
      } else {
        this.positiveArr[idx] = value;
      }
    }
  };

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js
  var LinesSliceCharSequence = class {
    constructor(lines, lineRange, considerWhitespaceChanges) {
      this.lines = lines;
      this.considerWhitespaceChanges = considerWhitespaceChanges;
      this.elements = [];
      this.firstCharOffsetByLine = [];
      this.additionalOffsetByLine = [];
      let trimFirstLineFully = false;
      if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {
        lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);
        trimFirstLineFully = true;
      }
      this.lineRange = lineRange;
      this.firstCharOffsetByLine[0] = 0;
      for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {
        let line = lines[i];
        let offset2 = 0;
        if (trimFirstLineFully) {
          offset2 = line.length;
          line = "";
          trimFirstLineFully = false;
        } else if (!considerWhitespaceChanges) {
          const trimmedStartLine = line.trimStart();
          offset2 = line.length - trimmedStartLine.length;
          line = trimmedStartLine.trimEnd();
        }
        this.additionalOffsetByLine.push(offset2);
        for (let i2 = 0; i2 < line.length; i2++) {
          this.elements.push(line.charCodeAt(i2));
        }
        if (i < lines.length - 1) {
          this.elements.push("\n".charCodeAt(0));
          this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;
        }
      }
      this.additionalOffsetByLine.push(0);
    }
    toString() {
      return `Slice: "${this.text}"`;
    }
    get text() {
      return this.getText(new OffsetRange(0, this.length));
    }
    getText(range) {
      return this.elements.slice(range.start, range.endExclusive).map((e) => String.fromCharCode(e)).join("");
    }
    getElement(offset2) {
      return this.elements[offset2];
    }
    get length() {
      return this.elements.length;
    }
    getBoundaryScore(length) {
      const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
      const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
      if (prevCategory === 7 && nextCategory === 8) {
        return 0;
      }
      if (prevCategory === 8) {
        return 150;
      }
      let score2 = 0;
      if (prevCategory !== nextCategory) {
        score2 += 10;
        if (prevCategory === 0 && nextCategory === 1) {
          score2 += 1;
        }
      }
      score2 += getCategoryBoundaryScore(prevCategory);
      score2 += getCategoryBoundaryScore(nextCategory);
      return score2;
    }
    translateOffset(offset2) {
      if (this.lineRange.isEmpty) {
        return new Position(this.lineRange.start + 1, 1);
      }
      const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset2);
      return new Position(this.lineRange.start + i + 1, offset2 - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);
    }
    translateRange(range) {
      return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));
    }
    /**
     * Finds the word that contains the character at the given offset
     */
    findWordContaining(offset2) {
      if (offset2 < 0 || offset2 >= this.elements.length) {
        return void 0;
      }
      if (!isWordChar(this.elements[offset2])) {
        return void 0;
      }
      let start2 = offset2;
      while (start2 > 0 && isWordChar(this.elements[start2 - 1])) {
        start2--;
      }
      let end = offset2;
      while (end < this.elements.length && isWordChar(this.elements[end])) {
        end++;
      }
      return new OffsetRange(start2, end);
    }
    countLinesIn(range) {
      return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;
    }
    isStronglyEqual(offset1, offset2) {
      return this.elements[offset1] === this.elements[offset2];
    }
    extendToFullLines(range) {
      var _a4, _b3;
      const start2 = (_a4 = findLastMonotonous(this.firstCharOffsetByLine, (x) => x <= range.start)) !== null && _a4 !== void 0 ? _a4 : 0;
      const end = (_b3 = findFirstMonotonous(this.firstCharOffsetByLine, (x) => range.endExclusive <= x)) !== null && _b3 !== void 0 ? _b3 : this.elements.length;
      return new OffsetRange(start2, end);
    }
  };
  function isWordChar(charCode) {
    return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
  }
  var score = {
    [
      0
      /* CharBoundaryCategory.WordLower */
    ]: 0,
    [
      1
      /* CharBoundaryCategory.WordUpper */
    ]: 0,
    [
      2
      /* CharBoundaryCategory.WordNumber */
    ]: 0,
    [
      3
      /* CharBoundaryCategory.End */
    ]: 10,
    [
      4
      /* CharBoundaryCategory.Other */
    ]: 2,
    [
      5
      /* CharBoundaryCategory.Separator */
    ]: 30,
    [
      6
      /* CharBoundaryCategory.Space */
    ]: 3,
    [
      7
      /* CharBoundaryCategory.LineBreakCR */
    ]: 10,
    [
      8
      /* CharBoundaryCategory.LineBreakLF */
    ]: 10
  };
  function getCategoryBoundaryScore(category) {
    return score[category];
  }
  function getCategory(charCode) {
    if (charCode === 10) {
      return 8;
    } else if (charCode === 13) {
      return 7;
    } else if (isSpace(charCode)) {
      return 6;
    } else if (charCode >= 97 && charCode <= 122) {
      return 0;
    } else if (charCode >= 65 && charCode <= 90) {
      return 1;
    } else if (charCode >= 48 && charCode <= 57) {
      return 2;
    } else if (charCode === -1) {
      return 3;
    } else if (charCode === 44 || charCode === 59) {
      return 5;
    } else {
      return 4;
    }
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js
  function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {
    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);
    if (!timeout.isValid()) {
      return [];
    }
    const filteredChanges = changes.filter((c) => !excludedChanges.has(c));
    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);
    pushMany(moves, unchangedMoves);
    moves = joinCloseConsecutiveMoves(moves);
    moves = moves.filter((current2) => {
      const lines = current2.original.toOffsetRange().slice(originalLines).map((l) => l.trim());
      const originalText = lines.join("\n");
      return originalText.length >= 15 && countWhere(lines, (l) => l.length >= 2) >= 2;
    });
    moves = removeMovesInSameDiff(changes, moves);
    return moves;
  }
  function countWhere(arr, predicate) {
    let count = 0;
    for (const t of arr) {
      if (predicate(t)) {
        count++;
      }
    }
    return count;
  }
  function computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {
    const moves = [];
    const deletions = changes.filter((c) => c.modified.isEmpty && c.original.length >= 3).map((d) => new LineRangeFragment(d.original, originalLines, d));
    const insertions = new Set(changes.filter((c) => c.original.isEmpty && c.modified.length >= 3).map((d) => new LineRangeFragment(d.modified, modifiedLines, d)));
    const excludedChanges = /* @__PURE__ */ new Set();
    for (const deletion of deletions) {
      let highestSimilarity = -1;
      let best;
      for (const insertion of insertions) {
        const similarity = deletion.computeSimilarity(insertion);
        if (similarity > highestSimilarity) {
          highestSimilarity = similarity;
          best = insertion;
        }
      }
      if (highestSimilarity > 0.9 && best) {
        insertions.delete(best);
        moves.push(new LineRangeMapping(deletion.range, best.range));
        excludedChanges.add(deletion.source);
        excludedChanges.add(best.source);
      }
      if (!timeout.isValid()) {
        return { moves, excludedChanges };
      }
    }
    return { moves, excludedChanges };
  }
  function computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {
    const moves = [];
    const original3LineHashes = new SetMap();
    for (const change of changes) {
      for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {
        const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;
        original3LineHashes.add(key, { range: new LineRange(i, i + 3) });
      }
    }
    const possibleMappings = [];
    changes.sort(compareBy((c) => c.modified.startLineNumber, numberComparator));
    for (const change of changes) {
      let lastMappings = [];
      for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {
        const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;
        const currentModifiedRange = new LineRange(i, i + 3);
        const nextMappings = [];
        original3LineHashes.forEach(key, ({ range }) => {
          for (const lastMapping of lastMappings) {
            if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
              lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);
              lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
              nextMappings.push(lastMapping);
              return;
            }
          }
          const mapping = {
            modifiedLineRange: currentModifiedRange,
            originalLineRange: range
          };
          possibleMappings.push(mapping);
          nextMappings.push(mapping);
        });
        lastMappings = nextMappings;
      }
      if (!timeout.isValid()) {
        return [];
      }
    }
    possibleMappings.sort(reverseOrder(compareBy((m) => m.modifiedLineRange.length, numberComparator)));
    const modifiedSet = new LineRangeSet();
    const originalSet = new LineRangeSet();
    for (const mapping of possibleMappings) {
      const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
      const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
      const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);
      const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);
      for (const s of modifiedIntersectedSections.ranges) {
        if (s.length < 3) {
          continue;
        }
        const modifiedLineRange = s;
        const originalLineRange = s.delta(-diffOrigToMod);
        moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));
        modifiedSet.addRange(modifiedLineRange);
        originalSet.addRange(originalLineRange);
      }
    }
    moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
    const monotonousChanges = new MonotonousArray(changes);
    for (let i = 0; i < moves.length; i++) {
      const move = moves[i];
      const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber <= move.original.startLineNumber);
      const firstTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber <= move.modified.startLineNumber);
      const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);
      const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber < move.original.endLineNumberExclusive);
      const lastTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber < move.modified.endLineNumberExclusive);
      const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);
      let extendToTop;
      for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {
        const origLine = move.original.startLineNumber - extendToTop - 1;
        const modLine = move.modified.startLineNumber - extendToTop - 1;
        if (origLine > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
          break;
        }
        if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      if (extendToTop > 0) {
        originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));
        modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));
      }
      let extendToBottom;
      for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {
        const origLine = move.original.endLineNumberExclusive + extendToBottom;
        const modLine = move.modified.endLineNumberExclusive + extendToBottom;
        if (origLine > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
          break;
        }
        if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      if (extendToBottom > 0) {
        originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));
        modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));
      }
      if (extendToTop > 0 || extendToBottom > 0) {
        moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));
      }
    }
    return moves;
  }
  function areLinesSimilar(line1, line2, timeout) {
    if (line1.trim() === line2.trim()) {
      return true;
    }
    if (line1.length > 300 && line2.length > 300) {
      return false;
    }
    const myersDiffingAlgorithm = new MyersDiffAlgorithm();
    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);
    let commonNonSpaceCharCount = 0;
    const inverted = SequenceDiff.invert(result.diffs, line1.length);
    for (const seq of inverted) {
      seq.seq1Range.forEach((idx) => {
        if (!isSpace(line1.charCodeAt(idx))) {
          commonNonSpaceCharCount++;
        }
      });
    }
    function countNonWsChars(str) {
      let count = 0;
      for (let i = 0; i < line1.length; i++) {
        if (!isSpace(str.charCodeAt(i))) {
          count++;
        }
      }
      return count;
    }
    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);
    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;
    return r;
  }
  function joinCloseConsecutiveMoves(moves) {
    if (moves.length === 0) {
      return moves;
    }
    moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
    const result = [moves[0]];
    for (let i = 1; i < moves.length; i++) {
      const last = result[result.length - 1];
      const current2 = moves[i];
      const originalDist = current2.original.startLineNumber - last.original.endLineNumberExclusive;
      const modifiedDist = current2.modified.startLineNumber - last.modified.endLineNumberExclusive;
      const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
      if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
        result[result.length - 1] = last.join(current2);
        continue;
      }
      result.push(current2);
    }
    return result;
  }
  function removeMovesInSameDiff(changes, moves) {
    const changesMonotonous = new MonotonousArray(changes);
    moves = moves.filter((m) => {
      const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c) => c.original.startLineNumber < m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));
      const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c) => c.modified.startLineNumber < m.modified.endLineNumberExclusive);
      const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;
      return differentDiffs;
    });
    return moves;
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js
  function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    let result = sequenceDiffs;
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    result = shiftSequenceDiffs(sequence1, sequence2, result);
    return result;
  }
  function joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {
    if (sequenceDiffs.length === 0) {
      return sequenceDiffs;
    }
    const result = [];
    result.push(sequenceDiffs[0]);
    for (let i = 1; i < sequenceDiffs.length; i++) {
      const prevResult = result[result.length - 1];
      let cur = sequenceDiffs[i];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
        let d;
        for (d = 1; d <= length; d++) {
          if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {
            break;
          }
        }
        d--;
        if (d === length) {
          result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));
          continue;
        }
        cur = cur.delta(-d);
      }
      result.push(cur);
    }
    const result2 = [];
    for (let i = 0; i < result.length - 1; i++) {
      const nextResult = result[i + 1];
      let cur = result[i];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
        let d;
        for (d = 0; d < length; d++) {
          if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {
            break;
          }
        }
        if (d === length) {
          result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));
          continue;
        }
        if (d > 0) {
          cur = cur.delta(d);
        }
      }
      result2.push(cur);
    }
    if (result.length > 0) {
      result2.push(result[result.length - 1]);
    }
    return result2;
  }
  function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
      return sequenceDiffs;
    }
    for (let i = 0; i < sequenceDiffs.length; i++) {
      const prevDiff = i > 0 ? sequenceDiffs[i - 1] : void 0;
      const diff = sequenceDiffs[i];
      const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : void 0;
      const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);
      const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);
      if (diff.seq1Range.isEmpty) {
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
      } else if (diff.seq2Range.isEmpty) {
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();
      }
    }
    return sequenceDiffs;
  }
  function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
    const maxShiftLimit = 100;
    let deltaBefore = 1;
    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
      deltaBefore++;
    }
    deltaBefore--;
    let deltaAfter = 0;
    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
      deltaAfter++;
    }
    if (deltaBefore === 0 && deltaAfter === 0) {
      return diff;
    }
    let bestDelta = 0;
    let bestScore = -1;
    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
      const seq2OffsetStart = diff.seq2Range.start + delta;
      const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
      const seq1Offset = diff.seq1Range.start + delta;
      const score2 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
      if (score2 > bestScore) {
        bestScore = score2;
        bestDelta = delta;
      }
    }
    return diff.delta(bestDelta);
  }
  function removeShortMatches(sequence1, sequence2, sequenceDiffs) {
    const result = [];
    for (const s of sequenceDiffs) {
      const last = result[result.length - 1];
      if (!last) {
        result.push(s);
        continue;
      }
      if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {
        result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));
      } else {
        result.push(s);
      }
    }
    return result;
  }
  function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {
    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);
    const additional = [];
    let lastPoint = new OffsetPair(0, 0);
    function scanWord(pair, equalMapping) {
      if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {
        return;
      }
      const w1 = sequence1.findWordContaining(pair.offset1);
      const w2 = sequence2.findWordContaining(pair.offset2);
      if (!w1 || !w2) {
        return;
      }
      let w = new SequenceDiff(w1, w2);
      const equalPart = w.intersect(equalMapping);
      let equalChars1 = equalPart.seq1Range.length;
      let equalChars2 = equalPart.seq2Range.length;
      while (equalMappings.length > 0) {
        const next = equalMappings[0];
        const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);
        if (!intersects) {
          break;
        }
        const v1 = sequence1.findWordContaining(next.seq1Range.start);
        const v2 = sequence2.findWordContaining(next.seq2Range.start);
        const v = new SequenceDiff(v1, v2);
        const equalPart2 = v.intersect(next);
        equalChars1 += equalPart2.seq1Range.length;
        equalChars2 += equalPart2.seq2Range.length;
        w = w.join(v);
        if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {
          equalMappings.shift();
        } else {
          break;
        }
      }
      if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {
        additional.push(w);
      }
      lastPoint = w.getEndExclusives();
    }
    while (equalMappings.length > 0) {
      const next = equalMappings.shift();
      if (next.seq1Range.isEmpty) {
        continue;
      }
      scanWord(next.getStarts(), next);
      scanWord(next.getEndExclusives().delta(-1), next);
    }
    const merged = mergeSequenceDiffs(sequenceDiffs, additional);
    return merged;
  }
  function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
    const result = [];
    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
      const sd1 = sequenceDiffs1[0];
      const sd2 = sequenceDiffs2[0];
      let next;
      if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
        next = sequenceDiffs1.shift();
      } else {
        next = sequenceDiffs2.shift();
      }
      if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
        result[result.length - 1] = result[result.length - 1].join(next);
      } else {
        result.push(next);
      }
    }
    return result;
  }
  function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
      return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
      shouldRepeat = false;
      const result = [
        diffs[0]
      ];
      for (let i = 1; i < diffs.length; i++) {
        let shouldJoinDiffs = function(before, after) {
          const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
          const unchangedText = sequence1.getText(unchangedRange);
          const unchangedTextWithoutWs = unchangedText.replace(/\s/g, "");
          if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {
            return true;
          }
          return false;
        };
        const cur = diffs[i];
        const lastResult = result[result.length - 1];
        const shouldJoin = shouldJoinDiffs(lastResult, cur);
        if (shouldJoin) {
          shouldRepeat = true;
          result[result.length - 1] = result[result.length - 1].join(cur);
        } else {
          result.push(cur);
        }
      }
      diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    return diffs;
  }
  function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
      return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
      shouldRepeat = false;
      const result = [
        diffs[0]
      ];
      for (let i = 1; i < diffs.length; i++) {
        let shouldJoinDiffs = function(before, after) {
          const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
          const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
          if (unchangedLineCount > 5 || unchangedRange.length > 500) {
            return false;
          }
          const unchangedText = sequence1.getText(unchangedRange).trim();
          if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
            return false;
          }
          const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
          const beforeSeq1Length = before.seq1Range.length;
          const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
          const beforeSeq2Length = before.seq2Range.length;
          const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);
          const afterSeq1Length = after.seq1Range.length;
          const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);
          const afterSeq2Length = after.seq2Range.length;
          const max = 2 * 40 + 50;
          function cap(v) {
            return Math.min(v, max);
          }
          if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max ** 1.5) ** 1.5 * 1.3) {
            return true;
          }
          return false;
        };
        const cur = diffs[i];
        const lastResult = result[result.length - 1];
        const shouldJoin = shouldJoinDiffs(lastResult, cur);
        if (shouldJoin) {
          shouldRepeat = true;
          result[result.length - 1] = result[result.length - 1].join(cur);
        } else {
          result.push(cur);
        }
      }
      diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    const newDiffs = [];
    forEachWithNeighbors(diffs, (prev, cur, next) => {
      let newDiff = cur;
      function shouldMarkAsChanged(text4) {
        return text4.length > 0 && text4.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;
      }
      const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
      const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));
      if (shouldMarkAsChanged(prefix)) {
        newDiff = newDiff.deltaStart(-prefix.length);
      }
      const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
      if (shouldMarkAsChanged(suffix)) {
        newDiff = newDiff.deltaEnd(suffix.length);
      }
      const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);
      const result = newDiff.intersect(availableSpace);
      if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {
        newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);
      } else {
        newDiffs.push(result);
      }
    });
    return newDiffs;
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js
  var LineSequence2 = class {
    constructor(trimmedHash, lines) {
      this.trimmedHash = trimmedHash;
      this.lines = lines;
    }
    getElement(offset2) {
      return this.trimmedHash[offset2];
    }
    get length() {
      return this.trimmedHash.length;
    }
    getBoundaryScore(length) {
      const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);
      const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);
      return 1e3 - (indentationBefore + indentationAfter);
    }
    getText(range) {
      return this.lines.slice(range.start, range.endExclusive).join("\n");
    }
    isStronglyEqual(offset1, offset2) {
      return this.lines[offset1] === this.lines[offset2];
    }
  };
  function getIndentation(str) {
    let i = 0;
    while (i < str.length && (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {
      i++;
    }
    return i;
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js
  var DefaultLinesDiffComputer = class {
    constructor() {
      this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();
      this.myersDiffingAlgorithm = new MyersDiffAlgorithm();
    }
    computeDiff(originalLines, modifiedLines, options) {
      if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {
        return new LinesDiff([], [], false);
      }
      if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
        return new LinesDiff([
          new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [
            new RangeMapping(new Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))
          ])
        ], [], false);
      }
      const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);
      const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
      const perfectHashes = /* @__PURE__ */ new Map();
      function getOrCreateHash(text4) {
        let hash = perfectHashes.get(text4);
        if (hash === void 0) {
          hash = perfectHashes.size;
          perfectHashes.set(text4, hash);
        }
        return hash;
      }
      const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));
      const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));
      const sequence1 = new LineSequence2(originalLinesHashes, originalLines);
      const sequence2 = new LineSequence2(modifiedLinesHashes, modifiedLines);
      const lineAlignmentResult = (() => {
        if (sequence1.length + sequence2.length < 1700) {
          return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
        }
        return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);
      })();
      let lineAlignments = lineAlignmentResult.diffs;
      let hitTimeout = lineAlignmentResult.hitTimeout;
      lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);
      lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);
      const alignments = [];
      const scanForWhitespaceChanges = (equalLinesCount) => {
        if (!considerWhitespaceChanges) {
          return;
        }
        for (let i = 0; i < equalLinesCount; i++) {
          const seq1Offset = seq1LastStart + i;
          const seq2Offset = seq2LastStart + i;
          if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
            const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
            for (const a of characterDiffs.mappings) {
              alignments.push(a);
            }
            if (characterDiffs.hitTimeout) {
              hitTimeout = true;
            }
          }
        }
      };
      let seq1LastStart = 0;
      let seq2LastStart = 0;
      for (const diff of lineAlignments) {
        assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
        const equalLinesCount = diff.seq1Range.start - seq1LastStart;
        scanForWhitespaceChanges(equalLinesCount);
        seq1LastStart = diff.seq1Range.endExclusive;
        seq2LastStart = diff.seq2Range.endExclusive;
        const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
        if (characterDiffs.hitTimeout) {
          hitTimeout = true;
        }
        for (const a of characterDiffs.mappings) {
          alignments.push(a);
        }
      }
      scanForWhitespaceChanges(originalLines.length - seq1LastStart);
      const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
      let moves = [];
      if (options.computeMoves) {
        moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);
      }
      assertFn(() => {
        function validatePosition(pos, lines) {
          if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
            return false;
          }
          const line = lines[pos.lineNumber - 1];
          if (pos.column < 1 || pos.column > line.length + 1) {
            return false;
          }
          return true;
        }
        function validateRange(range, lines) {
          if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {
            return false;
          }
          if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {
            return false;
          }
          return true;
        }
        for (const c of changes) {
          if (!c.innerChanges) {
            return false;
          }
          for (const ic of c.innerChanges) {
            const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
            if (!valid) {
              return false;
            }
          }
          if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {
            return false;
          }
        }
        return true;
      });
      return new LinesDiff(changes, moves, hitTimeout);
    }
    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {
      const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);
      const movesWithDiffs = moves.map((m) => {
        const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);
        const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
        return new MovedText(m, mappings);
      });
      return movesWithDiffs;
    }
    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
      const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);
      const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
      const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
      let diffs = diffResult.diffs;
      diffs = optimizeSequenceDiffs(slice1, slice2, diffs);
      diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);
      diffs = removeShortMatches(slice1, slice2, diffs);
      diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);
      const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));
      return {
        mappings: result,
        hitTimeout: diffResult.hitTimeout
      };
    }
  };
  function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
    const changes = [];
    for (const g of groupAdjacentBy(alignments.map((a) => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {
      const first = g[0];
      const last = g[g.length - 1];
      changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map((a) => a.innerChanges[0])));
    }
    assertFn(() => {
      if (!dontAssertStartLine && changes.length > 0) {
        if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {
          return false;
        }
        if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {
          return false;
        }
      }
      return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
      m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
    });
    return changes;
  }
  function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
    let lineStartDelta = 0;
    let lineEndDelta = 0;
    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
      lineEndDelta = -1;
    }
    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
      lineStartDelta = 1;
    }
    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/diff/linesDiffComputers.js
  var linesDiffComputers = {
    getLegacy: () => new LegacyLinesDiffComputer(),
    getDefault: () => new DefaultLinesDiffComputer()
  };

  // node_modules/monaco-editor-core/esm/vs/base/common/color.js
  function roundFloat(number, decimalPoints) {
    const decimal = Math.pow(10, decimalPoints);
    return Math.round(number * decimal) / decimal;
  }
  var RGBA = class {
    constructor(r, g, b, a = 1) {
      this._rgbaBrand = void 0;
      this.r = Math.min(255, Math.max(0, r)) | 0;
      this.g = Math.min(255, Math.max(0, g)) | 0;
      this.b = Math.min(255, Math.max(0, b)) | 0;
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
      return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
    }
  };
  var HSLA = class {
    constructor(h, s, l, a) {
      this._hslaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
      this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
      return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
    }
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h in the set [0, 360], s, and l in the set [0, 1].
     */
    static fromRGBA(rgba) {
      const r = rgba.r / 255;
      const g = rgba.g / 255;
      const b = rgba.b / 255;
      const a = rgba.a;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h = 0;
      let s = 0;
      const l = (min + max) / 2;
      const chroma = max - min;
      if (chroma > 0) {
        s = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);
        switch (max) {
          case r:
            h = (g - b) / chroma + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / chroma + 2;
            break;
          case b:
            h = (r - g) / chroma + 4;
            break;
        }
        h *= 60;
        h = Math.round(h);
      }
      return new HSLA(h, s, l, a);
    }
    static _hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     */
    static toRGBA(hsla) {
      const h = hsla.h / 360;
      const { s, l, a } = hsla;
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = HSLA._hue2rgb(p, q, h + 1 / 3);
        g = HSLA._hue2rgb(p, q, h);
        b = HSLA._hue2rgb(p, q, h - 1 / 3);
      }
      return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);
    }
  };
  var HSVA = class {
    constructor(h, s, v, a) {
      this._hsvaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
      this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
      return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
    }
    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
    static fromRGBA(rgba) {
      const r = rgba.r / 255;
      const g = rgba.g / 255;
      const b = rgba.b / 255;
      const cmax = Math.max(r, g, b);
      const cmin = Math.min(r, g, b);
      const delta = cmax - cmin;
      const s = cmax === 0 ? 0 : delta / cmax;
      let m;
      if (delta === 0) {
        m = 0;
      } else if (cmax === r) {
        m = ((g - b) / delta % 6 + 6) % 6;
      } else if (cmax === g) {
        m = (b - r) / delta + 2;
      } else {
        m = (r - g) / delta + 4;
      }
      return new HSVA(Math.round(m * 60), s, cmax, rgba.a);
    }
    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
    static toRGBA(hsva) {
      const { h, s, v, a } = hsva;
      const c = v * s;
      const x = c * (1 - Math.abs(h / 60 % 2 - 1));
      const m = v - c;
      let [r, g, b] = [0, 0, 0];
      if (h < 60) {
        r = c;
        g = x;
      } else if (h < 120) {
        r = x;
        g = c;
      } else if (h < 180) {
        g = c;
        b = x;
      } else if (h < 240) {
        g = x;
        b = c;
      } else if (h < 300) {
        r = x;
        b = c;
      } else if (h <= 360) {
        r = c;
        b = x;
      }
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);
      return new RGBA(r, g, b, a);
    }
  };
  var Color = class {
    static fromHex(hex) {
      return Color.Format.CSS.parseHex(hex) || Color.red;
    }
    static equals(a, b) {
      if (!a && !b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return a.equals(b);
    }
    get hsla() {
      if (this._hsla) {
        return this._hsla;
      } else {
        return HSLA.fromRGBA(this.rgba);
      }
    }
    get hsva() {
      if (this._hsva) {
        return this._hsva;
      }
      return HSVA.fromRGBA(this.rgba);
    }
    constructor(arg) {
      if (!arg) {
        throw new Error("Color needs a value");
      } else if (arg instanceof RGBA) {
        this.rgba = arg;
      } else if (arg instanceof HSLA) {
        this._hsla = arg;
        this.rgba = HSLA.toRGBA(arg);
      } else if (arg instanceof HSVA) {
        this._hsva = arg;
        this.rgba = HSVA.toRGBA(arg);
      } else {
        throw new Error("Invalid color ctor argument");
      }
    }
    equals(other) {
      return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
    }
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    getRelativeLuminance() {
      const R = Color._relativeLuminanceForComponent(this.rgba.r);
      const G = Color._relativeLuminanceForComponent(this.rgba.g);
      const B = Color._relativeLuminanceForComponent(this.rgba.b);
      const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
      return roundFloat(luminance, 4);
    }
    static _relativeLuminanceForComponent(color3) {
      const c = color3 / 255;
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    }
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    isLighter() {
      const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;
      return yiq >= 128;
    }
    isLighterThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 > lum2;
    }
    isDarkerThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 < lum2;
    }
    lighten(factor) {
      return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
    }
    darken(factor) {
      return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
    }
    transparent(factor) {
      const { r, g, b, a } = this.rgba;
      return new Color(new RGBA(r, g, b, a * factor));
    }
    isTransparent() {
      return this.rgba.a === 0;
    }
    isOpaque() {
      return this.rgba.a === 1;
    }
    opposite() {
      return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
    }
    makeOpaque(opaqueBackground) {
      if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
        return this;
      }
      const { r, g, b, a } = this.rgba;
      return new Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));
    }
    toString() {
      if (!this._toString) {
        this._toString = Color.Format.CSS.format(this);
      }
      return this._toString;
    }
    static getLighterColor(of, relative3, factor) {
      if (of.isLighterThan(relative3)) {
        return of;
      }
      factor = factor ? factor : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative3.getRelativeLuminance();
      factor = factor * (lum2 - lum1) / lum2;
      return of.lighten(factor);
    }
    static getDarkerColor(of, relative3, factor) {
      if (of.isDarkerThan(relative3)) {
        return of;
      }
      factor = factor ? factor : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative3.getRelativeLuminance();
      factor = factor * (lum1 - lum2) / lum1;
      return of.darken(factor);
    }
  };
  Color.white = new Color(new RGBA(255, 255, 255, 1));
  Color.black = new Color(new RGBA(0, 0, 0, 1));
  Color.red = new Color(new RGBA(255, 0, 0, 1));
  Color.blue = new Color(new RGBA(0, 0, 255, 1));
  Color.green = new Color(new RGBA(0, 255, 0, 1));
  Color.cyan = new Color(new RGBA(0, 255, 255, 1));
  Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
  Color.transparent = new Color(new RGBA(0, 0, 0, 0));
  (function(Color2) {
    let Format;
    (function(Format2) {
      let CSS;
      (function(CSS2) {
        function formatRGB(color3) {
          if (color3.rgba.a === 1) {
            return `rgb(${color3.rgba.r}, ${color3.rgba.g}, ${color3.rgba.b})`;
          }
          return Color2.Format.CSS.formatRGBA(color3);
        }
        CSS2.formatRGB = formatRGB;
        function formatRGBA(color3) {
          return `rgba(${color3.rgba.r}, ${color3.rgba.g}, ${color3.rgba.b}, ${+color3.rgba.a.toFixed(2)})`;
        }
        CSS2.formatRGBA = formatRGBA;
        function formatHSL(color3) {
          if (color3.hsla.a === 1) {
            return `hsl(${color3.hsla.h}, ${(color3.hsla.s * 100).toFixed(2)}%, ${(color3.hsla.l * 100).toFixed(2)}%)`;
          }
          return Color2.Format.CSS.formatHSLA(color3);
        }
        CSS2.formatHSL = formatHSL;
        function formatHSLA(color3) {
          return `hsla(${color3.hsla.h}, ${(color3.hsla.s * 100).toFixed(2)}%, ${(color3.hsla.l * 100).toFixed(2)}%, ${color3.hsla.a.toFixed(2)})`;
        }
        CSS2.formatHSLA = formatHSLA;
        function _toTwoDigitHex(n) {
          const r = n.toString(16);
          return r.length !== 2 ? "0" + r : r;
        }
        function formatHex(color3) {
          return `#${_toTwoDigitHex(color3.rgba.r)}${_toTwoDigitHex(color3.rgba.g)}${_toTwoDigitHex(color3.rgba.b)}`;
        }
        CSS2.formatHex = formatHex;
        function formatHexA(color3, compact = false) {
          if (compact && color3.rgba.a === 1) {
            return Color2.Format.CSS.formatHex(color3);
          }
          return `#${_toTwoDigitHex(color3.rgba.r)}${_toTwoDigitHex(color3.rgba.g)}${_toTwoDigitHex(color3.rgba.b)}${_toTwoDigitHex(Math.round(color3.rgba.a * 255))}`;
        }
        CSS2.formatHexA = formatHexA;
        function format2(color3) {
          if (color3.isOpaque()) {
            return Color2.Format.CSS.formatHex(color3);
          }
          return Color2.Format.CSS.formatRGBA(color3);
        }
        CSS2.format = format2;
        function parseHex(hex) {
          const length = hex.length;
          if (length === 0) {
            return null;
          }
          if (hex.charCodeAt(0) !== 35) {
            return null;
          }
          if (length === 7) {
            const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
            const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
            const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
            return new Color2(new RGBA(r, g, b, 1));
          }
          if (length === 9) {
            const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
            const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
            const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
            const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
            return new Color2(new RGBA(r, g, b, a / 255));
          }
          if (length === 4) {
            const r = _parseHexDigit(hex.charCodeAt(1));
            const g = _parseHexDigit(hex.charCodeAt(2));
            const b = _parseHexDigit(hex.charCodeAt(3));
            return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
          }
          if (length === 5) {
            const r = _parseHexDigit(hex.charCodeAt(1));
            const g = _parseHexDigit(hex.charCodeAt(2));
            const b = _parseHexDigit(hex.charCodeAt(3));
            const a = _parseHexDigit(hex.charCodeAt(4));
            return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));
          }
          return null;
        }
        CSS2.parseHex = parseHex;
        function _parseHexDigit(charCode) {
          switch (charCode) {
            case 48:
              return 0;
            case 49:
              return 1;
            case 50:
              return 2;
            case 51:
              return 3;
            case 52:
              return 4;
            case 53:
              return 5;
            case 54:
              return 6;
            case 55:
              return 7;
            case 56:
              return 8;
            case 57:
              return 9;
            case 97:
              return 10;
            case 65:
              return 10;
            case 98:
              return 11;
            case 66:
              return 11;
            case 99:
              return 12;
            case 67:
              return 12;
            case 100:
              return 13;
            case 68:
              return 13;
            case 101:
              return 14;
            case 69:
              return 14;
            case 102:
              return 15;
            case 70:
              return 15;
          }
          return 0;
        }
      })(CSS = Format2.CSS || (Format2.CSS = {}));
    })(Format = Color2.Format || (Color2.Format = {}));
  })(Color || (Color = {}));

  // node_modules/monaco-editor-core/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js
  function _parseCaptureGroups(captureGroups) {
    const values = [];
    for (const captureGroup of captureGroups) {
      const parsedNumber = Number(captureGroup);
      if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\s/g, "") !== "") {
        values.push(parsedNumber);
      }
    }
    return values;
  }
  function _toIColor(r, g, b, a) {
    return {
      red: r / 255,
      blue: b / 255,
      green: g / 255,
      alpha: a
    };
  }
  function _findRange(model, match) {
    const index4 = match.index;
    const length = match[0].length;
    if (!index4) {
      return;
    }
    const startPosition = model.positionAt(index4);
    const range = {
      startLineNumber: startPosition.lineNumber,
      startColumn: startPosition.column,
      endLineNumber: startPosition.lineNumber,
      endColumn: startPosition.column + length
    };
    return range;
  }
  function _findHexColorInformation(range, hexValue) {
    if (!range) {
      return;
    }
    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);
    if (!parsedHexColor) {
      return;
    }
    return {
      range,
      color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)
    };
  }
  function _findRGBColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    return {
      range,
      color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)
    };
  }
  function _findHSLColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));
    return {
      range,
      color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)
    };
  }
  function _findMatches(model, regex) {
    if (typeof model === "string") {
      return [...model.matchAll(regex)];
    } else {
      return model.findMatches(regex);
    }
  }
  function computeColors(model) {
    const result = [];
    const initialValidationRegex = /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm;
    const initialValidationMatches = _findMatches(model, initialValidationRegex);
    if (initialValidationMatches.length > 0) {
      for (const initialMatch of initialValidationMatches) {
        const initialCaptureGroups = initialMatch.filter((captureGroup) => captureGroup !== void 0);
        const colorScheme = initialCaptureGroups[1];
        const colorParameters = initialCaptureGroups[2];
        if (!colorParameters) {
          continue;
        }
        let colorInformation;
        if (colorScheme === "rgb") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "rgba") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "hsl") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "hsla") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "#") {
          colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);
        }
        if (colorInformation) {
          result.push(colorInformation);
        }
      }
    }
    return result;
  }
  function computeDefaultDocumentColors(model) {
    if (!model || typeof model.getValue !== "function" || typeof model.positionAt !== "function") {
      return [];
    }
    return computeColors(model);
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/services/findSectionHeaders.js
  var markRegex = new RegExp("\\bMARK:\\s*(.*)$", "d");
  var trimDashesRegex = /^-+|-+$/g;
  function findSectionHeaders(model, options) {
    var _a4;
    let headers = [];
    if (options.findRegionSectionHeaders && ((_a4 = options.foldingRules) === null || _a4 === void 0 ? void 0 : _a4.markers)) {
      const regionHeaders = collectRegionHeaders(model, options);
      headers = headers.concat(regionHeaders);
    }
    if (options.findMarkSectionHeaders) {
      const markHeaders = collectMarkHeaders(model);
      headers = headers.concat(markHeaders);
    }
    return headers;
  }
  function collectRegionHeaders(model, options) {
    const regionHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      const match = lineContent.match(options.foldingRules.markers.start);
      if (match) {
        const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };
        if (range.endColumn > range.startColumn) {
          const sectionHeader = {
            range,
            ...getHeaderText(lineContent.substring(match[0].length)),
            shouldBeInComments: false
          };
          if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
            regionHeaders.push(sectionHeader);
          }
        }
      }
    }
    return regionHeaders;
  }
  function collectMarkHeaders(model) {
    const markHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);
    }
    return markHeaders;
  }
  function addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {
    markRegex.lastIndex = 0;
    const match = markRegex.exec(lineContent);
    if (match) {
      const column = match.indices[1][0] + 1;
      const endColumn = match.indices[1][1] + 1;
      const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn };
      if (range.endColumn > range.startColumn) {
        const sectionHeader = {
          range,
          ...getHeaderText(match[1]),
          shouldBeInComments: true
        };
        if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
          sectionHeaders.push(sectionHeader);
        }
      }
    }
  }
  function getHeaderText(text4) {
    text4 = text4.trim();
    const hasSeparatorLine = text4.startsWith("-");
    text4 = text4.replace(trimDashesRegex, "");
    return { text: text4, hasSeparatorLine };
  }

  // node_modules/monaco-editor-core/esm/vs/editor/common/services/editorSimpleWorker.js
  var MirrorModel = class extends MirrorTextModel {
    get uri() {
      return this._uri;
    }
    get eol() {
      return this._eol;
    }
    getValue() {
      return this.getText();
    }
    findMatches(regex) {
      const matches = [];
      for (let i = 0; i < this._lines.length; i++) {
        const line = this._lines[i];
        const offsetToAdd = this.offsetAt(new Position(i + 1, 1));
        const iteratorOverMatches = line.matchAll(regex);
        for (const match of iteratorOverMatches) {
          if (match.index || match.index === 0) {
            match.index = match.index + offsetToAdd;
          }
          matches.push(match);
        }
      }
      return matches;
    }
    getLinesContent() {
      return this._lines.slice(0);
    }
    getLineCount() {
      return this._lines.length;
    }
    getLineContent(lineNumber) {
      return this._lines[lineNumber - 1];
    }
    getWordAtPosition(position4, wordDefinition) {
      const wordAtText = getWordAtText(position4.column, ensureValidWordDefinition(wordDefinition), this._lines[position4.lineNumber - 1], 0);
      if (wordAtText) {
        return new Range(position4.lineNumber, wordAtText.startColumn, position4.lineNumber, wordAtText.endColumn);
      }
      return null;
    }
    words(wordDefinition) {
      const lines = this._lines;
      const wordenize = this._wordenize.bind(this);
      let lineNumber = 0;
      let lineText = "";
      let wordRangesIdx = 0;
      let wordRanges = [];
      return {
        *[Symbol.iterator]() {
          while (true) {
            if (wordRangesIdx < wordRanges.length) {
              const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
              wordRangesIdx += 1;
              yield value;
            } else {
              if (lineNumber < lines.length) {
                lineText = lines[lineNumber];
                wordRanges = wordenize(lineText, wordDefinition);
                wordRangesIdx = 0;
                lineNumber += 1;
              } else {
                break;
              }
            }
          }
        }
      };
    }
    getLineWords(lineNumber, wordDefinition) {
      const content3 = this._lines[lineNumber - 1];
      const ranges = this._wordenize(content3, wordDefinition);
      const words = [];
      for (const range of ranges) {
        words.push({
          word: content3.substring(range.start, range.end),
          startColumn: range.start + 1,
          endColumn: range.end + 1
        });
      }
      return words;
    }
    _wordenize(content3, wordDefinition) {
      const result = [];
      let match;
      wordDefinition.lastIndex = 0;
      while (match = wordDefinition.exec(content3)) {
        if (match[0].length === 0) {
          break;
        }
        result.push({ start: match.index, end: match.index + match[0].length });
      }
      return result;
    }
    getValueInRange(range) {
      range = this._validateRange(range);
      if (range.startLineNumber === range.endLineNumber) {
        return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
      }
      const lineEnding2 = this._eol;
      const startLineIndex = range.startLineNumber - 1;
      const endLineIndex = range.endLineNumber - 1;
      const resultLines = [];
      resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
      for (let i = startLineIndex + 1; i < endLineIndex; i++) {
        resultLines.push(this._lines[i]);
      }
      resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
      return resultLines.join(lineEnding2);
    }
    offsetAt(position4) {
      position4 = this._validatePosition(position4);
      this._ensureLineStarts();
      return this._lineStarts.getPrefixSum(position4.lineNumber - 2) + (position4.column - 1);
    }
    positionAt(offset2) {
      offset2 = Math.floor(offset2);
      offset2 = Math.max(0, offset2);
      this._ensureLineStarts();
      const out = this._lineStarts.getIndexOf(offset2);
      const lineLength = this._lines[out.index].length;
      return {
        lineNumber: 1 + out.index,
        column: 1 + Math.min(out.remainder, lineLength)
      };
    }
    _validateRange(range) {
      const start2 = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
      const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
      if (start2.lineNumber !== range.startLineNumber || start2.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {
        return {
          startLineNumber: start2.lineNumber,
          startColumn: start2.column,
          endLineNumber: end.lineNumber,
          endColumn: end.column
        };
      }
      return range;
    }
    _validatePosition(position4) {
      if (!Position.isIPosition(position4)) {
        throw new Error("bad position");
      }
      let { lineNumber, column } = position4;
      let hasChanged = false;
      if (lineNumber < 1) {
        lineNumber = 1;
        column = 1;
        hasChanged = true;
      } else if (lineNumber > this._lines.length) {
        lineNumber = this._lines.length;
        column = this._lines[lineNumber - 1].length + 1;
        hasChanged = true;
      } else {
        const maxCharacter = this._lines[lineNumber - 1].length + 1;
        if (column < 1) {
          column = 1;
          hasChanged = true;
        } else if (column > maxCharacter) {
          column = maxCharacter;
          hasChanged = true;
        }
      }
      if (!hasChanged) {
        return position4;
      } else {
        return { lineNumber, column };
      }
    }
  };
  var EditorSimpleWorker = class {
    constructor(host, foreignModuleFactory) {
      this._host = host;
      this._models = /* @__PURE__ */ Object.create(null);
      this._foreignModuleFactory = foreignModuleFactory;
      this._foreignModule = null;
    }
    dispose() {
      this._models = /* @__PURE__ */ Object.create(null);
    }
    _getModel(uri) {
      return this._models[uri];
    }
    _getModels() {
      const all3 = [];
      Object.keys(this._models).forEach((key) => all3.push(this._models[key]));
      return all3;
    }
    acceptNewModel(data2) {
      this._models[data2.url] = new MirrorModel(URI.parse(data2.url), data2.lines, data2.EOL, data2.versionId);
    }
    acceptModelChanged(strURL, e) {
      if (!this._models[strURL]) {
        return;
      }
      const model = this._models[strURL];
      model.onEvents(e);
    }
    acceptRemovedModel(strURL) {
      if (!this._models[strURL]) {
        return;
      }
      delete this._models[strURL];
    }
    async computeUnicodeHighlights(url, options, range) {
      const model = this._getModel(url);
      if (!model) {
        return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
      }
      return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
    }
    async findSectionHeaders(url, options) {
      const model = this._getModel(url);
      if (!model) {
        return [];
      }
      return findSectionHeaders(model, options);
    }
    // ---- BEGIN diff --------------------------------------------------------------------------
    async computeDiff(originalUrl, modifiedUrl, options, algorithm) {
      const original = this._getModel(originalUrl);
      const modified = this._getModel(modifiedUrl);
      if (!original || !modified) {
        return null;
      }
      const result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
      return result;
    }
    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
      const diffAlgorithm = algorithm === "advanced" ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();
      const originalLines = originalTextModel.getLinesContent();
      const modifiedLines = modifiedTextModel.getLinesContent();
      const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
      const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);
      function getLineChanges(changes) {
        return changes.map((m) => {
          var _a4;
          return [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a4 = m.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((m2) => [
            m2.originalRange.startLineNumber,
            m2.originalRange.startColumn,
            m2.originalRange.endLineNumber,
            m2.originalRange.endColumn,
            m2.modifiedRange.startLineNumber,
            m2.modifiedRange.startColumn,
            m2.modifiedRange.endLineNumber,
            m2.modifiedRange.endColumn
          ])];
        });
      }
      return {
        identical,
        quitEarly: result.hitTimeout,
        changes: getLineChanges(result.changes),
        moves: result.moves.map((m) => [
          m.lineRangeMapping.original.startLineNumber,
          m.lineRangeMapping.original.endLineNumberExclusive,
          m.lineRangeMapping.modified.startLineNumber,
          m.lineRangeMapping.modified.endLineNumberExclusive,
          getLineChanges(m.changes)
        ])
      };
    }
    static _modelsAreIdentical(original, modified) {
      const originalLineCount = original.getLineCount();
      const modifiedLineCount = modified.getLineCount();
      if (originalLineCount !== modifiedLineCount) {
        return false;
      }
      for (let line = 1; line <= originalLineCount; line++) {
        const originalLine = original.getLineContent(line);
        const modifiedLine = modified.getLineContent(line);
        if (originalLine !== modifiedLine) {
          return false;
        }
      }
      return true;
    }
    async computeMoreMinimalEdits(modelUrl, edits, pretty) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return edits;
      }
      const result = [];
      let lastEol = void 0;
      edits = edits.slice(0).sort((a, b) => {
        if (a.range && b.range) {
          return Range.compareRangesUsingStarts(a.range, b.range);
        }
        const aRng = a.range ? 0 : 1;
        const bRng = b.range ? 0 : 1;
        return aRng - bRng;
      });
      let writeIndex = 0;
      for (let readIndex = 1; readIndex < edits.length; readIndex++) {
        if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {
          edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));
          edits[writeIndex].text += edits[readIndex].text;
        } else {
          writeIndex++;
          edits[writeIndex] = edits[readIndex];
        }
      }
      edits.length = writeIndex + 1;
      for (let { range, text: text4, eol: eol2 } of edits) {
        if (typeof eol2 === "number") {
          lastEol = eol2;
        }
        if (Range.isEmpty(range) && !text4) {
          continue;
        }
        const original = model.getValueInRange(range);
        text4 = text4.replace(/\r\n|\n|\r/g, model.eol);
        if (original === text4) {
          continue;
        }
        if (Math.max(text4.length, original.length) > EditorSimpleWorker._diffLimit) {
          result.push({ range, text: text4 });
          continue;
        }
        const changes = stringDiff(original, text4, pretty);
        const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
        for (const change of changes) {
          const start2 = model.positionAt(editOffset + change.originalStart);
          const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
          const newEdit = {
            text: text4.substr(change.modifiedStart, change.modifiedLength),
            range: { startLineNumber: start2.lineNumber, startColumn: start2.column, endLineNumber: end.lineNumber, endColumn: end.column }
          };
          if (model.getValueInRange(newEdit.range) !== newEdit.text) {
            result.push(newEdit);
          }
        }
      }
      if (typeof lastEol === "number") {
        result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
      }
      return result;
    }
    // ---- END minimal edits ---------------------------------------------------------------
    async computeLinks(modelUrl) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      return computeLinks(model);
    }
    // --- BEGIN default document colors -----------------------------------------------------------
    async computeDefaultDocumentColors(modelUrl) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      return computeDefaultDocumentColors(model);
    }
    async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
      const sw = new StopWatch();
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const seen = /* @__PURE__ */ new Set();
      outer:
        for (const url of modelUrls) {
          const model = this._getModel(url);
          if (!model) {
            continue;
          }
          for (const word of model.words(wordDefRegExp)) {
            if (word === leadingWord || !isNaN(Number(word))) {
              continue;
            }
            seen.add(word);
            if (seen.size > EditorSimpleWorker._suggestionsLimit) {
              break outer;
            }
          }
        }
      return { words: Array.from(seen), duration: sw.elapsed() };
    }
    // ---- END suggest --------------------------------------------------------------------------
    //#region -- word ranges --
    async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return /* @__PURE__ */ Object.create(null);
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const result = /* @__PURE__ */ Object.create(null);
      for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
        const words = model.getLineWords(line, wordDefRegExp);
        for (const word of words) {
          if (!isNaN(Number(word.word))) {
            continue;
          }
          let array = result[word.word];
          if (!array) {
            array = [];
            result[word.word] = array;
          }
          array.push({
            startLineNumber: line,
            startColumn: word.startColumn,
            endLineNumber: line,
            endColumn: word.endColumn
          });
        }
      }
      return result;
    }
    //#endregion
    async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      if (range.startColumn === range.endColumn) {
        range = {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn + 1
        };
      }
      const selectionText = model.getValueInRange(range);
      const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
      if (!wordRange) {
        return null;
      }
      const word = model.getValueInRange(wordRange);
      const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
      return result;
    }
    // ---- BEGIN foreign module support --------------------------------------------------------------------------
    loadForeignModule(moduleId, createData, foreignHostMethods) {
      const proxyMethodRequest = (method, args) => {
        return this._host.fhr(method, args);
      };
      const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
      const ctx = {
        host: foreignHost,
        getMirrorModels: () => {
          return this._getModels();
        }
      };
      if (this._foreignModuleFactory) {
        this._foreignModule = this._foreignModuleFactory(ctx, createData);
        return Promise.resolve(getAllMethodNames(this._foreignModule));
      }
      return Promise.reject(new Error(`Unexpected usage`));
    }
    // foreign method request
    fmr(method, args) {
      if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
        return Promise.reject(new Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
  EditorSimpleWorker._diffLimit = 1e5;
  EditorSimpleWorker._suggestionsLimit = 1e4;
  if (typeof importScripts === "function") {
    globalThis.monaco = createMonacoBaseAPI();
  }

  // node_modules/monaco-editor-core/esm/vs/editor/editor.worker.js
  var initialized = false;
  function initialize(foreignModule) {
    if (initialized) {
      return;
    }
    initialized = true;
    const simpleWorker = new SimpleWorkerServer((msg) => {
      globalThis.postMessage(msg);
    }, (host) => new EditorSimpleWorker(host, foreignModule));
    globalThis.onmessage = (e) => {
      simpleWorker.onmessage(e.data);
    };
  }
  globalThis.onmessage = (e) => {
    if (!initialized) {
      initialize(null);
    }
  };

  // node_modules/@volar/monaco/worker.js
  var worker_exports = {};
  __export(worker_exports, {
    WorkerLanguageService: () => WorkerLanguageService,
    createSimpleWorkerLanguageService: () => createSimpleWorkerLanguageService,
    createSimpleWorkerService: () => createSimpleWorkerService,
    createTypeScriptWorkerLanguageService: () => createTypeScriptWorkerLanguageService,
    createTypeScriptWorkerService: () => createTypeScriptWorkerService
  });
  var import_language_service = __toESM(require_language_service(), 1);
  var import_typescript = __toESM(require_typescript(), 1);

  // node_modules/vscode-uri/lib/esm/index.mjs
  var LIB;
  (() => {
    "use strict";
    var t = { 470: (t2) => {
      function e2(t3) {
        if ("string" != typeof t3)
          throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
      }
      function r2(t3, e3) {
        for (var r3, n3 = "", i = 0, o = -1, s = 0, h = 0; h <= t3.length; ++h) {
          if (h < t3.length)
            r3 = t3.charCodeAt(h);
          else {
            if (47 === r3)
              break;
            r3 = 47;
          }
          if (47 === r3) {
            if (o === h - 1 || 1 === s)
              ;
            else if (o !== h - 1 && 2 === s) {
              if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                if (n3.length > 2) {
                  var a = n3.lastIndexOf("/");
                  if (a !== n3.length - 1) {
                    -1 === a ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, a)).length - 1 - n3.lastIndexOf("/"), o = h, s = 0;
                    continue;
                  }
                } else if (2 === n3.length || 1 === n3.length) {
                  n3 = "", i = 0, o = h, s = 0;
                  continue;
                }
              }
              e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
            } else
              n3.length > 0 ? n3 += "/" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;
            o = h, s = 0;
          } else
            46 === r3 && -1 !== s ? ++s : s = -1;
        }
        return n3;
      }
      var n2 = { resolve: function() {
        for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
          var s;
          o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
        }
        return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
      }, normalize: function(t3) {
        if (e2(t3), 0 === t3.length)
          return ".";
        var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
        return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
      }, isAbsolute: function(t3) {
        return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
      }, join: function() {
        if (0 === arguments.length)
          return ".";
        for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
          var i = arguments[r3];
          e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
        }
        return void 0 === t3 ? "." : n2.normalize(t3);
      }, relative: function(t3, r3) {
        if (e2(t3), e2(r3), t3 === r3)
          return "";
        if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
          return "";
        for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i)
          ;
        for (var o = t3.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h)
          ;
        for (var a = r3.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u) {
          if (u === c) {
            if (a > c) {
              if (47 === r3.charCodeAt(h + u))
                return r3.slice(h + u + 1);
              if (0 === u)
                return r3.slice(h + u);
            } else
              s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
            break;
          }
          var l = t3.charCodeAt(i + u);
          if (l !== r3.charCodeAt(h + u))
            break;
          47 === l && (f = u);
        }
        var g = "";
        for (u = i + f + 1; u <= o; ++u)
          u !== o && 47 !== t3.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
        return g.length > 0 ? g + r3.slice(h + f) : (h += f, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));
      }, _makeLong: function(t3) {
        return t3;
      }, dirname: function(t3) {
        if (e2(t3), 0 === t3.length)
          return ".";
        for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s)
          if (47 === (r3 = t3.charCodeAt(s))) {
            if (!o) {
              i = s;
              break;
            }
          } else
            o = false;
        return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
      }, basename: function(t3, r3) {
        if (void 0 !== r3 && "string" != typeof r3)
          throw new TypeError('"ext" argument must be a string');
        e2(t3);
        var n3, i = 0, o = -1, s = true;
        if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
          if (r3.length === t3.length && r3 === t3)
            return "";
          var h = r3.length - 1, a = -1;
          for (n3 = t3.length - 1; n3 >= 0; --n3) {
            var c = t3.charCodeAt(n3);
            if (47 === c) {
              if (!s) {
                i = n3 + 1;
                break;
              }
            } else
              -1 === a && (s = false, a = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a));
          }
          return i === o ? o = a : -1 === o && (o = t3.length), t3.slice(i, o);
        }
        for (n3 = t3.length - 1; n3 >= 0; --n3)
          if (47 === t3.charCodeAt(n3)) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else
            -1 === o && (s = false, o = n3 + 1);
        return -1 === o ? "" : t3.slice(i, o);
      }, extname: function(t3) {
        e2(t3);
        for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1; h >= 0; --h) {
          var a = t3.charCodeAt(h);
          if (47 !== a)
            -1 === i && (o = false, i = h + 1), 46 === a ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
          else if (!o) {
            n3 = h + 1;
            break;
          }
        }
        return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
      }, format: function(t3) {
        if (null === t3 || "object" != typeof t3)
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
        return function(t4, e3) {
          var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
          return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
        }(0, t3);
      }, parse: function(t3) {
        e2(t3);
        var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
        if (0 === t3.length)
          return r3;
        var n3, i = t3.charCodeAt(0), o = 47 === i;
        o ? (r3.root = "/", n3 = 1) : n3 = 0;
        for (var s = -1, h = 0, a = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
          if (47 !== (i = t3.charCodeAt(f)))
            -1 === a && (c = false, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
          else if (!c) {
            h = f + 1;
            break;
          }
        return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r3.base = r3.name = 0 === h && o ? t3.slice(1, a) : t3.slice(h, a)) : (0 === h && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a)), r3.ext = t3.slice(s, a)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = "/"), r3;
      }, sep: "/", delimiter: ":", win32: null, posix: null };
      n2.posix = n2, t2.exports = n2;
    } }, e = {};
    function r(n2) {
      var i = e[n2];
      if (void 0 !== i)
        return i.exports;
      var o = e[n2] = { exports: {} };
      return t[n2](o, o.exports, r), o.exports;
    }
    r.d = (t2, e2) => {
      for (var n2 in e2)
        r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
    }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    };
    var n = {};
    (() => {
      let t2;
      if (r.r(n), r.d(n, { URI: () => f, Utils: () => P }), "object" == typeof process)
        t2 = "win32" === process.platform;
      else if ("object" == typeof navigator) {
        let e3 = navigator.userAgent;
        t2 = e3.indexOf("Windows") >= 0;
      }
      const e2 = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
      function s(t3, r2) {
        if (!t3.scheme && r2)
          throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
        if (t3.scheme && !e2.test(t3.scheme))
          throw new Error("[UriError]: Scheme contains illegal characters.");
        if (t3.path) {
          if (t3.authority) {
            if (!i.test(t3.path))
              throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
          } else if (o.test(t3.path))
            throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
      const h = "", a = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
      class f {
        static isUri(t3) {
          return t3 instanceof f || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
        }
        scheme;
        authority;
        path;
        query;
        fragment;
        constructor(t3, e3, r2, n2, i2, o2 = false) {
          "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = function(t4, e4) {
            return t4 || e4 ? t4 : "file";
          }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {
            switch (t4) {
              case "https":
              case "http":
              case "file":
                e4 ? e4[0] !== a && (e4 = a + e4) : e4 = a;
            }
            return e4;
          }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));
        }
        get fsPath() {
          return m(this, false);
        }
        with(t3) {
          if (!t3)
            return this;
          let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;
          return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);
        }
        static parse(t3, e3 = false) {
          const r2 = c.exec(t3);
          return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);
        }
        static file(e3) {
          let r2 = h;
          if (t2 && (e3 = e3.replace(/\\/g, a)), e3[0] === a && e3[1] === a) {
            const t3 = e3.indexOf(a, 2);
            -1 === t3 ? (r2 = e3.substring(2), e3 = a) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a);
          }
          return new l("file", r2, e3, h, h);
        }
        static from(t3) {
          const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
          return s(e3, true), e3;
        }
        toString(t3 = false) {
          return y(this, t3);
        }
        toJSON() {
          return this;
        }
        static revive(t3) {
          if (t3) {
            if (t3 instanceof f)
              return t3;
            {
              const e3 = new l(t3);
              return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;
            }
          }
          return t3;
        }
      }
      const u = t2 ? 1 : void 0;
      class l extends f {
        _formatted = null;
        _fsPath = null;
        get fsPath() {
          return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;
        }
        toString(t3 = false) {
          return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
        }
        toJSON() {
          const t3 = { $mid: 1 };
          return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
        }
      }
      const g = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
      function d(t3, e3, r2) {
        let n2, i2 = -1;
        for (let o2 = 0; o2 < t3.length; o2++) {
          const s2 = t3.charCodeAt(o2);
          if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2)
            -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t3.charAt(o2));
          else {
            void 0 === n2 && (n2 = t3.substr(0, o2));
            const e4 = g[s2];
            void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);
          }
        }
        return -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2))), void 0 !== n2 ? n2 : t3;
      }
      function p(t3) {
        let e3;
        for (let r2 = 0; r2 < t3.length; r2++) {
          const n2 = t3.charCodeAt(r2);
          35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t3[r2]);
        }
        return void 0 !== e3 ? e3 : t3;
      }
      function m(e3, r2) {
        let n2;
        return n2 = e3.authority && e3.path.length > 1 && "file" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\//g, "\\")), n2;
      }
      function y(t3, e3) {
        const r2 = e3 ? p : d;
        let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;
        if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += a, n2 += a), o2) {
          let t4 = o2.indexOf("@");
          if (-1 !== t4) {
            const e4 = o2.substr(0, t4);
            o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += ":", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += "@";
          }
          o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));
        }
        if (s2) {
          if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
            const t4 = s2.charCodeAt(1);
            t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
          } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
            const t4 = s2.charCodeAt(0);
            t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
          }
          n2 += r2(s2, true, false);
        }
        return h2 && (n2 += "?", n2 += r2(h2, false, false)), c2 && (n2 += "#", n2 += e3 ? c2 : d(c2, false, false)), n2;
      }
      function v(t3) {
        try {
          return decodeURIComponent(t3);
        } catch {
          return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;
        }
      }
      const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
      function C(t3) {
        return t3.match(b) ? t3.replace(b, (t4) => v(t4)) : t3;
      }
      var A = r(470);
      const w = A.posix || A, x = "/";
      var P;
      !function(t3) {
        t3.joinPath = function(t4, ...e3) {
          return t4.with({ path: w.join(t4.path, ...e3) });
        }, t3.resolvePath = function(t4, ...e3) {
          let r2 = t4.path, n2 = false;
          r2[0] !== x && (r2 = x + r2, n2 = true);
          let i2 = w.resolve(r2, ...e3);
          return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
        }, t3.dirname = function(t4) {
          if (0 === t4.path.length || t4.path === x)
            return t4;
          let e3 = w.dirname(t4.path);
          return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
        }, t3.basename = function(t4) {
          return w.basename(t4.path);
        }, t3.extname = function(t4) {
          return w.extname(t4.path);
        };
      }(P || (P = {}));
    })(), LIB = n;
  })();
  var { URI: URI2, Utils } = LIB;

  // node_modules/@volar/monaco/worker.js
  __reExport(worker_exports, __toESM(require_language_service(), 1));
  var fsFileSnapshots = (0, import_language_service.createUriMap)();
  var createSimpleWorkerService = createSimpleWorkerLanguageService;
  var createTypeScriptWorkerService = createTypeScriptWorkerLanguageService;
  function createSimpleWorkerLanguageService({ env: env2, workerContext, languagePlugins, languageServicePlugins, setup }) {
    const snapshots = /* @__PURE__ */ new Map();
    const language = (0, import_language_service.createLanguage)(languagePlugins, (0, import_language_service.createUriMap)(false), (uri) => {
      const model = workerContext.getMirrorModels().find((model2) => model2.uri.toString() === uri.toString());
      if (model) {
        const cache = snapshots.get(model);
        if (cache && cache[0] === model.version) {
          return;
        }
        const text4 = model.getValue();
        const snapshot = {
          getText: (start2, end) => text4.substring(start2, end),
          getLength: () => text4.length,
          getChangeRange: () => void 0
        };
        snapshots.set(model, [model.version, snapshot]);
        language.scripts.set(uri, snapshot);
      } else {
        language.scripts.delete(uri);
      }
    });
    const project = {};
    setup?.({ language, project });
    return new WorkerLanguageService((0, import_language_service.createLanguageService)(language, languageServicePlugins, env2, project));
  }
  function createTypeScriptWorkerLanguageService({ typescript: ts2, compilerOptions, env: env2, uriConverter, workerContext, languagePlugins, languageServicePlugins, setup }) {
    let projectVersion = 0;
    const modelSnapshot = /* @__PURE__ */ new WeakMap();
    const modelVersions = /* @__PURE__ */ new Map();
    const sys = (0, import_typescript.createSys)(ts2.sys, env2, () => {
      if (env2.workspaceFolders.length) {
        return uriConverter.asFileName(env2.workspaceFolders[0]);
      }
      return "";
    }, uriConverter);
    const language = (0, import_language_service.createLanguage)([
      ...languagePlugins,
      { getLanguageId: (uri) => (0, import_typescript.resolveFileLanguageId)(uri.path) }
    ], (0, import_language_service.createUriMap)(sys.useCaseSensitiveFileNames), (uri) => {
      let snapshot = getModelSnapshot(uri);
      if (!snapshot) {
        const cache = fsFileSnapshots.get(uri);
        const fileName = uriConverter.asFileName(uri);
        const modifiedTime = sys.getModifiedTime?.(fileName)?.valueOf();
        if (!cache || cache[0] !== modifiedTime) {
          if (sys.fileExists(fileName)) {
            const text4 = sys.readFile(fileName);
            const snapshot2 = text4 !== void 0 ? ts2.ScriptSnapshot.fromString(text4) : void 0;
            fsFileSnapshots.set(uri, [modifiedTime, snapshot2]);
          } else {
            fsFileSnapshots.set(uri, [modifiedTime, void 0]);
          }
        }
        snapshot = fsFileSnapshots.get(uri)?.[1];
      }
      if (snapshot) {
        language.scripts.set(uri, snapshot);
      } else {
        language.scripts.delete(uri);
      }
    });
    const project = {
      typescript: {
        configFileName: void 0,
        sys,
        uriConverter,
        ...(0, import_typescript.createLanguageServiceHost)(ts2, sys, language, (s) => uriConverter.asUri(s), {
          getCurrentDirectory() {
            return sys.getCurrentDirectory();
          },
          getScriptFileNames() {
            return workerContext.getMirrorModels().map((model) => uriConverter.asFileName(URI2.from(model.uri)));
          },
          getProjectVersion() {
            const models = workerContext.getMirrorModels();
            if (modelVersions.size === workerContext.getMirrorModels().length) {
              if (models.every((model) => modelVersions.get(model) === model.version)) {
                return projectVersion.toString();
              }
            }
            modelVersions.clear();
            for (const model of workerContext.getMirrorModels()) {
              modelVersions.set(model, model.version);
            }
            projectVersion++;
            return projectVersion.toString();
          },
          getScriptSnapshot(fileName) {
            const uri = uriConverter.asUri(fileName);
            return getModelSnapshot(uri);
          },
          getCompilationSettings() {
            return compilerOptions;
          }
        })
      }
    };
    setup?.({ language, project });
    return new WorkerLanguageService((0, import_language_service.createLanguageService)(language, languageServicePlugins, env2, project));
    function getModelSnapshot(uri) {
      const model = workerContext.getMirrorModels().find((model2) => model2.uri.toString() === uri.toString());
      if (model) {
        const cache = modelSnapshot.get(model);
        if (cache && cache[0] === model.version) {
          return cache[1];
        }
        const text4 = model.getValue();
        modelSnapshot.set(model, [model.version, {
          getText: (start2, end) => text4.substring(start2, end),
          getLength: () => text4.length,
          getChangeRange: () => void 0
        }]);
        return modelSnapshot.get(model)?.[1];
      }
    }
  }
  var WorkerLanguageService = class {
    constructor(languageService) {
      this.languageService = languageService;
      this.pendingRequests = /* @__PURE__ */ new Map();
    }
    getSemanticTokenLegend() {
      return this.languageService.semanticTokenLegend;
    }
    getCommands() {
      return this.languageService.commands;
    }
    getTriggerCharacters() {
      return this.languageService.triggerCharacters;
    }
    getAutoFormatTriggerCharacters() {
      return this.languageService.autoFormatTriggerCharacters;
    }
    getSignatureHelpTriggerCharacters() {
      return this.languageService.signatureHelpTriggerCharacters;
    }
    getSignatureHelpRetriggerCharacters() {
      return this.languageService.signatureHelpRetriggerCharacters;
    }
    executeCommand(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.executeCommand(...args, token));
    }
    getDocumentFormattingEdits(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getDocumentFormattingEdits(URI2.from(uri), ...restArgs, token));
    }
    getFoldingRanges(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getFoldingRanges(URI2.from(uri), ...restArgs, token));
    }
    getSelectionRanges(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getSelectionRanges(URI2.from(uri), ...restArgs, token));
    }
    getLinkedEditingRanges(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getLinkedEditingRanges(URI2.from(uri), ...restArgs, token));
    }
    getDocumentSymbols(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getDocumentSymbols(URI2.from(uri), ...restArgs, token));
    }
    getDocumentColors(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getDocumentColors(URI2.from(uri), ...restArgs, token));
    }
    getColorPresentations(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getColorPresentations(URI2.from(uri), ...restArgs, token));
    }
    getDiagnostics(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getDiagnostics(URI2.from(uri), ...restArgs, token));
    }
    getWorkspaceDiagnostics(requestId) {
      return this.withToken(requestId, (token) => this.languageService.getWorkspaceDiagnostics(token));
    }
    getReferences(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getReferences(URI2.from(uri), ...restArgs, token));
    }
    getFileReferences(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getFileReferences(URI2.from(uri), ...restArgs, token));
    }
    getDefinition(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getDefinition(URI2.from(uri), ...restArgs, token));
    }
    getTypeDefinition(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getTypeDefinition(URI2.from(uri), ...restArgs, token));
    }
    getImplementations(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getImplementations(URI2.from(uri), ...restArgs, token));
    }
    getRenameRange(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getRenameRange(URI2.from(uri), ...restArgs, token));
    }
    getRenameEdits(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getRenameEdits(URI2.from(uri), ...restArgs, token));
    }
    getFileRenameEdits(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getFileRenameEdits(URI2.from(uri), ...restArgs, token));
    }
    getSemanticTokens(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getSemanticTokens(URI2.from(uri), ...restArgs, token));
    }
    getHover(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getHover(URI2.from(uri), ...restArgs, token));
    }
    getCompletionItems(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getCompletionItems(URI2.from(uri), ...restArgs, token));
    }
    getCodeActions(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getCodeActions(URI2.from(uri), ...restArgs, token));
    }
    getSignatureHelp(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getSignatureHelp(URI2.from(uri), ...restArgs, token));
    }
    getCodeLenses(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getCodeLenses(URI2.from(uri), ...restArgs, token));
    }
    getDocumentHighlights(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getDocumentHighlights(URI2.from(uri), ...restArgs, token));
    }
    getDocumentLinks(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getDocumentLinks(URI2.from(uri), ...restArgs, token));
    }
    getWorkspaceSymbols(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.getWorkspaceSymbols(...args, token));
    }
    getAutoInsertSnippet(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getAutoInsertSnippet(URI2.from(uri), ...restArgs, token));
    }
    getDocumentDropEdits(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getDocumentDropEdits(URI2.from(uri), ...restArgs, token));
    }
    getInlayHints(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getInlayHints(URI2.from(uri), ...restArgs, token));
    }
    resolveCodeAction(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.resolveCodeAction(...args, token));
    }
    resolveCompletionItem(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.resolveCompletionItem(...args, token));
    }
    resolveCodeLens(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.resolveCodeLens(...args, token));
    }
    resolveDocumentLink(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.resolveDocumentLink(...args, token));
    }
    resolveInlayHint(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.resolveInlayHint(...args, token));
    }
    resolveWorkspaceSymbol(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.resolveWorkspaceSymbol(...args, token));
    }
    getCallHierarchyItems(requestId, uri, ...restArgs) {
      return this.withToken(requestId, (token) => this.languageService.getCallHierarchyItems(URI2.from(uri), ...restArgs, token));
    }
    getCallHierarchyIncomingCalls(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.getCallHierarchyIncomingCalls(...args, token));
    }
    getCallHierarchyOutgoingCalls(requestId, ...args) {
      return this.withToken(requestId, (token) => this.languageService.getCallHierarchyOutgoingCalls(...args, token));
    }
    dispose() {
      this.languageService.dispose();
    }
    cancelRequest(requestId) {
      this.pendingRequests.delete(requestId);
    }
    async withToken(requestId, fn) {
      const { pendingRequests } = this;
      const token = {
        get isCancellationRequested() {
          return !!pendingRequests.has(requestId);
        },
        onCancellationRequested(cb) {
          let callbacks = pendingRequests.get(requestId);
          if (!callbacks) {
            callbacks = /* @__PURE__ */ new Set();
            pendingRequests.set(requestId, callbacks);
          }
          callbacks.add(cb);
          return {
            dispose() {
              callbacks.delete(cb);
            }
          };
        }
      };
      this.pendingRequests.set(requestId, void 0);
      try {
        return await fn(token);
      } finally {
        this.pendingRequests.delete(requestId);
      }
    }
  };

  // src/worker/mdx.worker.js
  var import_volar_service_typescript = __toESM(require_volar_service_typescript(), 1);
  var import_jsdelivr = __toESM(require_jsdelivr(), 1);

  // node_modules/devlop/lib/default.js
  function ok() {
  }

  // node_modules/mdast-util-mdx/node_modules/mdast-util-mdx-expression/lib/index.js
  function mdxExpressionFromMarkdown() {
    return {
      enter: {
        mdxFlowExpression: enterMdxFlowExpression,
        mdxTextExpression: enterMdxTextExpression
      },
      exit: {
        mdxFlowExpression: exitMdxExpression,
        mdxFlowExpressionChunk: exitMdxExpressionData,
        mdxTextExpression: exitMdxExpression,
        mdxTextExpressionChunk: exitMdxExpressionData
      }
    };
  }
  function mdxExpressionToMarkdown() {
    return {
      handlers: {
        mdxFlowExpression: handleMdxExpression,
        mdxTextExpression: handleMdxExpression
      },
      unsafe: [
        { character: "{", inConstruct: ["phrasing"] },
        { atBreak: true, character: "{" }
      ]
    };
  }
  function enterMdxFlowExpression(token) {
    this.enter({ type: "mdxFlowExpression", value: "" }, token);
    this.buffer();
  }
  function enterMdxTextExpression(token) {
    this.enter({ type: "mdxTextExpression", value: "" }, token);
    this.buffer();
  }
  function exitMdxExpression(token) {
    const value = this.resume();
    const estree = token.estree;
    const node3 = this.stack[this.stack.length - 1];
    ok(node3.type === "mdxFlowExpression" || node3.type === "mdxTextExpression");
    this.exit(token);
    node3.value = value;
    if (estree) {
      node3.data = { estree };
    }
  }
  function exitMdxExpressionData(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
  function handleMdxExpression(node3) {
    const value = node3.value || "";
    return "{" + value + "}";
  }

  // node_modules/ccount/index.js
  function ccount(value, character) {
    const source = String(value);
    if (typeof character !== "string") {
      throw new TypeError("Expected character");
    }
    let count = 0;
    let index4 = source.indexOf(character);
    while (index4 !== -1) {
      count++;
      index4 = source.indexOf(character, index4 + character.length);
    }
    return count;
  }

  // node_modules/character-entities-legacy/index.js
  var characterEntitiesLegacy = [
    "AElig",
    "AMP",
    "Aacute",
    "Acirc",
    "Agrave",
    "Aring",
    "Atilde",
    "Auml",
    "COPY",
    "Ccedil",
    "ETH",
    "Eacute",
    "Ecirc",
    "Egrave",
    "Euml",
    "GT",
    "Iacute",
    "Icirc",
    "Igrave",
    "Iuml",
    "LT",
    "Ntilde",
    "Oacute",
    "Ocirc",
    "Ograve",
    "Oslash",
    "Otilde",
    "Ouml",
    "QUOT",
    "REG",
    "THORN",
    "Uacute",
    "Ucirc",
    "Ugrave",
    "Uuml",
    "Yacute",
    "aacute",
    "acirc",
    "acute",
    "aelig",
    "agrave",
    "amp",
    "aring",
    "atilde",
    "auml",
    "brvbar",
    "ccedil",
    "cedil",
    "cent",
    "copy",
    "curren",
    "deg",
    "divide",
    "eacute",
    "ecirc",
    "egrave",
    "eth",
    "euml",
    "frac12",
    "frac14",
    "frac34",
    "gt",
    "iacute",
    "icirc",
    "iexcl",
    "igrave",
    "iquest",
    "iuml",
    "laquo",
    "lt",
    "macr",
    "micro",
    "middot",
    "nbsp",
    "not",
    "ntilde",
    "oacute",
    "ocirc",
    "ograve",
    "ordf",
    "ordm",
    "oslash",
    "otilde",
    "ouml",
    "para",
    "plusmn",
    "pound",
    "quot",
    "raquo",
    "reg",
    "sect",
    "shy",
    "sup1",
    "sup2",
    "sup3",
    "szlig",
    "thorn",
    "times",
    "uacute",
    "ucirc",
    "ugrave",
    "uml",
    "uuml",
    "yacute",
    "yen",
    "yuml"
  ];

  // node_modules/character-reference-invalid/index.js
  var characterReferenceInvalid = {
    0: "\uFFFD",
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02C6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017D",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017E",
    159: "\u0178"
  };

  // node_modules/is-decimal/index.js
  function isDecimal(character) {
    const code2 = typeof character === "string" ? character.charCodeAt(0) : character;
    return code2 >= 48 && code2 <= 57;
  }

  // node_modules/is-hexadecimal/index.js
  function isHexadecimal(character) {
    const code2 = typeof character === "string" ? character.charCodeAt(0) : character;
    return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
  }

  // node_modules/is-alphabetical/index.js
  function isAlphabetical(character) {
    const code2 = typeof character === "string" ? character.charCodeAt(0) : character;
    return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
  }

  // node_modules/is-alphanumerical/index.js
  function isAlphanumerical(character) {
    return isAlphabetical(character) || isDecimal(character);
  }

  // node_modules/decode-named-character-reference/index.dom.js
  var element = document.createElement("i");
  function decodeNamedCharacterReference(value) {
    const characterReference2 = "&" + value + ";";
    element.innerHTML = characterReference2;
    const char = element.textContent;
    if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
      return false;
    }
    return char === characterReference2 ? false : char;
  }

  // node_modules/parse-entities/lib/index.js
  var fromCharCode = String.fromCharCode;
  var messages = [
    "",
    /* 1: Non terminated (named) */
    "Named character references must be terminated by a semicolon",
    /* 2: Non terminated (numeric) */
    "Numeric character references must be terminated by a semicolon",
    /* 3: Empty (named) */
    "Named character references cannot be empty",
    /* 4: Empty (numeric) */
    "Numeric character references cannot be empty",
    /* 5: Unknown (named) */
    "Named character references must be known",
    /* 6: Disallowed (numeric) */
    "Numeric character references cannot be disallowed",
    /* 7: Prohibited (numeric) */
    "Numeric character references cannot be outside the permissible Unicode range"
  ];
  function parseEntities(value, options = {}) {
    const additional = typeof options.additional === "string" ? options.additional.charCodeAt(0) : options.additional;
    const result = [];
    let index4 = 0;
    let lines = -1;
    let queue = "";
    let point5;
    let indent2;
    if (options.position) {
      if ("start" in options.position || "indent" in options.position) {
        indent2 = options.position.indent;
        point5 = options.position.start;
      } else {
        point5 = options.position;
      }
    }
    let line = (point5 ? point5.line : 0) || 1;
    let column = (point5 ? point5.column : 0) || 1;
    let previous2 = now();
    let character;
    index4--;
    while (++index4 <= value.length) {
      if (character === 10) {
        column = (indent2 ? indent2[lines] : 0) || 1;
      }
      character = value.charCodeAt(index4);
      if (character === 38) {
        const following = value.charCodeAt(index4 + 1);
        if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
          queue += fromCharCode(character);
          column++;
          continue;
        }
        const start2 = index4 + 1;
        let begin = start2;
        let end = start2;
        let type;
        if (following === 35) {
          end = ++begin;
          const following2 = value.charCodeAt(end);
          if (following2 === 88 || following2 === 120) {
            type = "hexadecimal";
            end = ++begin;
          } else {
            type = "decimal";
          }
        } else {
          type = "named";
        }
        let characterReferenceCharacters = "";
        let characterReference2 = "";
        let characters = "";
        const test = type === "named" ? isAlphanumerical : type === "decimal" ? isDecimal : isHexadecimal;
        end--;
        while (++end <= value.length) {
          const following2 = value.charCodeAt(end);
          if (!test(following2)) {
            break;
          }
          characters += fromCharCode(following2);
          if (type === "named" && characterEntitiesLegacy.includes(characters)) {
            characterReferenceCharacters = characters;
            characterReference2 = decodeNamedCharacterReference(characters);
          }
        }
        let terminated = value.charCodeAt(end) === 59;
        if (terminated) {
          end++;
          const namedReference = type === "named" ? decodeNamedCharacterReference(characters) : false;
          if (namedReference) {
            characterReferenceCharacters = characters;
            characterReference2 = namedReference;
          }
        }
        let diff = 1 + end - start2;
        let reference = "";
        if (!terminated && options.nonTerminated === false) {
        } else if (!characters) {
          if (type !== "named") {
            warning(4, diff);
          }
        } else if (type === "named") {
          if (terminated && !characterReference2) {
            warning(5, 1);
          } else {
            if (characterReferenceCharacters !== characters) {
              end = begin + characterReferenceCharacters.length;
              diff = 1 + end - begin;
              terminated = false;
            }
            if (!terminated) {
              const reason = characterReferenceCharacters ? 1 : 3;
              if (options.attribute) {
                const following2 = value.charCodeAt(end);
                if (following2 === 61) {
                  warning(reason, diff);
                  characterReference2 = "";
                } else if (isAlphanumerical(following2)) {
                  characterReference2 = "";
                } else {
                  warning(reason, diff);
                }
              } else {
                warning(reason, diff);
              }
            }
          }
          reference = characterReference2;
        } else {
          if (!terminated) {
            warning(2, diff);
          }
          let referenceCode = Number.parseInt(
            characters,
            type === "hexadecimal" ? 16 : 10
          );
          if (prohibited(referenceCode)) {
            warning(7, diff);
            reference = fromCharCode(
              65533
              /* `�` */
            );
          } else if (referenceCode in characterReferenceInvalid) {
            warning(6, diff);
            reference = characterReferenceInvalid[referenceCode];
          } else {
            let output = "";
            if (disallowed(referenceCode)) {
              warning(6, diff);
            }
            if (referenceCode > 65535) {
              referenceCode -= 65536;
              output += fromCharCode(referenceCode >>> (10 & 1023) | 55296);
              referenceCode = 56320 | referenceCode & 1023;
            }
            reference = output + fromCharCode(referenceCode);
          }
        }
        if (reference) {
          flush();
          previous2 = now();
          index4 = end - 1;
          column += end - start2 + 1;
          result.push(reference);
          const next = now();
          next.offset++;
          if (options.reference) {
            options.reference.call(
              options.referenceContext,
              reference,
              { start: previous2, end: next },
              value.slice(start2 - 1, end)
            );
          }
          previous2 = next;
        } else {
          characters = value.slice(start2 - 1, end);
          queue += characters;
          column += characters.length;
          index4 = end - 1;
        }
      } else {
        if (character === 10) {
          line++;
          lines++;
          column = 0;
        }
        if (Number.isNaN(character)) {
          flush();
        } else {
          queue += fromCharCode(character);
          column++;
        }
      }
    }
    return result.join("");
    function now() {
      return {
        line,
        column,
        offset: index4 + ((point5 ? point5.offset : 0) || 0)
      };
    }
    function warning(code2, offset2) {
      let position4;
      if (options.warning) {
        position4 = now();
        position4.column += offset2;
        position4.offset += offset2;
        options.warning.call(
          options.warningContext,
          messages[code2],
          position4,
          code2
        );
      }
    }
    function flush() {
      if (queue) {
        result.push(queue);
        if (options.text) {
          options.text.call(options.textContext, queue, {
            start: previous2,
            end: now()
          });
        }
        queue = "";
      }
    }
  }
  function prohibited(code2) {
    return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
  }
  function disallowed(code2) {
    return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
  }

  // node_modules/stringify-entities/lib/core.js
  var defaultSubsetRegex = /["&'<>`]/g;
  var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var controlCharactersRegex = (
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
  );
  var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
  var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
  function core(value, options) {
    value = value.replace(
      options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex,
      basic
    );
    if (options.subset || options.escapeOnly) {
      return value;
    }
    return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic);
    function surrogate(pair, index4, all3) {
      return options.format(
        (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
        all3.charCodeAt(index4 + 2),
        options
      );
    }
    function basic(character, index4, all3) {
      return options.format(
        character.charCodeAt(0),
        all3.charCodeAt(index4 + 1),
        options
      );
    }
  }
  function charactersToExpressionCached(subset) {
    let cached = subsetToRegexCache.get(subset);
    if (!cached) {
      cached = charactersToExpression(subset);
      subsetToRegexCache.set(subset, cached);
    }
    return cached;
  }
  function charactersToExpression(subset) {
    const groups = [];
    let index4 = -1;
    while (++index4 < subset.length) {
      groups.push(subset[index4].replace(regexEscapeRegex, "\\$&"));
    }
    return new RegExp("(?:" + groups.join("|") + ")", "g");
  }

  // node_modules/stringify-entities/lib/util/format-basic.js
  function formatBasic(code2) {
    return "&#x" + code2.toString(16).toUpperCase() + ";";
  }

  // node_modules/stringify-entities/lib/index.js
  function stringifyEntitiesLight(value, options) {
    return core(value, Object.assign({ format: formatBasic }, options));
  }

  // node_modules/mdast-util-mdx-jsx/node_modules/unist-util-stringify-position/lib/index.js
  function stringifyPosition(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if ("position" in value || "type" in value) {
      return position(value.position);
    }
    if ("start" in value || "end" in value) {
      return position(value);
    }
    if ("line" in value || "column" in value) {
      return point(value);
    }
    return "";
  }
  function point(point5) {
    return index(point5 && point5.line) + ":" + index(point5 && point5.column);
  }
  function position(pos) {
    return point(pos && pos.start) + "-" + point(pos && pos.end);
  }
  function index(value) {
    return value && typeof value === "number" ? value : 1;
  }

  // node_modules/vfile-message/node_modules/unist-util-stringify-position/lib/index.js
  function stringifyPosition2(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if ("position" in value || "type" in value) {
      return position2(value.position);
    }
    if ("start" in value || "end" in value) {
      return position2(value);
    }
    if ("line" in value || "column" in value) {
      return point2(value);
    }
    return "";
  }
  function point2(point5) {
    return index2(point5 && point5.line) + ":" + index2(point5 && point5.column);
  }
  function position2(pos) {
    return point2(pos && pos.start) + "-" + point2(pos && pos.end);
  }
  function index2(value) {
    return value && typeof value === "number" ? value : 1;
  }

  // node_modules/vfile-message/lib/index.js
  var VFileMessage = class extends Error {
    /**
     * Create a message for `reason`.
     *
     * > 🪦 **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {Options | null | undefined} [options]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // eslint-disable-next-line complexity
    constructor(causeOrReason, optionsOrParentOrPlace, origin) {
      super();
      if (typeof optionsOrParentOrPlace === "string") {
        origin = optionsOrParentOrPlace;
        optionsOrParentOrPlace = void 0;
      }
      let reason = "";
      let options = {};
      let legacyCause = false;
      if (optionsOrParentOrPlace) {
        if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
          options = { place: optionsOrParentOrPlace };
        } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
          options = { place: optionsOrParentOrPlace };
        } else if ("type" in optionsOrParentOrPlace) {
          options = {
            ancestors: [optionsOrParentOrPlace],
            place: optionsOrParentOrPlace.position
          };
        } else {
          options = { ...optionsOrParentOrPlace };
        }
      }
      if (typeof causeOrReason === "string") {
        reason = causeOrReason;
      } else if (!options.cause && causeOrReason) {
        legacyCause = true;
        reason = causeOrReason.message;
        options.cause = causeOrReason;
      }
      if (!options.ruleId && !options.source && typeof origin === "string") {
        const index4 = origin.indexOf(":");
        if (index4 === -1) {
          options.ruleId = origin;
        } else {
          options.source = origin.slice(0, index4);
          options.ruleId = origin.slice(index4 + 1);
        }
      }
      if (!options.place && options.ancestors && options.ancestors) {
        const parent = options.ancestors[options.ancestors.length - 1];
        if (parent) {
          options.place = parent.position;
        }
      }
      const start2 = options.place && "start" in options.place ? options.place.start : options.place;
      this.ancestors = options.ancestors || void 0;
      this.cause = options.cause || void 0;
      this.column = start2 ? start2.column : void 0;
      this.fatal = void 0;
      this.file;
      this.message = reason;
      this.line = start2 ? start2.line : void 0;
      this.name = stringifyPosition2(options.place) || "1:1";
      this.place = options.place || void 0;
      this.reason = this.message;
      this.ruleId = options.ruleId || void 0;
      this.source = options.source || void 0;
      this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
      this.actual;
      this.expected;
      this.note;
      this.url;
    }
  };
  VFileMessage.prototype.file = "";
  VFileMessage.prototype.name = "";
  VFileMessage.prototype.reason = "";
  VFileMessage.prototype.message = "";
  VFileMessage.prototype.stack = "";
  VFileMessage.prototype.column = void 0;
  VFileMessage.prototype.line = void 0;
  VFileMessage.prototype.ancestors = void 0;
  VFileMessage.prototype.cause = void 0;
  VFileMessage.prototype.fatal = void 0;
  VFileMessage.prototype.place = void 0;
  VFileMessage.prototype.ruleId = void 0;
  VFileMessage.prototype.source = void 0;

  // node_modules/mdast-util-mdx-jsx/lib/index.js
  var indent = "  ";
  function mdxJsxFromMarkdown() {
    return {
      canContainEols: ["mdxJsxTextElement"],
      enter: {
        mdxJsxFlowTag: enterMdxJsxTag,
        mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,
        mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,
        mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
        mdxJsxFlowTagAttributeValueLiteral: buffer,
        mdxJsxFlowTagAttributeValueExpression: buffer,
        mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,
        mdxJsxTextTag: enterMdxJsxTag,
        mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,
        mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,
        mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
        mdxJsxTextTagAttributeValueLiteral: buffer,
        mdxJsxTextTagAttributeValueExpression: buffer,
        mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker
      },
      exit: {
        mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,
        mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,
        mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,
        mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,
        mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
        mdxJsxFlowTagExpressionAttributeValue: data2,
        mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
        mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
        mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
        mdxJsxFlowTagAttributeValueLiteralValue: data2,
        mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
        mdxJsxFlowTagAttributeValueExpressionValue: data2,
        mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
        mdxJsxFlowTag: exitMdxJsxTag,
        mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,
        mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,
        mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,
        mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,
        mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
        mdxJsxTextTagExpressionAttributeValue: data2,
        mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
        mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
        mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
        mdxJsxTextTagAttributeValueLiteralValue: data2,
        mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
        mdxJsxTextTagAttributeValueExpressionValue: data2,
        mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
        mdxJsxTextTag: exitMdxJsxTag
      }
    };
    function buffer() {
      this.buffer();
    }
    function point5(d) {
      return { line: d.line, column: d.column, offset: d.offset };
    }
    function data2(token) {
      this.config.enter.data.call(this, token);
      this.config.exit.data.call(this, token);
    }
    function enterMdxJsxTag(token) {
      const tag = {
        name: void 0,
        attributes: [],
        close: false,
        selfClosing: false,
        start: token.start,
        end: token.end
      };
      if (!this.data.mdxJsxTagStack)
        this.data.mdxJsxTagStack = [];
      this.data.mdxJsxTag = tag;
      this.buffer();
    }
    function enterMdxJsxTagClosingMarker(token) {
      const stack = this.data.mdxJsxTagStack;
      ok(stack, "expected `mdxJsxTagStack`");
      if (stack.length === 0) {
        throw new VFileMessage(
          "Unexpected closing slash `/` in tag, expected an open tag first",
          { start: token.start, end: token.end },
          "mdast-util-mdx-jsx:unexpected-closing-slash"
        );
      }
    }
    function enterMdxJsxTagAnyAttribute(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      if (tag.close) {
        throw new VFileMessage(
          "Unexpected attribute in closing tag, expected the end of the tag",
          { start: token.start, end: token.end },
          "mdast-util-mdx-jsx:unexpected-attribute"
        );
      }
    }
    function enterMdxJsxTagSelfClosingMarker(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      if (tag.close) {
        throw new VFileMessage(
          "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
          { start: token.start, end: token.end },
          "mdast-util-mdx-jsx:unexpected-self-closing-slash"
        );
      }
    }
    function exitMdxJsxTagClosingMarker() {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      tag.close = true;
    }
    function exitMdxJsxTagNamePrimary(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      tag.name = this.sliceSerialize(token);
    }
    function exitMdxJsxTagNameMember(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      tag.name += "." + this.sliceSerialize(token);
    }
    function exitMdxJsxTagNameLocal(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      tag.name += ":" + this.sliceSerialize(token);
    }
    function enterMdxJsxTagAttribute(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      enterMdxJsxTagAnyAttribute.call(this, token);
      tag.attributes.push({
        type: "mdxJsxAttribute",
        name: "",
        value: null,
        position: {
          start: point5(token.start),
          // @ts-expect-error: `end` will be patched later.
          end: void 0
        }
      });
    }
    function enterMdxJsxTagExpressionAttribute(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      enterMdxJsxTagAnyAttribute.call(this, token);
      tag.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" });
      this.buffer();
    }
    function exitMdxJsxTagExpressionAttribute(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      const tail = tag.attributes[tag.attributes.length - 1];
      ok(tail.type === "mdxJsxExpressionAttribute");
      const estree = token.estree;
      tail.value = this.resume();
      if (estree) {
        tail.data = { estree };
      }
    }
    function exitMdxJsxTagAttributeNamePrimary(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      const node3 = tag.attributes[tag.attributes.length - 1];
      ok(node3.type === "mdxJsxAttribute");
      node3.name = this.sliceSerialize(token);
      ok(node3.position !== void 0);
      node3.position.end = point5(token.end);
    }
    function exitMdxJsxTagAttributeNameLocal(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      const node3 = tag.attributes[tag.attributes.length - 1];
      ok(node3.type === "mdxJsxAttribute");
      node3.name += ":" + this.sliceSerialize(token);
      ok(node3.position !== void 0);
      node3.position.end = point5(token.end);
    }
    function exitMdxJsxTagAttributeValueLiteral(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      const node3 = tag.attributes[tag.attributes.length - 1];
      node3.value = parseEntities(this.resume(), { nonTerminated: false });
      ok(node3.position !== void 0);
      node3.position.end = point5(token.end);
    }
    function exitMdxJsxTagAttributeValueExpression(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      const tail = tag.attributes[tag.attributes.length - 1];
      ok(tail.type === "mdxJsxAttribute");
      const node3 = { type: "mdxJsxAttributeValueExpression", value: this.resume() };
      const estree = token.estree;
      if (estree) {
        node3.data = { estree };
      }
      tail.value = node3;
      ok(tail.position !== void 0);
      tail.position.end = point5(token.end);
    }
    function exitMdxJsxTagSelfClosingMarker() {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      tag.selfClosing = true;
    }
    function exitMdxJsxTag(token) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      const stack = this.data.mdxJsxTagStack;
      ok(stack, "expected `mdxJsxTagStack`");
      const tail = stack[stack.length - 1];
      if (tag.close && tail.name !== tag.name) {
        throw new VFileMessage(
          "Unexpected closing tag `" + serializeAbbreviatedTag(tag) + "`, expected corresponding closing tag for `" + serializeAbbreviatedTag(tail) + "` (" + stringifyPosition(tail) + ")",
          { start: token.start, end: token.end },
          "mdast-util-mdx-jsx:end-tag-mismatch"
        );
      }
      this.resume();
      if (tag.close) {
        stack.pop();
      } else {
        this.enter(
          {
            type: token.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
            name: tag.name || null,
            attributes: tag.attributes,
            children: []
          },
          token,
          onErrorRightIsTag
        );
      }
      if (tag.selfClosing || tag.close) {
        this.exit(token, onErrorLeftIsTag);
      } else {
        stack.push(tag);
      }
    }
    function onErrorRightIsTag(closing, open) {
      const stack = this.data.mdxJsxTagStack;
      ok(stack, "expected `mdxJsxTagStack`");
      const tag = stack[stack.length - 1];
      ok(tag, "expected `mdxJsxTag`");
      const place = closing ? " before the end of `" + closing.type + "`" : "";
      const position4 = closing ? { start: closing.start, end: closing.end } : void 0;
      throw new VFileMessage(
        "Expected a closing tag for `" + serializeAbbreviatedTag(tag) + "` (" + stringifyPosition({ start: open.start, end: open.end }) + ")" + place,
        position4,
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    }
    function onErrorLeftIsTag(a, b) {
      const tag = this.data.mdxJsxTag;
      ok(tag, "expected `mdxJsxTag`");
      throw new VFileMessage(
        "Expected the closing tag `" + serializeAbbreviatedTag(tag) + "` either after the end of `" + b.type + "` (" + stringifyPosition(b.end) + ") or another opening tag after the start of `" + b.type + "` (" + stringifyPosition(b.start) + ")",
        { start: a.start, end: a.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    }
    function serializeAbbreviatedTag(tag) {
      return "<" + (tag.close ? "/" : "") + (tag.name || "") + ">";
    }
  }
  function mdxJsxToMarkdown(options) {
    const options_ = options || {};
    const quote = options_.quote || '"';
    const quoteSmart = options_.quoteSmart || false;
    const tightSelfClosing = options_.tightSelfClosing || false;
    const printWidth = options_.printWidth || Number.POSITIVE_INFINITY;
    const alternative = quote === '"' ? "'" : '"';
    if (quote !== '"' && quote !== "'") {
      throw new Error(
        "Cannot serialize attribute values with `" + quote + "` for `options.quote`, expected `\"`, or `'`"
      );
    }
    mdxElement.peek = peekElement;
    return {
      handlers: {
        mdxJsxFlowElement: mdxElement,
        mdxJsxTextElement: mdxElement
      },
      unsafe: [
        { character: "<", inConstruct: ["phrasing"] },
        { atBreak: true, character: "<" }
      ],
      // Always generate fenced code (never indented code).
      fences: true,
      // Always generate links with resources (never autolinks).
      resourceLink: true
    };
    function mdxElement(node3, _, state, info) {
      const flow3 = node3.type === "mdxJsxFlowElement";
      const selfClosing = node3.name ? !node3.children || node3.children.length === 0 : false;
      const depth = inferDepth(state);
      const currentIndent = createIndent(depth);
      const trackerOneLine = state.createTracker(info);
      const trackerMultiLine = state.createTracker(info);
      const serializedAttributes = [];
      const prefix = (flow3 ? currentIndent : "") + "<" + (node3.name || "");
      const exit2 = state.enter(node3.type);
      trackerOneLine.move(prefix);
      trackerMultiLine.move(prefix);
      if (node3.attributes && node3.attributes.length > 0) {
        if (!node3.name) {
          throw new Error("Cannot serialize fragment w/ attributes");
        }
        let index4 = -1;
        while (++index4 < node3.attributes.length) {
          const attribute = node3.attributes[index4];
          let result;
          if (attribute.type === "mdxJsxExpressionAttribute") {
            result = "{" + (attribute.value || "") + "}";
          } else {
            if (!attribute.name) {
              throw new Error("Cannot serialize attribute w/o name");
            }
            const value2 = attribute.value;
            const left = attribute.name;
            let right = "";
            if (value2 === null || value2 === void 0) {
            } else if (typeof value2 === "object") {
              right = "{" + (value2.value || "") + "}";
            } else {
              const appliedQuote = quoteSmart && ccount(value2, quote) > ccount(value2, alternative) ? alternative : quote;
              right = appliedQuote + stringifyEntitiesLight(value2, { subset: [appliedQuote] }) + appliedQuote;
            }
            result = left + (right ? "=" : "") + right;
          }
          serializedAttributes.push(result);
        }
      }
      let attributesOnTheirOwnLine = false;
      const attributesOnOneLine = serializedAttributes.join(" ");
      if (
        // Block:
        flow3 && // Including a line ending (expressions).
        (/\r?\n|\r/.test(attributesOnOneLine) || // Current position (including `<tag`).
        trackerOneLine.current().now.column + // -1 because columns, +1 for ` ` before attributes.
        // Attributes joined by spaces.
        attributesOnOneLine.length + // ` />`.
        (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)
      ) {
        attributesOnTheirOwnLine = true;
      }
      let tracker = trackerOneLine;
      let value = prefix;
      if (attributesOnTheirOwnLine) {
        tracker = trackerMultiLine;
        let index4 = -1;
        while (++index4 < serializedAttributes.length) {
          serializedAttributes[index4] = currentIndent + indent + serializedAttributes[index4];
        }
        value += tracker.move(
          "\n" + serializedAttributes.join("\n") + "\n" + currentIndent
        );
      } else if (attributesOnOneLine) {
        value += tracker.move(" " + attributesOnOneLine);
      }
      if (selfClosing) {
        value += tracker.move(
          (tightSelfClosing || attributesOnTheirOwnLine ? "" : " ") + "/"
        );
      }
      value += tracker.move(">");
      if (node3.children && node3.children.length > 0) {
        if (node3.type === "mdxJsxTextElement") {
          value += tracker.move(
            // @ts-expect-error: `containerPhrasing` is typed correctly, but TS
            // generates *hardcoded* types, which means that our dynamically added
            // directives are not present.
            // At some point, TS should fix that, and `from-markdown` should be fine.
            state.containerPhrasing(node3, {
              ...tracker.current(),
              before: ">",
              after: "<"
            })
          );
        } else {
          tracker.shift(2);
          value += tracker.move("\n");
          value += tracker.move(containerFlow(node3, state, tracker.current()));
          value += tracker.move("\n");
        }
      }
      if (!selfClosing) {
        value += tracker.move(
          (flow3 ? currentIndent : "") + "</" + (node3.name || "") + ">"
        );
      }
      exit2();
      return value;
    }
  }
  function containerFlow(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children;
    const tracker = state.createTracker(info);
    const currentIndent = createIndent(inferDepth(state));
    const results = [];
    let index4 = -1;
    indexStack.push(-1);
    while (++index4 < children.length) {
      const child = children[index4];
      indexStack[indexStack.length - 1] = index4;
      const childInfo = { before: "\n", after: "\n", ...tracker.current() };
      const result = state.handle(child, parent, state, childInfo);
      const serializedChild = child.type === "mdxJsxFlowElement" ? result : state.indentLines(result, function(line, _, blank) {
        return (blank ? "" : currentIndent) + line;
      });
      results.push(tracker.move(serializedChild));
      if (child.type !== "list") {
        state.bulletLastUsed = void 0;
      }
      if (index4 < children.length - 1) {
        results.push(tracker.move("\n\n"));
      }
    }
    indexStack.pop();
    return results.join("");
  }
  function inferDepth(state) {
    let depth = 0;
    let index4 = state.stack.length;
    while (--index4 > -1) {
      const name2 = state.stack[index4];
      if (name2 === "blockquote" || name2 === "listItem")
        break;
      if (name2 === "mdxJsxFlowElement")
        depth++;
    }
    return depth;
  }
  function createIndent(depth) {
    return indent.repeat(depth);
  }
  function peekElement() {
    return "<";
  }

  // node_modules/mdast-util-mdxjs-esm/lib/index.js
  function mdxjsEsmFromMarkdown() {
    return {
      enter: { mdxjsEsm: enterMdxjsEsm },
      exit: { mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData }
    };
  }
  function mdxjsEsmToMarkdown() {
    return { handlers: { mdxjsEsm: handleMdxjsEsm } };
  }
  function enterMdxjsEsm(token) {
    this.enter({ type: "mdxjsEsm", value: "" }, token);
    this.buffer();
  }
  function exitMdxjsEsm(token) {
    const value = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3.type === "mdxjsEsm");
    this.exit(token);
    const estree = token.estree;
    node3.value = value;
    if (estree) {
      node3.data = { estree };
    }
  }
  function exitMdxjsEsmData(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
  function handleMdxjsEsm(node3) {
    return node3.value || "";
  }

  // node_modules/mdast-util-mdx/lib/index.js
  function mdxFromMarkdown() {
    return [
      mdxExpressionFromMarkdown(),
      mdxJsxFromMarkdown(),
      mdxjsEsmFromMarkdown()
    ];
  }
  function mdxToMarkdown(options) {
    return {
      extensions: [
        mdxExpressionToMarkdown(),
        mdxJsxToMarkdown(options),
        mdxjsEsmToMarkdown()
      ]
    };
  }

  // node_modules/acorn/dist/acorn.mjs
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };
  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
  var keywords$1 = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };
  var keywordRelationalOperator = /^in(stanceof)?$/;
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  function isInAstralSet(code2, set) {
    var pos = 65536;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code2) {
        return false;
      }
      pos += set[i + 1];
      if (pos >= code2) {
        return true;
      }
    }
    return false;
  }
  function isIdentifierStart(code2, astral) {
    if (code2 < 65) {
      return code2 === 36;
    }
    if (code2 < 91) {
      return true;
    }
    if (code2 < 97) {
      return code2 === 95;
    }
    if (code2 < 123) {
      return true;
    }
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
    }
    if (astral === false) {
      return false;
    }
    return isInAstralSet(code2, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code2, astral) {
    if (code2 < 48) {
      return code2 === 36;
    }
    if (code2 < 58) {
      return true;
    }
    if (code2 < 65) {
      return false;
    }
    if (code2 < 91) {
      return true;
    }
    if (code2 < 97) {
      return code2 === 95;
    }
    if (code2 < 123) {
      return true;
    }
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
    }
    if (astral === false) {
      return false;
    }
    return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
  }
  var TokenType = function TokenType2(label, conf) {
    if (conf === void 0)
      conf = {};
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };
  function binop(name2, prec) {
    return new TokenType(name2, { beforeExpr: true, binop: prec });
  }
  var beforeExpr = { beforeExpr: true };
  var startsExpr = { startsExpr: true };
  var keywords = {};
  function kw(name2, options) {
    if (options === void 0)
      options = {};
    options.keyword = name2;
    return keywords[name2] = new TokenType(name2, options);
  }
  var types$1 = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    privateId: new TokenType("privateId", startsExpr),
    eof: new TokenType("eof"),
    // Punctuation token types.
    bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.
    eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
    assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
    incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
    prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", { beforeExpr: true }),
    coalesce: binop("??", 1),
    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", { isLoop: true, beforeExpr: true }),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", { isLoop: true }),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", { isLoop: true }),
    _with: kw("with"),
    _new: kw("new", { beforeExpr: true, startsExpr: true }),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", { beforeExpr: true, binop: 7 }),
    _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
    _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
    _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
    _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
  };
  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code2) {
    return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
  }
  function nextLineBreak(code2, from, end) {
    if (end === void 0)
      end = code2.length;
    for (var i = from; i < end; i++) {
      var next = code2.charCodeAt(i);
      if (isNewLine(next)) {
        return i < end - 1 && next === 13 && code2.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
      }
    }
    return -1;
  }
  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;
  var hasOwn = Object.hasOwn || function(obj, propName) {
    return hasOwnProperty.call(obj, propName);
  };
  var isArray = Array.isArray || function(obj) {
    return toString.call(obj) === "[object Array]";
  };
  var regexpCache = /* @__PURE__ */ Object.create(null);
  function wordsRegexp(words) {
    return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
  }
  function codePointToString(code2) {
    if (code2 <= 65535) {
      return String.fromCharCode(code2);
    }
    code2 -= 65536;
    return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
  }
  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
  var Position2 = function Position3(line, col) {
    this.line = line;
    this.column = col;
  };
  Position2.prototype.offset = function offset(n) {
    return new Position2(this.line, this.column + n);
  };
  var SourceLocation = function SourceLocation2(p, start2, end) {
    this.start = start2;
    this.end = end;
    if (p.sourceFile !== null) {
      this.source = p.sourceFile;
    }
  };
  function getLineInfo(input, offset2) {
    for (var line = 1, cur = 0; ; ) {
      var nextBreak = nextLineBreak(input, cur, offset2);
      if (nextBreak < 0) {
        return new Position2(line, offset2 - cur);
      }
      ++line;
      cur = nextBreak;
    }
  }
  var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
    // (the latest version the library supports). This influences
    // support for strict mode, the set of reserved words, and support
    // for new syntax features.
    ecmaVersion: null,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called when
    // a semicolon is automatically inserted. It will be passed the
    // position of the inserted semicolon as an offset, and if
    // `locations` is enabled, it is given the location as a `{line,
    // column}` object as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program, and an import.meta expression
    // in a script isn't considered an error.
    allowImportExportEverywhere: false,
    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: null,
    // When enabled, super identifiers are not constrained to
    // appearing in methods and do not raise an error when they appear elsewhere.
    allowSuperOutsideMethod: null,
    // When enabled, hashbang directive in the beginning of file is
    // allowed and treated as a line comment. Enabled by default when
    // `ecmaVersion` >= 2023.
    allowHashBang: false,
    // By default, the parser will verify that private properties are
    // only used in places where they are valid and have been declared.
    // Set this to false to turn such checks off.
    checkPrivateFields: true,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callback—that will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    // When this option has an array as value, objects representing the
    // comments are pushed to it.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };
  var warnedAboutEcmaVersion = false;
  function getOptions(opts) {
    var options = {};
    for (var opt in defaultOptions) {
      options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
    }
    if (options.ecmaVersion === "latest") {
      options.ecmaVersion = 1e8;
    } else if (options.ecmaVersion == null) {
      if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
        warnedAboutEcmaVersion = true;
        console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
      }
      options.ecmaVersion = 11;
    } else if (options.ecmaVersion >= 2015) {
      options.ecmaVersion -= 2009;
    }
    if (options.allowReserved == null) {
      options.allowReserved = options.ecmaVersion < 5;
    }
    if (!opts || opts.allowHashBang == null) {
      options.allowHashBang = options.ecmaVersion >= 14;
    }
    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function(token) {
        return tokens.push(token);
      };
    }
    if (isArray(options.onComment)) {
      options.onComment = pushComment(options, options.onComment);
    }
    return options;
  }
  function pushComment(options, array) {
    return function(block, text4, start2, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text4,
        start: start2,
        end
      };
      if (options.locations) {
        comment.loc = new SourceLocation(this, startLoc, endLoc);
      }
      if (options.ranges) {
        comment.range = [start2, end];
      }
      array.push(comment);
    };
  }
  var SCOPE_TOP = 1;
  var SCOPE_FUNCTION = 2;
  var SCOPE_ASYNC = 4;
  var SCOPE_GENERATOR = 8;
  var SCOPE_ARROW = 16;
  var SCOPE_SIMPLE_CATCH = 32;
  var SCOPE_SUPER = 64;
  var SCOPE_DIRECT_SUPER = 128;
  var SCOPE_CLASS_STATIC_BLOCK = 256;
  var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
  }
  var BIND_NONE = 0;
  var BIND_VAR = 1;
  var BIND_LEXICAL = 2;
  var BIND_FUNCTION = 3;
  var BIND_SIMPLE_CATCH = 4;
  var BIND_OUTSIDE = 5;
  var Parser = function Parser2(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
      if (options.sourceType === "module") {
        reserved += " await";
      }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);
    this.containsEsc = false;
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }
    this.type = types$1.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    this.context = this.initialContext();
    this.exprAllowed = true;
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);
    this.potentialArrowAt = -1;
    this.potentialArrowInForAwait = false;
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = /* @__PURE__ */ Object.create(null);
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
      this.skipLineComment(2);
    }
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);
    this.regexpState = null;
    this.privateNameStack = [];
  };
  var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
  Parser.prototype.parse = function parse() {
    var node3 = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node3);
  };
  prototypeAccessors.inFunction.get = function() {
    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
  };
  prototypeAccessors.inGenerator.get = function() {
    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
  };
  prototypeAccessors.inAsync.get = function() {
    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
  };
  prototypeAccessors.canAwait.get = function() {
    for (var i = this.scopeStack.length - 1; i >= 0; i--) {
      var scope = this.scopeStack[i];
      if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
        return false;
      }
      if (scope.flags & SCOPE_FUNCTION) {
        return (scope.flags & SCOPE_ASYNC) > 0;
      }
    }
    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
  };
  prototypeAccessors.allowSuper.get = function() {
    var ref2 = this.currentThisScope();
    var flags = ref2.flags;
    var inClassFieldInit = ref2.inClassFieldInit;
    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
  };
  prototypeAccessors.allowDirectSuper.get = function() {
    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
  };
  prototypeAccessors.treatFunctionsAsVar.get = function() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  };
  prototypeAccessors.allowNewDotTarget.get = function() {
    var ref2 = this.currentThisScope();
    var flags = ref2.flags;
    var inClassFieldInit = ref2.inClassFieldInit;
    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
  };
  prototypeAccessors.inClassStaticBlock.get = function() {
    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
  };
  Parser.extend = function extend() {
    var plugins = [], len = arguments.length;
    while (len--)
      plugins[len] = arguments[len];
    var cls = this;
    for (var i = 0; i < plugins.length; i++) {
      cls = plugins[i](cls);
    }
    return cls;
  };
  Parser.parse = function parse2(input, options) {
    return new this(options, input).parse();
  };
  Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression();
  };
  Parser.tokenizer = function tokenizer(input, options) {
    return new this(options, input);
  };
  Object.defineProperties(Parser.prototype, prototypeAccessors);
  var pp$9 = Parser.prototype;
  var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
  pp$9.strictDirective = function(start2) {
    if (this.options.ecmaVersion < 5) {
      return false;
    }
    for (; ; ) {
      skipWhiteSpace.lastIndex = start2;
      start2 += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start2));
      if (!match) {
        return false;
      }
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start2 + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
      }
      start2 += match[0].length;
      skipWhiteSpace.lastIndex = start2;
      start2 += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start2] === ";") {
        start2++;
      }
    }
  };
  pp$9.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true;
    } else {
      return false;
    }
  };
  pp$9.isContextual = function(name2) {
    return this.type === types$1.name && this.value === name2 && !this.containsEsc;
  };
  pp$9.eatContextual = function(name2) {
    if (!this.isContextual(name2)) {
      return false;
    }
    this.next();
    return true;
  };
  pp$9.expectContextual = function(name2) {
    if (!this.eatContextual(name2)) {
      this.unexpected();
    }
  };
  pp$9.canInsertSemicolon = function() {
    return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };
  pp$9.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon) {
        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
      }
      return true;
    }
  };
  pp$9.semicolon = function() {
    if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
      this.unexpected();
    }
  };
  pp$9.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma) {
        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
      }
      if (!notNext) {
        this.next();
      }
      return true;
    }
  };
  pp$9.expect = function(type) {
    this.eat(type) || this.unexpected();
  };
  pp$9.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };
  var DestructuringErrors = function DestructuringErrors2() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  };
  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) {
      return;
    }
    if (refDestructuringErrors.trailingComma > -1) {
      this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
    }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) {
      this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
    }
  };
  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) {
      return false;
    }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) {
      return shorthandAssign >= 0 || doubleProto >= 0;
    }
    if (shorthandAssign >= 0) {
      this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
    }
    if (doubleProto >= 0) {
      this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
    }
  };
  pp$9.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
      this.raise(this.yieldPos, "Yield expression cannot be a default value");
    }
    if (this.awaitPos) {
      this.raise(this.awaitPos, "Await expression cannot be a default value");
    }
  };
  pp$9.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression") {
      return this.isSimpleAssignTarget(expr.expression);
    }
    return expr.type === "Identifier" || expr.type === "MemberExpression";
  };
  var pp$8 = Parser.prototype;
  pp$8.parseTopLevel = function(node3) {
    var exports3 = /* @__PURE__ */ Object.create(null);
    if (!node3.body) {
      node3.body = [];
    }
    while (this.type !== types$1.eof) {
      var stmt = this.parseStatement(null, true, exports3);
      node3.body.push(stmt);
    }
    if (this.inModule) {
      for (var i = 0, list4 = Object.keys(this.undefinedExports); i < list4.length; i += 1) {
        var name2 = list4[i];
        this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
      }
    }
    this.adaptDirectivePrologue(node3.body);
    this.next();
    node3.sourceType = this.options.sourceType;
    return this.finishNode(node3, "Program");
  };
  var loopLabel = { kind: "loop" };
  var switchLabel = { kind: "switch" };
  pp$8.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 91 || nextCh === 92) {
      return true;
    }
    if (context) {
      return false;
    }
    if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
        ++pos;
      }
      if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) {
        return true;
      }
    }
    return false;
  };
  pp$8.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, after;
    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
  };
  pp$8.parseStatement = function(context, topLevel, exports3) {
    var starttype = this.type, node3 = this.startNode(), kind;
    if (this.isLet(context)) {
      starttype = types$1._var;
      kind = "let";
    }
    switch (starttype) {
      case types$1._break:
      case types$1._continue:
        return this.parseBreakContinueStatement(node3, starttype.keyword);
      case types$1._debugger:
        return this.parseDebuggerStatement(node3);
      case types$1._do:
        return this.parseDoStatement(node3);
      case types$1._for:
        return this.parseForStatement(node3);
      case types$1._function:
        if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
          this.unexpected();
        }
        return this.parseFunctionStatement(node3, false, !context);
      case types$1._class:
        if (context) {
          this.unexpected();
        }
        return this.parseClass(node3, true);
      case types$1._if:
        return this.parseIfStatement(node3);
      case types$1._return:
        return this.parseReturnStatement(node3);
      case types$1._switch:
        return this.parseSwitchStatement(node3);
      case types$1._throw:
        return this.parseThrowStatement(node3);
      case types$1._try:
        return this.parseTryStatement(node3);
      case types$1._const:
      case types$1._var:
        kind = kind || this.value;
        if (context && kind !== "var") {
          this.unexpected();
        }
        return this.parseVarStatement(node3, kind);
      case types$1._while:
        return this.parseWhileStatement(node3);
      case types$1._with:
        return this.parseWithStatement(node3);
      case types$1.braceL:
        return this.parseBlock(true, node3);
      case types$1.semi:
        return this.parseEmptyStatement(node3);
      case types$1._export:
      case types$1._import:
        if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 40 || nextCh === 46) {
            return this.parseExpressionStatement(node3, this.parseExpression());
          }
        }
        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel) {
            this.raise(this.start, "'import' and 'export' may only appear at the top level");
          }
          if (!this.inModule) {
            this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
          }
        }
        return starttype === types$1._import ? this.parseImport(node3) : this.parseExport(node3, exports3);
      default:
        if (this.isAsyncFunction()) {
          if (context) {
            this.unexpected();
          }
          this.next();
          return this.parseFunctionStatement(node3, true, !context);
        }
        var maybeName = this.value, expr = this.parseExpression();
        if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
          return this.parseLabeledStatement(node3, maybeName, expr, context);
        } else {
          return this.parseExpressionStatement(node3, expr);
        }
    }
  };
  pp$8.parseBreakContinueStatement = function(node3, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon()) {
      node3.label = null;
    } else if (this.type !== types$1.name) {
      this.unexpected();
    } else {
      node3.label = this.parseIdent();
      this.semicolon();
    }
    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node3.label == null || lab.name === node3.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) {
          break;
        }
        if (node3.label && isBreak) {
          break;
        }
      }
    }
    if (i === this.labels.length) {
      this.raise(node3.start, "Unsyntactic " + keyword);
    }
    return this.finishNode(node3, isBreak ? "BreakStatement" : "ContinueStatement");
  };
  pp$8.parseDebuggerStatement = function(node3) {
    this.next();
    this.semicolon();
    return this.finishNode(node3, "DebuggerStatement");
  };
  pp$8.parseDoStatement = function(node3) {
    this.next();
    this.labels.push(loopLabel);
    node3.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types$1._while);
    node3.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6) {
      this.eat(types$1.semi);
    } else {
      this.semicolon();
    }
    return this.finishNode(node3, "DoWhileStatement");
  };
  pp$8.parseForStatement = function(node3) {
    this.next();
    var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types$1.parenL);
    if (this.type === types$1.semi) {
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node3, null);
    }
    var isLet = this.isLet();
    if (this.type === types$1._var || this.type === types$1._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$1._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node3.await = awaitAt > -1;
          }
        }
        return this.parseForIn(node3, init$1);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node3, init$1);
    }
    var startsWithLet = this.isContextual("let"), isForOf = false;
    var containsEsc = this.containsEsc;
    var refDestructuringErrors = new DestructuringErrors();
    var initPos = this.start;
    var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (awaitAt > -1) {
        if (this.type === types$1._in) {
          this.unexpected(awaitAt);
        }
        node3.await = true;
      } else if (isForOf && this.options.ecmaVersion >= 8) {
        if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
          this.unexpected();
        } else if (this.options.ecmaVersion >= 9) {
          node3.await = false;
        }
      }
      if (startsWithLet && isForOf) {
        this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLValPattern(init);
      return this.parseForIn(node3, init);
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node3, init);
  };
  pp$8.parseFunctionStatement = function(node3, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node3, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
  };
  pp$8.parseIfStatement = function(node3) {
    this.next();
    node3.test = this.parseParenExpression();
    node3.consequent = this.parseStatement("if");
    node3.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
    return this.finishNode(node3, "IfStatement");
  };
  pp$8.parseReturnStatement = function(node3) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
      this.raise(this.start, "'return' outside of function");
    }
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon()) {
      node3.argument = null;
    } else {
      node3.argument = this.parseExpression();
      this.semicolon();
    }
    return this.finishNode(node3, "ReturnStatement");
  };
  pp$8.parseSwitchStatement = function(node3) {
    this.next();
    node3.discriminant = this.parseParenExpression();
    node3.cases = [];
    this.expect(types$1.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);
    var cur;
    for (var sawDefault = false; this.type !== types$1.braceR; ) {
      if (this.type === types$1._case || this.type === types$1._default) {
        var isCase = this.type === types$1._case;
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        node3.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) {
            this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
          }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types$1.colon);
      } else {
        if (!cur) {
          this.unexpected();
        }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) {
      this.finishNode(cur, "SwitchCase");
    }
    this.next();
    this.labels.pop();
    return this.finishNode(node3, "SwitchStatement");
  };
  pp$8.parseThrowStatement = function(node3) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
      this.raise(this.lastTokEnd, "Illegal newline after throw");
    }
    node3.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node3, "ThrowStatement");
  };
  var empty$1 = [];
  pp$8.parseCatchClauseParam = function() {
    var param = this.parseBindingAtom();
    var simple = param.type === "Identifier";
    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
    this.expect(types$1.parenR);
    return param;
  };
  pp$8.parseTryStatement = function(node3) {
    this.next();
    node3.block = this.parseBlock();
    node3.handler = null;
    if (this.type === types$1._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types$1.parenL)) {
        clause.param = this.parseCatchClauseParam();
      } else {
        if (this.options.ecmaVersion < 10) {
          this.unexpected();
        }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node3.handler = this.finishNode(clause, "CatchClause");
    }
    node3.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
    if (!node3.handler && !node3.finalizer) {
      this.raise(node3.start, "Missing catch or finally clause");
    }
    return this.finishNode(node3, "TryStatement");
  };
  pp$8.parseVarStatement = function(node3, kind, allowMissingInitializer) {
    this.next();
    this.parseVar(node3, false, kind, allowMissingInitializer);
    this.semicolon();
    return this.finishNode(node3, "VariableDeclaration");
  };
  pp$8.parseWhileStatement = function(node3) {
    this.next();
    node3.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node3.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node3, "WhileStatement");
  };
  pp$8.parseWithStatement = function(node3) {
    if (this.strict) {
      this.raise(this.start, "'with' in strict mode");
    }
    this.next();
    node3.object = this.parseParenExpression();
    node3.body = this.parseStatement("with");
    return this.finishNode(node3, "WithStatement");
  };
  pp$8.parseEmptyStatement = function(node3) {
    this.next();
    return this.finishNode(node3, "EmptyStatement");
  };
  pp$8.parseLabeledStatement = function(node3, maybeName, expr, context) {
    for (var i$1 = 0, list4 = this.labels; i$1 < list4.length; i$1 += 1) {
      var label = list4[i$1];
      if (label.name === maybeName) {
        this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      }
    }
    var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node3.start) {
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else {
        break;
      }
    }
    this.labels.push({ name: maybeName, kind, statementStart: this.start });
    node3.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node3.label = expr;
    return this.finishNode(node3, "LabeledStatement");
  };
  pp$8.parseExpressionStatement = function(node3, expr) {
    node3.expression = expr;
    this.semicolon();
    return this.finishNode(node3, "ExpressionStatement");
  };
  pp$8.parseBlock = function(createNewLexicalScope, node3, exitStrict) {
    if (createNewLexicalScope === void 0)
      createNewLexicalScope = true;
    if (node3 === void 0)
      node3 = this.startNode();
    node3.body = [];
    this.expect(types$1.braceL);
    if (createNewLexicalScope) {
      this.enterScope(0);
    }
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node3.body.push(stmt);
    }
    if (exitStrict) {
      this.strict = false;
    }
    this.next();
    if (createNewLexicalScope) {
      this.exitScope();
    }
    return this.finishNode(node3, "BlockStatement");
  };
  pp$8.parseFor = function(node3, init) {
    node3.init = init;
    this.expect(types$1.semi);
    node3.test = this.type === types$1.semi ? null : this.parseExpression();
    this.expect(types$1.semi);
    node3.update = this.type === types$1.parenR ? null : this.parseExpression();
    this.expect(types$1.parenR);
    node3.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node3, "ForStatement");
  };
  pp$8.parseForIn = function(node3, init) {
    var isForIn = this.type === types$1._in;
    this.next();
    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
      this.raise(
        init.start,
        (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
      );
    }
    node3.left = init;
    node3.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types$1.parenR);
    node3.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node3, isForIn ? "ForInStatement" : "ForOfStatement");
  };
  pp$8.parseVar = function(node3, isFor, kind, allowMissingInitializer) {
    node3.declarations = [];
    node3.kind = kind;
    for (; ; ) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types$1.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        this.unexpected();
      } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node3.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types$1.comma)) {
        break;
      }
    }
    return node3;
  };
  pp$8.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };
  var FUNC_STATEMENT = 1;
  var FUNC_HANGING_STATEMENT = 2;
  var FUNC_NULLABLE_ID = 4;
  pp$8.parseFunction = function(node3, statement, allowExpressionBody, isAsync, forInit) {
    this.initFunction(node3);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
        this.unexpected();
      }
      node3.generator = this.eat(types$1.star);
    }
    if (this.options.ecmaVersion >= 8) {
      node3.async = !!isAsync;
    }
    if (statement & FUNC_STATEMENT) {
      node3.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
      if (node3.id && !(statement & FUNC_HANGING_STATEMENT)) {
        this.checkLValSimple(node3.id, this.strict || node3.generator || node3.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
      }
    }
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node3.async, node3.generator));
    if (!(statement & FUNC_STATEMENT)) {
      node3.id = this.type === types$1.name ? this.parseIdent() : null;
    }
    this.parseFunctionParams(node3);
    this.parseFunctionBody(node3, allowExpressionBody, false, forInit);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node3, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
  };
  pp$8.parseFunctionParams = function(node3) {
    this.expect(types$1.parenL);
    node3.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };
  pp$8.parseClass = function(node3, isStatement) {
    this.next();
    var oldStrict = this.strict;
    this.strict = true;
    this.parseClassId(node3, isStatement);
    this.parseClassSuper(node3);
    var privateNameMap = this.enterClassBody();
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types$1.braceL);
    while (this.type !== types$1.braceR) {
      var element2 = this.parseClassElement(node3.superClass !== null);
      if (element2) {
        classBody.body.push(element2);
        if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
          if (hadConstructor) {
            this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
          }
          hadConstructor = true;
        } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
          this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node3.body = this.finishNode(classBody, "ClassBody");
    this.exitClassBody();
    return this.finishNode(node3, isStatement ? "ClassDeclaration" : "ClassExpression");
  };
  pp$8.parseClassElement = function(constructorAllowsSuper) {
    if (this.eat(types$1.semi)) {
      return null;
    }
    var ecmaVersion = this.options.ecmaVersion;
    var node3 = this.startNode();
    var keyName = "";
    var isGenerator = false;
    var isAsync = false;
    var kind = "method";
    var isStatic = false;
    if (this.eatContextual("static")) {
      if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
        this.parseClassStaticBlock(node3);
        return node3;
      }
      if (this.isClassElementNameStart() || this.type === types$1.star) {
        isStatic = true;
      } else {
        keyName = "static";
      }
    }
    node3.static = isStatic;
    if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
        isAsync = true;
      } else {
        keyName = "async";
      }
    }
    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
      isGenerator = true;
    }
    if (!keyName && !isAsync && !isGenerator) {
      var lastValue = this.value;
      if (this.eatContextual("get") || this.eatContextual("set")) {
        if (this.isClassElementNameStart()) {
          kind = lastValue;
        } else {
          keyName = lastValue;
        }
      }
    }
    if (keyName) {
      node3.computed = false;
      node3.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
      node3.key.name = keyName;
      this.finishNode(node3.key, "Identifier");
    } else {
      this.parseClassElementName(node3);
    }
    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
      var isConstructor = !node3.static && checkKeyName(node3, "constructor");
      var allowsDirectSuper = isConstructor && constructorAllowsSuper;
      if (isConstructor && kind !== "method") {
        this.raise(node3.key.start, "Constructor can't have get/set modifier");
      }
      node3.kind = isConstructor ? "constructor" : kind;
      this.parseClassMethod(node3, isGenerator, isAsync, allowsDirectSuper);
    } else {
      this.parseClassField(node3);
    }
    return node3;
  };
  pp$8.isClassElementNameStart = function() {
    return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
  };
  pp$8.parseClassElementName = function(element2) {
    if (this.type === types$1.privateId) {
      if (this.value === "constructor") {
        this.raise(this.start, "Classes can't have an element named '#constructor'");
      }
      element2.computed = false;
      element2.key = this.parsePrivateIdent();
    } else {
      this.parsePropertyName(element2);
    }
  };
  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    var key = method.key;
    if (method.kind === "constructor") {
      if (isGenerator) {
        this.raise(key.start, "Constructor can't be a generator");
      }
      if (isAsync) {
        this.raise(key.start, "Constructor can't be an async method");
      }
    } else if (method.static && checkKeyName(method, "prototype")) {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && value.params.length !== 0) {
      this.raiseRecoverable(value.start, "getter should have no params");
    }
    if (method.kind === "set" && value.params.length !== 1) {
      this.raiseRecoverable(value.start, "setter should have exactly one param");
    }
    if (method.kind === "set" && value.params[0].type === "RestElement") {
      this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
    }
    return this.finishNode(method, "MethodDefinition");
  };
  pp$8.parseClassField = function(field) {
    if (checkKeyName(field, "constructor")) {
      this.raise(field.key.start, "Classes can't have a field named 'constructor'");
    } else if (field.static && checkKeyName(field, "prototype")) {
      this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
    }
    if (this.eat(types$1.eq)) {
      var scope = this.currentThisScope();
      var inClassFieldInit = scope.inClassFieldInit;
      scope.inClassFieldInit = true;
      field.value = this.parseMaybeAssign();
      scope.inClassFieldInit = inClassFieldInit;
    } else {
      field.value = null;
    }
    this.semicolon();
    return this.finishNode(field, "PropertyDefinition");
  };
  pp$8.parseClassStaticBlock = function(node3) {
    node3.body = [];
    var oldLabels = this.labels;
    this.labels = [];
    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node3.body.push(stmt);
    }
    this.next();
    this.exitScope();
    this.labels = oldLabels;
    return this.finishNode(node3, "StaticBlock");
  };
  pp$8.parseClassId = function(node3, isStatement) {
    if (this.type === types$1.name) {
      node3.id = this.parseIdent();
      if (isStatement) {
        this.checkLValSimple(node3.id, BIND_LEXICAL, false);
      }
    } else {
      if (isStatement === true) {
        this.unexpected();
      }
      node3.id = null;
    }
  };
  pp$8.parseClassSuper = function(node3) {
    node3.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
  };
  pp$8.enterClassBody = function() {
    var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
    this.privateNameStack.push(element2);
    return element2.declared;
  };
  pp$8.exitClassBody = function() {
    var ref2 = this.privateNameStack.pop();
    var declared = ref2.declared;
    var used = ref2.used;
    if (!this.options.checkPrivateFields) {
      return;
    }
    var len = this.privateNameStack.length;
    var parent = len === 0 ? null : this.privateNameStack[len - 1];
    for (var i = 0; i < used.length; ++i) {
      var id = used[i];
      if (!hasOwn(declared, id.name)) {
        if (parent) {
          parent.used.push(id);
        } else {
          this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
        }
      }
    }
  };
  function isPrivateNameConflicted(privateNameMap, element2) {
    var name2 = element2.key.name;
    var curr = privateNameMap[name2];
    var next = "true";
    if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
      next = (element2.static ? "s" : "i") + element2.kind;
    }
    if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
      privateNameMap[name2] = "true";
      return false;
    } else if (!curr) {
      privateNameMap[name2] = next;
      return false;
    } else {
      return true;
    }
  }
  function checkKeyName(node3, name2) {
    var computed = node3.computed;
    var key = node3.key;
    return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
  }
  pp$8.parseExportAllDeclaration = function(node3, exports3) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node3.exported = this.parseModuleExportName();
        this.checkExport(exports3, node3.exported, this.lastTokStart);
      } else {
        node3.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node3.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node3, "ExportAllDeclaration");
  };
  pp$8.parseExport = function(node3, exports3) {
    this.next();
    if (this.eat(types$1.star)) {
      return this.parseExportAllDeclaration(node3, exports3);
    }
    if (this.eat(types$1._default)) {
      this.checkExport(exports3, "default", this.lastTokStart);
      node3.declaration = this.parseExportDefaultDeclaration();
      return this.finishNode(node3, "ExportDefaultDeclaration");
    }
    if (this.shouldParseExportStatement()) {
      node3.declaration = this.parseExportDeclaration(node3);
      if (node3.declaration.type === "VariableDeclaration") {
        this.checkVariableExport(exports3, node3.declaration.declarations);
      } else {
        this.checkExport(exports3, node3.declaration.id, node3.declaration.id.start);
      }
      node3.specifiers = [];
      node3.source = null;
    } else {
      node3.declaration = null;
      node3.specifiers = this.parseExportSpecifiers(exports3);
      if (this.eatContextual("from")) {
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node3.source = this.parseExprAtom();
      } else {
        for (var i = 0, list4 = node3.specifiers; i < list4.length; i += 1) {
          var spec = list4[i];
          this.checkUnreserved(spec.local);
          this.checkLocalExport(spec.local);
          if (spec.local.type === "Literal") {
            this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
          }
        }
        node3.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node3, "ExportNamedDeclaration");
  };
  pp$8.parseExportDeclaration = function(node3) {
    return this.parseStatement(null);
  };
  pp$8.parseExportDefaultDeclaration = function() {
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) {
        this.next();
      }
      return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      return this.parseClass(cNode, "nullableID");
    } else {
      var declaration = this.parseMaybeAssign();
      this.semicolon();
      return declaration;
    }
  };
  pp$8.checkExport = function(exports3, name2, pos) {
    if (!exports3) {
      return;
    }
    if (typeof name2 !== "string") {
      name2 = name2.type === "Identifier" ? name2.name : name2.value;
    }
    if (hasOwn(exports3, name2)) {
      this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
    }
    exports3[name2] = true;
  };
  pp$8.checkPatternExport = function(exports3, pat) {
    var type = pat.type;
    if (type === "Identifier") {
      this.checkExport(exports3, pat, pat.start);
    } else if (type === "ObjectPattern") {
      for (var i = 0, list4 = pat.properties; i < list4.length; i += 1) {
        var prop = list4[i];
        this.checkPatternExport(exports3, prop);
      }
    } else if (type === "ArrayPattern") {
      for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];
        if (elt) {
          this.checkPatternExport(exports3, elt);
        }
      }
    } else if (type === "Property") {
      this.checkPatternExport(exports3, pat.value);
    } else if (type === "AssignmentPattern") {
      this.checkPatternExport(exports3, pat.left);
    } else if (type === "RestElement") {
      this.checkPatternExport(exports3, pat.argument);
    }
  };
  pp$8.checkVariableExport = function(exports3, decls) {
    if (!exports3) {
      return;
    }
    for (var i = 0, list4 = decls; i < list4.length; i += 1) {
      var decl = list4[i];
      this.checkPatternExport(exports3, decl.id);
    }
  };
  pp$8.shouldParseExportStatement = function() {
    return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
  };
  pp$8.parseExportSpecifier = function(exports3) {
    var node3 = this.startNode();
    node3.local = this.parseModuleExportName();
    node3.exported = this.eatContextual("as") ? this.parseModuleExportName() : node3.local;
    this.checkExport(
      exports3,
      node3.exported,
      node3.exported.start
    );
    return this.finishNode(node3, "ExportSpecifier");
  };
  pp$8.parseExportSpecifiers = function(exports3) {
    var nodes = [], first = true;
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      nodes.push(this.parseExportSpecifier(exports3));
    }
    return nodes;
  };
  pp$8.parseImport = function(node3) {
    this.next();
    if (this.type === types$1.string) {
      node3.specifiers = empty$1;
      node3.source = this.parseExprAtom();
    } else {
      node3.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node3.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node3, "ImportDeclaration");
  };
  pp$8.parseImportSpecifier = function() {
    var node3 = this.startNode();
    node3.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node3.local = this.parseIdent();
    } else {
      this.checkUnreserved(node3.imported);
      node3.local = node3.imported;
    }
    this.checkLValSimple(node3.local, BIND_LEXICAL);
    return this.finishNode(node3, "ImportSpecifier");
  };
  pp$8.parseImportDefaultSpecifier = function() {
    var node3 = this.startNode();
    node3.local = this.parseIdent();
    this.checkLValSimple(node3.local, BIND_LEXICAL);
    return this.finishNode(node3, "ImportDefaultSpecifier");
  };
  pp$8.parseImportNamespaceSpecifier = function() {
    var node3 = this.startNode();
    this.next();
    this.expectContextual("as");
    node3.local = this.parseIdent();
    this.checkLValSimple(node3.local, BIND_LEXICAL);
    return this.finishNode(node3, "ImportNamespaceSpecifier");
  };
  pp$8.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types$1.name) {
      nodes.push(this.parseImportDefaultSpecifier());
      if (!this.eat(types$1.comma)) {
        return nodes;
      }
    }
    if (this.type === types$1.star) {
      nodes.push(this.parseImportNamespaceSpecifier());
      return nodes;
    }
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      nodes.push(this.parseImportSpecifier());
    }
    return nodes;
  };
  pp$8.parseModuleExportName = function() {
    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
      var stringLiteral = this.parseLiteral(this.value);
      if (loneSurrogate.test(stringLiteral.value)) {
        this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
      }
      return stringLiteral;
    }
    return this.parseIdent(true);
  };
  pp$8.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$8.isDirectiveCandidate = function(statement) {
    return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
    (this.input[statement.start] === '"' || this.input[statement.start] === "'");
  };
  var pp$7 = Parser.prototype;
  pp$7.toAssignable = function(node3, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node3) {
      switch (node3.type) {
        case "Identifier":
          if (this.inAsync && node3.name === "await") {
            this.raise(node3.start, "Cannot use 'await' as identifier inside an async function");
          }
          break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node3.type = "ObjectPattern";
          if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          for (var i = 0, list4 = node3.properties; i < list4.length; i += 1) {
            var prop = list4[i];
            this.toAssignable(prop, isBinding);
            if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
              this.raise(prop.argument.start, "Unexpected token");
            }
          }
          break;
        case "Property":
          if (node3.kind !== "init") {
            this.raise(node3.key.start, "Object pattern can't contain getter or setter");
          }
          this.toAssignable(node3.value, isBinding);
          break;
        case "ArrayExpression":
          node3.type = "ArrayPattern";
          if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          this.toAssignableList(node3.elements, isBinding);
          break;
        case "SpreadElement":
          node3.type = "RestElement";
          this.toAssignable(node3.argument, isBinding);
          if (node3.argument.type === "AssignmentPattern") {
            this.raise(node3.argument.start, "Rest elements cannot have a default value");
          }
          break;
        case "AssignmentExpression":
          if (node3.operator !== "=") {
            this.raise(node3.left.end, "Only '=' operator can be used for specifying default value.");
          }
          node3.type = "AssignmentPattern";
          delete node3.operator;
          this.toAssignable(node3.left, isBinding);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(node3.expression, isBinding, refDestructuringErrors);
          break;
        case "ChainExpression":
          this.raiseRecoverable(node3.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (!isBinding) {
            break;
          }
        default:
          this.raise(node3.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) {
      this.checkPatternErrors(refDestructuringErrors, true);
    }
    return node3;
  };
  pp$7.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) {
        this.toAssignable(elt, isBinding);
      }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
        this.unexpected(last.argument.start);
      }
    }
    return exprList;
  };
  pp$7.parseSpread = function(refDestructuringErrors) {
    var node3 = this.startNode();
    this.next();
    node3.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node3, "SpreadElement");
  };
  pp$7.parseRestBinding = function() {
    var node3 = this.startNode();
    this.next();
    if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
      this.unexpected();
    }
    node3.argument = this.parseBindingAtom();
    return this.finishNode(node3, "RestElement");
  };
  pp$7.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
        case types$1.bracketL:
          var node3 = this.startNode();
          this.next();
          node3.elements = this.parseBindingList(types$1.bracketR, true, true);
          return this.finishNode(node3, "ArrayPattern");
        case types$1.braceL:
          return this.parseObj(true);
      }
    }
    return this.parseIdent();
  };
  pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(types$1.comma);
      }
      if (allowEmpty && this.type === types$1.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      } else if (this.type === types$1.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        this.expect(close);
        break;
      } else {
        elts.push(this.parseAssignableListItem(allowModifiers));
      }
    }
    return elts;
  };
  pp$7.parseAssignableListItem = function(allowModifiers) {
    var elem = this.parseMaybeDefault(this.start, this.startLoc);
    this.parseBindingListItem(elem);
    return elem;
  };
  pp$7.parseBindingListItem = function(param) {
    return param;
  };
  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
      return left;
    }
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.left = left;
    node3.right = this.parseMaybeAssign();
    return this.finishNode(node3, "AssignmentPattern");
  };
  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0)
      bindingType = BIND_NONE;
    var isBind = bindingType !== BIND_NONE;
    switch (expr.type) {
      case "Identifier":
        if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
          this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
        }
        if (isBind) {
          if (bindingType === BIND_LEXICAL && expr.name === "let") {
            this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
          }
          if (checkClashes) {
            if (hasOwn(checkClashes, expr.name)) {
              this.raiseRecoverable(expr.start, "Argument name clash");
            }
            checkClashes[expr.name] = true;
          }
          if (bindingType !== BIND_OUTSIDE) {
            this.declareName(expr.name, bindingType, expr.start);
          }
        }
        break;
      case "ChainExpression":
        this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (isBind) {
          this.raiseRecoverable(expr.start, "Binding member expression");
        }
        break;
      case "ParenthesizedExpression":
        if (isBind) {
          this.raiseRecoverable(expr.start, "Binding parenthesized expression");
        }
        return this.checkLValSimple(expr.expression, bindingType, checkClashes);
      default:
        this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
    }
  };
  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0)
      bindingType = BIND_NONE;
    switch (expr.type) {
      case "ObjectPattern":
        for (var i = 0, list4 = expr.properties; i < list4.length; i += 1) {
          var prop = list4[i];
          this.checkLValInnerPattern(prop, bindingType, checkClashes);
        }
        break;
      case "ArrayPattern":
        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
          var elem = list$1[i$1];
          if (elem) {
            this.checkLValInnerPattern(elem, bindingType, checkClashes);
          }
        }
        break;
      default:
        this.checkLValSimple(expr, bindingType, checkClashes);
    }
  };
  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0)
      bindingType = BIND_NONE;
    switch (expr.type) {
      case "Property":
        this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
        break;
      case "AssignmentPattern":
        this.checkLValPattern(expr.left, bindingType, checkClashes);
        break;
      case "RestElement":
        this.checkLValPattern(expr.argument, bindingType, checkClashes);
        break;
      default:
        this.checkLValPattern(expr, bindingType, checkClashes);
    }
  };
  var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };
  var types = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function(p) {
      return p.tryReadTemplateToken();
    }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };
  var pp$6 = Parser.prototype;
  pp$6.initialContext = function() {
    return [types.b_stat];
  };
  pp$6.curContext = function() {
    return this.context[this.context.length - 1];
  };
  pp$6.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types.f_expr || parent === types.f_stat) {
      return true;
    }
    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
      return !parent.isExpr;
    }
    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    }
    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
      return true;
    }
    if (prevType === types$1.braceL) {
      return parent === types.b_stat;
    }
    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
      return false;
    }
    return !this.exprAllowed;
  };
  pp$6.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function") {
        return context.generator;
      }
    }
    return false;
  };
  pp$6.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types$1.dot) {
      this.exprAllowed = false;
    } else if (update = type.updateContext) {
      update.call(this, prevType);
    } else {
      this.exprAllowed = type.beforeExpr;
    }
  };
  pp$6.overrideContext = function(tokenCtx) {
    if (this.curContext() !== tokenCtx) {
      this.context[this.context.length - 1] = tokenCtx;
    }
  };
  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return;
    }
    var out = this.context.pop();
    if (out === types.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };
  types$1.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
    this.exprAllowed = true;
  };
  types$1.dollarBraceL.updateContext = function() {
    this.context.push(types.b_tmpl);
    this.exprAllowed = true;
  };
  types$1.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
    this.context.push(statementParens ? types.p_stat : types.p_expr);
    this.exprAllowed = true;
  };
  types$1.incDec.updateContext = function() {
  };
  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
      this.context.push(types.f_expr);
    } else {
      this.context.push(types.f_stat);
    }
    this.exprAllowed = false;
  };
  types$1.colon.updateContext = function() {
    if (this.curContext().token === "function") {
      this.context.pop();
    }
    this.exprAllowed = true;
  };
  types$1.backQuote.updateContext = function() {
    if (this.curContext() === types.q_tmpl) {
      this.context.pop();
    } else {
      this.context.push(types.q_tmpl);
    }
    this.exprAllowed = false;
  };
  types$1.star.updateContext = function(prevType) {
    if (prevType === types$1._function) {
      var index4 = this.context.length - 1;
      if (this.context[index4] === types.f_expr) {
        this.context[index4] = types.f_expr_gen;
      } else {
        this.context[index4] = types.f_gen;
      }
    }
    this.exprAllowed = true;
  };
  types$1.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
      if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
        allowed = true;
      }
    }
    this.exprAllowed = allowed;
  };
  var pp$5 = Parser.prototype;
  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
      return;
    }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
      return;
    }
    var key = prop.key;
    var name2;
    switch (key.type) {
      case "Identifier":
        name2 = key.name;
        break;
      case "Literal":
        name2 = String(key.value);
        break;
      default:
        return;
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name2 === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0) {
              refDestructuringErrors.doubleProto = key.start;
            }
          } else {
            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
          }
        }
        propHash.proto = true;
      }
      return;
    }
    name2 = "$" + name2;
    var other = propHash[name2];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition) {
        this.raiseRecoverable(key.start, "Redefinition of property");
      }
    } else {
      other = propHash[name2] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };
  pp$5.parseExpression = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
    if (this.type === types$1.comma) {
      var node3 = this.startNodeAt(startPos, startLoc);
      node3.expressions = [expr];
      while (this.eat(types$1.comma)) {
        node3.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
      }
      return this.finishNode(node3, "SequenceExpression");
    }
    return expr;
  };
  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) {
        return this.parseYield(forInit);
      } else {
        this.exprAllowed = false;
      }
    }
    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      oldDoubleProto = refDestructuringErrors.doubleProto;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors();
      ownDestructuringErrors = true;
    }
    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types$1.parenL || this.type === types$1.name) {
      this.potentialArrowAt = this.start;
      this.potentialArrowInForAwait = forInit === "await";
    }
    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc);
    }
    if (this.type.isAssign) {
      var node3 = this.startNodeAt(startPos, startLoc);
      node3.operator = this.value;
      if (this.type === types$1.eq) {
        left = this.toAssignable(left, false, refDestructuringErrors);
      }
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= left.start) {
        refDestructuringErrors.shorthandAssign = -1;
      }
      if (this.type === types$1.eq) {
        this.checkLValPattern(left);
      } else {
        this.checkLValSimple(left);
      }
      node3.left = left;
      this.next();
      node3.right = this.parseMaybeAssign(forInit);
      if (oldDoubleProto > -1) {
        refDestructuringErrors.doubleProto = oldDoubleProto;
      }
      return this.finishNode(node3, "AssignmentExpression");
    } else {
      if (ownDestructuringErrors) {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
    }
    if (oldParenAssign > -1) {
      refDestructuringErrors.parenthesizedAssign = oldParenAssign;
    }
    if (oldTrailingComma > -1) {
      refDestructuringErrors.trailingComma = oldTrailingComma;
    }
    return left;
  };
  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(forInit, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    if (this.eat(types$1.question)) {
      var node3 = this.startNodeAt(startPos, startLoc);
      node3.test = expr;
      node3.consequent = this.parseMaybeAssign();
      this.expect(types$1.colon);
      node3.alternate = this.parseMaybeAssign(forInit);
      return this.finishNode(node3, "ConditionalExpression");
    }
    return expr;
  };
  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
  };
  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
    var prec = this.type.binop;
    if (prec != null && (!forInit || this.type !== types$1._in)) {
      if (prec > minPrec) {
        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
        var coalesce = this.type === types$1.coalesce;
        if (coalesce) {
          prec = types$1.logicalAND.binop;
        }
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
        var node3 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node3, leftStartPos, leftStartLoc, minPrec, forInit);
      }
    }
    return left;
  };
  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    if (right.type === "PrivateIdentifier") {
      this.raise(right.start, "Private identifier can only be left side of binary expression");
    }
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.left = left;
    node3.operator = op;
    node3.right = right;
    return this.finishNode(node3, logical ? "LogicalExpression" : "BinaryExpression");
  };
  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && this.canAwait) {
      expr = this.parseAwait(forInit);
      sawUnary = true;
    } else if (this.type.prefix) {
      var node3 = this.startNode(), update = this.type === types$1.incDec;
      node3.operator = this.value;
      node3.prefix = true;
      this.next();
      node3.argument = this.parseMaybeUnary(null, true, update, forInit);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) {
        this.checkLValSimple(node3.argument);
      } else if (this.strict && node3.operator === "delete" && isLocalVariableAccess(node3.argument)) {
        this.raiseRecoverable(node3.start, "Deleting local variable in strict mode");
      } else if (node3.operator === "delete" && isPrivateFieldAccess(node3.argument)) {
        this.raiseRecoverable(node3.start, "Private fields can not be deleted");
      } else {
        sawUnary = true;
      }
      expr = this.finishNode(node3, update ? "UpdateExpression" : "UnaryExpression");
    } else if (!sawUnary && this.type === types$1.privateId) {
      if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
        this.unexpected();
      }
      expr = this.parsePrivateIdent();
      if (this.type !== types$1._in) {
        this.unexpected();
      }
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLValSimple(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }
    if (!incDec && this.eat(types$1.starstar)) {
      if (sawUnary) {
        this.unexpected(this.lastTokStart);
      } else {
        return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
      }
    } else {
      return expr;
    }
  };
  function isLocalVariableAccess(node3) {
    return node3.type === "Identifier" || node3.type === "ParenthesizedExpression" && isLocalVariableAccess(node3.expression);
  }
  function isPrivateFieldAccess(node3) {
    return node3.type === "MemberExpression" && node3.property.type === "PrivateIdentifier" || node3.type === "ChainExpression" && isPrivateFieldAccess(node3.expression) || node3.type === "ParenthesizedExpression" && isPrivateFieldAccess(node3.expression);
  }
  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors, forInit);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
      return expr;
    }
    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) {
        refDestructuringErrors.parenthesizedAssign = -1;
      }
      if (refDestructuringErrors.parenthesizedBind >= result.start) {
        refDestructuringErrors.parenthesizedBind = -1;
      }
      if (refDestructuringErrors.trailingComma >= result.start) {
        refDestructuringErrors.trailingComma = -1;
      }
    }
    return result;
  };
  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
    var optionalChained = false;
    while (true) {
      var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
      if (element2.optional) {
        optionalChained = true;
      }
      if (element2 === base || element2.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element2;
          element2 = this.finishNode(chainNode, "ChainExpression");
        }
        return element2;
      }
      base = element2;
    }
  };
  pp$5.shouldParseAsyncArrow = function() {
    return !this.canInsertSemicolon() && this.eat(types$1.arrow);
  };
  pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
  };
  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types$1.questionDot);
    if (noCalls && optional) {
      this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    }
    var computed = this.eat(types$1.bracketL);
    if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
      var node3 = this.startNodeAt(startPos, startLoc);
      node3.object = base;
      if (computed) {
        node3.property = this.parseExpression();
        this.expect(types$1.bracketR);
      } else if (this.type === types$1.privateId && base.type !== "Super") {
        node3.property = this.parsePrivateIdent();
      } else {
        node3.property = this.parseIdent(this.options.allowReserved !== "never");
      }
      node3.computed = !!computed;
      if (optionalSupported) {
        node3.optional = optional;
      }
      base = this.finishNode(node3, "MemberExpression");
    } else if (!noCalls && this.eat(types$1.parenL)) {
      var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0) {
          this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
        }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (optionalSupported) {
        node$1.optional = optional;
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types$1.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({ isTagged: true });
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base;
  };
  pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
    if (this.type === types$1.slash) {
      this.readRegexp();
    }
    var node3, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
      case types$1._super:
        if (!this.allowSuper) {
          this.raise(this.start, "'super' keyword outside a method");
        }
        node3 = this.startNode();
        this.next();
        if (this.type === types$1.parenL && !this.allowDirectSuper) {
          this.raise(node3.start, "super() call outside constructor of a subclass");
        }
        if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
          this.unexpected();
        }
        return this.finishNode(node3, "Super");
      case types$1._this:
        node3 = this.startNode();
        this.next();
        return this.finishNode(node3, "ThisExpression");
      case types$1.name:
        var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
        var id = this.parseIdent(false);
        if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
          this.overrideContext(types.f_expr);
          return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
        }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types$1.arrow)) {
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
          }
          if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
            id = this.parseIdent(false);
            if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
              this.unexpected();
            }
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
          }
        }
        return id;
      case types$1.regexp:
        var value = this.value;
        node3 = this.parseLiteral(value.value);
        node3.regex = { pattern: value.pattern, flags: value.flags };
        return node3;
      case types$1.num:
      case types$1.string:
        return this.parseLiteral(this.value);
      case types$1._null:
      case types$1._true:
      case types$1._false:
        node3 = this.startNode();
        node3.value = this.type === types$1._null ? null : this.type === types$1._true;
        node3.raw = this.type.keyword;
        this.next();
        return this.finishNode(node3, "Literal");
      case types$1.parenL:
        var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
            refDestructuringErrors.parenthesizedAssign = start2;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = start2;
          }
        }
        return expr;
      case types$1.bracketL:
        node3 = this.startNode();
        this.next();
        node3.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node3, "ArrayExpression");
      case types$1.braceL:
        this.overrideContext(types.b_expr);
        return this.parseObj(false, refDestructuringErrors);
      case types$1._function:
        node3 = this.startNode();
        this.next();
        return this.parseFunction(node3, 0);
      case types$1._class:
        return this.parseClass(this.startNode(), false);
      case types$1._new:
        return this.parseNew();
      case types$1.backQuote:
        return this.parseTemplate();
      case types$1._import:
        if (this.options.ecmaVersion >= 11) {
          return this.parseExprImport(forNew);
        } else {
          return this.unexpected();
        }
      default:
        return this.parseExprAtomDefault();
    }
  };
  pp$5.parseExprAtomDefault = function() {
    this.unexpected();
  };
  pp$5.parseExprImport = function(forNew) {
    var node3 = this.startNode();
    if (this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword import");
    }
    this.next();
    if (this.type === types$1.parenL && !forNew) {
      return this.parseDynamicImport(node3);
    } else if (this.type === types$1.dot) {
      var meta = this.startNodeAt(node3.start, node3.loc && node3.loc.start);
      meta.name = "import";
      node3.meta = this.finishNode(meta, "Identifier");
      return this.parseImportMeta(node3);
    } else {
      this.unexpected();
    }
  };
  pp$5.parseDynamicImport = function(node3) {
    this.next();
    node3.source = this.parseMaybeAssign();
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
    return this.finishNode(node3, "ImportExpression");
  };
  pp$5.parseImportMeta = function(node3) {
    this.next();
    var containsEsc = this.containsEsc;
    node3.property = this.parseIdent(true);
    if (node3.property.name !== "meta") {
      this.raiseRecoverable(node3.property.start, "The only valid meta property for import is 'import.meta'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node3.start, "'import.meta' must not contain escaped characters");
    }
    if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
      this.raiseRecoverable(node3.start, "Cannot use 'import.meta' outside a module");
    }
    return this.finishNode(node3, "MetaProperty");
  };
  pp$5.parseLiteral = function(value) {
    var node3 = this.startNode();
    node3.value = value;
    node3.raw = this.input.slice(this.start, this.end);
    if (node3.raw.charCodeAt(node3.raw.length - 1) === 110) {
      node3.bigint = node3.raw.slice(0, -1).replace(/_/g, "");
    }
    this.next();
    return this.finishNode(node3, "Literal");
  };
  pp$5.parseParenExpression = function() {
    this.expect(types$1.parenL);
    var val = this.parseExpression();
    this.expect(types$1.parenR);
    return val;
  };
  pp$5.shouldParseArrow = function(exprList) {
    return !this.canInsertSemicolon();
  };
  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      while (this.type !== types$1.parenR) {
        first ? first = false : this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
          lastIsComma = true;
          break;
        } else if (this.type === types$1.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types$1.comma) {
            this.raiseRecoverable(
              this.start,
              "Comma is not permitted after the rest element"
            );
          }
          break;
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
      this.expect(types$1.parenR);
      if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
      }
      if (!exprList.length || lastIsComma) {
        this.unexpected(this.lastTokStart);
      }
      if (spreadStart) {
        this.unexpected(spreadStart);
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }
    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression");
    } else {
      return val;
    }
  };
  pp$5.parseParenItem = function(item) {
    return item;
  };
  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
  };
  var empty = [];
  pp$5.parseNew = function() {
    if (this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    }
    var node3 = this.startNode();
    this.next();
    if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
      var meta = this.startNodeAt(node3.start, node3.loc && node3.loc.start);
      meta.name = "new";
      node3.meta = this.finishNode(meta, "Identifier");
      this.next();
      var containsEsc = this.containsEsc;
      node3.property = this.parseIdent(true);
      if (node3.property.name !== "target") {
        this.raiseRecoverable(node3.property.start, "The only valid meta property for new is 'new.target'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node3.start, "'new.target' must not contain escaped characters");
      }
      if (!this.allowNewDotTarget) {
        this.raiseRecoverable(node3.start, "'new.target' can only be used in functions and class static block");
      }
      return this.finishNode(node3, "MetaProperty");
    }
    var startPos = this.start, startLoc = this.startLoc;
    node3.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
    if (this.eat(types$1.parenL)) {
      node3.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
    } else {
      node3.arguments = empty;
    }
    return this.finishNode(node3, "NewExpression");
  };
  pp$5.parseTemplateElement = function(ref2) {
    var isTagged = ref2.isTagged;
    var elem = this.startNode();
    if (this.type === types$1.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value.replace(/\r\n?/g, "\n"),
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types$1.backQuote;
    return this.finishNode(elem, "TemplateElement");
  };
  pp$5.parseTemplate = function(ref2) {
    if (ref2 === void 0)
      ref2 = {};
    var isTagged = ref2.isTagged;
    if (isTagged === void 0)
      isTagged = false;
    var node3 = this.startNode();
    this.next();
    node3.expressions = [];
    var curElt = this.parseTemplateElement({ isTagged });
    node3.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types$1.eof) {
        this.raise(this.pos, "Unterminated template literal");
      }
      this.expect(types$1.dollarBraceL);
      node3.expressions.push(this.parseExpression());
      this.expect(types$1.braceR);
      node3.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
    }
    this.next();
    return this.finishNode(node3, "TemplateLiteral");
  };
  pp$5.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };
  pp$5.parseObj = function(isPattern, refDestructuringErrors) {
    var node3 = this.startNode(), first = true, propHash = {};
    node3.properties = [];
    this.next();
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) {
        this.checkPropClash(prop, propHash, refDestructuringErrors);
      }
      node3.properties.push(prop);
    }
    return this.finishNode(node3, isPattern ? "ObjectPattern" : "ObjectExpression");
  };
  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement");
      }
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      return this.finishNode(prop, "SpreadElement");
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) {
        isGenerator = this.eat(types$1.star);
      }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
      this.parsePropertyName(prop);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property");
  };
  pp$5.parseGetterSetter = function(prop) {
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start2 = prop.value.start;
      if (prop.kind === "get") {
        this.raiseRecoverable(start2, "getter should have no params");
      } else {
        this.raiseRecoverable(start2, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  };
  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types$1.colon) {
      this.unexpected();
    }
    if (this.eat(types$1.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
      if (isPattern) {
        this.unexpected();
      }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
      if (isGenerator || isAsync) {
        this.unexpected();
      }
      this.parseGetterSetter(prop);
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) {
        this.unexpected();
      }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos) {
        this.awaitIdentPos = startPos;
      }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else if (this.type === types$1.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0) {
          refDestructuringErrors.shorthandAssign = this.start;
        }
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else {
        prop.value = this.copyNode(prop.key);
      }
      prop.shorthand = true;
    } else {
      this.unexpected();
    }
  };
  pp$5.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types$1.bracketR);
        return prop.key;
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  };
  pp$5.initFunction = function(node3) {
    node3.id = null;
    if (this.options.ecmaVersion >= 6) {
      node3.generator = node3.expression = false;
    }
    if (this.options.ecmaVersion >= 8) {
      node3.async = false;
    }
  };
  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node3 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.initFunction(node3);
    if (this.options.ecmaVersion >= 6) {
      node3.generator = isGenerator;
    }
    if (this.options.ecmaVersion >= 8) {
      node3.async = !!isAsync;
    }
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node3.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
    this.expect(types$1.parenL);
    node3.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node3, false, true, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node3, "FunctionExpression");
  };
  pp$5.parseArrowExpression = function(node3, params, isAsync, forInit) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node3);
    if (this.options.ecmaVersion >= 8) {
      node3.async = !!isAsync;
    }
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    node3.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node3, true, false, forInit);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node3, "ArrowFunctionExpression");
  };
  pp$5.parseFunctionBody = function(node3, isArrowFunction, isMethod, forInit) {
    var isExpression = isArrowFunction && this.type !== types$1.braceL;
    var oldStrict = this.strict, useStrict = false;
    if (isExpression) {
      node3.body = this.parseMaybeAssign(forInit);
      node3.expression = true;
      this.checkParams(node3, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node3.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        if (useStrict && nonSimple) {
          this.raiseRecoverable(node3.start, "Illegal 'use strict' directive in function with non-simple parameter list");
        }
      }
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) {
        this.strict = true;
      }
      this.checkParams(node3, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node3.params));
      if (this.strict && node3.id) {
        this.checkLValSimple(node3.id, BIND_OUTSIDE);
      }
      node3.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
      node3.expression = false;
      this.adaptDirectivePrologue(node3.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };
  pp$5.isSimpleParamList = function(params) {
    for (var i = 0, list4 = params; i < list4.length; i += 1) {
      var param = list4[i];
      if (param.type !== "Identifier") {
        return false;
      }
    }
    return true;
  };
  pp$5.checkParams = function(node3, allowDuplicates) {
    var nameHash = /* @__PURE__ */ Object.create(null);
    for (var i = 0, list4 = node3.params; i < list4.length; i += 1) {
      var param = list4[i];
      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };
  pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) {
          break;
        }
      } else {
        first = false;
      }
      var elt = void 0;
      if (allowEmpty && this.type === types$1.comma) {
        elt = null;
      } else if (this.type === types$1.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts;
  };
  pp$5.checkUnreserved = function(ref2) {
    var start2 = ref2.start;
    var end = ref2.end;
    var name2 = ref2.name;
    if (this.inGenerator && name2 === "yield") {
      this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
    }
    if (this.inAsync && name2 === "await") {
      this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
    }
    if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
      this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
    }
    if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
      this.raise(start2, "Cannot use " + name2 + " in class static initialization block");
    }
    if (this.keywords.test(name2)) {
      this.raise(start2, "Unexpected keyword '" + name2 + "'");
    }
    if (this.options.ecmaVersion < 6 && this.input.slice(start2, end).indexOf("\\") !== -1) {
      return;
    }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name2)) {
      if (!this.inAsync && name2 === "await") {
        this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
      }
      this.raiseRecoverable(start2, "The keyword '" + name2 + "' is reserved");
    }
  };
  pp$5.parseIdent = function(liberal) {
    var node3 = this.parseIdentNode();
    this.next(!!liberal);
    this.finishNode(node3, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node3);
      if (node3.name === "await" && !this.awaitIdentPos) {
        this.awaitIdentPos = node3.start;
      }
    }
    return node3;
  };
  pp$5.parseIdentNode = function() {
    var node3 = this.startNode();
    if (this.type === types$1.name) {
      node3.name = this.value;
    } else if (this.type.keyword) {
      node3.name = this.type.keyword;
      if ((node3.name === "class" || node3.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
      this.type = types$1.name;
    } else {
      this.unexpected();
    }
    return node3;
  };
  pp$5.parsePrivateIdent = function() {
    var node3 = this.startNode();
    if (this.type === types$1.privateId) {
      node3.name = this.value;
    } else {
      this.unexpected();
    }
    this.next();
    this.finishNode(node3, "PrivateIdentifier");
    if (this.options.checkPrivateFields) {
      if (this.privateNameStack.length === 0) {
        this.raise(node3.start, "Private field '#" + node3.name + "' must be declared in an enclosing class");
      } else {
        this.privateNameStack[this.privateNameStack.length - 1].used.push(node3);
      }
    }
    return node3;
  };
  pp$5.parseYield = function(forInit) {
    if (!this.yieldPos) {
      this.yieldPos = this.start;
    }
    var node3 = this.startNode();
    this.next();
    if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
      node3.delegate = false;
      node3.argument = null;
    } else {
      node3.delegate = this.eat(types$1.star);
      node3.argument = this.parseMaybeAssign(forInit);
    }
    return this.finishNode(node3, "YieldExpression");
  };
  pp$5.parseAwait = function(forInit) {
    if (!this.awaitPos) {
      this.awaitPos = this.start;
    }
    var node3 = this.startNode();
    this.next();
    node3.argument = this.parseMaybeUnary(null, true, false, forInit);
    return this.finishNode(node3, "AwaitExpression");
  };
  var pp$4 = Parser.prototype;
  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos;
    err.loc = loc;
    err.raisedAt = this.pos;
    throw err;
  };
  pp$4.raiseRecoverable = pp$4.raise;
  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position2(this.curLine, this.pos - this.lineStart);
    }
  };
  var pp$3 = Parser.prototype;
  var Scope = function Scope2(flags) {
    this.flags = flags;
    this.var = [];
    this.lexical = [];
    this.functions = [];
    this.inClassFieldInit = false;
  };
  pp$3.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };
  pp$3.exitScope = function() {
    this.scopeStack.pop();
  };
  pp$3.treatFunctionsAsVarInScope = function(scope) {
    return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
  };
  pp$3.declareName = function(name2, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
      scope.lexical.push(name2);
      if (this.inModule && scope.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name2);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar) {
        redeclared = scope$2.lexical.indexOf(name2) > -1;
      } else {
        redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
      }
      scope$2.functions.push(name2);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
          redeclared = true;
          break;
        }
        scope$3.var.push(name2);
        if (this.inModule && scope$3.flags & SCOPE_TOP) {
          delete this.undefinedExports[name2];
        }
        if (scope$3.flags & SCOPE_VAR) {
          break;
        }
      }
    }
    if (redeclared) {
      this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
    }
  };
  pp$3.checkLocalExport = function(id) {
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };
  pp$3.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1];
  };
  pp$3.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1; ; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) {
        return scope;
      }
    }
  };
  pp$3.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1; ; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
        return scope;
      }
    }
  };
  var Node2 = function Node3(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations) {
      this.loc = new SourceLocation(parser, loc);
    }
    if (parser.options.directSourceFile) {
      this.sourceFile = parser.options.directSourceFile;
    }
    if (parser.options.ranges) {
      this.range = [pos, 0];
    }
  };
  var pp$2 = Parser.prototype;
  pp$2.startNode = function() {
    return new Node2(this, this.start, this.startLoc);
  };
  pp$2.startNodeAt = function(pos, loc) {
    return new Node2(this, pos, loc);
  };
  function finishNodeAt(node3, type, pos, loc) {
    node3.type = type;
    node3.end = pos;
    if (this.options.locations) {
      node3.loc.end = loc;
    }
    if (this.options.ranges) {
      node3.range[1] = pos;
    }
    return node3;
  }
  pp$2.finishNode = function(node3, type) {
    return finishNodeAt.call(this, node3, type, this.lastTokEnd, this.lastTokEndLoc);
  };
  pp$2.finishNodeAt = function(node3, type, pos, loc) {
    return finishNodeAt.call(this, node3, type, pos, loc);
  };
  pp$2.copyNode = function(node3) {
    var newNode = new Node2(this, node3.start, this.startLoc);
    for (var prop in node3) {
      newNode[prop] = node3[prop];
    }
    return newNode;
  };
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
  var ecma13BinaryProperties = ecma12BinaryProperties;
  var ecma14BinaryProperties = ecma13BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties,
    12: ecma12BinaryProperties,
    13: ecma13BinaryProperties,
    14: ecma14BinaryProperties
  };
  var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
  var unicodeBinaryPropertiesOfStrings = {
    9: "",
    10: "",
    11: "",
    12: "",
    13: "",
    14: ecma14BinaryPropertiesOfStrings
  };
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
  var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
  var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
  var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues,
    12: ecma12ScriptValues,
    13: ecma13ScriptValues,
    14: ecma14ScriptValues
  };
  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;
    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  for (i = 0, list4 = [9, 10, 11, 12, 13, 14]; i < list4.length; i += 1) {
    ecmaVersion = list4[i];
    buildUnicodeData(ecmaVersion);
  }
  var ecmaVersion;
  var i;
  var list4;
  var pp$1 = Parser.prototype;
  var BranchID = function BranchID2(parent, base) {
    this.parent = parent;
    this.base = base || this;
  };
  BranchID.prototype.separatedFrom = function separatedFrom(alt) {
    for (var self2 = this; self2; self2 = self2.parent) {
      for (var other = alt; other; other = other.parent) {
        if (self2.base === other.base && self2 !== other) {
          return true;
        }
      }
    }
    return false;
  };
  BranchID.prototype.sibling = function sibling() {
    return new BranchID(this.parent, this.base);
  };
  var RegExpValidationState = function RegExpValidationState2(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchV = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = /* @__PURE__ */ Object.create(null);
    this.backReferenceNames = [];
    this.branchID = null;
  };
  RegExpValidationState.prototype.reset = function reset(start2, pattern, flags) {
    var unicodeSets = flags.indexOf("v") !== -1;
    var unicode = flags.indexOf("u") !== -1;
    this.start = start2 | 0;
    this.source = pattern + "";
    this.flags = flags;
    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
      this.switchU = true;
      this.switchV = true;
      this.switchN = true;
    } else {
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchV = false;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    }
  };
  RegExpValidationState.prototype.raise = function raise(message) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
  };
  RegExpValidationState.prototype.at = function at(i, forceU) {
    if (forceU === void 0)
      forceU = false;
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1;
    }
    var c = s.charCodeAt(i);
    if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
      return c;
    }
    var next = s.charCodeAt(i + 1);
    return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
  };
  RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
    if (forceU === void 0)
      forceU = false;
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l;
    }
    var c = s.charCodeAt(i), next;
    if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
      return i + 1;
    }
    return i + 2;
  };
  RegExpValidationState.prototype.current = function current(forceU) {
    if (forceU === void 0)
      forceU = false;
    return this.at(this.pos, forceU);
  };
  RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
    if (forceU === void 0)
      forceU = false;
    return this.at(this.nextIndex(this.pos, forceU), forceU);
  };
  RegExpValidationState.prototype.advance = function advance(forceU) {
    if (forceU === void 0)
      forceU = false;
    this.pos = this.nextIndex(this.pos, forceU);
  };
  RegExpValidationState.prototype.eat = function eat(ch, forceU) {
    if (forceU === void 0)
      forceU = false;
    if (this.current(forceU) === ch) {
      this.advance(forceU);
      return true;
    }
    return false;
  };
  RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
    if (forceU === void 0)
      forceU = false;
    var pos = this.pos;
    for (var i = 0, list4 = chs; i < list4.length; i += 1) {
      var ch = list4[i];
      var current2 = this.at(pos, forceU);
      if (current2 === -1 || current2 !== ch) {
        return false;
      }
      pos = this.nextIndex(pos, forceU);
    }
    this.pos = pos;
    return true;
  };
  pp$1.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;
    var u = false;
    var v = false;
    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
      if (flag === "u") {
        u = true;
      }
      if (flag === "v") {
        v = true;
      }
    }
    if (this.options.ecmaVersion >= 15 && u && v) {
      this.raise(state.start, "Invalid regular expression flag");
    }
  };
  function hasProp(obj) {
    for (var _ in obj) {
      return true;
    }
    return false;
  }
  pp$1.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);
    if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };
  pp$1.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames = /* @__PURE__ */ Object.create(null);
    state.backReferenceNames.length = 0;
    state.branchID = null;
    this.regexp_disjunction(state);
    if (state.pos !== state.source.length) {
      if (state.eat(
        41
        /* ) */
      )) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(
        93
        /* ] */
      ) || state.eat(
        125
        /* } */
      )) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list4 = state.backReferenceNames; i < list4.length; i += 1) {
      var name2 = list4[i];
      if (!state.groupNames[name2]) {
        state.raise("Invalid named capture referenced");
      }
    }
  };
  pp$1.regexp_disjunction = function(state) {
    var trackDisjunction = this.options.ecmaVersion >= 16;
    if (trackDisjunction) {
      state.branchID = new BranchID(state.branchID, null);
    }
    this.regexp_alternative(state);
    while (state.eat(
      124
      /* | */
    )) {
      if (trackDisjunction) {
        state.branchID = state.branchID.sibling();
      }
      this.regexp_alternative(state);
    }
    if (trackDisjunction) {
      state.branchID = state.branchID.parent;
    }
    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(
      123
      /* { */
    )) {
      state.raise("Lone quantifier brackets");
    }
  };
  pp$1.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
    }
  };
  pp$1.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true;
    }
    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true;
    }
    return false;
  };
  pp$1.regexp_eatAssertion = function(state) {
    var start2 = state.pos;
    state.lastAssertionIsQuantifiable = false;
    if (state.eat(
      94
      /* ^ */
    ) || state.eat(
      36
      /* $ */
    )) {
      return true;
    }
    if (state.eat(
      92
      /* \ */
    )) {
      if (state.eat(
        66
        /* B */
      ) || state.eat(
        98
        /* b */
      )) {
        return true;
      }
      state.pos = start2;
    }
    if (state.eat(
      40
      /* ( */
    ) && state.eat(
      63
      /* ? */
    )) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(
          60
          /* < */
        );
      }
      if (state.eat(
        61
        /* = */
      ) || state.eat(
        33
        /* ! */
      )) {
        this.regexp_disjunction(state);
        if (!state.eat(
          41
          /* ) */
        )) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true;
      }
    }
    state.pos = start2;
    return false;
  };
  pp$1.regexp_eatQuantifier = function(state, noError) {
    if (noError === void 0)
      noError = false;
    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(
        63
        /* ? */
      );
      return true;
    }
    return false;
  };
  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
    return state.eat(
      42
      /* * */
    ) || state.eat(
      43
      /* + */
    ) || state.eat(
      63
      /* ? */
    ) || this.regexp_eatBracedQuantifier(state, noError);
  };
  pp$1.regexp_eatBracedQuantifier = function(state, noError) {
    var start2 = state.pos;
    if (state.eat(
      123
      /* { */
    )) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(
          44
          /* , */
        ) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(
          125
          /* } */
        )) {
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true;
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start2;
    }
    return false;
  };
  pp$1.regexp_eatAtom = function(state) {
    return this.regexp_eatPatternCharacters(state) || state.eat(
      46
      /* . */
    ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
  };
  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start2 = state.pos;
    if (state.eat(
      92
      /* \ */
    )) {
      if (this.regexp_eatAtomEscape(state)) {
        return true;
      }
      state.pos = start2;
    }
    return false;
  };
  pp$1.regexp_eatUncapturingGroup = function(state) {
    var start2 = state.pos;
    if (state.eat(
      40
      /* ( */
    )) {
      if (state.eat(
        63
        /* ? */
      ) && state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          return true;
        }
        state.raise("Unterminated group");
      }
      state.pos = start2;
    }
    return false;
  };
  pp$1.regexp_eatCapturingGroup = function(state) {
    if (state.eat(
      40
      /* ( */
    )) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 63) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        state.numCapturingParens += 1;
        return true;
      }
      state.raise("Unterminated group");
    }
    return false;
  };
  pp$1.regexp_eatExtendedAtom = function(state) {
    return state.eat(
      46
      /* . */
    ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
  };
  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false;
  };
  pp$1.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  function isSyntaxCharacter(ch) {
    return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
  }
  pp$1.regexp_eatPatternCharacters = function(state) {
    var start2 = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start2;
  };
  pp$1.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_groupSpecifier = function(state) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (!this.regexp_eatGroupName(state)) {
        state.raise("Invalid group");
      }
      var trackDisjunction = this.options.ecmaVersion >= 16;
      var known = state.groupNames[state.lastStringValue];
      if (known) {
        if (trackDisjunction) {
          for (var i = 0, list4 = known; i < list4.length; i += 1) {
            var altID = list4[i];
            if (!altID.separatedFrom(state.branchID)) {
              state.raise("Duplicate capture group name");
            }
          }
        } else {
          state.raise("Duplicate capture group name");
        }
      }
      if (trackDisjunction) {
        (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
      } else {
        state.groupNames[state.lastStringValue] = true;
      }
    }
  };
  pp$1.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(
      60
      /* < */
    )) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
        62
        /* > */
      )) {
        return true;
      }
      state.raise("Invalid capture group name");
    }
    return false;
  };
  pp$1.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true;
    }
    return false;
  };
  pp$1.regexp_eatRegExpIdentifierStart = function(state) {
    var start2 = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true;
    }
    state.pos = start2;
    return false;
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
  }
  pp$1.regexp_eatRegExpIdentifierPart = function(state) {
    var start2 = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true;
    }
    state.pos = start2;
    return false;
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
  }
  pp$1.regexp_eatAtomEscape = function(state) {
    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
      return true;
    }
    if (state.switchU) {
      if (state.current() === 99) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false;
  };
  pp$1.regexp_eatBackReference = function(state) {
    var start2 = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true;
      }
      if (n <= state.numCapturingParens) {
        return true;
      }
      state.pos = start2;
    }
    return false;
  };
  pp$1.regexp_eatKGroupName = function(state) {
    if (state.eat(
      107
      /* k */
    )) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true;
      }
      state.raise("Invalid named reference");
    }
    return false;
  };
  pp$1.regexp_eatCharacterEscape = function(state) {
    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
  };
  pp$1.regexp_eatCControlLetter = function(state) {
    var start2 = state.pos;
    if (state.eat(
      99
      /* c */
    )) {
      if (this.regexp_eatControlLetter(state)) {
        return true;
      }
      state.pos = start2;
    }
    return false;
  };
  pp$1.regexp_eatZero = function(state) {
    if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 116) {
      state.lastIntValue = 9;
      state.advance();
      return true;
    }
    if (ch === 110) {
      state.lastIntValue = 10;
      state.advance();
      return true;
    }
    if (ch === 118) {
      state.lastIntValue = 11;
      state.advance();
      return true;
    }
    if (ch === 102) {
      state.lastIntValue = 12;
      state.advance();
      return true;
    }
    if (ch === 114) {
      state.lastIntValue = 13;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 32;
      state.advance();
      return true;
    }
    return false;
  };
  function isControlLetter(ch) {
    return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
  }
  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if (forceU === void 0)
      forceU = false;
    var start2 = state.pos;
    var switchU = forceU || state.switchU;
    if (state.eat(
      117
      /* u */
    )) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 55296 && lead <= 56319) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(
            92
            /* \ */
          ) && state.eat(
            117
            /* u */
          ) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 56320 && trail <= 57343) {
              state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
              return true;
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true;
      }
      if (switchU && state.eat(
        123
        /* { */
      ) && this.regexp_eatHexDigits(state) && state.eat(
        125
        /* } */
      ) && isValidUnicode(state.lastIntValue)) {
        return true;
      }
      if (switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start2;
    }
    return false;
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 1114111;
  }
  pp$1.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true;
      }
      if (state.eat(
        47
        /* / */
      )) {
        state.lastIntValue = 47;
        return true;
      }
      return false;
    }
    var ch = state.current();
    if (ch !== 99 && (!state.switchN || ch !== 107)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 49 && ch <= 57) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
        state.advance();
      } while ((ch = state.current()) >= 48 && ch <= 57);
      return true;
    }
    return false;
  };
  var CharSetNone = 0;
  var CharSetOk = 1;
  var CharSetString = 2;
  pp$1.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();
    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return CharSetOk;
    }
    var negate = false;
    if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
      state.lastIntValue = -1;
      state.advance();
      var result;
      if (state.eat(
        123
        /* { */
      ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
        125
        /* } */
      )) {
        if (negate && result === CharSetString) {
          state.raise("Invalid property name");
        }
        return result;
      }
      state.raise("Invalid property name");
    }
    return CharSetNone;
  };
  function isCharacterClassEscape(ch) {
    return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
  }
  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start2 = state.pos;
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(
      61
      /* = */
    )) {
      var name2 = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name2, value);
        return CharSetOk;
      }
    }
    state.pos = start2;
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    }
    return CharSetNone;
  };
  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value) {
    if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
      state.raise("Invalid property name");
    }
    if (!state.unicodeProperties.nonBinary[name2].test(value)) {
      state.raise("Invalid property value");
    }
  };
  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (state.unicodeProperties.binary.test(nameOrValue)) {
      return CharSetOk;
    }
    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
      return CharSetString;
    }
    state.raise("Invalid property name");
  };
  pp$1.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 95;
  }
  pp$1.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
  }
  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state);
  };
  pp$1.regexp_eatCharacterClass = function(state) {
    if (state.eat(
      91
      /* [ */
    )) {
      var negate = state.eat(
        94
        /* ^ */
      );
      var result = this.regexp_classContents(state);
      if (!state.eat(
        93
        /* ] */
      )) {
        state.raise("Unterminated character class");
      }
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return true;
    }
    return false;
  };
  pp$1.regexp_classContents = function(state) {
    if (state.current() === 93) {
      return CharSetOk;
    }
    if (state.switchV) {
      return this.regexp_classSetExpression(state);
    }
    this.regexp_nonEmptyClassRanges(state);
    return CharSetOk;
  };
  pp$1.regexp_nonEmptyClassRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(
        45
        /* - */
      ) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };
  pp$1.regexp_eatClassAtom = function(state) {
    var start2 = state.pos;
    if (state.eat(
      92
      /* \ */
    )) {
      if (this.regexp_eatClassEscape(state)) {
        return true;
      }
      if (state.switchU) {
        var ch$1 = state.current();
        if (ch$1 === 99 || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start2;
    }
    var ch = state.current();
    if (ch !== 93) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatClassEscape = function(state) {
    var start2 = state.pos;
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    if (state.switchU && state.eat(
      45
      /* - */
    )) {
      state.lastIntValue = 45;
      return true;
    }
    if (!state.switchU && state.eat(
      99
      /* c */
    )) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true;
      }
      state.pos = start2;
    }
    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
  };
  pp$1.regexp_classSetExpression = function(state) {
    var result = CharSetOk, subResult;
    if (this.regexp_eatClassSetRange(state))
      ;
    else if (subResult = this.regexp_eatClassSetOperand(state)) {
      if (subResult === CharSetString) {
        result = CharSetString;
      }
      var start2 = state.pos;
      while (state.eatChars(
        [38, 38]
        /* && */
      )) {
        if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
          if (subResult !== CharSetString) {
            result = CharSetOk;
          }
          continue;
        }
        state.raise("Invalid character in character class");
      }
      if (start2 !== state.pos) {
        return result;
      }
      while (state.eatChars(
        [45, 45]
        /* -- */
      )) {
        if (this.regexp_eatClassSetOperand(state)) {
          continue;
        }
        state.raise("Invalid character in character class");
      }
      if (start2 !== state.pos) {
        return result;
      }
    } else {
      state.raise("Invalid character in character class");
    }
    for (; ; ) {
      if (this.regexp_eatClassSetRange(state)) {
        continue;
      }
      subResult = this.regexp_eatClassSetOperand(state);
      if (!subResult) {
        return result;
      }
      if (subResult === CharSetString) {
        result = CharSetString;
      }
    }
  };
  pp$1.regexp_eatClassSetRange = function(state) {
    var start2 = state.pos;
    if (this.regexp_eatClassSetCharacter(state)) {
      var left = state.lastIntValue;
      if (state.eat(
        45
        /* - */
      ) && this.regexp_eatClassSetCharacter(state)) {
        var right = state.lastIntValue;
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
        return true;
      }
      state.pos = start2;
    }
    return false;
  };
  pp$1.regexp_eatClassSetOperand = function(state) {
    if (this.regexp_eatClassSetCharacter(state)) {
      return CharSetOk;
    }
    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
  };
  pp$1.regexp_eatNestedClass = function(state) {
    var start2 = state.pos;
    if (state.eat(
      91
      /* [ */
    )) {
      var negate = state.eat(
        94
        /* ^ */
      );
      var result = this.regexp_classContents(state);
      if (state.eat(
        93
        /* ] */
      )) {
        if (negate && result === CharSetString) {
          state.raise("Negated character class may contain strings");
        }
        return result;
      }
      state.pos = start2;
    }
    if (state.eat(
      92
      /* \ */
    )) {
      var result$1 = this.regexp_eatCharacterClassEscape(state);
      if (result$1) {
        return result$1;
      }
      state.pos = start2;
    }
    return null;
  };
  pp$1.regexp_eatClassStringDisjunction = function(state) {
    var start2 = state.pos;
    if (state.eatChars(
      [92, 113]
      /* \q */
    )) {
      if (state.eat(
        123
        /* { */
      )) {
        var result = this.regexp_classStringDisjunctionContents(state);
        if (state.eat(
          125
          /* } */
        )) {
          return result;
        }
      } else {
        state.raise("Invalid escape");
      }
      state.pos = start2;
    }
    return null;
  };
  pp$1.regexp_classStringDisjunctionContents = function(state) {
    var result = this.regexp_classString(state);
    while (state.eat(
      124
      /* | */
    )) {
      if (this.regexp_classString(state) === CharSetString) {
        result = CharSetString;
      }
    }
    return result;
  };
  pp$1.regexp_classString = function(state) {
    var count = 0;
    while (this.regexp_eatClassSetCharacter(state)) {
      count++;
    }
    return count === 1 ? CharSetOk : CharSetString;
  };
  pp$1.regexp_eatClassSetCharacter = function(state) {
    var start2 = state.pos;
    if (state.eat(
      92
      /* \ */
    )) {
      if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
        return true;
      }
      if (state.eat(
        98
        /* b */
      )) {
        state.lastIntValue = 8;
        return true;
      }
      state.pos = start2;
      return false;
    }
    var ch = state.current();
    if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
      return false;
    }
    if (isClassSetSyntaxCharacter(ch)) {
      return false;
    }
    state.advance();
    state.lastIntValue = ch;
    return true;
  };
  function isClassSetReservedDoublePunctuatorCharacter(ch) {
    return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
  }
  function isClassSetSyntaxCharacter(ch) {
    return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
  }
  pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
    var ch = state.current();
    if (isClassSetReservedPunctuator(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  function isClassSetReservedPunctuator(ch) {
    return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
  }
  pp$1.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 95) {
      state.lastIntValue = ch % 32;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatHexEscapeSequence = function(state) {
    var start2 = state.pos;
    if (state.eat(
      120
      /* x */
    )) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true;
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start2;
    }
    return false;
  };
  pp$1.regexp_eatDecimalDigits = function(state) {
    var start2 = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    }
    return state.pos !== start2;
  };
  function isDecimalDigit(ch) {
    return ch >= 48 && ch <= 57;
  }
  pp$1.regexp_eatHexDigits = function(state) {
    var start2 = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start2;
  };
  function isHexDigit(ch) {
    return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
  }
  function hexToInt(ch) {
    if (ch >= 65 && ch <= 70) {
      return 10 + (ch - 65);
    }
    if (ch >= 97 && ch <= 102) {
      return 10 + (ch - 97);
    }
    return ch - 48;
  }
  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true;
    }
    return false;
  };
  pp$1.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 48;
      state.advance();
      return true;
    }
    state.lastIntValue = 0;
    return false;
  };
  function isOctalDigit(ch) {
    return ch >= 48 && ch <= 55;
  }
  pp$1.regexp_eatFixedHexDigits = function(state, length) {
    var start2 = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start2;
        return false;
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true;
  };
  var Token2 = function Token3(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations) {
      this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
    }
    if (p.options.ranges) {
      this.range = [p.start, p.end];
    }
  };
  var pp = Parser.prototype;
  pp.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
    }
    if (this.options.onToken) {
      this.options.onToken(new Token2(this));
    }
    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };
  pp.getToken = function() {
    this.next();
    return new Token2(this);
  };
  if (typeof Symbol !== "undefined") {
    pp[Symbol.iterator] = function() {
      var this$1$1 = this;
      return {
        next: function() {
          var token = this$1$1.getToken();
          return {
            done: token.type === types$1.eof,
            value: token
          };
        }
      };
    };
  }
  pp.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) {
      this.skipSpace();
    }
    this.start = this.pos;
    if (this.options.locations) {
      this.startLoc = this.curPosition();
    }
    if (this.pos >= this.input.length) {
      return this.finishToken(types$1.eof);
    }
    if (curContext.override) {
      return curContext.override(this);
    } else {
      this.readToken(this.fullCharCodeAtPos());
    }
  };
  pp.readToken = function(code2) {
    if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
      return this.readWord();
    }
    return this.getTokenFromCode(code2);
  };
  pp.fullCharCodeAtPos = function() {
    var code2 = this.input.charCodeAt(this.pos);
    if (code2 <= 55295 || code2 >= 56320) {
      return code2;
    }
    var next = this.input.charCodeAt(this.pos + 1);
    return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
  };
  pp.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start2 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) {
      this.raise(this.pos - 2, "Unterminated comment");
    }
    this.pos = end + 2;
    if (this.options.locations) {
      for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
        ++this.curLine;
        pos = this.lineStart = nextBreak;
      }
    }
    if (this.options.onComment) {
      this.options.onComment(
        true,
        this.input.slice(start2 + 2, end),
        start2,
        this.pos,
        startLoc,
        this.curPosition()
      );
    }
  };
  pp.skipLineComment = function(startSkip) {
    var start2 = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment) {
      this.options.onComment(
        false,
        this.input.slice(start2 + startSkip, this.pos),
        start2,
        this.pos,
        startLoc,
        this.curPosition()
      );
    }
  };
  pp.skipSpace = function() {
    loop:
      while (this.pos < this.input.length) {
        var ch = this.input.charCodeAt(this.pos);
        switch (ch) {
          case 32:
          case 160:
            ++this.pos;
            break;
          case 13:
            if (this.input.charCodeAt(this.pos + 1) === 10) {
              ++this.pos;
            }
          case 10:
          case 8232:
          case 8233:
            ++this.pos;
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            break;
          case 47:
            switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break loop;
            }
            break;
          default:
            if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
              ++this.pos;
            } else {
              break loop;
            }
        }
      }
  };
  pp.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) {
      this.endLoc = this.curPosition();
    }
    var prevType = this.type;
    this.type = type;
    this.value = val;
    this.updateContext(prevType);
  };
  pp.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) {
      return this.readNumber(true);
    }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
      this.pos += 3;
      return this.finishToken(types$1.ellipsis);
    } else {
      ++this.pos;
      return this.finishToken(types$1.dot);
    }
  };
  pp.readToken_slash = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) {
      ++this.pos;
      return this.readRegexp();
    }
    if (next === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(types$1.slash, 1);
  };
  pp.readToken_mult_modulo_exp = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
    if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
      ++size;
      tokentype = types$1.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }
    if (next === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(tokentype, size);
  };
  pp.readToken_pipe_amp = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code2) {
      if (this.options.ecmaVersion >= 12) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
    }
    if (next === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
  };
  pp.readToken_caret = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(types$1.bitwiseXOR, 1);
  };
  pp.readToken_plus_min = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code2) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(types$1.incDec, 2);
    }
    if (next === 61) {
      return this.finishOp(types$1.assign, 2);
    }
    return this.finishOp(types$1.plusMin, 1);
  };
  pp.readToken_lt_gt = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code2) {
      size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) {
        return this.finishOp(types$1.assign, size + 1);
      }
      return this.finishOp(types$1.bitShift, size);
    }
    if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }
    if (next === 61) {
      size = 2;
    }
    return this.finishOp(types$1.relational, size);
  };
  pp.readToken_eq_excl = function(code2) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) {
      return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
    }
    if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
      this.pos += 2;
      return this.finishToken(types$1.arrow);
    }
    return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
  };
  pp.readToken_question = function() {
    var ecmaVersion = this.options.ecmaVersion;
    if (ecmaVersion >= 11) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 46) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 < 48 || next2 > 57) {
          return this.finishOp(types$1.questionDot, 2);
        }
      }
      if (next === 63) {
        if (ecmaVersion >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61) {
            return this.finishOp(types$1.assign, 3);
          }
        }
        return this.finishOp(types$1.coalesce, 2);
      }
    }
    return this.finishOp(types$1.question, 1);
  };
  pp.readToken_numberSign = function() {
    var ecmaVersion = this.options.ecmaVersion;
    var code2 = 35;
    if (ecmaVersion >= 13) {
      ++this.pos;
      code2 = this.fullCharCodeAtPos();
      if (isIdentifierStart(code2, true) || code2 === 92) {
        return this.finishToken(types$1.privateId, this.readWord1());
      }
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
  };
  pp.getTokenFromCode = function(code2) {
    switch (code2) {
      case 46:
        return this.readToken_dot();
      case 40:
        ++this.pos;
        return this.finishToken(types$1.parenL);
      case 41:
        ++this.pos;
        return this.finishToken(types$1.parenR);
      case 59:
        ++this.pos;
        return this.finishToken(types$1.semi);
      case 44:
        ++this.pos;
        return this.finishToken(types$1.comma);
      case 91:
        ++this.pos;
        return this.finishToken(types$1.bracketL);
      case 93:
        ++this.pos;
        return this.finishToken(types$1.bracketR);
      case 123:
        ++this.pos;
        return this.finishToken(types$1.braceL);
      case 125:
        ++this.pos;
        return this.finishToken(types$1.braceR);
      case 58:
        ++this.pos;
        return this.finishToken(types$1.colon);
      case 96:
        if (this.options.ecmaVersion < 6) {
          break;
        }
        ++this.pos;
        return this.finishToken(types$1.backQuote);
      case 48:
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 120 || next === 88) {
          return this.readRadixNumber(16);
        }
        if (this.options.ecmaVersion >= 6) {
          if (next === 111 || next === 79) {
            return this.readRadixNumber(8);
          }
          if (next === 98 || next === 66) {
            return this.readRadixNumber(2);
          }
        }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.readNumber(false);
      case 34:
      case 39:
        return this.readString(code2);
      case 47:
        return this.readToken_slash();
      case 37:
      case 42:
        return this.readToken_mult_modulo_exp(code2);
      case 124:
      case 38:
        return this.readToken_pipe_amp(code2);
      case 94:
        return this.readToken_caret();
      case 43:
      case 45:
        return this.readToken_plus_min(code2);
      case 60:
      case 62:
        return this.readToken_lt_gt(code2);
      case 61:
      case 33:
        return this.readToken_eq_excl(code2);
      case 63:
        return this.readToken_question();
      case 126:
        return this.finishOp(types$1.prefix, 1);
      case 35:
        return this.readToken_numberSign();
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
  };
  pp.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str);
  };
  pp.readRegexp = function() {
    var escaped, inClass, start2 = this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length) {
        this.raise(start2, "Unterminated regular expression");
      }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) {
        this.raise(start2, "Unterminated regular expression");
      }
      if (!escaped) {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }
        escaped = ch === "\\";
      } else {
        escaped = false;
      }
      ++this.pos;
    }
    var pattern = this.input.slice(start2, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) {
      this.unexpected(flagsStart);
    }
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start2, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);
    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
    }
    return this.finishToken(types$1.regexp, { pattern, flags, value });
  };
  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
    var start2 = this.pos, total = 0, lastCode = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
      var code2 = this.input.charCodeAt(this.pos), val = void 0;
      if (allowSeparators && code2 === 95) {
        if (isLegacyOctalNumericLiteral) {
          this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
        }
        if (lastCode === 95) {
          this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
        }
        if (i === 0) {
          this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
        }
        lastCode = code2;
        continue;
      }
      if (code2 >= 97) {
        val = code2 - 97 + 10;
      } else if (code2 >= 65) {
        val = code2 - 65 + 10;
      } else if (code2 >= 48 && code2 <= 57) {
        val = code2 - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        break;
      }
      lastCode = code2;
      total = total * radix + val;
    }
    if (allowSeparators && lastCode === 95) {
      this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
    }
    if (this.pos === start2 || len != null && this.pos - start2 !== len) {
      return null;
    }
    return total;
  };
  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) {
      return parseInt(str, 8);
    }
    return parseFloat(str.replace(/_/g, ""));
  }
  function stringToBigInt(str) {
    if (typeof BigInt !== "function") {
      return null;
    }
    return BigInt(str.replace(/_/g, ""));
  }
  pp.readRadixNumber = function(radix) {
    var start2 = this.pos;
    this.pos += 2;
    var val = this.readInt(radix);
    if (val == null) {
      this.raise(this.start + 2, "Expected number in radix " + radix);
    }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start2, this.pos));
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val);
  };
  pp.readNumber = function(startsWithDot) {
    var start2 = this.pos;
    if (!startsWithDot && this.readInt(10, void 0, true) === null) {
      this.raise(start2, "Invalid number");
    }
    var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
    if (octal && this.strict) {
      this.raise(start2, "Invalid number");
    }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var val$1 = stringToBigInt(this.input.slice(start2, this.pos));
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$1.num, val$1);
    }
    if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
      octal = false;
    }
    if (next === 46 && !octal) {
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) {
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) {
        ++this.pos;
      }
      if (this.readInt(10) === null) {
        this.raise(start2, "Invalid number");
      }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    var val = stringToNumber(this.input.slice(start2, this.pos), octal);
    return this.finishToken(types$1.num, val);
  };
  pp.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code2;
    if (ch === 123) {
      if (this.options.ecmaVersion < 6) {
        this.unexpected();
      }
      var codePos = ++this.pos;
      code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code2 > 1114111) {
        this.invalidStringToken(codePos, "Code point out of bounds");
      }
    } else {
      code2 = this.readHexChar(4);
    }
    return code2;
  };
  pp.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length) {
        this.raise(this.start, "Unterminated string constant");
      }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) {
        break;
      }
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else if (ch === 8232 || ch === 8233) {
        if (this.options.ecmaVersion < 10) {
          this.raise(this.start, "Unterminated string constant");
        }
        ++this.pos;
        if (this.options.locations) {
          this.curLine++;
          this.lineStart = this.pos;
        }
      } else {
        if (isNewLine(ch)) {
          this.raise(this.start, "Unterminated string constant");
        }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types$1.string, out);
  };
  var INVALID_TEMPLATE_ESCAPE_ERROR = {};
  pp.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err;
      }
    }
    this.inTemplateElement = false;
  };
  pp.invalidStringToken = function(position4, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR;
    } else {
      this.raise(position4, message);
    }
  };
  pp.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length) {
        this.raise(this.start, "Unterminated template");
      }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types$1.dollarBraceL);
          } else {
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types$1.template, out);
      }
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };
  pp.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break;
        case "$":
          if (this.input[this.pos + 1] !== "{") {
            break;
          }
        case "`":
          return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
        case "\r":
          if (this.input[this.pos + 1] === "\n") {
            ++this.pos;
          }
        case "\n":
        case "\u2028":
        case "\u2029":
          ++this.curLine;
          this.lineStart = this.pos + 1;
          break;
      }
    }
    this.raise(this.start, "Unterminated template");
  };
  pp.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      case 117:
        return codePointToString(this.readCodePoint());
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      case 102:
        return "\f";
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) {
          ++this.pos;
        }
      case 10:
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      case 56:
      case 57:
        if (this.strict) {
          this.invalidStringToken(
            this.pos - 1,
            "Invalid escape sequence"
          );
        }
        if (inTemplate) {
          var codePos = this.pos - 1;
          this.invalidStringToken(
            codePos,
            "Invalid escape sequence in template string"
          );
        }
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          this.pos += octalStr.length - 1;
          ch = this.input.charCodeAt(this.pos);
          if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
            this.invalidStringToken(
              this.pos - 1 - octalStr.length,
              inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
            );
          }
          return String.fromCharCode(octal);
        }
        if (isNewLine(ch)) {
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        }
        return String.fromCharCode(ch);
    }
  };
  pp.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) {
      this.invalidStringToken(codePos, "Bad character escape sequence");
    }
    return n;
  };
  pp.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 65535 ? 1 : 2;
      } else if (ch === 92) {
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) {
          this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
        }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
          this.invalidStringToken(escStart, "Invalid Unicode escape");
        }
        word += codePointToString(esc);
        chunkStart = this.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos);
  };
  pp.readWord = function() {
    var word = this.readWord1();
    var type = types$1.name;
    if (this.keywords.test(word)) {
      type = keywords[word];
    }
    return this.finishToken(type, word);
  };
  var version = "8.12.1";
  Parser.acorn = {
    Parser,
    version,
    defaultOptions,
    Position: Position2,
    SourceLocation,
    getLineInfo,
    Node: Node2,
    TokenType,
    tokTypes: types$1,
    keywordTypes: keywords,
    TokContext,
    tokContexts: types,
    isIdentifierChar,
    isIdentifierStart,
    Token: Token2,
    isNewLine,
    lineBreak,
    lineBreakG,
    nonASCIIwhitespace
  };

  // node_modules/micromark-extension-mdxjs/index.js
  var import_acorn_jsx = __toESM(require_acorn_jsx(), 1);

  // node_modules/micromark-factory-mdx-expression/node_modules/micromark-util-character/index.js
  var asciiAlpha = regexCheck(/[A-Za-z]/);
  var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
  var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
  var asciiDigit = regexCheck(/\d/);
  var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
  var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
  function markdownLineEnding(code2) {
    return code2 !== null && code2 < -2;
  }
  var unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
  var unicodeWhitespace = regexCheck(/\s/);
  function regexCheck(regex) {
    return check;
    function check(code2) {
      return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
    }
  }

  // node_modules/estree-util-visit/lib/color.default.js
  function color(d) {
    return d;
  }

  // node_modules/estree-util-visit/lib/index.js
  var own = {}.hasOwnProperty;
  var CONTINUE = Symbol("continue");
  var EXIT = Symbol("exit");
  var SKIP = Symbol("skip");
  function visit(tree, visitor) {
    let enter;
    let leave;
    if (typeof visitor === "function") {
      enter = visitor;
    } else if (visitor && typeof visitor === "object") {
      if (visitor.enter)
        enter = visitor.enter;
      if (visitor.leave)
        leave = visitor.leave;
    }
    build(tree, void 0, void 0, [])();
    function build(node3, key, index4, parents) {
      if (nodelike(node3)) {
        visit4.displayName = "node (" + color(node3.type) + ")";
      }
      return visit4;
      function visit4() {
        const result = enter ? toResult(enter(node3, key, index4, parents)) : [];
        if (result[0] === EXIT) {
          return result;
        }
        if (result[0] !== SKIP) {
          let cKey;
          for (cKey in node3) {
            if (own.call(node3, cKey) && node3[cKey] && typeof node3[cKey] === "object" && // @ts-expect-error: custom esast extension.
            cKey !== "data" && // @ts-expect-error: custom esast extension.
            cKey !== "position") {
              const grandparents = parents.concat(node3);
              const value = node3[cKey];
              if (Array.isArray(value)) {
                const nodes = (
                  /** @type {Array<unknown>} */
                  value
                );
                let cIndex = 0;
                while (cIndex > -1 && cIndex < nodes.length) {
                  const subvalue = nodes[cIndex];
                  if (nodelike(subvalue)) {
                    const subresult = build(
                      subvalue,
                      cKey,
                      cIndex,
                      grandparents
                    )();
                    if (subresult[0] === EXIT)
                      return subresult;
                    cIndex = typeof subresult[1] === "number" ? subresult[1] : cIndex + 1;
                  } else {
                    cIndex++;
                  }
                }
              } else if (nodelike(value)) {
                const subresult = build(value, cKey, void 0, grandparents)();
                if (subresult[0] === EXIT)
                  return subresult;
              }
            }
          }
        }
        return leave ? toResult(leave(node3, key, index4, parents)) : result;
      }
    }
  }
  function toResult(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE, value];
    }
    return [value];
  }
  function nodelike(value) {
    return Boolean(
      value && typeof value === "object" && "type" in value && typeof value.type === "string" && value.type.length > 0
    );
  }

  // node_modules/micromark-util-events-to-acorn/index.js
  function eventsToAcorn(events, options) {
    const prefix = options.prefix || "";
    const suffix = options.suffix || "";
    const acornOptions = Object.assign({}, options.acornOptions);
    const comments = [];
    const tokens = [];
    const onComment = acornOptions.onComment;
    const onToken = acornOptions.onToken;
    let swallow = false;
    let estree;
    let exception;
    const acornConfig = Object.assign({}, acornOptions, {
      onComment: comments,
      preserveParens: true
    });
    if (onToken) {
      acornConfig.onToken = tokens;
    }
    const collection = collect(events, options.tokenTypes);
    const source = collection.value;
    const value = prefix + source + suffix;
    const isEmptyExpression = options.expression && empty2(source);
    if (isEmptyExpression && !options.allowEmpty) {
      throw new VFileMessage("Unexpected empty expression", {
        place: parseOffsetToUnistPoint(0),
        ruleId: "unexpected-empty-expression",
        source: "micromark-extension-mdx-expression"
      });
    }
    try {
      estree = options.expression && !isEmptyExpression ? options.acorn.parseExpressionAt(value, 0, acornConfig) : options.acorn.parse(value, acornConfig);
    } catch (error_) {
      const error = (
        /** @type {AcornError} */
        error_
      );
      const point5 = parseOffsetToUnistPoint(error.pos);
      error.message = String(error.message).replace(/ \(\d+:\d+\)$/, "");
      error.pos = point5.offset;
      error.loc = {
        line: point5.line,
        column: point5.column - 1
      };
      exception = error;
      swallow = error.raisedAt >= prefix.length + source.length || // Broken comments are raised at their start, not their end.
      error.message === "Unterminated comment";
    }
    if (estree && options.expression && !isEmptyExpression) {
      if (empty2(value.slice(estree.end, value.length - suffix.length))) {
        estree = {
          type: "Program",
          start: 0,
          end: prefix.length + source.length,
          // @ts-expect-error: It’s good.
          body: [{
            type: "ExpressionStatement",
            expression: estree,
            start: 0,
            end: prefix.length + source.length
          }],
          sourceType: "module",
          comments: []
        };
      } else {
        const point5 = parseOffsetToUnistPoint(estree.end);
        const error = (
          /** @type {AcornError} */
          new Error("Unexpected content after expression")
        );
        error.pos = point5.offset;
        error.loc = {
          line: point5.line,
          column: point5.column - 1
        };
        exception = error;
        estree = void 0;
      }
    }
    if (estree) {
      estree.comments = comments;
      visit(estree, function(esnode, field, index4, parents) {
        let context = (
          /** @type {AcornNode | Array<AcornNode>} */
          parents[parents.length - 1]
        );
        let prop = field;
        if (esnode.type === "ParenthesizedExpression" && context && prop) {
          if (typeof index4 === "number") {
            context = context[prop];
            prop = index4;
          }
          context[prop] = esnode.expression;
        }
        fixPosition(esnode);
      });
      if (Array.isArray(onComment)) {
        onComment.push(...comments);
      } else if (typeof onComment === "function") {
        for (const comment of comments) {
          onComment(comment.type === "Block", comment.value, comment.start, comment.end, comment.loc.start, comment.loc.end);
        }
      }
      for (const token of tokens) {
        if (token.end <= prefix.length || token.start - prefix.length >= source.length) {
          continue;
        }
        fixPosition(token);
        if (Array.isArray(onToken)) {
          onToken.push(token);
        } else {
          onToken(token);
        }
      }
    }
    return {
      estree,
      error: exception,
      swallow
    };
    function fixPosition(nodeOrToken) {
      const pointStart = parseOffsetToUnistPoint(nodeOrToken.start);
      const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end);
      nodeOrToken.start = pointStart.offset;
      nodeOrToken.end = pointEnd.offset;
      nodeOrToken.loc = {
        start: {
          line: pointStart.line,
          column: pointStart.column - 1,
          offset: pointStart.offset
        },
        end: {
          line: pointEnd.line,
          column: pointEnd.column - 1,
          offset: pointEnd.offset
        }
      };
      nodeOrToken.range = [nodeOrToken.start, nodeOrToken.end];
    }
    function parseOffsetToUnistPoint(acornOffset) {
      let sourceOffset = acornOffset - prefix.length;
      if (sourceOffset < 0) {
        sourceOffset = 0;
      } else if (sourceOffset > source.length) {
        sourceOffset = source.length;
      }
      let point5 = relativeToPoint(collection.stops, sourceOffset);
      if (!point5) {
        point5 = {
          line: options.start.line,
          column: options.start.column,
          offset: options.start.offset
        };
      }
      return point5;
    }
  }
  function empty2(value) {
    return /^\s*$/.test(value.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
  }
  function collect(events, tokenTypes) {
    const result = {
      value: "",
      stops: []
    };
    let index4 = -1;
    while (++index4 < events.length) {
      const event = events[index4];
      if (event[0] === "enter") {
        const type = event[1].type;
        if (type === "lineEnding" || tokenTypes.includes(type)) {
          const chunks = event[2].sliceStream(event[1]);
          while (chunks.length > 0 && chunks[0] === -1) {
            chunks.shift();
          }
          const value = serializeChunks(chunks);
          result.stops.push([result.value.length, event[1].start]);
          result.value += value;
          result.stops.push([result.value.length, event[1].end]);
        }
      }
    }
    return result;
  }
  function relativeToPoint(stops, relative3) {
    let index4 = 0;
    while (index4 < stops.length && stops[index4][0] <= relative3) {
      index4 += 1;
    }
    if (index4 === 0) {
      return void 0;
    }
    const [stopRelative, stopAbsolute] = stops[index4 - 1];
    const rest = relative3 - stopRelative;
    return {
      line: stopAbsolute.line,
      column: stopAbsolute.column + rest,
      offset: stopAbsolute.offset + rest
    };
  }
  function serializeChunks(chunks) {
    let index4 = -1;
    const result = [];
    let atTab;
    while (++index4 < chunks.length) {
      const chunk = chunks[index4];
      let value;
      if (typeof chunk === "string") {
        value = chunk;
      } else
        switch (chunk) {
          case -5: {
            value = "\r";
            break;
          }
          case -4: {
            value = "\n";
            break;
          }
          case -3: {
            value = "\r\n";
            break;
          }
          case -2: {
            value = "	";
            break;
          }
          case -1: {
            if (atTab)
              continue;
            value = " ";
            break;
          }
          default: {
            value = String.fromCharCode(chunk);
          }
        }
      atTab = chunk === -2;
      result.push(value);
    }
    return result.join("");
  }

  // node_modules/micromark-factory-mdx-expression/node_modules/unist-util-position-from-estree/lib/index.js
  function positionFromEstree(node3) {
    const nodeLike = node3 || {};
    const loc = nodeLike.loc || {};
    const range = nodeLike.range || [void 0, void 0];
    const start2 = pointOrUndefined(loc.start, range[0] || nodeLike.start);
    const end = pointOrUndefined(loc.end, range[1] || nodeLike.end);
    if (start2 && end) {
      return { start: start2, end };
    }
  }
  function pointOrUndefined(estreePoint, estreeOffset) {
    if (estreePoint && typeof estreePoint === "object") {
      const line = "line" in estreePoint ? numberOrUndefined(estreePoint.line) : void 0;
      const column = "column" in estreePoint ? numberOrUndefined(estreePoint.column) : void 0;
      if (line && column !== void 0) {
        return {
          line,
          column: column + 1,
          offset: numberOrUndefined(estreeOffset)
        };
      }
    }
  }
  function numberOrUndefined(value) {
    return typeof value === "number" && value > -1 ? value : void 0;
  }

  // node_modules/micromark-factory-mdx-expression/index.js
  var trouble = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression";
  var unexpectedEofHash = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-";
  var unexpectedLazyHash = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed";
  var nonSpreadHash = "#unexpected-type-in-code-expected-an-object-spread-spread";
  var spreadExtraHash = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported";
  var acornHash = "#could-not-parse-expression-with-acorn";
  function factoryMdxExpression(effects, ok3, type, markerType, chunkType, acorn, acornOptions, addResult, spread, allowEmpty, allowLazy) {
    const self2 = this;
    const eventStart = this.events.length + 3;
    let size = 0;
    let pointStart;
    let lastCrash;
    return start2;
    function start2(code2) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      pointStart = self2.now();
      return before;
    }
    function before(code2) {
      if (code2 === null) {
        if (lastCrash)
          throw lastCrash;
        const error = new VFileMessage(
          "Unexpected end of file in expression, expected a corresponding closing brace for `{`",
          {
            place: self2.now(),
            ruleId: "unexpected-eof",
            source: "micromark-extension-mdx-expression"
          }
        );
        error.url = trouble + unexpectedEofHash;
        throw error;
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return eolAfter;
      }
      if (code2 === 125 && size === 0) {
        const next = acorn ? mdxExpressionParse.call(
          self2,
          acorn,
          acornOptions,
          chunkType,
          eventStart,
          pointStart,
          allowEmpty || false,
          spread || false
        ) : {
          type: "ok",
          estree: void 0
        };
        if (next.type === "ok") {
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          const token = effects.exit(type);
          if (addResult && next.estree) {
            Object.assign(token, {
              estree: next.estree
            });
          }
          return ok3;
        }
        lastCrash = next.message;
        effects.enter(chunkType);
        effects.consume(code2);
        return inside;
      }
      effects.enter(chunkType);
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === 125 && size === 0 || code2 === null || markdownLineEnding(code2)) {
        effects.exit(chunkType);
        return before(code2);
      }
      if (code2 === 123 && !acorn) {
        size += 1;
      } else if (code2 === 125) {
        size -= 1;
      }
      effects.consume(code2);
      return inside;
    }
    function eolAfter(code2) {
      const now = self2.now();
      if (now.line !== pointStart.line && !allowLazy && self2.parser.lazy[now.line]) {
        const error = new VFileMessage(
          "Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
          {
            place: self2.now(),
            ruleId: "unexpected-lazy",
            source: "micromark-extension-mdx-expression"
          }
        );
        error.url = trouble + unexpectedLazyHash;
        throw error;
      }
      return before(code2);
    }
  }
  function mdxExpressionParse(acorn, acornOptions, chunkType, eventStart, pointStart, allowEmpty, spread) {
    const result = eventsToAcorn(this.events.slice(eventStart), {
      acorn,
      tokenTypes: [chunkType],
      acornOptions,
      start: pointStart,
      expression: true,
      allowEmpty,
      prefix: spread ? "({" : "",
      suffix: spread ? "})" : ""
    });
    const estree = result.estree;
    if (spread && estree) {
      const head = estree.body[0];
      if (head.type !== "ExpressionStatement" || head.expression.type !== "ObjectExpression") {
        const place = positionFromEstree(head);
        const error = new VFileMessage(
          "Unexpected `" + head.type + "` in code: expected an object spread (`{...spread}`)",
          {
            place: place.start,
            ruleId: "non-spread",
            source: "micromark-extension-mdx-expression"
          }
        );
        error.url = trouble + nonSpreadHash;
        throw error;
      }
      if (head.expression.properties[1]) {
        const place = positionFromEstree(head.expression.properties[1]);
        const error = new VFileMessage(
          "Unexpected extra content in spread: only a single spread is supported",
          {
            place: place.start,
            ruleId: "spread-extra",
            source: "micromark-extension-mdx-expression"
          }
        );
        error.url = trouble + spreadExtraHash;
        throw error;
      }
      if (head.expression.properties[0] && head.expression.properties[0].type !== "SpreadElement") {
        const place = positionFromEstree(head.expression.properties[0]);
        const error = new VFileMessage(
          "Unexpected `" + head.expression.properties[0].type + "` in code: only spread elements are supported",
          {
            place: place.start,
            ruleId: "non-spread",
            source: "micromark-extension-mdx-expression"
          }
        );
        error.url = trouble + nonSpreadHash;
        throw error;
      }
    }
    if (result.error) {
      const error = new VFileMessage("Could not parse expression with acorn", {
        cause: result.error,
        place: {
          line: result.error.loc.line,
          column: result.error.loc.column + 1,
          offset: result.error.pos
        },
        ruleId: "acorn",
        source: "micromark-extension-mdx-expression"
      });
      error.url = trouble + acornHash;
      return {
        type: "nok",
        message: error
      };
    }
    return {
      type: "ok",
      estree
    };
  }

  // node_modules/micromark-extension-mdx-expression/node_modules/micromark-util-character/index.js
  var asciiAlpha2 = regexCheck2(/[A-Za-z]/);
  var asciiAlphanumeric2 = regexCheck2(/[\dA-Za-z]/);
  var asciiAtext2 = regexCheck2(/[#-'*+\--9=?A-Z^-~]/);
  var asciiDigit2 = regexCheck2(/\d/);
  var asciiHexDigit2 = regexCheck2(/[\dA-Fa-f]/);
  var asciiPunctuation2 = regexCheck2(/[!-/:-@[-`{-~]/);
  function markdownLineEnding2(code2) {
    return code2 !== null && code2 < -2;
  }
  function markdownSpace(code2) {
    return code2 === -2 || code2 === -1 || code2 === 32;
  }
  var unicodePunctuation2 = regexCheck2(/\p{P}|\p{S}/u);
  var unicodeWhitespace2 = regexCheck2(/\s/);
  function regexCheck2(regex) {
    return check;
    function check(code2) {
      return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
    }
  }

  // node_modules/micromark-extension-mdx-expression/node_modules/micromark-factory-space/index.js
  function factorySpace(effects, ok3, type, max) {
    const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
    let size = 0;
    return start2;
    function start2(code2) {
      if (markdownSpace(code2)) {
        effects.enter(type);
        return prefix(code2);
      }
      return ok3(code2);
    }
    function prefix(code2) {
      if (markdownSpace(code2) && size++ < limit) {
        effects.consume(code2);
        return prefix;
      }
      effects.exit(type);
      return ok3(code2);
    }
  }

  // node_modules/micromark-extension-mdx-expression/lib/syntax.js
  function mdxExpression(options) {
    const options_ = options || {};
    const addResult = options_.addResult;
    const acorn = options_.acorn;
    const spread = options_.spread;
    let allowEmpty = options_.allowEmpty;
    let acornOptions;
    if (allowEmpty === null || allowEmpty === void 0) {
      allowEmpty = true;
    }
    if (acorn) {
      if (!acorn.parseExpressionAt) {
        throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
      }
      acornOptions = Object.assign({
        ecmaVersion: 2024,
        sourceType: "module"
      }, options_.acornOptions);
    } else if (options_.acornOptions || options_.addResult) {
      throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
    }
    return {
      flow: {
        [123]: {
          name: "mdxFlowExpression",
          tokenize: tokenizeFlowExpression,
          concrete: true
        }
      },
      text: {
        [123]: {
          name: "mdxTextExpression",
          tokenize: tokenizeTextExpression
        }
      }
    };
    function tokenizeFlowExpression(effects, ok3, nok) {
      const self2 = this;
      return start2;
      function start2(code2) {
        return before(code2);
      }
      function before(code2) {
        return factoryMdxExpression.call(self2, effects, after, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", acorn, acornOptions, addResult, spread, allowEmpty)(code2);
      }
      function after(code2) {
        return markdownSpace(code2) ? factorySpace(effects, end, "whitespace")(code2) : end(code2);
      }
      function end(code2) {
        const lessThanValue = self2.parser.constructs.flow[60];
        const constructs3 = Array.isArray(lessThanValue) ? lessThanValue : (
          /* c8 ignore next 3 -- always a list when normalized. */
          lessThanValue ? [lessThanValue] : []
        );
        const jsxTag = constructs3.find(function(d) {
          return d.name === "mdxJsxFlowTag";
        });
        if (code2 === 60 && jsxTag) {
          return effects.attempt(jsxTag, end, nok)(code2);
        }
        return code2 === null || markdownLineEnding2(code2) ? ok3(code2) : nok(code2);
      }
    }
    function tokenizeTextExpression(effects, ok3) {
      const self2 = this;
      return start2;
      function start2(code2) {
        return factoryMdxExpression.call(self2, effects, ok3, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", acorn, acornOptions, addResult, spread, allowEmpty, true)(code2);
      }
    }
  }

  // node_modules/micromark-extension-mdx-jsx/node_modules/estree-util-is-identifier-name/lib/index.js
  var startRe = /[$_\p{ID_Start}]/u;
  var contRe = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u;
  var contReJsx = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u;
  var emptyOptions = {};
  function start(code2) {
    return code2 ? startRe.test(String.fromCodePoint(code2)) : false;
  }
  function cont(code2, options) {
    const settings = options || emptyOptions;
    const re = settings.jsx ? contReJsx : contRe;
    return code2 ? re.test(String.fromCodePoint(code2)) : false;
  }

  // node_modules/micromark-extension-mdx-jsx/node_modules/micromark-util-character/index.js
  var asciiAlpha3 = regexCheck3(/[A-Za-z]/);
  var asciiAlphanumeric3 = regexCheck3(/[\dA-Za-z]/);
  var asciiAtext3 = regexCheck3(/[#-'*+\--9=?A-Z^-~]/);
  var asciiDigit3 = regexCheck3(/\d/);
  var asciiHexDigit3 = regexCheck3(/[\dA-Fa-f]/);
  var asciiPunctuation3 = regexCheck3(/[!-/:-@[-`{-~]/);
  function markdownLineEnding3(code2) {
    return code2 !== null && code2 < -2;
  }
  function markdownLineEndingOrSpace(code2) {
    return code2 !== null && (code2 < 0 || code2 === 32);
  }
  function markdownSpace2(code2) {
    return code2 === -2 || code2 === -1 || code2 === 32;
  }
  var unicodePunctuation3 = regexCheck3(/\p{P}|\p{S}/u);
  var unicodeWhitespace3 = regexCheck3(/\s/);
  function regexCheck3(regex) {
    return check;
    function check(code2) {
      return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
    }
  }

  // node_modules/micromark-extension-mdx-jsx/lib/factory-tag.js
  var trouble2 = "https://github.com/micromark/micromark-extension-mdx-jsx";
  function factoryTag(effects, ok3, nok, acorn, acornOptions, addResult, allowLazy, tagType, tagMarkerType, tagClosingMarkerType, tagSelfClosingMarker, tagNameType, tagNamePrimaryType, tagNameMemberMarkerType, tagNameMemberType, tagNamePrefixMarkerType, tagNameLocalType, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, tagAttributeType, tagAttributeNameType, tagAttributeNamePrimaryType, tagAttributeNamePrefixMarkerType, tagAttributeNameLocalType, tagAttributeInitializerMarkerType, tagAttributeValueLiteralType, tagAttributeValueLiteralMarkerType, tagAttributeValueLiteralValueType, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionValueType) {
    const self2 = this;
    let returnState;
    let marker;
    return start2;
    function start2(code2) {
      effects.enter(tagType);
      effects.enter(tagMarkerType);
      effects.consume(code2);
      effects.exit(tagMarkerType);
      return startAfter;
    }
    function startAfter(code2) {
      if (markdownLineEndingOrSpace(code2)) {
        return nok(code2);
      }
      returnState = nameBefore;
      return esWhitespaceStart(code2);
    }
    function nameBefore(code2) {
      if (code2 === 47) {
        effects.enter(tagClosingMarkerType);
        effects.consume(code2);
        effects.exit(tagClosingMarkerType);
        returnState = closingTagNameBefore;
        return esWhitespaceStart;
      }
      if (code2 === 62) {
        return tagEnd(code2);
      }
      if (code2 !== null && code2 >= 0 && start(code2)) {
        effects.enter(tagNameType);
        effects.enter(tagNamePrimaryType);
        effects.consume(code2);
        return primaryName;
      }
      crash(code2, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (code2 === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : ""));
    }
    function closingTagNameBefore(code2) {
      if (code2 === 62) {
        return tagEnd(code2);
      }
      if (code2 !== null && code2 >= 0 && start(code2)) {
        effects.enter(tagNameType);
        effects.enter(tagNamePrimaryType);
        effects.consume(code2);
        return primaryName;
      }
      crash(code2, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (code2 === 42 || code2 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
    }
    function primaryName(code2) {
      if (code2 !== null && code2 >= 0 && cont(code2, {
        jsx: true
      })) {
        effects.consume(code2);
        return primaryName;
      }
      if (code2 === 46 || code2 === 47 || code2 === 58 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace3(code2)) {
        effects.exit(tagNamePrimaryType);
        returnState = primaryNameAfter;
        return esWhitespaceStart(code2);
      }
      crash(code2, "in name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code2 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
    }
    function primaryNameAfter(code2) {
      if (code2 === 46) {
        effects.enter(tagNameMemberMarkerType);
        effects.consume(code2);
        effects.exit(tagNameMemberMarkerType);
        returnState = memberNameBefore;
        return esWhitespaceStart;
      }
      if (code2 === 58) {
        effects.enter(tagNamePrefixMarkerType);
        effects.consume(code2);
        effects.exit(tagNamePrefixMarkerType);
        returnState = localNameBefore;
        return esWhitespaceStart;
      }
      if (code2 === 47 || code2 === 62 || code2 === 123 || code2 !== null && code2 >= 0 && start(code2)) {
        effects.exit(tagNameType);
        return attributeBefore(code2);
      }
      crash(code2, "after name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
    }
    function memberNameBefore(code2) {
      if (code2 !== null && code2 >= 0 && start(code2)) {
        effects.enter(tagNameMemberType);
        effects.consume(code2);
        return memberName;
      }
      crash(code2, "before member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
    }
    function memberName(code2) {
      if (code2 !== null && code2 >= 0 && cont(code2, {
        jsx: true
      })) {
        effects.consume(code2);
        return memberName;
      }
      if (code2 === 46 || code2 === 47 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace3(code2)) {
        effects.exit(tagNameMemberType);
        returnState = memberNameAfter;
        return esWhitespaceStart(code2);
      }
      crash(code2, "in member name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code2 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
    }
    function memberNameAfter(code2) {
      if (code2 === 46) {
        effects.enter(tagNameMemberMarkerType);
        effects.consume(code2);
        effects.exit(tagNameMemberMarkerType);
        returnState = memberNameBefore;
        return esWhitespaceStart;
      }
      if (code2 === 47 || code2 === 62 || code2 === 123 || code2 !== null && code2 >= 0 && start(code2)) {
        effects.exit(tagNameType);
        return attributeBefore(code2);
      }
      crash(code2, "after member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
    }
    function localNameBefore(code2) {
      if (code2 !== null && code2 >= 0 && start(code2)) {
        effects.enter(tagNameLocalType);
        effects.consume(code2);
        return localName;
      }
      crash(code2, "before local name", "a character that can start a name, such as a letter, `$`, or `_`" + (code2 === 43 || code2 !== null && code2 > 46 && code2 < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
    }
    function localName(code2) {
      if (code2 !== null && code2 >= 0 && cont(code2, {
        jsx: true
      })) {
        effects.consume(code2);
        return localName;
      }
      if (code2 === 47 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace3(code2)) {
        effects.exit(tagNameLocalType);
        returnState = localNameAfter;
        return esWhitespaceStart(code2);
      }
      crash(code2, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag");
    }
    function localNameAfter(code2) {
      if (code2 === 47 || code2 === 62 || code2 === 123 || code2 !== null && code2 >= 0 && start(code2)) {
        effects.exit(tagNameType);
        return attributeBefore(code2);
      }
      crash(code2, "after local name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
    }
    function attributeBefore(code2) {
      if (code2 === 47) {
        effects.enter(tagSelfClosingMarker);
        effects.consume(code2);
        effects.exit(tagSelfClosingMarker);
        returnState = selfClosing;
        return esWhitespaceStart;
      }
      if (code2 === 62) {
        return tagEnd(code2);
      }
      if (code2 === 123) {
        return factoryMdxExpression.call(self2, effects, attributeExpressionAfter, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, acorn, acornOptions, addResult, true, false, allowLazy)(code2);
      }
      if (code2 !== null && code2 >= 0 && start(code2)) {
        effects.enter(tagAttributeType);
        effects.enter(tagAttributeNameType);
        effects.enter(tagAttributeNamePrimaryType);
        effects.consume(code2);
        return attributePrimaryName;
      }
      crash(code2, "before attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
    }
    function attributeExpressionAfter(code2) {
      returnState = attributeBefore;
      return esWhitespaceStart(code2);
    }
    function attributePrimaryName(code2) {
      if (code2 !== null && code2 >= 0 && cont(code2, {
        jsx: true
      })) {
        effects.consume(code2);
        return attributePrimaryName;
      }
      if (code2 === 47 || code2 === 58 || code2 === 61 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace3(code2)) {
        effects.exit(tagAttributeNamePrimaryType);
        returnState = attributePrimaryNameAfter;
        return esWhitespaceStart(code2);
      }
      crash(code2, "in attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
    }
    function attributePrimaryNameAfter(code2) {
      if (code2 === 58) {
        effects.enter(tagAttributeNamePrefixMarkerType);
        effects.consume(code2);
        effects.exit(tagAttributeNamePrefixMarkerType);
        returnState = attributeLocalNameBefore;
        return esWhitespaceStart;
      }
      if (code2 === 61) {
        effects.exit(tagAttributeNameType);
        effects.enter(tagAttributeInitializerMarkerType);
        effects.consume(code2);
        effects.exit(tagAttributeInitializerMarkerType);
        returnState = attributeValueBefore;
        return esWhitespaceStart;
      }
      if (code2 === 47 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace3(code2) || code2 !== null && code2 >= 0 && start(code2)) {
        effects.exit(tagAttributeNameType);
        effects.exit(tagAttributeType);
        returnState = attributeBefore;
        return esWhitespaceStart(code2);
      }
      crash(code2, "after attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
    }
    function attributeLocalNameBefore(code2) {
      if (code2 !== null && code2 >= 0 && start(code2)) {
        effects.enter(tagAttributeNameLocalType);
        effects.consume(code2);
        return attributeLocalName;
      }
      crash(code2, "before local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
    }
    function attributeLocalName(code2) {
      if (code2 !== null && code2 >= 0 && cont(code2, {
        jsx: true
      })) {
        effects.consume(code2);
        return attributeLocalName;
      }
      if (code2 === 47 || code2 === 61 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace3(code2)) {
        effects.exit(tagAttributeNameLocalType);
        effects.exit(tagAttributeNameType);
        returnState = attributeLocalNameAfter;
        return esWhitespaceStart(code2);
      }
      crash(code2, "in local attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
    }
    function attributeLocalNameAfter(code2) {
      if (code2 === 61) {
        effects.enter(tagAttributeInitializerMarkerType);
        effects.consume(code2);
        effects.exit(tagAttributeInitializerMarkerType);
        returnState = attributeValueBefore;
        return esWhitespaceStart;
      }
      if (code2 === 47 || code2 === 62 || code2 === 123 || code2 !== null && code2 >= 0 && start(code2)) {
        effects.exit(tagAttributeType);
        return attributeBefore(code2);
      }
      crash(code2, "after local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
    }
    function attributeValueBefore(code2) {
      if (code2 === 34 || code2 === 39) {
        effects.enter(tagAttributeValueLiteralType);
        effects.enter(tagAttributeValueLiteralMarkerType);
        effects.consume(code2);
        effects.exit(tagAttributeValueLiteralMarkerType);
        marker = code2;
        return attributeValueQuotedStart;
      }
      if (code2 === 123) {
        return factoryMdxExpression.call(self2, effects, attributeValueExpressionAfter, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionValueType, acorn, acornOptions, addResult, false, false, allowLazy)(code2);
      }
      crash(code2, "before attribute value", "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (code2 === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : ""));
    }
    function attributeValueExpressionAfter(code2) {
      effects.exit(tagAttributeType);
      returnState = attributeBefore;
      return esWhitespaceStart(code2);
    }
    function attributeValueQuotedStart(code2) {
      if (code2 === null) {
        crash(code2, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(marker) + "`");
      }
      if (code2 === marker) {
        effects.enter(tagAttributeValueLiteralMarkerType);
        effects.consume(code2);
        effects.exit(tagAttributeValueLiteralMarkerType);
        effects.exit(tagAttributeValueLiteralType);
        effects.exit(tagAttributeType);
        marker = void 0;
        returnState = attributeBefore;
        return esWhitespaceStart;
      }
      if (markdownLineEnding3(code2)) {
        returnState = attributeValueQuotedStart;
        return esWhitespaceStart(code2);
      }
      effects.enter(tagAttributeValueLiteralValueType);
      return attributeValueQuoted(code2);
    }
    function attributeValueQuoted(code2) {
      if (code2 === null || code2 === marker || markdownLineEnding3(code2)) {
        effects.exit(tagAttributeValueLiteralValueType);
        return attributeValueQuotedStart(code2);
      }
      effects.consume(code2);
      return attributeValueQuoted;
    }
    function selfClosing(code2) {
      if (code2 === 62) {
        return tagEnd(code2);
      }
      crash(code2, "after self-closing slash", "`>` to end the tag" + (code2 === 42 || code2 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
    }
    function tagEnd(code2) {
      effects.enter(tagMarkerType);
      effects.consume(code2);
      effects.exit(tagMarkerType);
      effects.exit(tagType);
      return ok3;
    }
    function esWhitespaceStart(code2) {
      if (markdownLineEnding3(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return esWhitespaceEolAfter;
      }
      if (markdownSpace2(code2) || unicodeWhitespace3(code2)) {
        effects.enter("esWhitespace");
        return esWhitespaceInside(code2);
      }
      return returnState(code2);
    }
    function esWhitespaceInside(code2) {
      if (markdownLineEnding3(code2)) {
        effects.exit("esWhitespace");
        return esWhitespaceStart(code2);
      }
      if (markdownSpace2(code2) || unicodeWhitespace3(code2)) {
        effects.consume(code2);
        return esWhitespaceInside;
      }
      effects.exit("esWhitespace");
      return returnState(code2);
    }
    function esWhitespaceEolAfter(code2) {
      if (!allowLazy && self2.parser.lazy[self2.now().line]) {
        const error = new VFileMessage("Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", self2.now(), "micromark-extension-mdx-jsx:unexpected-lazy");
        error.url = trouble2 + "#unexpected-lazy-line-in-container-expected-line-to-be";
        throw error;
      }
      return esWhitespaceStart(code2);
    }
    function crash(code2, at2, expect) {
      const error = new VFileMessage("Unexpected " + (code2 === null ? "end of file" : "character `" + (code2 === 96 ? "` ` `" : String.fromCodePoint(code2)) + "` (" + serializeCharCode(code2) + ")") + " " + at2 + ", expected " + expect, self2.now(), "micromark-extension-mdx-jsx:unexpected-" + (code2 === null ? "eof" : "character"));
      error.url = trouble2 + (code2 === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect");
      throw error;
    }
  }
  function serializeCharCode(code2) {
    return "U+" + code2.toString(16).toUpperCase().padStart(4, "0");
  }

  // node_modules/micromark-extension-mdx-jsx/lib/jsx-text.js
  function jsxText(acorn, options) {
    return {
      name: "mdxJsxTextTag",
      tokenize: tokenizeJsxText
    };
    function tokenizeJsxText(effects, ok3, nok) {
      return factoryTag.call(this, effects, ok3, nok, acorn, options.acornOptions, options.addResult, true, "mdxJsxTextTag", "mdxJsxTextTagMarker", "mdxJsxTextTagClosingMarker", "mdxJsxTextTagSelfClosingMarker", "mdxJsxTextTagName", "mdxJsxTextTagNamePrimary", "mdxJsxTextTagNameMemberMarker", "mdxJsxTextTagNameMember", "mdxJsxTextTagNamePrefixMarker", "mdxJsxTextTagNameLocal", "mdxJsxTextTagExpressionAttribute", "mdxJsxTextTagExpressionAttributeMarker", "mdxJsxTextTagExpressionAttributeValue", "mdxJsxTextTagAttribute", "mdxJsxTextTagAttributeName", "mdxJsxTextTagAttributeNamePrimary", "mdxJsxTextTagAttributeNamePrefixMarker", "mdxJsxTextTagAttributeNameLocal", "mdxJsxTextTagAttributeInitializerMarker", "mdxJsxTextTagAttributeValueLiteral", "mdxJsxTextTagAttributeValueLiteralMarker", "mdxJsxTextTagAttributeValueLiteralValue", "mdxJsxTextTagAttributeValueExpression", "mdxJsxTextTagAttributeValueExpressionMarker", "mdxJsxTextTagAttributeValueExpressionValue");
    }
  }

  // node_modules/micromark-extension-mdx-jsx/node_modules/micromark-factory-space/index.js
  function factorySpace2(effects, ok3, type, max) {
    const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
    let size = 0;
    return start2;
    function start2(code2) {
      if (markdownSpace2(code2)) {
        effects.enter(type);
        return prefix(code2);
      }
      return ok3(code2);
    }
    function prefix(code2) {
      if (markdownSpace2(code2) && size++ < limit) {
        effects.consume(code2);
        return prefix;
      }
      effects.exit(type);
      return ok3(code2);
    }
  }

  // node_modules/micromark-extension-mdx-jsx/lib/jsx-flow.js
  function jsxFlow(acorn, options) {
    return {
      name: "mdxJsxFlowTag",
      tokenize: tokenizeJsxFlow,
      concrete: true
    };
    function tokenizeJsxFlow(effects, ok3, nok) {
      const self2 = this;
      return start2;
      function start2(code2) {
        return before(code2);
      }
      function before(code2) {
        return factoryTag.call(self2, effects, after, nok, acorn, options.acornOptions, options.addResult, false, "mdxJsxFlowTag", "mdxJsxFlowTagMarker", "mdxJsxFlowTagClosingMarker", "mdxJsxFlowTagSelfClosingMarker", "mdxJsxFlowTagName", "mdxJsxFlowTagNamePrimary", "mdxJsxFlowTagNameMemberMarker", "mdxJsxFlowTagNameMember", "mdxJsxFlowTagNamePrefixMarker", "mdxJsxFlowTagNameLocal", "mdxJsxFlowTagExpressionAttribute", "mdxJsxFlowTagExpressionAttributeMarker", "mdxJsxFlowTagExpressionAttributeValue", "mdxJsxFlowTagAttribute", "mdxJsxFlowTagAttributeName", "mdxJsxFlowTagAttributeNamePrimary", "mdxJsxFlowTagAttributeNamePrefixMarker", "mdxJsxFlowTagAttributeNameLocal", "mdxJsxFlowTagAttributeInitializerMarker", "mdxJsxFlowTagAttributeValueLiteral", "mdxJsxFlowTagAttributeValueLiteralMarker", "mdxJsxFlowTagAttributeValueLiteralValue", "mdxJsxFlowTagAttributeValueExpression", "mdxJsxFlowTagAttributeValueExpressionMarker", "mdxJsxFlowTagAttributeValueExpressionValue")(code2);
      }
      function after(code2) {
        return markdownSpace2(code2) ? factorySpace2(effects, end, "whitespace")(code2) : end(code2);
      }
      function end(code2) {
        const leftBraceValue = self2.parser.constructs.flow[123];
        const constructs3 = Array.isArray(leftBraceValue) ? leftBraceValue : leftBraceValue ? [leftBraceValue] : [];
        const expression = constructs3.find((d) => d.name === "mdxFlowExpression");
        return code2 === 60 ? (
          // We can’t just say: fine. Lines of blocks have to be parsed until an eol/eof.
          start2(code2)
        ) : code2 === 123 && expression ? effects.attempt(expression, end, nok)(code2) : code2 === null || markdownLineEnding3(code2) ? ok3(code2) : nok(code2);
      }
    }
  }

  // node_modules/micromark-extension-mdx-jsx/lib/syntax.js
  function mdxJsx(options) {
    const settings = options || {};
    const acorn = settings.acorn;
    let acornOptions;
    if (acorn) {
      if (!acorn.parse || !acorn.parseExpressionAt) {
        throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
      }
      acornOptions = Object.assign({
        ecmaVersion: 2024,
        sourceType: "module"
      }, settings.acornOptions, {
        locations: true
      });
    } else if (settings.acornOptions || settings.addResult) {
      throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
    }
    return {
      flow: {
        [60]: jsxFlow(acorn || void 0, {
          acornOptions,
          addResult: settings.addResult || void 0
        })
      },
      text: {
        [60]: jsxText(acorn || void 0, {
          acornOptions,
          addResult: settings.addResult || void 0
        })
      }
    };
  }

  // node_modules/micromark-extension-mdx-md/index.js
  function mdxMd() {
    return {
      disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
    };
  }

  // node_modules/micromark-extension-mdxjs-esm/node_modules/micromark-util-character/index.js
  var asciiAlpha4 = regexCheck4(/[A-Za-z]/);
  var asciiAlphanumeric4 = regexCheck4(/[\dA-Za-z]/);
  var asciiAtext4 = regexCheck4(/[#-'*+\--9=?A-Z^-~]/);
  var asciiDigit4 = regexCheck4(/\d/);
  var asciiHexDigit4 = regexCheck4(/[\dA-Fa-f]/);
  var asciiPunctuation4 = regexCheck4(/[!-/:-@[-`{-~]/);
  function markdownLineEnding4(code2) {
    return code2 !== null && code2 < -2;
  }
  function markdownSpace3(code2) {
    return code2 === -2 || code2 === -1 || code2 === 32;
  }
  var unicodePunctuation4 = regexCheck4(/\p{P}|\p{S}/u);
  var unicodeWhitespace4 = regexCheck4(/\s/);
  function regexCheck4(regex) {
    return check;
    function check(code2) {
      return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
    }
  }

  // node_modules/micromark-extension-mdxjs-esm/node_modules/micromark-factory-space/index.js
  function factorySpace3(effects, ok3, type, max) {
    const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
    let size = 0;
    return start2;
    function start2(code2) {
      if (markdownSpace3(code2)) {
        effects.enter(type);
        return prefix(code2);
      }
      return ok3(code2);
    }
    function prefix(code2) {
      if (markdownSpace3(code2) && size++ < limit) {
        effects.consume(code2);
        return prefix;
      }
      effects.exit(type);
      return ok3(code2);
    }
  }

  // node_modules/micromark-extension-mdxjs-esm/node_modules/micromark-core-commonmark/lib/blank-line.js
  var blankLine = {
    tokenize: tokenizeBlankLine,
    partial: true
  };
  function tokenizeBlankLine(effects, ok3, nok) {
    return start2;
    function start2(code2) {
      return markdownSpace3(code2) ? factorySpace3(effects, after, "linePrefix")(code2) : after(code2);
    }
    function after(code2) {
      return code2 === null || markdownLineEnding4(code2) ? ok3(code2) : nok(code2);
    }
  }

  // node_modules/micromark-extension-mdxjs-esm/node_modules/unist-util-position-from-estree/lib/index.js
  function positionFromEstree2(node3) {
    const nodeLike = node3 || {};
    const loc = nodeLike.loc || {};
    const range = nodeLike.range || [void 0, void 0];
    const start2 = pointOrUndefined2(loc.start, range[0] || nodeLike.start);
    const end = pointOrUndefined2(loc.end, range[1] || nodeLike.end);
    if (start2 && end) {
      return { start: start2, end };
    }
  }
  function pointOrUndefined2(estreePoint, estreeOffset) {
    if (estreePoint && typeof estreePoint === "object") {
      const line = "line" in estreePoint ? numberOrUndefined2(estreePoint.line) : void 0;
      const column = "column" in estreePoint ? numberOrUndefined2(estreePoint.column) : void 0;
      if (line && column !== void 0) {
        return {
          line,
          column: column + 1,
          offset: numberOrUndefined2(estreeOffset)
        };
      }
    }
  }
  function numberOrUndefined2(value) {
    return typeof value === "number" && value > -1 ? value : void 0;
  }

  // node_modules/micromark-extension-mdxjs-esm/lib/syntax.js
  var blankLineBefore = {
    tokenize: tokenizeNextBlank,
    partial: true
  };
  var trouble3 = "https://github.com/micromark/micromark-extension-mdxjs-esm";
  var allowedAcornTypes = /* @__PURE__ */ new Set(["ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]);
  function mdxjsEsm(options) {
    const exportImportConstruct = {
      tokenize: tokenizeExportImport,
      concrete: true
    };
    if (!options || !options.acorn || !options.acorn.parse) {
      throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
    }
    const acorn = options.acorn;
    const acornOptions = Object.assign({
      ecmaVersion: 2024,
      sourceType: "module"
    }, options.acornOptions, {
      locations: true
    });
    return {
      flow: {
        [101]: exportImportConstruct,
        [105]: exportImportConstruct
      }
    };
    function tokenizeExportImport(effects, ok3, nok) {
      const self2 = this;
      const definedModuleSpecifiers = self2.parser.definedModuleSpecifiers || (self2.parser.definedModuleSpecifiers = []);
      const eventStart = this.events.length + 1;
      let buffer = "";
      return self2.interrupt ? nok : start2;
      function start2(code2) {
        if (self2.now().column > 1)
          return nok(code2);
        effects.enter("mdxjsEsm");
        effects.enter("mdxjsEsmData");
        effects.consume(code2);
        buffer += String.fromCharCode(code2);
        return word;
      }
      function word(code2) {
        if (asciiAlpha4(code2)) {
          effects.consume(code2);
          buffer += String.fromCharCode(code2);
          return word;
        }
        if ((buffer === "import" || buffer === "export") && code2 === 32) {
          effects.consume(code2);
          return inside;
        }
        return nok(code2);
      }
      function inside(code2) {
        if (code2 === null || markdownLineEnding4(code2)) {
          effects.exit("mdxjsEsmData");
          return lineStart(code2);
        }
        effects.consume(code2);
        return inside;
      }
      function lineStart(code2) {
        if (code2 === null) {
          return atEnd(code2);
        }
        if (markdownLineEnding4(code2)) {
          return effects.check(blankLineBefore, atEnd, continuationStart)(code2);
        }
        effects.enter("mdxjsEsmData");
        return inside(code2);
      }
      function continuationStart(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return lineStart;
      }
      function atEnd(code2) {
        const result = eventsToAcorn(self2.events.slice(eventStart), {
          acorn,
          acornOptions,
          tokenTypes: ["mdxjsEsmData"],
          prefix: definedModuleSpecifiers.length > 0 ? "var " + definedModuleSpecifiers.join(",") + "\n" : ""
        });
        if (result.error) {
          if (code2 !== null && result.swallow) {
            return continuationStart(code2);
          }
          const error = new VFileMessage("Could not parse import/exports with acorn", {
            cause: result.error,
            place: {
              line: result.error.loc.line,
              column: result.error.loc.column + 1,
              offset: result.error.pos
            },
            ruleId: "acorn",
            source: "micromark-extension-mdxjs-esm"
          });
          error.url = trouble3 + "#could-not-parse-importexports-with-acorn";
          throw error;
        }
        if (definedModuleSpecifiers.length > 0) {
          const declaration = result.estree.body.shift();
        }
        let index4 = -1;
        while (++index4 < result.estree.body.length) {
          const node3 = result.estree.body[index4];
          if (!allowedAcornTypes.has(node3.type)) {
            const error = new VFileMessage("Unexpected `" + node3.type + "` in code: only import/exports are supported", {
              place: positionFromEstree2(node3),
              ruleId: "non-esm",
              source: "micromark-extension-mdxjs-esm"
            });
            error.url = trouble3 + "#unexpected-type-in-code-only-importexports-are-supported";
            throw error;
          }
          if (node3.type === "ImportDeclaration" && !self2.interrupt) {
            let index5 = -1;
            while (++index5 < node3.specifiers.length) {
              const specifier = node3.specifiers[index5];
              definedModuleSpecifiers.push(specifier.local.name);
            }
          }
        }
        Object.assign(effects.exit("mdxjsEsm"), options.addResult ? {
          estree: result.estree
        } : void 0);
        return ok3(code2);
      }
    }
  }
  function tokenizeNextBlank(effects, ok3, nok) {
    return start2;
    function start2(code2) {
      effects.enter("lineEndingBlank");
      effects.consume(code2);
      effects.exit("lineEndingBlank");
      return effects.attempt(blankLine, ok3, nok);
    }
  }

  // node_modules/micromark-extension-mdxjs/node_modules/micromark-util-chunked/index.js
  function splice(list4, start2, remove, items) {
    const end = list4.length;
    let chunkStart = 0;
    let parameters;
    if (start2 < 0) {
      start2 = -start2 > end ? 0 : end + start2;
    } else {
      start2 = start2 > end ? end : start2;
    }
    remove = remove > 0 ? remove : 0;
    if (items.length < 1e4) {
      parameters = Array.from(items);
      parameters.unshift(start2, remove);
      list4.splice(...parameters);
    } else {
      if (remove)
        list4.splice(start2, remove);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + 1e4);
        parameters.unshift(start2, 0);
        list4.splice(...parameters);
        chunkStart += 1e4;
        start2 += 1e4;
      }
    }
  }

  // node_modules/micromark-extension-mdxjs/node_modules/micromark-util-combine-extensions/index.js
  var hasOwnProperty2 = {}.hasOwnProperty;
  function combineExtensions(extensions) {
    const all3 = {};
    let index4 = -1;
    while (++index4 < extensions.length) {
      syntaxExtension(all3, extensions[index4]);
    }
    return all3;
  }
  function syntaxExtension(all3, extension2) {
    let hook;
    for (hook in extension2) {
      const maybe = hasOwnProperty2.call(all3, hook) ? all3[hook] : void 0;
      const left = maybe || (all3[hook] = {});
      const right = extension2[hook];
      let code2;
      if (right) {
        for (code2 in right) {
          if (!hasOwnProperty2.call(left, code2))
            left[code2] = [];
          const value = right[code2];
          constructs(
            // @ts-expect-error Looks like a list.
            left[code2],
            Array.isArray(value) ? value : value ? [value] : []
          );
        }
      }
    }
  }
  function constructs(existing, list4) {
    let index4 = -1;
    const before = [];
    while (++index4 < list4.length) {
      ;
      (list4[index4].add === "after" ? existing : before).push(list4[index4]);
    }
    splice(existing, 0, 0, before);
  }

  // node_modules/micromark-extension-mdxjs/index.js
  function mdxjs(options) {
    const settings = Object.assign(
      {
        acorn: Parser.extend((0, import_acorn_jsx.default)()),
        acornOptions: { ecmaVersion: 2024, sourceType: "module" },
        addResult: true
      },
      options
    );
    return combineExtensions([
      mdxjsEsm(settings),
      mdxExpression(settings),
      mdxJsx(settings),
      mdxMd()
    ]);
  }

  // node_modules/remark-mdx/lib/index.js
  var emptyOptions2 = {};
  function remarkMdx(options) {
    const self2 = (
      /** @type {Processor} */
      this
    );
    const settings = options || emptyOptions2;
    const data2 = self2.data();
    const micromarkExtensions = data2.micromarkExtensions || (data2.micromarkExtensions = []);
    const fromMarkdownExtensions = data2.fromMarkdownExtensions || (data2.fromMarkdownExtensions = []);
    const toMarkdownExtensions = data2.toMarkdownExtensions || (data2.toMarkdownExtensions = []);
    micromarkExtensions.push(mdxjs(settings));
    fromMarkdownExtensions.push(mdxFromMarkdown());
    toMarkdownExtensions.push(mdxToMarkdown(settings));
  }

  // node_modules/remark-parse/node_modules/mdast-util-to-string/lib/index.js
  var emptyOptions3 = {};
  function toString2(value, options) {
    const settings = options || emptyOptions3;
    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
    return one(value, includeImageAlt, includeHtml);
  }
  function one(value, includeImageAlt, includeHtml) {
    if (node(value)) {
      if ("value" in value) {
        return value.type === "html" && !includeHtml ? "" : value.value;
      }
      if (includeImageAlt && "alt" in value && value.alt) {
        return value.alt;
      }
      if ("children" in value) {
        return all(value.children, includeImageAlt, includeHtml);
      }
    }
    if (Array.isArray(value)) {
      return all(value, includeImageAlt, includeHtml);
    }
    return "";
  }
  function all(values, includeImageAlt, includeHtml) {
    const result = [];
    let index4 = -1;
    while (++index4 < values.length) {
      result[index4] = one(values[index4], includeImageAlt, includeHtml);
    }
    return result.join("");
  }
  function node(value) {
    return Boolean(value && typeof value === "object");
  }

  // node_modules/remark-parse/node_modules/micromark-util-chunked/index.js
  function splice2(list4, start2, remove, items) {
    const end = list4.length;
    let chunkStart = 0;
    let parameters;
    if (start2 < 0) {
      start2 = -start2 > end ? 0 : end + start2;
    } else {
      start2 = start2 > end ? end : start2;
    }
    remove = remove > 0 ? remove : 0;
    if (items.length < 1e4) {
      parameters = Array.from(items);
      parameters.unshift(start2, remove);
      list4.splice(...parameters);
    } else {
      if (remove)
        list4.splice(start2, remove);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + 1e4);
        parameters.unshift(start2, 0);
        list4.splice(...parameters);
        chunkStart += 1e4;
        start2 += 1e4;
      }
    }
  }
  function push(list4, items) {
    if (list4.length > 0) {
      splice2(list4, list4.length, 0, items);
      return list4;
    }
    return items;
  }

  // node_modules/remark-parse/node_modules/micromark-util-combine-extensions/index.js
  var hasOwnProperty3 = {}.hasOwnProperty;
  function combineExtensions2(extensions) {
    const all3 = {};
    let index4 = -1;
    while (++index4 < extensions.length) {
      syntaxExtension2(all3, extensions[index4]);
    }
    return all3;
  }
  function syntaxExtension2(all3, extension2) {
    let hook;
    for (hook in extension2) {
      const maybe = hasOwnProperty3.call(all3, hook) ? all3[hook] : void 0;
      const left = maybe || (all3[hook] = {});
      const right = extension2[hook];
      let code2;
      if (right) {
        for (code2 in right) {
          if (!hasOwnProperty3.call(left, code2))
            left[code2] = [];
          const value = right[code2];
          constructs2(
            // @ts-expect-error Looks like a list.
            left[code2],
            Array.isArray(value) ? value : value ? [value] : []
          );
        }
      }
    }
  }
  function constructs2(existing, list4) {
    let index4 = -1;
    const before = [];
    while (++index4 < list4.length) {
      ;
      (list4[index4].add === "after" ? existing : before).push(list4[index4]);
    }
    splice2(existing, 0, 0, before);
  }

  // node_modules/remark-parse/node_modules/micromark-util-decode-numeric-character-reference/index.js
  function decodeNumericCharacterReference(value, base) {
    const code2 = Number.parseInt(value, base);
    if (
      // C0 except for HT, LF, FF, CR, space.
      code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
      code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
      code2 > 55295 && code2 < 57344 || // Noncharacters.
      code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
      (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
      // Out of range
      code2 > 1114111
    ) {
      return "\uFFFD";
    }
    return String.fromCodePoint(code2);
  }

  // node_modules/remark-parse/node_modules/micromark-util-normalize-identifier/index.js
  function normalizeIdentifier(value) {
    return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }

  // node_modules/remark-parse/node_modules/micromark-util-character/index.js
  var asciiAlpha5 = regexCheck5(/[A-Za-z]/);
  var asciiAlphanumeric5 = regexCheck5(/[\dA-Za-z]/);
  var asciiAtext5 = regexCheck5(/[#-'*+\--9=?A-Z^-~]/);
  function asciiControl(code2) {
    return (
      // Special whitespace codes (which have negative values), C0 and Control
      // character DEL
      code2 !== null && (code2 < 32 || code2 === 127)
    );
  }
  var asciiDigit5 = regexCheck5(/\d/);
  var asciiHexDigit5 = regexCheck5(/[\dA-Fa-f]/);
  var asciiPunctuation5 = regexCheck5(/[!-/:-@[-`{-~]/);
  function markdownLineEnding5(code2) {
    return code2 !== null && code2 < -2;
  }
  function markdownLineEndingOrSpace2(code2) {
    return code2 !== null && (code2 < 0 || code2 === 32);
  }
  function markdownSpace4(code2) {
    return code2 === -2 || code2 === -1 || code2 === 32;
  }
  var unicodePunctuation5 = regexCheck5(/\p{P}|\p{S}/u);
  var unicodeWhitespace5 = regexCheck5(/\s/);
  function regexCheck5(regex) {
    return check;
    function check(code2) {
      return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
    }
  }

  // node_modules/remark-parse/node_modules/micromark-factory-space/index.js
  function factorySpace4(effects, ok3, type, max) {
    const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
    let size = 0;
    return start2;
    function start2(code2) {
      if (markdownSpace4(code2)) {
        effects.enter(type);
        return prefix(code2);
      }
      return ok3(code2);
    }
    function prefix(code2) {
      if (markdownSpace4(code2) && size++ < limit) {
        effects.consume(code2);
        return prefix;
      }
      effects.exit(type);
      return ok3(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark/lib/initialize/content.js
  var content = {
    tokenize: initializeContent
  };
  function initializeContent(effects) {
    const contentStart = effects.attempt(
      this.parser.constructs.contentInitial,
      afterContentStartConstruct,
      paragraphInitial
    );
    let previous2;
    return contentStart;
    function afterContentStartConstruct(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace4(effects, contentStart, "linePrefix");
    }
    function paragraphInitial(code2) {
      effects.enter("paragraph");
      return lineStart(code2);
    }
    function lineStart(code2) {
      const token = effects.enter("chunkText", {
        contentType: "text",
        previous: previous2
      });
      if (previous2) {
        previous2.next = token;
      }
      previous2 = token;
      return data2(code2);
    }
    function data2(code2) {
      if (code2 === null) {
        effects.exit("chunkText");
        effects.exit("paragraph");
        effects.consume(code2);
        return;
      }
      if (markdownLineEnding5(code2)) {
        effects.consume(code2);
        effects.exit("chunkText");
        return lineStart;
      }
      effects.consume(code2);
      return data2;
    }
  }

  // node_modules/remark-parse/node_modules/micromark/lib/initialize/document.js
  var document3 = {
    tokenize: initializeDocument
  };
  var containerConstruct = {
    tokenize: tokenizeContainer
  };
  function initializeDocument(effects) {
    const self2 = this;
    const stack = [];
    let continued = 0;
    let childFlow;
    let childToken;
    let lineStartOffset;
    return start2;
    function start2(code2) {
      if (continued < stack.length) {
        const item = stack[continued];
        self2.containerState = item[1];
        return effects.attempt(
          item[0].continuation,
          documentContinue,
          checkNewContainers
        )(code2);
      }
      return checkNewContainers(code2);
    }
    function documentContinue(code2) {
      continued++;
      if (self2.containerState._closeFlow) {
        self2.containerState._closeFlow = void 0;
        if (childFlow) {
          closeFlow();
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let point5;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            point5 = self2.events[indexBeforeFlow][1].end;
            break;
          }
        }
        exitContainers(continued);
        let index4 = indexBeforeExits;
        while (index4 < self2.events.length) {
          self2.events[index4][1].end = Object.assign({}, point5);
          index4++;
        }
        splice2(
          self2.events,
          indexBeforeFlow + 1,
          0,
          self2.events.slice(indexBeforeExits)
        );
        self2.events.length = index4;
        return checkNewContainers(code2);
      }
      return start2(code2);
    }
    function checkNewContainers(code2) {
      if (continued === stack.length) {
        if (!childFlow) {
          return documentContinued(code2);
        }
        if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
          return flowStart(code2);
        }
        self2.interrupt = Boolean(
          childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
        );
      }
      self2.containerState = {};
      return effects.check(
        containerConstruct,
        thereIsANewContainer,
        thereIsNoNewContainer
      )(code2);
    }
    function thereIsANewContainer(code2) {
      if (childFlow)
        closeFlow();
      exitContainers(continued);
      return documentContinued(code2);
    }
    function thereIsNoNewContainer(code2) {
      self2.parser.lazy[self2.now().line] = continued !== stack.length;
      lineStartOffset = self2.now().offset;
      return flowStart(code2);
    }
    function documentContinued(code2) {
      self2.containerState = {};
      return effects.attempt(
        containerConstruct,
        containerContinue,
        flowStart
      )(code2);
    }
    function containerContinue(code2) {
      continued++;
      stack.push([self2.currentConstruct, self2.containerState]);
      return documentContinued(code2);
    }
    function flowStart(code2) {
      if (code2 === null) {
        if (childFlow)
          closeFlow();
        exitContainers(0);
        effects.consume(code2);
        return;
      }
      childFlow = childFlow || self2.parser.flow(self2.now());
      effects.enter("chunkFlow", {
        contentType: "flow",
        previous: childToken,
        _tokenizer: childFlow
      });
      return flowContinue(code2);
    }
    function flowContinue(code2) {
      if (code2 === null) {
        writeToChild(effects.exit("chunkFlow"), true);
        exitContainers(0);
        effects.consume(code2);
        return;
      }
      if (markdownLineEnding5(code2)) {
        effects.consume(code2);
        writeToChild(effects.exit("chunkFlow"));
        continued = 0;
        self2.interrupt = void 0;
        return start2;
      }
      effects.consume(code2);
      return flowContinue;
    }
    function writeToChild(token, eof) {
      const stream = self2.sliceStream(token);
      if (eof)
        stream.push(null);
      token.previous = childToken;
      if (childToken)
        childToken.next = token;
      childToken = token;
      childFlow.defineSkip(token.start);
      childFlow.write(stream);
      if (self2.parser.lazy[token.start.line]) {
        let index4 = childFlow.events.length;
        while (index4--) {
          if (
            // The token starts before the line ending…
            childFlow.events[index4][1].start.offset < lineStartOffset && // …and either is not ended yet…
            (!childFlow.events[index4][1].end || // …or ends after it.
            childFlow.events[index4][1].end.offset > lineStartOffset)
          ) {
            return;
          }
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let seen;
        let point5;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            if (seen) {
              point5 = self2.events[indexBeforeFlow][1].end;
              break;
            }
            seen = true;
          }
        }
        exitContainers(continued);
        index4 = indexBeforeExits;
        while (index4 < self2.events.length) {
          self2.events[index4][1].end = Object.assign({}, point5);
          index4++;
        }
        splice2(
          self2.events,
          indexBeforeFlow + 1,
          0,
          self2.events.slice(indexBeforeExits)
        );
        self2.events.length = index4;
      }
    }
    function exitContainers(size) {
      let index4 = stack.length;
      while (index4-- > size) {
        const entry = stack[index4];
        self2.containerState = entry[1];
        entry[0].exit.call(self2, effects);
      }
      stack.length = size;
    }
    function closeFlow() {
      childFlow.write([null]);
      childToken = void 0;
      childFlow = void 0;
      self2.containerState._closeFlow = void 0;
    }
  }
  function tokenizeContainer(effects, ok3, nok) {
    return factorySpace4(
      effects,
      effects.attempt(this.parser.constructs.document, ok3, nok),
      "linePrefix",
      this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
  }

  // node_modules/remark-parse/node_modules/micromark-util-classify-character/index.js
  function classifyCharacter(code2) {
    if (code2 === null || markdownLineEndingOrSpace2(code2) || unicodeWhitespace5(code2)) {
      return 1;
    }
    if (unicodePunctuation5(code2)) {
      return 2;
    }
  }

  // node_modules/remark-parse/node_modules/micromark-util-resolve-all/index.js
  function resolveAll(constructs3, events, context) {
    const called = [];
    let index4 = -1;
    while (++index4 < constructs3.length) {
      const resolve3 = constructs3[index4].resolveAll;
      if (resolve3 && !called.includes(resolve3)) {
        events = resolve3(events, context);
        called.push(resolve3);
      }
    }
    return events;
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/attention.js
  var attention = {
    name: "attention",
    tokenize: tokenizeAttention,
    resolveAll: resolveAllAttention
  };
  function resolveAllAttention(events, context) {
    let index4 = -1;
    let open;
    let group;
    let text4;
    let openingSequence;
    let closingSequence;
    let use;
    let nextEvents;
    let offset2;
    while (++index4 < events.length) {
      if (events[index4][0] === "enter" && events[index4][1].type === "attentionSequence" && events[index4][1]._close) {
        open = index4;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index4][1]).charCodeAt(0)) {
            if ((events[open][1]._close || events[index4][1]._open) && (events[index4][1].end.offset - events[index4][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index4][1].end.offset - events[index4][1].start.offset) % 3)) {
              continue;
            }
            use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index4][1].end.offset - events[index4][1].start.offset > 1 ? 2 : 1;
            const start2 = Object.assign({}, events[open][1].end);
            const end = Object.assign({}, events[index4][1].start);
            movePoint(start2, -use);
            movePoint(end, use);
            openingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: start2,
              end: Object.assign({}, events[open][1].end)
            };
            closingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: Object.assign({}, events[index4][1].start),
              end
            };
            text4 = {
              type: use > 1 ? "strongText" : "emphasisText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index4][1].start)
            };
            group = {
              type: use > 1 ? "strong" : "emphasis",
              start: Object.assign({}, openingSequence.start),
              end: Object.assign({}, closingSequence.end)
            };
            events[open][1].end = Object.assign({}, openingSequence.start);
            events[index4][1].start = Object.assign({}, closingSequence.end);
            nextEvents = [];
            if (events[open][1].end.offset - events[open][1].start.offset) {
              nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);
            }
            nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text4, context]]);
            nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index4), context));
            nextEvents = push(nextEvents, [["exit", text4, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);
            if (events[index4][1].end.offset - events[index4][1].start.offset) {
              offset2 = 2;
              nextEvents = push(nextEvents, [["enter", events[index4][1], context], ["exit", events[index4][1], context]]);
            } else {
              offset2 = 0;
            }
            splice2(events, open - 1, index4 - open + 3, nextEvents);
            index4 = open + nextEvents.length - offset2 - 2;
            break;
          }
        }
      }
    }
    index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][1].type === "attentionSequence") {
        events[index4][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeAttention(effects, ok3) {
    const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
    const previous2 = this.previous;
    const before = classifyCharacter(previous2);
    let marker;
    return start2;
    function start2(code2) {
      marker = code2;
      effects.enter("attentionSequence");
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        return inside;
      }
      const token = effects.exit("attentionSequence");
      const after = classifyCharacter(code2);
      const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
      const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
      token._open = Boolean(marker === 42 ? open : open && (before || !close));
      token._close = Boolean(marker === 42 ? close : close && (after || !open));
      return ok3(code2);
    }
  }
  function movePoint(point5, offset2) {
    point5.column += offset2;
    point5.offset += offset2;
    point5._bufferIndex += offset2;
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/autolink.js
  var autolink = {
    name: "autolink",
    tokenize: tokenizeAutolink
  };
  function tokenizeAutolink(effects, ok3, nok) {
    let size = 0;
    return start2;
    function start2(code2) {
      effects.enter("autolink");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.enter("autolinkProtocol");
      return open;
    }
    function open(code2) {
      if (asciiAlpha5(code2)) {
        effects.consume(code2);
        return schemeOrEmailAtext;
      }
      if (code2 === 64) {
        return nok(code2);
      }
      return emailAtext(code2);
    }
    function schemeOrEmailAtext(code2) {
      if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric5(code2)) {
        size = 1;
        return schemeInsideOrEmailAtext(code2);
      }
      return emailAtext(code2);
    }
    function schemeInsideOrEmailAtext(code2) {
      if (code2 === 58) {
        effects.consume(code2);
        size = 0;
        return urlInside;
      }
      if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric5(code2)) && size++ < 32) {
        effects.consume(code2);
        return schemeInsideOrEmailAtext;
      }
      size = 0;
      return emailAtext(code2);
    }
    function urlInside(code2) {
      if (code2 === 62) {
        effects.exit("autolinkProtocol");
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok3;
      }
      if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return urlInside;
    }
    function emailAtext(code2) {
      if (code2 === 64) {
        effects.consume(code2);
        return emailAtSignOrDot;
      }
      if (asciiAtext5(code2)) {
        effects.consume(code2);
        return emailAtext;
      }
      return nok(code2);
    }
    function emailAtSignOrDot(code2) {
      return asciiAlphanumeric5(code2) ? emailLabel(code2) : nok(code2);
    }
    function emailLabel(code2) {
      if (code2 === 46) {
        effects.consume(code2);
        size = 0;
        return emailAtSignOrDot;
      }
      if (code2 === 62) {
        effects.exit("autolinkProtocol").type = "autolinkEmail";
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok3;
      }
      return emailValue(code2);
    }
    function emailValue(code2) {
      if ((code2 === 45 || asciiAlphanumeric5(code2)) && size++ < 63) {
        const next = code2 === 45 ? emailValue : emailLabel;
        effects.consume(code2);
        return next;
      }
      return nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/blank-line.js
  var blankLine2 = {
    tokenize: tokenizeBlankLine2,
    partial: true
  };
  function tokenizeBlankLine2(effects, ok3, nok) {
    return start2;
    function start2(code2) {
      return markdownSpace4(code2) ? factorySpace4(effects, after, "linePrefix")(code2) : after(code2);
    }
    function after(code2) {
      return code2 === null || markdownLineEnding5(code2) ? ok3(code2) : nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/block-quote.js
  var blockQuote = {
    name: "blockQuote",
    tokenize: tokenizeBlockQuoteStart,
    continuation: {
      tokenize: tokenizeBlockQuoteContinuation
    },
    exit
  };
  function tokenizeBlockQuoteStart(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code2) {
      if (code2 === 62) {
        const state = self2.containerState;
        if (!state.open) {
          effects.enter("blockQuote", {
            _container: true
          });
          state.open = true;
        }
        effects.enter("blockQuotePrefix");
        effects.enter("blockQuoteMarker");
        effects.consume(code2);
        effects.exit("blockQuoteMarker");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      if (markdownSpace4(code2)) {
        effects.enter("blockQuotePrefixWhitespace");
        effects.consume(code2);
        effects.exit("blockQuotePrefixWhitespace");
        effects.exit("blockQuotePrefix");
        return ok3;
      }
      effects.exit("blockQuotePrefix");
      return ok3(code2);
    }
  }
  function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
    const self2 = this;
    return contStart;
    function contStart(code2) {
      if (markdownSpace4(code2)) {
        return factorySpace4(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
      }
      return contBefore(code2);
    }
    function contBefore(code2) {
      return effects.attempt(blockQuote, ok3, nok)(code2);
    }
  }
  function exit(effects) {
    effects.exit("blockQuote");
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/character-escape.js
  var characterEscape = {
    name: "characterEscape",
    tokenize: tokenizeCharacterEscape
  };
  function tokenizeCharacterEscape(effects, ok3, nok) {
    return start2;
    function start2(code2) {
      effects.enter("characterEscape");
      effects.enter("escapeMarker");
      effects.consume(code2);
      effects.exit("escapeMarker");
      return inside;
    }
    function inside(code2) {
      if (asciiPunctuation5(code2)) {
        effects.enter("characterEscapeValue");
        effects.consume(code2);
        effects.exit("characterEscapeValue");
        effects.exit("characterEscape");
        return ok3;
      }
      return nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/character-reference.js
  var characterReference = {
    name: "characterReference",
    tokenize: tokenizeCharacterReference
  };
  function tokenizeCharacterReference(effects, ok3, nok) {
    const self2 = this;
    let size = 0;
    let max;
    let test;
    return start2;
    function start2(code2) {
      effects.enter("characterReference");
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      return open;
    }
    function open(code2) {
      if (code2 === 35) {
        effects.enter("characterReferenceMarkerNumeric");
        effects.consume(code2);
        effects.exit("characterReferenceMarkerNumeric");
        return numeric;
      }
      effects.enter("characterReferenceValue");
      max = 31;
      test = asciiAlphanumeric5;
      return value(code2);
    }
    function numeric(code2) {
      if (code2 === 88 || code2 === 120) {
        effects.enter("characterReferenceMarkerHexadecimal");
        effects.consume(code2);
        effects.exit("characterReferenceMarkerHexadecimal");
        effects.enter("characterReferenceValue");
        max = 6;
        test = asciiHexDigit5;
        return value;
      }
      effects.enter("characterReferenceValue");
      max = 7;
      test = asciiDigit5;
      return value(code2);
    }
    function value(code2) {
      if (code2 === 59 && size) {
        const token = effects.exit("characterReferenceValue");
        if (test === asciiAlphanumeric5 && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
          return nok(code2);
        }
        effects.enter("characterReferenceMarker");
        effects.consume(code2);
        effects.exit("characterReferenceMarker");
        effects.exit("characterReference");
        return ok3;
      }
      if (test(code2) && size++ < max) {
        effects.consume(code2);
        return value;
      }
      return nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/code-fenced.js
  var nonLazyContinuation = {
    tokenize: tokenizeNonLazyContinuation,
    partial: true
  };
  var codeFenced = {
    name: "codeFenced",
    tokenize: tokenizeCodeFenced,
    concrete: true
  };
  function tokenizeCodeFenced(effects, ok3, nok) {
    const self2 = this;
    const closeStart = {
      tokenize: tokenizeCloseStart,
      partial: true
    };
    let initialPrefix = 0;
    let sizeOpen = 0;
    let marker;
    return start2;
    function start2(code2) {
      return beforeSequenceOpen(code2);
    }
    function beforeSequenceOpen(code2) {
      const tail = self2.events[self2.events.length - 1];
      initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
      marker = code2;
      effects.enter("codeFenced");
      effects.enter("codeFencedFence");
      effects.enter("codeFencedFenceSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === marker) {
        sizeOpen++;
        effects.consume(code2);
        return sequenceOpen;
      }
      if (sizeOpen < 3) {
        return nok(code2);
      }
      effects.exit("codeFencedFenceSequence");
      return markdownSpace4(code2) ? factorySpace4(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
    }
    function infoBefore(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok3(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
      }
      effects.enter("codeFencedFenceInfo");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return info(code2);
    }
    function info(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return infoBefore(code2);
      }
      if (markdownSpace4(code2)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return factorySpace4(effects, metaBefore, "whitespace")(code2);
      }
      if (code2 === 96 && code2 === marker) {
        return nok(code2);
      }
      effects.consume(code2);
      return info;
    }
    function metaBefore(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        return infoBefore(code2);
      }
      effects.enter("codeFencedFenceMeta");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return meta(code2);
    }
    function meta(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceMeta");
        return infoBefore(code2);
      }
      if (code2 === 96 && code2 === marker) {
        return nok(code2);
      }
      effects.consume(code2);
      return meta;
    }
    function atNonLazyBreak(code2) {
      return effects.attempt(closeStart, after, contentBefore)(code2);
    }
    function contentBefore(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return contentStart;
    }
    function contentStart(code2) {
      return initialPrefix > 0 && markdownSpace4(code2) ? factorySpace4(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code2) : beforeContentChunk(code2);
    }
    function beforeContentChunk(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
      }
      effects.enter("codeFlowValue");
      return contentChunk(code2);
    }
    function contentChunk(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("codeFlowValue");
        return beforeContentChunk(code2);
      }
      effects.consume(code2);
      return contentChunk;
    }
    function after(code2) {
      effects.exit("codeFenced");
      return ok3(code2);
    }
    function tokenizeCloseStart(effects2, ok4, nok2) {
      let size = 0;
      return startBefore;
      function startBefore(code2) {
        effects2.enter("lineEnding");
        effects2.consume(code2);
        effects2.exit("lineEnding");
        return start3;
      }
      function start3(code2) {
        effects2.enter("codeFencedFence");
        return markdownSpace4(code2) ? factorySpace4(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : beforeSequenceClose(code2);
      }
      function beforeSequenceClose(code2) {
        if (code2 === marker) {
          effects2.enter("codeFencedFenceSequence");
          return sequenceClose(code2);
        }
        return nok2(code2);
      }
      function sequenceClose(code2) {
        if (code2 === marker) {
          size++;
          effects2.consume(code2);
          return sequenceClose;
        }
        if (size >= sizeOpen) {
          effects2.exit("codeFencedFenceSequence");
          return markdownSpace4(code2) ? factorySpace4(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
        }
        return nok2(code2);
      }
      function sequenceCloseAfter(code2) {
        if (code2 === null || markdownLineEnding5(code2)) {
          effects2.exit("codeFencedFence");
          return ok4(code2);
        }
        return nok2(code2);
      }
    }
  }
  function tokenizeNonLazyContinuation(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/code-indented.js
  var codeIndented = {
    name: "codeIndented",
    tokenize: tokenizeCodeIndented
  };
  var furtherStart = {
    tokenize: tokenizeFurtherStart,
    partial: true
  };
  function tokenizeCodeIndented(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code2) {
      effects.enter("codeIndented");
      return factorySpace4(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
    }
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
    }
    function atBreak(code2) {
      if (code2 === null) {
        return after(code2);
      }
      if (markdownLineEnding5(code2)) {
        return effects.attempt(furtherStart, atBreak, after)(code2);
      }
      effects.enter("codeFlowValue");
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("codeFlowValue");
        return atBreak(code2);
      }
      effects.consume(code2);
      return inside;
    }
    function after(code2) {
      effects.exit("codeIndented");
      return ok3(code2);
    }
  }
  function tokenizeFurtherStart(effects, ok3, nok) {
    const self2 = this;
    return furtherStart2;
    function furtherStart2(code2) {
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code2);
      }
      if (markdownLineEnding5(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return furtherStart2;
      }
      return factorySpace4(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
    }
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok3(code2) : markdownLineEnding5(code2) ? furtherStart2(code2) : nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/code-text.js
  var codeText = {
    name: "codeText",
    tokenize: tokenizeCodeText,
    resolve: resolveCodeText,
    previous
  };
  function resolveCodeText(events) {
    let tailExitIndex = events.length - 4;
    let headEnterIndex = 3;
    let index4;
    let enter;
    if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
      index4 = headEnterIndex;
      while (++index4 < tailExitIndex) {
        if (events[index4][1].type === "codeTextData") {
          events[headEnterIndex][1].type = "codeTextPadding";
          events[tailExitIndex][1].type = "codeTextPadding";
          headEnterIndex += 2;
          tailExitIndex -= 2;
          break;
        }
      }
    }
    index4 = headEnterIndex - 1;
    tailExitIndex++;
    while (++index4 <= tailExitIndex) {
      if (enter === void 0) {
        if (index4 !== tailExitIndex && events[index4][1].type !== "lineEnding") {
          enter = index4;
        }
      } else if (index4 === tailExitIndex || events[index4][1].type === "lineEnding") {
        events[enter][1].type = "codeTextData";
        if (index4 !== enter + 2) {
          events[enter][1].end = events[index4 - 1][1].end;
          events.splice(enter + 2, index4 - enter - 2);
          tailExitIndex -= index4 - enter - 2;
          index4 = enter + 2;
        }
        enter = void 0;
      }
    }
    return events;
  }
  function previous(code2) {
    return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function tokenizeCodeText(effects, ok3, nok) {
    const self2 = this;
    let sizeOpen = 0;
    let size;
    let token;
    return start2;
    function start2(code2) {
      effects.enter("codeText");
      effects.enter("codeTextSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === 96) {
        effects.consume(code2);
        sizeOpen++;
        return sequenceOpen;
      }
      effects.exit("codeTextSequence");
      return between2(code2);
    }
    function between2(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 32) {
        effects.enter("space");
        effects.consume(code2);
        effects.exit("space");
        return between2;
      }
      if (code2 === 96) {
        token = effects.enter("codeTextSequence");
        size = 0;
        return sequenceClose(code2);
      }
      if (markdownLineEnding5(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return between2;
      }
      effects.enter("codeTextData");
      return data2(code2);
    }
    function data2(code2) {
      if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding5(code2)) {
        effects.exit("codeTextData");
        return between2(code2);
      }
      effects.consume(code2);
      return data2;
    }
    function sequenceClose(code2) {
      if (code2 === 96) {
        effects.consume(code2);
        size++;
        return sequenceClose;
      }
      if (size === sizeOpen) {
        effects.exit("codeTextSequence");
        effects.exit("codeText");
        return ok3(code2);
      }
      token.type = "codeTextData";
      return data2(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-util-subtokenize/lib/splice-buffer.js
  var SpliceBuffer = class {
    /**
     * @param {ReadonlyArray<T> | null | undefined} [initial]
     *   Initial items (optional).
     * @returns
     *   Splice buffer.
     */
    constructor(initial) {
      this.left = initial ? [...initial] : [];
      this.right = [];
    }
    /**
     * Array access;
     * does not move the cursor.
     *
     * @param {number} index
     *   Index.
     * @return {T}
     *   Item.
     */
    get(index4) {
      if (index4 < 0 || index4 >= this.left.length + this.right.length) {
        throw new RangeError("Cannot access index `" + index4 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
      }
      if (index4 < this.left.length)
        return this.left[index4];
      return this.right[this.right.length - index4 + this.left.length - 1];
    }
    /**
     * The length of the splice buffer, one greater than the largest index in the
     * array.
     */
    get length() {
      return this.left.length + this.right.length;
    }
    /**
     * Remove and return `list[0]`;
     * moves the cursor to `0`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    shift() {
      this.setCursor(0);
      return this.right.pop();
    }
    /**
     * Slice the buffer to get an array;
     * does not move the cursor.
     *
     * @param {number} start
     *   Start.
     * @param {number | null | undefined} [end]
     *   End (optional).
     * @returns {Array<T>}
     *   Array of items.
     */
    slice(start2, end) {
      const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
      if (stop < this.left.length) {
        return this.left.slice(start2, stop);
      }
      if (start2 > this.left.length) {
        return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start2 + this.left.length).reverse();
      }
      return this.left.slice(start2).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
    }
    /**
     * Mimics the behavior of Array.prototype.splice() except for the change of
     * interface necessary to avoid segfaults when patching in very large arrays.
     *
     * This operation moves cursor is moved to `start` and results in the cursor
     * placed after any inserted items.
     *
     * @param {number} start
     *   Start;
     *   zero-based index at which to start changing the array;
     *   negative numbers count backwards from the end of the array and values
     *   that are out-of bounds are clamped to the appropriate end of the array.
     * @param {number | null | undefined} [deleteCount=0]
     *   Delete count (default: `0`);
     *   maximum number of elements to delete, starting from start.
     * @param {Array<T> | null | undefined} [items=[]]
     *   Items to include in place of the deleted items (default: `[]`).
     * @return {Array<T>}
     *   Any removed items.
     */
    splice(start2, deleteCount, items) {
      const count = deleteCount || 0;
      this.setCursor(Math.trunc(start2));
      const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);
      if (items)
        chunkedPush(this.left, items);
      return removed.reverse();
    }
    /**
     * Remove and return the highest-numbered item in the array, so
     * `list[list.length - 1]`;
     * Moves the cursor to `length`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    pop() {
      this.setCursor(Number.POSITIVE_INFINITY);
      return this.left.pop();
    }
    /**
     * Inserts a single item to the high-numbered side of the array;
     * moves the cursor to `length`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    push(item) {
      this.setCursor(Number.POSITIVE_INFINITY);
      this.left.push(item);
    }
    /**
     * Inserts many items to the high-numbered side of the array.
     * Moves the cursor to `length`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    pushMany(items) {
      this.setCursor(Number.POSITIVE_INFINITY);
      chunkedPush(this.left, items);
    }
    /**
     * Inserts a single item to the low-numbered side of the array;
     * Moves the cursor to `0`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    unshift(item) {
      this.setCursor(0);
      this.right.push(item);
    }
    /**
     * Inserts many items to the low-numbered side of the array;
     * moves the cursor to `0`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    unshiftMany(items) {
      this.setCursor(0);
      chunkedPush(this.right, items.reverse());
    }
    /**
     * Move the cursor to a specific position in the array. Requires
     * time proportional to the distance moved.
     *
     * If `n < 0`, the cursor will end up at the beginning.
     * If `n > length`, the cursor will end up at the end.
     *
     * @param {number} n
     *   Position.
     * @return {undefined}
     *   Nothing.
     */
    setCursor(n) {
      if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)
        return;
      if (n < this.left.length) {
        const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
        chunkedPush(this.right, removed.reverse());
      } else {
        const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
        chunkedPush(this.left, removed.reverse());
      }
    }
  };
  function chunkedPush(list4, right) {
    let chunkStart = 0;
    if (right.length < 1e4) {
      list4.push(...right);
    } else {
      while (chunkStart < right.length) {
        list4.push(...right.slice(chunkStart, chunkStart + 1e4));
        chunkStart += 1e4;
      }
    }
  }

  // node_modules/remark-parse/node_modules/micromark-util-subtokenize/index.js
  function subtokenize(eventsArray) {
    const jumps = {};
    let index4 = -1;
    let event;
    let lineIndex;
    let otherIndex;
    let otherEvent;
    let parameters;
    let subevents;
    let more;
    const events = new SpliceBuffer(eventsArray);
    while (++index4 < events.length) {
      while (index4 in jumps) {
        index4 = jumps[index4];
      }
      event = events.get(index4);
      if (index4 && event[1].type === "chunkFlow" && events.get(index4 - 1)[1].type === "listItemPrefix") {
        subevents = event[1]._tokenizer.events;
        otherIndex = 0;
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
          otherIndex += 2;
        }
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
          while (++otherIndex < subevents.length) {
            if (subevents[otherIndex][1].type === "content") {
              break;
            }
            if (subevents[otherIndex][1].type === "chunkText") {
              subevents[otherIndex][1]._isInFirstContentOfListItem = true;
              otherIndex++;
            }
          }
        }
      }
      if (event[0] === "enter") {
        if (event[1].contentType) {
          Object.assign(jumps, subcontent(events, index4));
          index4 = jumps[index4];
          more = true;
        }
      } else if (event[1]._container) {
        otherIndex = index4;
        lineIndex = void 0;
        while (otherIndex--) {
          otherEvent = events.get(otherIndex);
          if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
            if (otherEvent[0] === "enter") {
              if (lineIndex) {
                events.get(lineIndex)[1].type = "lineEndingBlank";
              }
              otherEvent[1].type = "lineEnding";
              lineIndex = otherIndex;
            }
          } else {
            break;
          }
        }
        if (lineIndex) {
          event[1].end = Object.assign({}, events.get(lineIndex)[1].start);
          parameters = events.slice(lineIndex, index4);
          parameters.unshift(event);
          events.splice(lineIndex, index4 - lineIndex + 1, parameters);
        }
      }
    }
    splice2(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
    return !more;
  }
  function subcontent(events, eventIndex) {
    const token = events.get(eventIndex)[1];
    const context = events.get(eventIndex)[2];
    let startPosition = eventIndex - 1;
    const startPositions = [];
    const tokenizer2 = token._tokenizer || context.parser[token.contentType](token.start);
    const childEvents = tokenizer2.events;
    const jumps = [];
    const gaps = {};
    let stream;
    let previous2;
    let index4 = -1;
    let current2 = token;
    let adjust = 0;
    let start2 = 0;
    const breaks = [start2];
    while (current2) {
      while (events.get(++startPosition)[1] !== current2) {
      }
      startPositions.push(startPosition);
      if (!current2._tokenizer) {
        stream = context.sliceStream(current2);
        if (!current2.next) {
          stream.push(null);
        }
        if (previous2) {
          tokenizer2.defineSkip(current2.start);
        }
        if (current2._isInFirstContentOfListItem) {
          tokenizer2._gfmTasklistFirstContentOfListItem = true;
        }
        tokenizer2.write(stream);
        if (current2._isInFirstContentOfListItem) {
          tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
        }
      }
      previous2 = current2;
      current2 = current2.next;
    }
    current2 = token;
    while (++index4 < childEvents.length) {
      if (
        // Find a void token that includes a break.
        childEvents[index4][0] === "exit" && childEvents[index4 - 1][0] === "enter" && childEvents[index4][1].type === childEvents[index4 - 1][1].type && childEvents[index4][1].start.line !== childEvents[index4][1].end.line
      ) {
        start2 = index4 + 1;
        breaks.push(start2);
        current2._tokenizer = void 0;
        current2.previous = void 0;
        current2 = current2.next;
      }
    }
    tokenizer2.events = [];
    if (current2) {
      current2._tokenizer = void 0;
      current2.previous = void 0;
    } else {
      breaks.pop();
    }
    index4 = breaks.length;
    while (index4--) {
      const slice = childEvents.slice(breaks[index4], breaks[index4 + 1]);
      const start3 = startPositions.pop();
      jumps.push([start3, start3 + slice.length - 1]);
      events.splice(start3, 2, slice);
    }
    jumps.reverse();
    index4 = -1;
    while (++index4 < jumps.length) {
      gaps[adjust + jumps[index4][0]] = adjust + jumps[index4][1];
      adjust += jumps[index4][1] - jumps[index4][0] - 1;
    }
    return gaps;
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/content.js
  var content2 = {
    tokenize: tokenizeContent,
    resolve: resolveContent
  };
  var continuationConstruct = {
    tokenize: tokenizeContinuation,
    partial: true
  };
  function resolveContent(events) {
    subtokenize(events);
    return events;
  }
  function tokenizeContent(effects, ok3) {
    let previous2;
    return chunkStart;
    function chunkStart(code2) {
      effects.enter("content");
      previous2 = effects.enter("chunkContent", {
        contentType: "content"
      });
      return chunkInside(code2);
    }
    function chunkInside(code2) {
      if (code2 === null) {
        return contentEnd(code2);
      }
      if (markdownLineEnding5(code2)) {
        return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
      }
      effects.consume(code2);
      return chunkInside;
    }
    function contentEnd(code2) {
      effects.exit("chunkContent");
      effects.exit("content");
      return ok3(code2);
    }
    function contentContinue(code2) {
      effects.consume(code2);
      effects.exit("chunkContent");
      previous2.next = effects.enter("chunkContent", {
        contentType: "content",
        previous: previous2
      });
      previous2 = previous2.next;
      return chunkInside;
    }
  }
  function tokenizeContinuation(effects, ok3, nok) {
    const self2 = this;
    return startLookahead;
    function startLookahead(code2) {
      effects.exit("chunkContent");
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace4(effects, prefixed, "linePrefix");
    }
    function prefixed(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        return nok(code2);
      }
      const tail = self2.events[self2.events.length - 1];
      if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return ok3(code2);
      }
      return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-factory-destination/index.js
  function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
    const limit = max || Number.POSITIVE_INFINITY;
    let balance = 0;
    return start2;
    function start2(code2) {
      if (code2 === 60) {
        effects.enter(type);
        effects.enter(literalType);
        effects.enter(literalMarkerType);
        effects.consume(code2);
        effects.exit(literalMarkerType);
        return enclosedBefore;
      }
      if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
        return nok(code2);
      }
      effects.enter(type);
      effects.enter(rawType);
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return raw(code2);
    }
    function enclosedBefore(code2) {
      if (code2 === 62) {
        effects.enter(literalMarkerType);
        effects.consume(code2);
        effects.exit(literalMarkerType);
        effects.exit(literalType);
        effects.exit(type);
        return ok3;
      }
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return enclosed(code2);
    }
    function enclosed(code2) {
      if (code2 === 62) {
        effects.exit("chunkString");
        effects.exit(stringType);
        return enclosedBefore(code2);
      }
      if (code2 === null || code2 === 60 || markdownLineEnding5(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? enclosedEscape : enclosed;
    }
    function enclosedEscape(code2) {
      if (code2 === 60 || code2 === 62 || code2 === 92) {
        effects.consume(code2);
        return enclosed;
      }
      return enclosed(code2);
    }
    function raw(code2) {
      if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace2(code2))) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok3(code2);
      }
      if (balance < limit && code2 === 40) {
        effects.consume(code2);
        balance++;
        return raw;
      }
      if (code2 === 41) {
        effects.consume(code2);
        balance--;
        return raw;
      }
      if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? rawEscape : raw;
    }
    function rawEscape(code2) {
      if (code2 === 40 || code2 === 41 || code2 === 92) {
        effects.consume(code2);
        return raw;
      }
      return raw(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-factory-label/index.js
  function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
    const self2 = this;
    let size = 0;
    let seen;
    return start2;
    function start2(code2) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.enter(stringType);
      return atBreak;
    }
    function atBreak(code2) {
      if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once we’ve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesn’t need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
        return nok(code2);
      }
      if (code2 === 93) {
        effects.exit(stringType);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.exit(type);
        return ok3;
      }
      if (markdownLineEnding5(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return atBreak;
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return labelInside(code2);
    }
    function labelInside(code2) {
      if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding5(code2) || size++ > 999) {
        effects.exit("chunkString");
        return atBreak(code2);
      }
      effects.consume(code2);
      if (!seen)
        seen = !markdownSpace4(code2);
      return code2 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code2) {
      if (code2 === 91 || code2 === 92 || code2 === 93) {
        effects.consume(code2);
        size++;
        return labelInside;
      }
      return labelInside(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-factory-title/index.js
  function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
    let marker;
    return start2;
    function start2(code2) {
      if (code2 === 34 || code2 === 39 || code2 === 40) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        marker = code2 === 40 ? 41 : code2;
        return begin;
      }
      return nok(code2);
    }
    function begin(code2) {
      if (code2 === marker) {
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.exit(type);
        return ok3;
      }
      effects.enter(stringType);
      return atBreak(code2);
    }
    function atBreak(code2) {
      if (code2 === marker) {
        effects.exit(stringType);
        return begin(marker);
      }
      if (code2 === null) {
        return nok(code2);
      }
      if (markdownLineEnding5(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace4(effects, atBreak, "linePrefix");
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === marker || code2 === null || markdownLineEnding5(code2)) {
        effects.exit("chunkString");
        return atBreak(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? escape : inside;
    }
    function escape(code2) {
      if (code2 === marker || code2 === 92) {
        effects.consume(code2);
        return inside;
      }
      return inside(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-factory-whitespace/index.js
  function factoryWhitespace(effects, ok3) {
    let seen;
    return start2;
    function start2(code2) {
      if (markdownLineEnding5(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        seen = true;
        return start2;
      }
      if (markdownSpace4(code2)) {
        return factorySpace4(
          effects,
          start2,
          seen ? "linePrefix" : "lineSuffix"
        )(code2);
      }
      return ok3(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/definition.js
  var definition = {
    name: "definition",
    tokenize: tokenizeDefinition
  };
  var titleBefore = {
    tokenize: tokenizeTitleBefore,
    partial: true
  };
  function tokenizeDefinition(effects, ok3, nok) {
    const self2 = this;
    let identifier;
    return start2;
    function start2(code2) {
      effects.enter("definition");
      return before(code2);
    }
    function before(code2) {
      return factoryLabel.call(
        self2,
        effects,
        labelAfter,
        // Note: we don’t need to reset the way `markdown-rs` does.
        nok,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(code2);
    }
    function labelAfter(code2) {
      identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
      if (code2 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code2);
        effects.exit("definitionMarker");
        return markerAfter;
      }
      return nok(code2);
    }
    function markerAfter(code2) {
      return markdownLineEndingOrSpace2(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
    }
    function destinationBefore(code2) {
      return factoryDestination(
        effects,
        destinationAfter,
        // Note: we don’t need to reset the way `markdown-rs` does.
        nok,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(code2);
    }
    function destinationAfter(code2) {
      return effects.attempt(titleBefore, after, after)(code2);
    }
    function after(code2) {
      return markdownSpace4(code2) ? factorySpace4(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
    }
    function afterWhitespace(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("definition");
        self2.parser.defined.push(identifier);
        return ok3(code2);
      }
      return nok(code2);
    }
  }
  function tokenizeTitleBefore(effects, ok3, nok) {
    return titleBefore2;
    function titleBefore2(code2) {
      return markdownLineEndingOrSpace2(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
    }
    function beforeMarker(code2) {
      return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
    }
    function titleAfter(code2) {
      return markdownSpace4(code2) ? factorySpace4(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
    }
    function titleAfterOptionalWhitespace(code2) {
      return code2 === null || markdownLineEnding5(code2) ? ok3(code2) : nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/hard-break-escape.js
  var hardBreakEscape = {
    name: "hardBreakEscape",
    tokenize: tokenizeHardBreakEscape
  };
  function tokenizeHardBreakEscape(effects, ok3, nok) {
    return start2;
    function start2(code2) {
      effects.enter("hardBreakEscape");
      effects.consume(code2);
      return after;
    }
    function after(code2) {
      if (markdownLineEnding5(code2)) {
        effects.exit("hardBreakEscape");
        return ok3(code2);
      }
      return nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/heading-atx.js
  var headingAtx = {
    name: "headingAtx",
    tokenize: tokenizeHeadingAtx,
    resolve: resolveHeadingAtx
  };
  function resolveHeadingAtx(events, context) {
    let contentEnd = events.length - 2;
    let contentStart = 3;
    let content3;
    let text4;
    if (events[contentStart][1].type === "whitespace") {
      contentStart += 2;
    }
    if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
      contentEnd -= 2;
    }
    if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
      contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
    }
    if (contentEnd > contentStart) {
      content3 = {
        type: "atxHeadingText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end
      };
      text4 = {
        type: "chunkText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end,
        contentType: "text"
      };
      splice2(events, contentStart, contentEnd - contentStart + 1, [["enter", content3, context], ["enter", text4, context], ["exit", text4, context], ["exit", content3, context]]);
    }
    return events;
  }
  function tokenizeHeadingAtx(effects, ok3, nok) {
    let size = 0;
    return start2;
    function start2(code2) {
      effects.enter("atxHeading");
      return before(code2);
    }
    function before(code2) {
      effects.enter("atxHeadingSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === 35 && size++ < 6) {
        effects.consume(code2);
        return sequenceOpen;
      }
      if (code2 === null || markdownLineEndingOrSpace2(code2)) {
        effects.exit("atxHeadingSequence");
        return atBreak(code2);
      }
      return nok(code2);
    }
    function atBreak(code2) {
      if (code2 === 35) {
        effects.enter("atxHeadingSequence");
        return sequenceFurther(code2);
      }
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("atxHeading");
        return ok3(code2);
      }
      if (markdownSpace4(code2)) {
        return factorySpace4(effects, atBreak, "whitespace")(code2);
      }
      effects.enter("atxHeadingText");
      return data2(code2);
    }
    function sequenceFurther(code2) {
      if (code2 === 35) {
        effects.consume(code2);
        return sequenceFurther;
      }
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    function data2(code2) {
      if (code2 === null || code2 === 35 || markdownLineEndingOrSpace2(code2)) {
        effects.exit("atxHeadingText");
        return atBreak(code2);
      }
      effects.consume(code2);
      return data2;
    }
  }

  // node_modules/remark-parse/node_modules/micromark-util-html-tag-name/index.js
  var htmlBlockNames = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
  var htmlRawNames = ["pre", "script", "style", "textarea"];

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/html-flow.js
  var htmlFlow = {
    name: "htmlFlow",
    tokenize: tokenizeHtmlFlow,
    resolveTo: resolveToHtmlFlow,
    concrete: true
  };
  var blankLineBefore2 = {
    tokenize: tokenizeBlankLineBefore,
    partial: true
  };
  var nonLazyContinuationStart = {
    tokenize: tokenizeNonLazyContinuationStart,
    partial: true
  };
  function resolveToHtmlFlow(events) {
    let index4 = events.length;
    while (index4--) {
      if (events[index4][0] === "enter" && events[index4][1].type === "htmlFlow") {
        break;
      }
    }
    if (index4 > 1 && events[index4 - 2][1].type === "linePrefix") {
      events[index4][1].start = events[index4 - 2][1].start;
      events[index4 + 1][1].start = events[index4 - 2][1].start;
      events.splice(index4 - 2, 2);
    }
    return events;
  }
  function tokenizeHtmlFlow(effects, ok3, nok) {
    const self2 = this;
    let marker;
    let closingTag;
    let buffer;
    let index4;
    let markerB;
    return start2;
    function start2(code2) {
      return before(code2);
    }
    function before(code2) {
      effects.enter("htmlFlow");
      effects.enter("htmlFlowData");
      effects.consume(code2);
      return open;
    }
    function open(code2) {
      if (code2 === 33) {
        effects.consume(code2);
        return declarationOpen;
      }
      if (code2 === 47) {
        effects.consume(code2);
        closingTag = true;
        return tagCloseStart;
      }
      if (code2 === 63) {
        effects.consume(code2);
        marker = 3;
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      if (asciiAlpha5(code2)) {
        effects.consume(code2);
        buffer = String.fromCharCode(code2);
        return tagName;
      }
      return nok(code2);
    }
    function declarationOpen(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        marker = 2;
        return commentOpenInside;
      }
      if (code2 === 91) {
        effects.consume(code2);
        marker = 5;
        index4 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha5(code2)) {
        effects.consume(code2);
        marker = 4;
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      return nok(code2);
    }
    function commentOpenInside(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      return nok(code2);
    }
    function cdataOpenInside(code2) {
      const value = "CDATA[";
      if (code2 === value.charCodeAt(index4++)) {
        effects.consume(code2);
        if (index4 === value.length) {
          return self2.interrupt ? ok3 : continuation;
        }
        return cdataOpenInside;
      }
      return nok(code2);
    }
    function tagCloseStart(code2) {
      if (asciiAlpha5(code2)) {
        effects.consume(code2);
        buffer = String.fromCharCode(code2);
        return tagName;
      }
      return nok(code2);
    }
    function tagName(code2) {
      if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace2(code2)) {
        const slash = code2 === 47;
        const name2 = buffer.toLowerCase();
        if (!slash && !closingTag && htmlRawNames.includes(name2)) {
          marker = 1;
          return self2.interrupt ? ok3(code2) : continuation(code2);
        }
        if (htmlBlockNames.includes(buffer.toLowerCase())) {
          marker = 6;
          if (slash) {
            effects.consume(code2);
            return basicSelfClosing;
          }
          return self2.interrupt ? ok3(code2) : continuation(code2);
        }
        marker = 7;
        return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
      }
      if (code2 === 45 || asciiAlphanumeric5(code2)) {
        effects.consume(code2);
        buffer += String.fromCharCode(code2);
        return tagName;
      }
      return nok(code2);
    }
    function basicSelfClosing(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        return self2.interrupt ? ok3 : continuation;
      }
      return nok(code2);
    }
    function completeClosingTagAfter(code2) {
      if (markdownSpace4(code2)) {
        effects.consume(code2);
        return completeClosingTagAfter;
      }
      return completeEnd(code2);
    }
    function completeAttributeNameBefore(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        return completeEnd;
      }
      if (code2 === 58 || code2 === 95 || asciiAlpha5(code2)) {
        effects.consume(code2);
        return completeAttributeName;
      }
      if (markdownSpace4(code2)) {
        effects.consume(code2);
        return completeAttributeNameBefore;
      }
      return completeEnd(code2);
    }
    function completeAttributeName(code2) {
      if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric5(code2)) {
        effects.consume(code2);
        return completeAttributeName;
      }
      return completeAttributeNameAfter(code2);
    }
    function completeAttributeNameAfter(code2) {
      if (code2 === 61) {
        effects.consume(code2);
        return completeAttributeValueBefore;
      }
      if (markdownSpace4(code2)) {
        effects.consume(code2);
        return completeAttributeNameAfter;
      }
      return completeAttributeNameBefore(code2);
    }
    function completeAttributeValueBefore(code2) {
      if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
        return nok(code2);
      }
      if (code2 === 34 || code2 === 39) {
        effects.consume(code2);
        markerB = code2;
        return completeAttributeValueQuoted;
      }
      if (markdownSpace4(code2)) {
        effects.consume(code2);
        return completeAttributeValueBefore;
      }
      return completeAttributeValueUnquoted(code2);
    }
    function completeAttributeValueQuoted(code2) {
      if (code2 === markerB) {
        effects.consume(code2);
        markerB = null;
        return completeAttributeValueQuotedAfter;
      }
      if (code2 === null || markdownLineEnding5(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return completeAttributeValueQuoted;
    }
    function completeAttributeValueUnquoted(code2) {
      if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace2(code2)) {
        return completeAttributeNameAfter(code2);
      }
      effects.consume(code2);
      return completeAttributeValueUnquoted;
    }
    function completeAttributeValueQuotedAfter(code2) {
      if (code2 === 47 || code2 === 62 || markdownSpace4(code2)) {
        return completeAttributeNameBefore(code2);
      }
      return nok(code2);
    }
    function completeEnd(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        return completeAfter;
      }
      return nok(code2);
    }
    function completeAfter(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        return continuation(code2);
      }
      if (markdownSpace4(code2)) {
        effects.consume(code2);
        return completeAfter;
      }
      return nok(code2);
    }
    function continuation(code2) {
      if (code2 === 45 && marker === 2) {
        effects.consume(code2);
        return continuationCommentInside;
      }
      if (code2 === 60 && marker === 1) {
        effects.consume(code2);
        return continuationRawTagOpen;
      }
      if (code2 === 62 && marker === 4) {
        effects.consume(code2);
        return continuationClose;
      }
      if (code2 === 63 && marker === 3) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      if (code2 === 93 && marker === 5) {
        effects.consume(code2);
        return continuationCdataInside;
      }
      if (markdownLineEnding5(code2) && (marker === 6 || marker === 7)) {
        effects.exit("htmlFlowData");
        return effects.check(blankLineBefore2, continuationAfter, continuationStart)(code2);
      }
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("htmlFlowData");
        return continuationStart(code2);
      }
      effects.consume(code2);
      return continuation;
    }
    function continuationStart(code2) {
      return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code2);
    }
    function continuationStartNonLazy(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return continuationBefore;
    }
    function continuationBefore(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        return continuationStart(code2);
      }
      effects.enter("htmlFlowData");
      return continuation(code2);
    }
    function continuationCommentInside(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      return continuation(code2);
    }
    function continuationRawTagOpen(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        buffer = "";
        return continuationRawEndTag;
      }
      return continuation(code2);
    }
    function continuationRawEndTag(code2) {
      if (code2 === 62) {
        const name2 = buffer.toLowerCase();
        if (htmlRawNames.includes(name2)) {
          effects.consume(code2);
          return continuationClose;
        }
        return continuation(code2);
      }
      if (asciiAlpha5(code2) && buffer.length < 8) {
        effects.consume(code2);
        buffer += String.fromCharCode(code2);
        return continuationRawEndTag;
      }
      return continuation(code2);
    }
    function continuationCdataInside(code2) {
      if (code2 === 93) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      return continuation(code2);
    }
    function continuationDeclarationInside(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        return continuationClose;
      }
      if (code2 === 45 && marker === 2) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      return continuation(code2);
    }
    function continuationClose(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("htmlFlowData");
        return continuationAfter(code2);
      }
      effects.consume(code2);
      return continuationClose;
    }
    function continuationAfter(code2) {
      effects.exit("htmlFlow");
      return ok3(code2);
    }
  }
  function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code2) {
      if (markdownLineEnding5(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
    }
  }
  function tokenizeBlankLineBefore(effects, ok3, nok) {
    return start2;
    function start2(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return effects.attempt(blankLine2, ok3, nok);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/html-text.js
  var htmlText = {
    name: "htmlText",
    tokenize: tokenizeHtmlText
  };
  function tokenizeHtmlText(effects, ok3, nok) {
    const self2 = this;
    let marker;
    let index4;
    let returnState;
    return start2;
    function start2(code2) {
      effects.enter("htmlText");
      effects.enter("htmlTextData");
      effects.consume(code2);
      return open;
    }
    function open(code2) {
      if (code2 === 33) {
        effects.consume(code2);
        return declarationOpen;
      }
      if (code2 === 47) {
        effects.consume(code2);
        return tagCloseStart;
      }
      if (code2 === 63) {
        effects.consume(code2);
        return instruction;
      }
      if (asciiAlpha5(code2)) {
        effects.consume(code2);
        return tagOpen;
      }
      return nok(code2);
    }
    function declarationOpen(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return commentOpenInside;
      }
      if (code2 === 91) {
        effects.consume(code2);
        index4 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha5(code2)) {
        effects.consume(code2);
        return declaration;
      }
      return nok(code2);
    }
    function commentOpenInside(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return commentEnd;
      }
      return nok(code2);
    }
    function comment(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 45) {
        effects.consume(code2);
        return commentClose;
      }
      if (markdownLineEnding5(code2)) {
        returnState = comment;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return comment;
    }
    function commentClose(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return commentEnd;
      }
      return comment(code2);
    }
    function commentEnd(code2) {
      return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment(code2);
    }
    function cdataOpenInside(code2) {
      const value = "CDATA[";
      if (code2 === value.charCodeAt(index4++)) {
        effects.consume(code2);
        return index4 === value.length ? cdata : cdataOpenInside;
      }
      return nok(code2);
    }
    function cdata(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 93) {
        effects.consume(code2);
        return cdataClose;
      }
      if (markdownLineEnding5(code2)) {
        returnState = cdata;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return cdata;
    }
    function cdataClose(code2) {
      if (code2 === 93) {
        effects.consume(code2);
        return cdataEnd;
      }
      return cdata(code2);
    }
    function cdataEnd(code2) {
      if (code2 === 62) {
        return end(code2);
      }
      if (code2 === 93) {
        effects.consume(code2);
        return cdataEnd;
      }
      return cdata(code2);
    }
    function declaration(code2) {
      if (code2 === null || code2 === 62) {
        return end(code2);
      }
      if (markdownLineEnding5(code2)) {
        returnState = declaration;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return declaration;
    }
    function instruction(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 63) {
        effects.consume(code2);
        return instructionClose;
      }
      if (markdownLineEnding5(code2)) {
        returnState = instruction;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return instruction;
    }
    function instructionClose(code2) {
      return code2 === 62 ? end(code2) : instruction(code2);
    }
    function tagCloseStart(code2) {
      if (asciiAlpha5(code2)) {
        effects.consume(code2);
        return tagClose;
      }
      return nok(code2);
    }
    function tagClose(code2) {
      if (code2 === 45 || asciiAlphanumeric5(code2)) {
        effects.consume(code2);
        return tagClose;
      }
      return tagCloseBetween(code2);
    }
    function tagCloseBetween(code2) {
      if (markdownLineEnding5(code2)) {
        returnState = tagCloseBetween;
        return lineEndingBefore(code2);
      }
      if (markdownSpace4(code2)) {
        effects.consume(code2);
        return tagCloseBetween;
      }
      return end(code2);
    }
    function tagOpen(code2) {
      if (code2 === 45 || asciiAlphanumeric5(code2)) {
        effects.consume(code2);
        return tagOpen;
      }
      if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace2(code2)) {
        return tagOpenBetween(code2);
      }
      return nok(code2);
    }
    function tagOpenBetween(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        return end;
      }
      if (code2 === 58 || code2 === 95 || asciiAlpha5(code2)) {
        effects.consume(code2);
        return tagOpenAttributeName;
      }
      if (markdownLineEnding5(code2)) {
        returnState = tagOpenBetween;
        return lineEndingBefore(code2);
      }
      if (markdownSpace4(code2)) {
        effects.consume(code2);
        return tagOpenBetween;
      }
      return end(code2);
    }
    function tagOpenAttributeName(code2) {
      if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric5(code2)) {
        effects.consume(code2);
        return tagOpenAttributeName;
      }
      return tagOpenAttributeNameAfter(code2);
    }
    function tagOpenAttributeNameAfter(code2) {
      if (code2 === 61) {
        effects.consume(code2);
        return tagOpenAttributeValueBefore;
      }
      if (markdownLineEnding5(code2)) {
        returnState = tagOpenAttributeNameAfter;
        return lineEndingBefore(code2);
      }
      if (markdownSpace4(code2)) {
        effects.consume(code2);
        return tagOpenAttributeNameAfter;
      }
      return tagOpenBetween(code2);
    }
    function tagOpenAttributeValueBefore(code2) {
      if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
        return nok(code2);
      }
      if (code2 === 34 || code2 === 39) {
        effects.consume(code2);
        marker = code2;
        return tagOpenAttributeValueQuoted;
      }
      if (markdownLineEnding5(code2)) {
        returnState = tagOpenAttributeValueBefore;
        return lineEndingBefore(code2);
      }
      if (markdownSpace4(code2)) {
        effects.consume(code2);
        return tagOpenAttributeValueBefore;
      }
      effects.consume(code2);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuoted(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        marker = void 0;
        return tagOpenAttributeValueQuotedAfter;
      }
      if (code2 === null) {
        return nok(code2);
      }
      if (markdownLineEnding5(code2)) {
        returnState = tagOpenAttributeValueQuoted;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return tagOpenAttributeValueQuoted;
    }
    function tagOpenAttributeValueUnquoted(code2) {
      if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
        return nok(code2);
      }
      if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace2(code2)) {
        return tagOpenBetween(code2);
      }
      effects.consume(code2);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuotedAfter(code2) {
      if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace2(code2)) {
        return tagOpenBetween(code2);
      }
      return nok(code2);
    }
    function end(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        effects.exit("htmlTextData");
        effects.exit("htmlText");
        return ok3;
      }
      return nok(code2);
    }
    function lineEndingBefore(code2) {
      effects.exit("htmlTextData");
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return lineEndingAfter;
    }
    function lineEndingAfter(code2) {
      return markdownSpace4(code2) ? factorySpace4(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : lineEndingAfterPrefix(code2);
    }
    function lineEndingAfterPrefix(code2) {
      effects.enter("htmlTextData");
      return returnState(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/label-end.js
  var labelEnd = {
    name: "labelEnd",
    tokenize: tokenizeLabelEnd,
    resolveTo: resolveToLabelEnd,
    resolveAll: resolveAllLabelEnd
  };
  var resourceConstruct = {
    tokenize: tokenizeResource
  };
  var referenceFullConstruct = {
    tokenize: tokenizeReferenceFull
  };
  var referenceCollapsedConstruct = {
    tokenize: tokenizeReferenceCollapsed
  };
  function resolveAllLabelEnd(events) {
    let index4 = -1;
    while (++index4 < events.length) {
      const token = events[index4][1];
      if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
        events.splice(index4 + 1, token.type === "labelImage" ? 4 : 2);
        token.type = "data";
        index4++;
      }
    }
    return events;
  }
  function resolveToLabelEnd(events, context) {
    let index4 = events.length;
    let offset2 = 0;
    let token;
    let open;
    let close;
    let media;
    while (index4--) {
      token = events[index4][1];
      if (open) {
        if (token.type === "link" || token.type === "labelLink" && token._inactive) {
          break;
        }
        if (events[index4][0] === "enter" && token.type === "labelLink") {
          token._inactive = true;
        }
      } else if (close) {
        if (events[index4][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
          open = index4;
          if (token.type !== "labelLink") {
            offset2 = 2;
            break;
          }
        }
      } else if (token.type === "labelEnd") {
        close = index4;
      }
    }
    const group = {
      type: events[open][1].type === "labelLink" ? "link" : "image",
      start: Object.assign({}, events[open][1].start),
      end: Object.assign({}, events[events.length - 1][1].end)
    };
    const label = {
      type: "label",
      start: Object.assign({}, events[open][1].start),
      end: Object.assign({}, events[close][1].end)
    };
    const text4 = {
      type: "labelText",
      start: Object.assign({}, events[open + offset2 + 2][1].end),
      end: Object.assign({}, events[close - 2][1].start)
    };
    media = [["enter", group, context], ["enter", label, context]];
    media = push(media, events.slice(open + 1, open + offset2 + 3));
    media = push(media, [["enter", text4, context]]);
    media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset2 + 4, close - 3), context));
    media = push(media, [["exit", text4, context], events[close - 2], events[close - 1], ["exit", label, context]]);
    media = push(media, events.slice(close + 1));
    media = push(media, [["exit", group, context]]);
    splice2(events, open, events.length, media);
    return events;
  }
  function tokenizeLabelEnd(effects, ok3, nok) {
    const self2 = this;
    let index4 = self2.events.length;
    let labelStart;
    let defined;
    while (index4--) {
      if ((self2.events[index4][1].type === "labelImage" || self2.events[index4][1].type === "labelLink") && !self2.events[index4][1]._balanced) {
        labelStart = self2.events[index4][1];
        break;
      }
    }
    return start2;
    function start2(code2) {
      if (!labelStart) {
        return nok(code2);
      }
      if (labelStart._inactive) {
        return labelEndNok(code2);
      }
      defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })));
      effects.enter("labelEnd");
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelEnd");
      return after;
    }
    function after(code2) {
      if (code2 === 40) {
        return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code2);
      }
      if (code2 === 91) {
        return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code2);
      }
      return defined ? labelEndOk(code2) : labelEndNok(code2);
    }
    function referenceNotFull(code2) {
      return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code2);
    }
    function labelEndOk(code2) {
      return ok3(code2);
    }
    function labelEndNok(code2) {
      labelStart._balanced = true;
      return nok(code2);
    }
  }
  function tokenizeResource(effects, ok3, nok) {
    return resourceStart;
    function resourceStart(code2) {
      effects.enter("resource");
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      return resourceBefore;
    }
    function resourceBefore(code2) {
      return markdownLineEndingOrSpace2(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
    }
    function resourceOpen(code2) {
      if (code2 === 41) {
        return resourceEnd(code2);
      }
      return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
    }
    function resourceDestinationAfter(code2) {
      return markdownLineEndingOrSpace2(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
    }
    function resourceDestinationMissing(code2) {
      return nok(code2);
    }
    function resourceBetween(code2) {
      if (code2 === 34 || code2 === 39 || code2 === 40) {
        return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
      }
      return resourceEnd(code2);
    }
    function resourceTitleAfter(code2) {
      return markdownLineEndingOrSpace2(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
    }
    function resourceEnd(code2) {
      if (code2 === 41) {
        effects.enter("resourceMarker");
        effects.consume(code2);
        effects.exit("resourceMarker");
        effects.exit("resource");
        return ok3;
      }
      return nok(code2);
    }
  }
  function tokenizeReferenceFull(effects, ok3, nok) {
    const self2 = this;
    return referenceFull;
    function referenceFull(code2) {
      return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code2);
    }
    function referenceFullAfter(code2) {
      return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok3(code2) : nok(code2);
    }
    function referenceFullMissing(code2) {
      return nok(code2);
    }
  }
  function tokenizeReferenceCollapsed(effects, ok3, nok) {
    return referenceCollapsedStart;
    function referenceCollapsedStart(code2) {
      effects.enter("reference");
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      return referenceCollapsedOpen;
    }
    function referenceCollapsedOpen(code2) {
      if (code2 === 93) {
        effects.enter("referenceMarker");
        effects.consume(code2);
        effects.exit("referenceMarker");
        effects.exit("reference");
        return ok3;
      }
      return nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/label-start-image.js
  var labelStartImage = {
    name: "labelStartImage",
    tokenize: tokenizeLabelStartImage,
    resolveAll: labelEnd.resolveAll
  };
  function tokenizeLabelStartImage(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code2) {
      effects.enter("labelImage");
      effects.enter("labelImageMarker");
      effects.consume(code2);
      effects.exit("labelImageMarker");
      return open;
    }
    function open(code2) {
      if (code2 === 91) {
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelImage");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/label-start-link.js
  var labelStartLink = {
    name: "labelStartLink",
    tokenize: tokenizeLabelStartLink,
    resolveAll: labelEnd.resolveAll
  };
  function tokenizeLabelStartLink(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code2) {
      effects.enter("labelLink");
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelLink");
      return after;
    }
    function after(code2) {
      return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/line-ending.js
  var lineEnding = {
    name: "lineEnding",
    tokenize: tokenizeLineEnding
  };
  function tokenizeLineEnding(effects, ok3) {
    return start2;
    function start2(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace4(effects, ok3, "linePrefix");
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/thematic-break.js
  var thematicBreak = {
    name: "thematicBreak",
    tokenize: tokenizeThematicBreak
  };
  function tokenizeThematicBreak(effects, ok3, nok) {
    let size = 0;
    let marker;
    return start2;
    function start2(code2) {
      effects.enter("thematicBreak");
      return before(code2);
    }
    function before(code2) {
      marker = code2;
      return atBreak(code2);
    }
    function atBreak(code2) {
      if (code2 === marker) {
        effects.enter("thematicBreakSequence");
        return sequence(code2);
      }
      if (size >= 3 && (code2 === null || markdownLineEnding5(code2))) {
        effects.exit("thematicBreak");
        return ok3(code2);
      }
      return nok(code2);
    }
    function sequence(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        size++;
        return sequence;
      }
      effects.exit("thematicBreakSequence");
      return markdownSpace4(code2) ? factorySpace4(effects, atBreak, "whitespace")(code2) : atBreak(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/list.js
  var list = {
    name: "list",
    tokenize: tokenizeListStart,
    continuation: {
      tokenize: tokenizeListContinuation
    },
    exit: tokenizeListEnd
  };
  var listItemPrefixWhitespaceConstruct = {
    tokenize: tokenizeListItemPrefixWhitespace,
    partial: true
  };
  var indentConstruct = {
    tokenize: tokenizeIndent,
    partial: true
  };
  function tokenizeListStart(effects, ok3, nok) {
    const self2 = this;
    const tail = self2.events[self2.events.length - 1];
    let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    let size = 0;
    return start2;
    function start2(code2) {
      const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
      if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit5(code2)) {
        if (!self2.containerState.type) {
          self2.containerState.type = kind;
          effects.enter(kind, {
            _container: true
          });
        }
        if (kind === "listUnordered") {
          effects.enter("listItemPrefix");
          return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
        }
        if (!self2.interrupt || code2 === 49) {
          effects.enter("listItemPrefix");
          effects.enter("listItemValue");
          return inside(code2);
        }
      }
      return nok(code2);
    }
    function inside(code2) {
      if (asciiDigit5(code2) && ++size < 10) {
        effects.consume(code2);
        return inside;
      }
      if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
        effects.exit("listItemValue");
        return atMarker(code2);
      }
      return nok(code2);
    }
    function atMarker(code2) {
      effects.enter("listItemMarker");
      effects.consume(code2);
      effects.exit("listItemMarker");
      self2.containerState.marker = self2.containerState.marker || code2;
      return effects.check(
        blankLine2,
        // Can’t be empty when interrupting.
        self2.interrupt ? nok : onBlank,
        effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
      );
    }
    function onBlank(code2) {
      self2.containerState.initialBlankLine = true;
      initialSize++;
      return endOfPrefix(code2);
    }
    function otherPrefix(code2) {
      if (markdownSpace4(code2)) {
        effects.enter("listItemPrefixWhitespace");
        effects.consume(code2);
        effects.exit("listItemPrefixWhitespace");
        return endOfPrefix;
      }
      return nok(code2);
    }
    function endOfPrefix(code2) {
      self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
      return ok3(code2);
    }
  }
  function tokenizeListContinuation(effects, ok3, nok) {
    const self2 = this;
    self2.containerState._closeFlow = void 0;
    return effects.check(blankLine2, onBlank, notBlank);
    function onBlank(code2) {
      self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
      return factorySpace4(effects, ok3, "listItemIndent", self2.containerState.size + 1)(code2);
    }
    function notBlank(code2) {
      if (self2.containerState.furtherBlankLines || !markdownSpace4(code2)) {
        self2.containerState.furtherBlankLines = void 0;
        self2.containerState.initialBlankLine = void 0;
        return notInCurrentItem(code2);
      }
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code2);
    }
    function notInCurrentItem(code2) {
      self2.containerState._closeFlow = true;
      self2.interrupt = void 0;
      return factorySpace4(effects, effects.attempt(list, ok3, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
    }
  }
  function tokenizeIndent(effects, ok3, nok) {
    const self2 = this;
    return factorySpace4(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code2) : nok(code2);
    }
  }
  function tokenizeListEnd(effects) {
    effects.exit(this.containerState.type);
  }
  function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
    const self2 = this;
    return factorySpace4(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return !markdownSpace4(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok3(code2) : nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/setext-underline.js
  var setextUnderline = {
    name: "setextUnderline",
    tokenize: tokenizeSetextUnderline,
    resolveTo: resolveToSetextUnderline
  };
  function resolveToSetextUnderline(events, context) {
    let index4 = events.length;
    let content3;
    let text4;
    let definition3;
    while (index4--) {
      if (events[index4][0] === "enter") {
        if (events[index4][1].type === "content") {
          content3 = index4;
          break;
        }
        if (events[index4][1].type === "paragraph") {
          text4 = index4;
        }
      } else {
        if (events[index4][1].type === "content") {
          events.splice(index4, 1);
        }
        if (!definition3 && events[index4][1].type === "definition") {
          definition3 = index4;
        }
      }
    }
    const heading2 = {
      type: "setextHeading",
      start: Object.assign({}, events[text4][1].start),
      end: Object.assign({}, events[events.length - 1][1].end)
    };
    events[text4][1].type = "setextHeadingText";
    if (definition3) {
      events.splice(text4, 0, ["enter", heading2, context]);
      events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
      events[content3][1].end = Object.assign({}, events[definition3][1].end);
    } else {
      events[content3][1] = heading2;
    }
    events.push(["exit", heading2, context]);
    return events;
  }
  function tokenizeSetextUnderline(effects, ok3, nok) {
    const self2 = this;
    let marker;
    return start2;
    function start2(code2) {
      let index4 = self2.events.length;
      let paragraph2;
      while (index4--) {
        if (self2.events[index4][1].type !== "lineEnding" && self2.events[index4][1].type !== "linePrefix" && self2.events[index4][1].type !== "content") {
          paragraph2 = self2.events[index4][1].type === "paragraph";
          break;
        }
      }
      if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
        effects.enter("setextHeadingLine");
        marker = code2;
        return before(code2);
      }
      return nok(code2);
    }
    function before(code2) {
      effects.enter("setextHeadingLineSequence");
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        return inside;
      }
      effects.exit("setextHeadingLineSequence");
      return markdownSpace4(code2) ? factorySpace4(effects, after, "lineSuffix")(code2) : after(code2);
    }
    function after(code2) {
      if (code2 === null || markdownLineEnding5(code2)) {
        effects.exit("setextHeadingLine");
        return ok3(code2);
      }
      return nok(code2);
    }
  }

  // node_modules/remark-parse/node_modules/micromark/lib/initialize/flow.js
  var flow = {
    tokenize: initializeFlow
  };
  function initializeFlow(effects) {
    const self2 = this;
    const initial = effects.attempt(
      // Try to parse a blank line.
      blankLine2,
      atBlankEnding,
      // Try to parse initial flow (essentially, only code).
      effects.attempt(
        this.parser.constructs.flowInitial,
        afterConstruct,
        factorySpace4(
          effects,
          effects.attempt(
            this.parser.constructs.flow,
            afterConstruct,
            effects.attempt(content2, afterConstruct)
          ),
          "linePrefix"
        )
      )
    );
    return initial;
    function atBlankEnding(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("lineEndingBlank");
      effects.consume(code2);
      effects.exit("lineEndingBlank");
      self2.currentConstruct = void 0;
      return initial;
    }
    function afterConstruct(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      self2.currentConstruct = void 0;
      return initial;
    }
  }

  // node_modules/remark-parse/node_modules/micromark/lib/initialize/text.js
  var resolver = {
    resolveAll: createResolver()
  };
  var string = initializeFactory("string");
  var text = initializeFactory("text");
  function initializeFactory(field) {
    return {
      tokenize: initializeText,
      resolveAll: createResolver(
        field === "text" ? resolveAllLineSuffixes : void 0
      )
    };
    function initializeText(effects) {
      const self2 = this;
      const constructs3 = this.parser.constructs[field];
      const text4 = effects.attempt(constructs3, start2, notText);
      return start2;
      function start2(code2) {
        return atBreak(code2) ? text4(code2) : notText(code2);
      }
      function notText(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("data");
        effects.consume(code2);
        return data2;
      }
      function data2(code2) {
        if (atBreak(code2)) {
          effects.exit("data");
          return text4(code2);
        }
        effects.consume(code2);
        return data2;
      }
      function atBreak(code2) {
        if (code2 === null) {
          return true;
        }
        const list4 = constructs3[code2];
        let index4 = -1;
        if (list4) {
          while (++index4 < list4.length) {
            const item = list4[index4];
            if (!item.previous || item.previous.call(self2, self2.previous)) {
              return true;
            }
          }
        }
        return false;
      }
    }
  }
  function createResolver(extraResolver) {
    return resolveAllText;
    function resolveAllText(events, context) {
      let index4 = -1;
      let enter;
      while (++index4 <= events.length) {
        if (enter === void 0) {
          if (events[index4] && events[index4][1].type === "data") {
            enter = index4;
            index4++;
          }
        } else if (!events[index4] || events[index4][1].type !== "data") {
          if (index4 !== enter + 2) {
            events[enter][1].end = events[index4 - 1][1].end;
            events.splice(enter + 2, index4 - enter - 2);
            index4 = enter + 2;
          }
          enter = void 0;
        }
      }
      return extraResolver ? extraResolver(events, context) : events;
    }
  }
  function resolveAllLineSuffixes(events, context) {
    let eventIndex = 0;
    while (++eventIndex <= events.length) {
      if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
        const data2 = events[eventIndex - 1][1];
        const chunks = context.sliceStream(data2);
        let index4 = chunks.length;
        let bufferIndex = -1;
        let size = 0;
        let tabs;
        while (index4--) {
          const chunk = chunks[index4];
          if (typeof chunk === "string") {
            bufferIndex = chunk.length;
            while (chunk.charCodeAt(bufferIndex - 1) === 32) {
              size++;
              bufferIndex--;
            }
            if (bufferIndex)
              break;
            bufferIndex = -1;
          } else if (chunk === -2) {
            tabs = true;
            size++;
          } else if (chunk === -1) {
          } else {
            index4++;
            break;
          }
        }
        if (size) {
          const token = {
            type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              line: data2.end.line,
              column: data2.end.column - size,
              offset: data2.end.offset - size,
              _index: data2.start._index + index4,
              _bufferIndex: index4 ? bufferIndex : data2.start._bufferIndex + bufferIndex
            },
            end: Object.assign({}, data2.end)
          };
          data2.end = Object.assign({}, token.start);
          if (data2.start.offset === data2.end.offset) {
            Object.assign(data2, token);
          } else {
            events.splice(
              eventIndex,
              0,
              ["enter", token, context],
              ["exit", token, context]
            );
            eventIndex += 2;
          }
        }
        eventIndex++;
      }
    }
    return events;
  }

  // node_modules/remark-parse/node_modules/micromark/lib/create-tokenizer.js
  function createTokenizer(parser, initialize2, from) {
    let point5 = Object.assign(
      from ? Object.assign({}, from) : {
        line: 1,
        column: 1,
        offset: 0
      },
      {
        _index: 0,
        _bufferIndex: -1
      }
    );
    const columnStart = {};
    const resolveAllConstructs = [];
    let chunks = [];
    let stack = [];
    let consumed = true;
    const effects = {
      consume,
      enter,
      exit: exit2,
      attempt: constructFactory(onsuccessfulconstruct),
      check: constructFactory(onsuccessfulcheck),
      interrupt: constructFactory(onsuccessfulcheck, {
        interrupt: true
      })
    };
    const context = {
      previous: null,
      code: null,
      containerState: {},
      events: [],
      parser,
      sliceStream,
      sliceSerialize,
      now,
      defineSkip,
      write
    };
    let state = initialize2.tokenize.call(context, effects);
    let expectedCode;
    if (initialize2.resolveAll) {
      resolveAllConstructs.push(initialize2);
    }
    return context;
    function write(slice) {
      chunks = push(chunks, slice);
      main();
      if (chunks[chunks.length - 1] !== null) {
        return [];
      }
      addResult(initialize2, 0);
      context.events = resolveAll(resolveAllConstructs, context.events, context);
      return context.events;
    }
    function sliceSerialize(token, expandTabs) {
      return serializeChunks2(sliceStream(token), expandTabs);
    }
    function sliceStream(token) {
      return sliceChunks(chunks, token);
    }
    function now() {
      const { line, column, offset: offset2, _index, _bufferIndex } = point5;
      return {
        line,
        column,
        offset: offset2,
        _index,
        _bufferIndex
      };
    }
    function defineSkip(value) {
      columnStart[value.line] = value.column;
      accountForPotentialSkip();
    }
    function main() {
      let chunkIndex;
      while (point5._index < chunks.length) {
        const chunk = chunks[point5._index];
        if (typeof chunk === "string") {
          chunkIndex = point5._index;
          if (point5._bufferIndex < 0) {
            point5._bufferIndex = 0;
          }
          while (point5._index === chunkIndex && point5._bufferIndex < chunk.length) {
            go(chunk.charCodeAt(point5._bufferIndex));
          }
        } else {
          go(chunk);
        }
      }
    }
    function go(code2) {
      consumed = void 0;
      expectedCode = code2;
      state = state(code2);
    }
    function consume(code2) {
      if (markdownLineEnding5(code2)) {
        point5.line++;
        point5.column = 1;
        point5.offset += code2 === -3 ? 2 : 1;
        accountForPotentialSkip();
      } else if (code2 !== -1) {
        point5.column++;
        point5.offset++;
      }
      if (point5._bufferIndex < 0) {
        point5._index++;
      } else {
        point5._bufferIndex++;
        if (point5._bufferIndex === chunks[point5._index].length) {
          point5._bufferIndex = -1;
          point5._index++;
        }
      }
      context.previous = code2;
      consumed = true;
    }
    function enter(type, fields) {
      const token = fields || {};
      token.type = type;
      token.start = now();
      context.events.push(["enter", token, context]);
      stack.push(token);
      return token;
    }
    function exit2(type) {
      const token = stack.pop();
      token.end = now();
      context.events.push(["exit", token, context]);
      return token;
    }
    function onsuccessfulconstruct(construct, info) {
      addResult(construct, info.from);
    }
    function onsuccessfulcheck(_, info) {
      info.restore();
    }
    function constructFactory(onreturn, fields) {
      return hook;
      function hook(constructs3, returnState, bogusState) {
        let listOfConstructs;
        let constructIndex;
        let currentConstruct;
        let info;
        return Array.isArray(constructs3) ? handleListOfConstructs(constructs3) : "tokenize" in constructs3 ? (
          // @ts-expect-error Looks like a construct.
          handleListOfConstructs([constructs3])
        ) : handleMapOfConstructs(constructs3);
        function handleMapOfConstructs(map4) {
          return start2;
          function start2(code2) {
            const def = code2 !== null && map4[code2];
            const all3 = code2 !== null && map4.null;
            const list4 = [
              // To do: add more extension tests.
              /* c8 ignore next 2 */
              ...Array.isArray(def) ? def : def ? [def] : [],
              ...Array.isArray(all3) ? all3 : all3 ? [all3] : []
            ];
            return handleListOfConstructs(list4)(code2);
          }
        }
        function handleListOfConstructs(list4) {
          listOfConstructs = list4;
          constructIndex = 0;
          if (list4.length === 0) {
            return bogusState;
          }
          return handleConstruct(list4[constructIndex]);
        }
        function handleConstruct(construct) {
          return start2;
          function start2(code2) {
            info = store();
            currentConstruct = construct;
            if (!construct.partial) {
              context.currentConstruct = construct;
            }
            if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
              return nok(code2);
            }
            return construct.tokenize.call(
              // If we do have fields, create an object w/ `context` as its
              // prototype.
              // This allows a “live binding”, which is needed for `interrupt`.
              fields ? Object.assign(Object.create(context), fields) : context,
              effects,
              ok3,
              nok
            )(code2);
          }
        }
        function ok3(code2) {
          consumed = true;
          onreturn(currentConstruct, info);
          return returnState;
        }
        function nok(code2) {
          consumed = true;
          info.restore();
          if (++constructIndex < listOfConstructs.length) {
            return handleConstruct(listOfConstructs[constructIndex]);
          }
          return bogusState;
        }
      }
    }
    function addResult(construct, from2) {
      if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
        resolveAllConstructs.push(construct);
      }
      if (construct.resolve) {
        splice2(
          context.events,
          from2,
          context.events.length - from2,
          construct.resolve(context.events.slice(from2), context)
        );
      }
      if (construct.resolveTo) {
        context.events = construct.resolveTo(context.events, context);
      }
    }
    function store() {
      const startPoint = now();
      const startPrevious = context.previous;
      const startCurrentConstruct = context.currentConstruct;
      const startEventsIndex = context.events.length;
      const startStack = Array.from(stack);
      return {
        restore,
        from: startEventsIndex
      };
      function restore() {
        point5 = startPoint;
        context.previous = startPrevious;
        context.currentConstruct = startCurrentConstruct;
        context.events.length = startEventsIndex;
        stack = startStack;
        accountForPotentialSkip();
      }
    }
    function accountForPotentialSkip() {
      if (point5.line in columnStart && point5.column < 2) {
        point5.column = columnStart[point5.line];
        point5.offset += columnStart[point5.line] - 1;
      }
    }
  }
  function sliceChunks(chunks, token) {
    const startIndex = token.start._index;
    const startBufferIndex = token.start._bufferIndex;
    const endIndex = token.end._index;
    const endBufferIndex = token.end._bufferIndex;
    let view;
    if (startIndex === endIndex) {
      view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
    } else {
      view = chunks.slice(startIndex, endIndex);
      if (startBufferIndex > -1) {
        const head = view[0];
        if (typeof head === "string") {
          view[0] = head.slice(startBufferIndex);
        } else {
          view.shift();
        }
      }
      if (endBufferIndex > 0) {
        view.push(chunks[endIndex].slice(0, endBufferIndex));
      }
    }
    return view;
  }
  function serializeChunks2(chunks, expandTabs) {
    let index4 = -1;
    const result = [];
    let atTab;
    while (++index4 < chunks.length) {
      const chunk = chunks[index4];
      let value;
      if (typeof chunk === "string") {
        value = chunk;
      } else
        switch (chunk) {
          case -5: {
            value = "\r";
            break;
          }
          case -4: {
            value = "\n";
            break;
          }
          case -3: {
            value = "\r\n";
            break;
          }
          case -2: {
            value = expandTabs ? " " : "	";
            break;
          }
          case -1: {
            if (!expandTabs && atTab)
              continue;
            value = " ";
            break;
          }
          default: {
            value = String.fromCharCode(chunk);
          }
        }
      atTab = chunk === -2;
      result.push(value);
    }
    return result.join("");
  }

  // node_modules/remark-parse/node_modules/micromark/lib/constructs.js
  var constructs_exports = {};
  __export(constructs_exports, {
    attentionMarkers: () => attentionMarkers,
    contentInitial: () => contentInitial,
    disable: () => disable,
    document: () => document4,
    flow: () => flow2,
    flowInitial: () => flowInitial,
    insideSpan: () => insideSpan,
    string: () => string2,
    text: () => text2
  });
  var document4 = {
    [42]: list,
    [43]: list,
    [45]: list,
    [48]: list,
    [49]: list,
    [50]: list,
    [51]: list,
    [52]: list,
    [53]: list,
    [54]: list,
    [55]: list,
    [56]: list,
    [57]: list,
    [62]: blockQuote
  };
  var contentInitial = {
    [91]: definition
  };
  var flowInitial = {
    [-2]: codeIndented,
    [-1]: codeIndented,
    [32]: codeIndented
  };
  var flow2 = {
    [35]: headingAtx,
    [42]: thematicBreak,
    [45]: [setextUnderline, thematicBreak],
    [60]: htmlFlow,
    [61]: setextUnderline,
    [95]: thematicBreak,
    [96]: codeFenced,
    [126]: codeFenced
  };
  var string2 = {
    [38]: characterReference,
    [92]: characterEscape
  };
  var text2 = {
    [-5]: lineEnding,
    [-4]: lineEnding,
    [-3]: lineEnding,
    [33]: labelStartImage,
    [38]: characterReference,
    [42]: attention,
    [60]: [autolink, htmlText],
    [91]: labelStartLink,
    [92]: [hardBreakEscape, characterEscape],
    [93]: labelEnd,
    [95]: attention,
    [96]: codeText
  };
  var insideSpan = {
    null: [attention, resolver]
  };
  var attentionMarkers = {
    null: [42, 95]
  };
  var disable = {
    null: []
  };

  // node_modules/remark-parse/node_modules/micromark/lib/parse.js
  function parse3(options) {
    const settings = options || {};
    const constructs3 = (
      /** @type {FullNormalizedExtension} */
      combineExtensions2([constructs_exports, ...settings.extensions || []])
    );
    const parser = {
      defined: [],
      lazy: {},
      constructs: constructs3,
      content: create(content),
      document: create(document3),
      flow: create(flow),
      string: create(string),
      text: create(text)
    };
    return parser;
    function create(initial) {
      return creator;
      function creator(from) {
        return createTokenizer(parser, initial, from);
      }
    }
  }

  // node_modules/remark-parse/node_modules/micromark/lib/postprocess.js
  function postprocess(events) {
    while (!subtokenize(events)) {
    }
    return events;
  }

  // node_modules/remark-parse/node_modules/micromark/lib/preprocess.js
  var search = /[\0\t\n\r]/g;
  function preprocess() {
    let column = 1;
    let buffer = "";
    let start2 = true;
    let atCarriageReturn;
    return preprocessor;
    function preprocessor(value, encoding, end) {
      const chunks = [];
      let match;
      let next;
      let startPosition;
      let endPosition;
      let code2;
      value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
      startPosition = 0;
      buffer = "";
      if (start2) {
        if (value.charCodeAt(0) === 65279) {
          startPosition++;
        }
        start2 = void 0;
      }
      while (startPosition < value.length) {
        search.lastIndex = startPosition;
        match = search.exec(value);
        endPosition = match && match.index !== void 0 ? match.index : value.length;
        code2 = value.charCodeAt(endPosition);
        if (!match) {
          buffer = value.slice(startPosition);
          break;
        }
        if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
          chunks.push(-3);
          atCarriageReturn = void 0;
        } else {
          if (atCarriageReturn) {
            chunks.push(-5);
            atCarriageReturn = void 0;
          }
          if (startPosition < endPosition) {
            chunks.push(value.slice(startPosition, endPosition));
            column += endPosition - startPosition;
          }
          switch (code2) {
            case 0: {
              chunks.push(65533);
              column++;
              break;
            }
            case 9: {
              next = Math.ceil(column / 4) * 4;
              chunks.push(-2);
              while (column++ < next)
                chunks.push(-1);
              break;
            }
            case 10: {
              chunks.push(-4);
              column = 1;
              break;
            }
            default: {
              atCarriageReturn = true;
              column = 1;
            }
          }
        }
        startPosition = endPosition + 1;
      }
      if (end) {
        if (atCarriageReturn)
          chunks.push(-5);
        if (buffer)
          chunks.push(buffer);
        chunks.push(null);
      }
      return chunks;
    }
  }

  // node_modules/remark-parse/node_modules/micromark-util-decode-string/index.js
  var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function decodeString(value) {
    return value.replace(characterEscapeOrReference, decode2);
  }
  function decode2($0, $1, $2) {
    if ($1) {
      return $1;
    }
    const head = $2.charCodeAt(0);
    if (head === 35) {
      const head2 = $2.charCodeAt(1);
      const hex = head2 === 120 || head2 === 88;
      return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
    }
    return decodeNamedCharacterReference($2) || $0;
  }

  // node_modules/remark-parse/node_modules/unist-util-stringify-position/lib/index.js
  function stringifyPosition3(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if ("position" in value || "type" in value) {
      return position3(value.position);
    }
    if ("start" in value || "end" in value) {
      return position3(value);
    }
    if ("line" in value || "column" in value) {
      return point3(value);
    }
    return "";
  }
  function point3(point5) {
    return index3(point5 && point5.line) + ":" + index3(point5 && point5.column);
  }
  function position3(pos) {
    return point3(pos && pos.start) + "-" + point3(pos && pos.end);
  }
  function index3(value) {
    return value && typeof value === "number" ? value : 1;
  }

  // node_modules/remark-parse/node_modules/mdast-util-from-markdown/lib/index.js
  var own2 = {}.hasOwnProperty;
  function fromMarkdown(value, encoding, options) {
    if (typeof encoding !== "string") {
      options = encoding;
      encoding = void 0;
    }
    return compiler(options)(postprocess(parse3(options).document().write(preprocess()(value, encoding, true))));
  }
  function compiler(options) {
    const config = {
      transforms: [],
      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
      enter: {
        autolink: opener(link2),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading2),
        blockQuote: opener(blockQuote2),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText2, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition3),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis2),
        hardBreakEscape: opener(hardBreak2),
        hardBreakTrailing: opener(hardBreak2),
        htmlFlow: opener(html2, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html2, buffer),
        htmlTextData: onenterdata,
        image: opener(image2),
        label: buffer,
        link: opener(link2),
        listItem: opener(listItem2),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list4, onenterlistordered),
        listUnordered: opener(list4),
        paragraph: opener(paragraph2),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading2),
        strong: opener(strong2),
        thematicBreak: opener(thematicBreak3)
      },
      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        characterReference: onexitcharacterreference,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    };
    configure(config, (options || {}).mdastExtensions || []);
    const data2 = {};
    return compile;
    function compile(events) {
      let tree = {
        type: "root",
        children: []
      };
      const context = {
        stack: [tree],
        tokenStack: [],
        config,
        enter,
        exit: exit2,
        buffer,
        resume,
        data: data2
      };
      const listStack = [];
      let index4 = -1;
      while (++index4 < events.length) {
        if (events[index4][1].type === "listOrdered" || events[index4][1].type === "listUnordered") {
          if (events[index4][0] === "enter") {
            listStack.push(index4);
          } else {
            const tail = listStack.pop();
            index4 = prepareList(events, tail, index4);
          }
        }
      }
      index4 = -1;
      while (++index4 < events.length) {
        const handler = config[events[index4][0]];
        if (own2.call(handler, events[index4][1].type)) {
          handler[events[index4][1].type].call(Object.assign({
            sliceSerialize: events[index4][2].sliceSerialize
          }, context), events[index4][1]);
        }
      }
      if (context.tokenStack.length > 0) {
        const tail = context.tokenStack[context.tokenStack.length - 1];
        const handler = tail[1] || defaultOnError;
        handler.call(context, void 0, tail[0]);
      }
      tree.position = {
        start: point4(events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }),
        end: point4(events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        })
      };
      index4 = -1;
      while (++index4 < config.transforms.length) {
        tree = config.transforms[index4](tree) || tree;
      }
      return tree;
    }
    function prepareList(events, start2, length) {
      let index4 = start2 - 1;
      let containerBalance = -1;
      let listSpread = false;
      let listItem3;
      let lineIndex;
      let firstBlankLineIndex;
      let atMarker;
      while (++index4 <= length) {
        const event = events[index4];
        switch (event[1].type) {
          case "listUnordered":
          case "listOrdered":
          case "blockQuote": {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
            break;
          }
          case "lineEndingBlank": {
            if (event[0] === "enter") {
              if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index4;
              }
              atMarker = void 0;
            }
            break;
          }
          case "linePrefix":
          case "listItemValue":
          case "listItemMarker":
          case "listItemPrefix":
          case "listItemPrefixWhitespace": {
            break;
          }
          default: {
            atMarker = void 0;
          }
        }
        if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
          if (listItem3) {
            let tailIndex = index4;
            lineIndex = void 0;
            while (tailIndex--) {
              const tailEvent = events[tailIndex];
              if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                if (tailEvent[0] === "exit")
                  continue;
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                  listSpread = true;
                }
                tailEvent[1].type = "lineEnding";
                lineIndex = tailIndex;
              } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
              } else {
                break;
              }
            }
            if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
              listItem3._spread = true;
            }
            listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
            events.splice(lineIndex || index4, 0, ["exit", listItem3, event[2]]);
            index4++;
            length++;
          }
          if (event[1].type === "listItemPrefix") {
            const item = {
              type: "listItem",
              _spread: false,
              start: Object.assign({}, event[1].start),
              // @ts-expect-error: we’ll add `end` in a second.
              end: void 0
            };
            listItem3 = item;
            events.splice(index4, 0, ["enter", item, event[2]]);
            index4++;
            length++;
            firstBlankLineIndex = void 0;
            atMarker = true;
          }
        }
      }
      events[start2][1]._spread = listSpread;
      return length;
    }
    function opener(create, and) {
      return open;
      function open(token) {
        enter.call(this, create(token), token);
        if (and)
          and.call(this, token);
      }
    }
    function buffer() {
      this.stack.push({
        type: "fragment",
        children: []
      });
    }
    function enter(node3, token, errorHandler2) {
      const parent = this.stack[this.stack.length - 1];
      const siblings = parent.children;
      siblings.push(node3);
      this.stack.push(node3);
      this.tokenStack.push([token, errorHandler2]);
      node3.position = {
        start: point4(token.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      };
    }
    function closer(and) {
      return close;
      function close(token) {
        if (and)
          and.call(this, token);
        exit2.call(this, token);
      }
    }
    function exit2(token, onExitError) {
      const node3 = this.stack.pop();
      const open = this.tokenStack.pop();
      if (!open) {
        throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition3({
          start: token.start,
          end: token.end
        }) + "): it\u2019s not open");
      } else if (open[0].type !== token.type) {
        if (onExitError) {
          onExitError.call(this, token, open[0]);
        } else {
          const handler = open[1] || defaultOnError;
          handler.call(this, token, open[0]);
        }
      }
      node3.position.end = point4(token.end);
    }
    function resume() {
      return toString2(this.stack.pop());
    }
    function onenterlistordered() {
      this.data.expectingFirstListItemValue = true;
    }
    function onenterlistitemvalue(token) {
      if (this.data.expectingFirstListItemValue) {
        const ancestor = this.stack[this.stack.length - 2];
        ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
        this.data.expectingFirstListItemValue = void 0;
      }
    }
    function onexitcodefencedfenceinfo() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.lang = data3;
    }
    function onexitcodefencedfencemeta() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.meta = data3;
    }
    function onexitcodefencedfence() {
      if (this.data.flowCodeInside)
        return;
      this.buffer();
      this.data.flowCodeInside = true;
    }
    function onexitcodefenced() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
      this.data.flowCodeInside = void 0;
    }
    function onexitcodeindented() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3.replace(/(\r?\n|\r)$/g, "");
    }
    function onexitdefinitionlabelstring(token) {
      const label = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.label = label;
      node3.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    }
    function onexitdefinitiontitlestring() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.title = data3;
    }
    function onexitdefinitiondestinationstring() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.url = data3;
    }
    function onexitatxheadingsequence(token) {
      const node3 = this.stack[this.stack.length - 1];
      if (!node3.depth) {
        const depth = this.sliceSerialize(token).length;
        node3.depth = depth;
      }
    }
    function onexitsetextheadingtext() {
      this.data.setextHeadingSlurpLineEnding = true;
    }
    function onexitsetextheadinglinesequence(token) {
      const node3 = this.stack[this.stack.length - 1];
      node3.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
    }
    function onexitsetextheading() {
      this.data.setextHeadingSlurpLineEnding = void 0;
    }
    function onenterdata(token) {
      const node3 = this.stack[this.stack.length - 1];
      const siblings = node3.children;
      let tail = siblings[siblings.length - 1];
      if (!tail || tail.type !== "text") {
        tail = text4();
        tail.position = {
          start: point4(token.start),
          // @ts-expect-error: we’ll add `end` later.
          end: void 0
        };
        siblings.push(tail);
      }
      this.stack.push(tail);
    }
    function onexitdata(token) {
      const tail = this.stack.pop();
      tail.value += this.sliceSerialize(token);
      tail.position.end = point4(token.end);
    }
    function onexitlineending(token) {
      const context = this.stack[this.stack.length - 1];
      if (this.data.atHardBreak) {
        const tail = context.children[context.children.length - 1];
        tail.position.end = point4(token.end);
        this.data.atHardBreak = void 0;
        return;
      }
      if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
        onenterdata.call(this, token);
        onexitdata.call(this, token);
      }
    }
    function onexithardbreak() {
      this.data.atHardBreak = true;
    }
    function onexithtmlflow() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3;
    }
    function onexithtmltext() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3;
    }
    function onexitcodetext() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3;
    }
    function onexitlink() {
      const node3 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node3.type += "Reference";
        node3.referenceType = referenceType;
        delete node3.url;
        delete node3.title;
      } else {
        delete node3.identifier;
        delete node3.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitimage() {
      const node3 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node3.type += "Reference";
        node3.referenceType = referenceType;
        delete node3.url;
        delete node3.title;
      } else {
        delete node3.identifier;
        delete node3.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitlabeltext(token) {
      const string3 = this.sliceSerialize(token);
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.label = decodeString(string3);
      ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
    }
    function onexitlabel() {
      const fragment = this.stack[this.stack.length - 1];
      const value = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      this.data.inReference = true;
      if (node3.type === "link") {
        const children = fragment.children;
        node3.children = children;
      } else {
        node3.alt = value;
      }
    }
    function onexitresourcedestinationstring() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.url = data3;
    }
    function onexitresourcetitlestring() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.title = data3;
    }
    function onexitresource() {
      this.data.inReference = void 0;
    }
    function onenterreference() {
      this.data.referenceType = "collapsed";
    }
    function onexitreferencestring(token) {
      const label = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.label = label;
      node3.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
      this.data.referenceType = "full";
    }
    function onexitcharacterreferencemarker(token) {
      this.data.characterReferenceType = token.type;
    }
    function onexitcharacterreferencevalue(token) {
      const data3 = this.sliceSerialize(token);
      const type = this.data.characterReferenceType;
      let value;
      if (type) {
        value = decodeNumericCharacterReference(data3, type === "characterReferenceMarkerNumeric" ? 10 : 16);
        this.data.characterReferenceType = void 0;
      } else {
        const result = decodeNamedCharacterReference(data3);
        value = result;
      }
      const tail = this.stack[this.stack.length - 1];
      tail.value += value;
    }
    function onexitcharacterreference(token) {
      const tail = this.stack.pop();
      tail.position.end = point4(token.end);
    }
    function onexitautolinkprotocol(token) {
      onexitdata.call(this, token);
      const node3 = this.stack[this.stack.length - 1];
      node3.url = this.sliceSerialize(token);
    }
    function onexitautolinkemail(token) {
      onexitdata.call(this, token);
      const node3 = this.stack[this.stack.length - 1];
      node3.url = "mailto:" + this.sliceSerialize(token);
    }
    function blockQuote2() {
      return {
        type: "blockquote",
        children: []
      };
    }
    function codeFlow() {
      return {
        type: "code",
        lang: null,
        meta: null,
        value: ""
      };
    }
    function codeText2() {
      return {
        type: "inlineCode",
        value: ""
      };
    }
    function definition3() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function emphasis2() {
      return {
        type: "emphasis",
        children: []
      };
    }
    function heading2() {
      return {
        type: "heading",
        // @ts-expect-error `depth` will be set later.
        depth: 0,
        children: []
      };
    }
    function hardBreak2() {
      return {
        type: "break"
      };
    }
    function html2() {
      return {
        type: "html",
        value: ""
      };
    }
    function image2() {
      return {
        type: "image",
        title: null,
        url: "",
        alt: null
      };
    }
    function link2() {
      return {
        type: "link",
        title: null,
        url: "",
        children: []
      };
    }
    function list4(token) {
      return {
        type: "list",
        ordered: token.type === "listOrdered",
        start: null,
        spread: token._spread,
        children: []
      };
    }
    function listItem2(token) {
      return {
        type: "listItem",
        spread: token._spread,
        checked: null,
        children: []
      };
    }
    function paragraph2() {
      return {
        type: "paragraph",
        children: []
      };
    }
    function strong2() {
      return {
        type: "strong",
        children: []
      };
    }
    function text4() {
      return {
        type: "text",
        value: ""
      };
    }
    function thematicBreak3() {
      return {
        type: "thematicBreak"
      };
    }
  }
  function point4(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function configure(combined, extensions) {
    let index4 = -1;
    while (++index4 < extensions.length) {
      const value = extensions[index4];
      if (Array.isArray(value)) {
        configure(combined, value);
      } else {
        extension(combined, value);
      }
    }
  }
  function extension(combined, extension2) {
    let key;
    for (key in extension2) {
      if (own2.call(extension2, key)) {
        switch (key) {
          case "canContainEols": {
            const right = extension2[key];
            if (right) {
              combined[key].push(...right);
            }
            break;
          }
          case "transforms": {
            const right = extension2[key];
            if (right) {
              combined[key].push(...right);
            }
            break;
          }
          case "enter":
          case "exit": {
            const right = extension2[key];
            if (right) {
              Object.assign(combined[key], right);
            }
            break;
          }
        }
      }
    }
  }
  function defaultOnError(left, right) {
    if (left) {
      throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition3({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition3({
        start: right.start,
        end: right.end
      }) + ") is open");
    } else {
      throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition3({
        start: right.start,
        end: right.end
      }) + ") is still open");
    }
  }

  // node_modules/remark-parse/lib/index.js
  function remarkParse(options) {
    const self2 = this;
    self2.parser = parser;
    function parser(doc) {
      return fromMarkdown(doc, {
        ...self2.data("settings"),
        ...options,
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: self2.data("micromarkExtensions") || [],
        mdastExtensions: self2.data("fromMarkdownExtensions") || []
      });
    }
  }

  // node_modules/bail/index.js
  function bail(error) {
    if (error) {
      throw error;
    }
  }

  // node_modules/unified/lib/index.js
  var import_extend = __toESM(require_extend(), 1);

  // node_modules/is-plain-obj/index.js
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  }

  // node_modules/trough/lib/index.js
  function trough() {
    const fns = [];
    const pipeline = { run, use };
    return pipeline;
    function run(...values) {
      let middlewareIndex = -1;
      const callback = values.pop();
      if (typeof callback !== "function") {
        throw new TypeError("Expected function as last argument, not " + callback);
      }
      next(null, ...values);
      function next(error, ...output) {
        const fn = fns[++middlewareIndex];
        let index4 = -1;
        if (error) {
          callback(error);
          return;
        }
        while (++index4 < values.length) {
          if (output[index4] === null || output[index4] === void 0) {
            output[index4] = values[index4];
          }
        }
        values = output;
        if (fn) {
          wrap(fn, next)(...output);
        } else {
          callback(null, ...output);
        }
      }
    }
    function use(middelware) {
      if (typeof middelware !== "function") {
        throw new TypeError(
          "Expected `middelware` to be a function, not " + middelware
        );
      }
      fns.push(middelware);
      return pipeline;
    }
  }
  function wrap(middleware, callback) {
    let called;
    return wrapped;
    function wrapped(...parameters) {
      const fnExpectsCallback = middleware.length > parameters.length;
      let result;
      if (fnExpectsCallback) {
        parameters.push(done);
      }
      try {
        result = middleware.apply(this, parameters);
      } catch (error) {
        const exception = (
          /** @type {Error} */
          error
        );
        if (fnExpectsCallback && called) {
          throw exception;
        }
        return done(exception);
      }
      if (!fnExpectsCallback) {
        if (result && result.then && typeof result.then === "function") {
          result.then(then, done);
        } else if (result instanceof Error) {
          done(result);
        } else {
          then(result);
        }
      }
    }
    function done(error, ...output) {
      if (!called) {
        called = true;
        callback(error, ...output);
      }
    }
    function then(value) {
      done(null, value);
    }
  }

  // node_modules/unified/node_modules/vfile/lib/minpath.browser.js
  var minpath = { basename: basename2, dirname: dirname2, extname: extname2, join, sep: "/" };
  function basename2(path, extname4) {
    if (extname4 !== void 0 && typeof extname4 !== "string") {
      throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start2 = 0;
    let end = -1;
    let index4 = path.length;
    let seenNonSlash;
    if (extname4 === void 0 || extname4.length === 0 || extname4.length > path.length) {
      while (index4--) {
        if (path.codePointAt(index4) === 47) {
          if (seenNonSlash) {
            start2 = index4 + 1;
            break;
          }
        } else if (end < 0) {
          seenNonSlash = true;
          end = index4 + 1;
        }
      }
      return end < 0 ? "" : path.slice(start2, end);
    }
    if (extname4 === path) {
      return "";
    }
    let firstNonSlashEnd = -1;
    let extnameIndex = extname4.length - 1;
    while (index4--) {
      if (path.codePointAt(index4) === 47) {
        if (seenNonSlash) {
          start2 = index4 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd < 0) {
          seenNonSlash = true;
          firstNonSlashEnd = index4 + 1;
        }
        if (extnameIndex > -1) {
          if (path.codePointAt(index4) === extname4.codePointAt(extnameIndex--)) {
            if (extnameIndex < 0) {
              end = index4;
            }
          } else {
            extnameIndex = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start2 === end) {
      end = firstNonSlashEnd;
    } else if (end < 0) {
      end = path.length;
    }
    return path.slice(start2, end);
  }
  function dirname2(path) {
    assertPath(path);
    if (path.length === 0) {
      return ".";
    }
    let end = -1;
    let index4 = path.length;
    let unmatchedSlash;
    while (--index4) {
      if (path.codePointAt(index4) === 47) {
        if (unmatchedSlash) {
          end = index4;
          break;
        }
      } else if (!unmatchedSlash) {
        unmatchedSlash = true;
      }
    }
    return end < 0 ? path.codePointAt(0) === 47 ? "/" : "." : end === 1 && path.codePointAt(0) === 47 ? "//" : path.slice(0, end);
  }
  function extname2(path) {
    assertPath(path);
    let index4 = path.length;
    let end = -1;
    let startPart = 0;
    let startDot = -1;
    let preDotState = 0;
    let unmatchedSlash;
    while (index4--) {
      const code2 = path.codePointAt(index4);
      if (code2 === 47) {
        if (unmatchedSlash) {
          startPart = index4 + 1;
          break;
        }
        continue;
      }
      if (end < 0) {
        unmatchedSlash = true;
        end = index4 + 1;
      }
      if (code2 === 46) {
        if (startDot < 0) {
          startDot = index4;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot > -1) {
        preDotState = -1;
      }
    }
    if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
    preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  }
  function join(...segments) {
    let index4 = -1;
    let joined;
    while (++index4 < segments.length) {
      assertPath(segments[index4]);
      if (segments[index4]) {
        joined = joined === void 0 ? segments[index4] : joined + "/" + segments[index4];
      }
    }
    return joined === void 0 ? "." : normalize2(joined);
  }
  function normalize2(path) {
    assertPath(path);
    const absolute = path.codePointAt(0) === 47;
    let value = normalizeString2(path, !absolute);
    if (value.length === 0 && !absolute) {
      value = ".";
    }
    if (value.length > 0 && path.codePointAt(path.length - 1) === 47) {
      value += "/";
    }
    return absolute ? "/" + value : value;
  }
  function normalizeString2(path, allowAboveRoot) {
    let result = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let index4 = -1;
    let code2;
    let lastSlashIndex;
    while (++index4 <= path.length) {
      if (index4 < path.length) {
        code2 = path.codePointAt(index4);
      } else if (code2 === 47) {
        break;
      } else {
        code2 = 47;
      }
      if (code2 === 47) {
        if (lastSlash === index4 - 1 || dots === 1) {
        } else if (lastSlash !== index4 - 1 && dots === 2) {
          if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
            if (result.length > 2) {
              lastSlashIndex = result.lastIndexOf("/");
              if (lastSlashIndex !== result.length - 1) {
                if (lastSlashIndex < 0) {
                  result = "";
                  lastSegmentLength = 0;
                } else {
                  result = result.slice(0, lastSlashIndex);
                  lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                }
                lastSlash = index4;
                dots = 0;
                continue;
              }
            } else if (result.length > 0) {
              result = "";
              lastSegmentLength = 0;
              lastSlash = index4;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            result = result.length > 0 ? result + "/.." : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (result.length > 0) {
            result += "/" + path.slice(lastSlash + 1, index4);
          } else {
            result = path.slice(lastSlash + 1, index4);
          }
          lastSegmentLength = index4 - lastSlash - 1;
        }
        lastSlash = index4;
        dots = 0;
      } else if (code2 === 46 && dots > -1) {
        dots++;
      } else {
        dots = -1;
      }
    }
    return result;
  }
  function assertPath(path) {
    if (typeof path !== "string") {
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(path)
      );
    }
  }

  // node_modules/unified/node_modules/vfile/lib/minproc.browser.js
  var minproc = { cwd: cwd2 };
  function cwd2() {
    return "/";
  }

  // node_modules/unified/node_modules/vfile/lib/minurl.shared.js
  function isUrl(fileUrlOrPath) {
    return Boolean(
      fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
      fileUrlOrPath.auth === void 0
    );
  }

  // node_modules/unified/node_modules/vfile/lib/minurl.browser.js
  function urlToPath(path) {
    if (typeof path === "string") {
      path = new URL(path);
    } else if (!isUrl(path)) {
      const error = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + path + "`"
      );
      error.code = "ERR_INVALID_ARG_TYPE";
      throw error;
    }
    if (path.protocol !== "file:") {
      const error = new TypeError("The URL must be of scheme file");
      error.code = "ERR_INVALID_URL_SCHEME";
      throw error;
    }
    return getPathFromURLPosix(path);
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      const error = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      error.code = "ERR_INVALID_FILE_URL_HOST";
      throw error;
    }
    const pathname = url.pathname;
    let index4 = -1;
    while (++index4 < pathname.length) {
      if (pathname.codePointAt(index4) === 37 && pathname.codePointAt(index4 + 1) === 50) {
        const third = pathname.codePointAt(index4 + 2);
        if (third === 70 || third === 102) {
          const error = new TypeError(
            "File URL path must not include encoded / characters"
          );
          error.code = "ERR_INVALID_FILE_URL_PATH";
          throw error;
        }
      }
    }
    return decodeURIComponent(pathname);
  }

  // node_modules/unified/node_modules/vfile/lib/index.js
  var order = (
    /** @type {const} */
    [
      "history",
      "path",
      "basename",
      "stem",
      "extname",
      "dirname"
    ]
  );
  var VFile = class {
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Uint8Array` — `{value: options}`
     * *   `URL` — `{path: options}`
     * *   `VFile` — shallow copies its data over to the new file
     * *   `object` — all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(value) {
      let options;
      if (!value) {
        options = {};
      } else if (isUrl(value)) {
        options = { path: value };
      } else if (typeof value === "string" || isUint8Array(value)) {
        options = { value };
      } else {
        options = value;
      }
      this.cwd = "cwd" in options ? "" : minproc.cwd();
      this.data = {};
      this.history = [];
      this.messages = [];
      this.value;
      this.map;
      this.result;
      this.stored;
      let index4 = -1;
      while (++index4 < order.length) {
        const field2 = order[index4];
        if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
          this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
        }
      }
      let field;
      for (field in options) {
        if (!order.includes(field)) {
          this[field] = options[field];
        }
      }
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     *
     * @returns {string | undefined}
     *   Basename.
     */
    get basename() {
      return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} basename
     *   Basename.
     * @returns {undefined}
     *   Nothing.
     */
    set basename(basename4) {
      assertNonEmpty(basename4, "basename");
      assertPart(basename4, "basename");
      this.path = minpath.join(this.dirname || "", basename4);
    }
    /**
     * Get the parent path (example: `'~'`).
     *
     * @returns {string | undefined}
     *   Dirname.
     */
    get dirname() {
      return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if there’s no `path` yet.
     *
     * @param {string | undefined} dirname
     *   Dirname.
     * @returns {undefined}
     *   Nothing.
     */
    set dirname(dirname4) {
      assertPath2(this.basename, "dirname");
      this.path = minpath.join(dirname4 || "", this.basename);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     *
     * @returns {string | undefined}
     *   Extname.
     */
    get extname() {
      return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if there’s no `path` yet.
     *
     * @param {string | undefined} extname
     *   Extname.
     * @returns {undefined}
     *   Nothing.
     */
    set extname(extname4) {
      assertPart(extname4, "extname");
      assertPath2(this.dirname, "extname");
      if (extname4) {
        if (extname4.codePointAt(0) !== 46) {
          throw new Error("`extname` must start with `.`");
        }
        if (extname4.includes(".", 1)) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = minpath.join(this.dirname, this.stem + (extname4 || ""));
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     *   Path.
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {URL | string} path
     *   Path.
     * @returns {undefined}
     *   Nothing.
     */
    set path(path) {
      if (isUrl(path)) {
        path = urlToPath(path);
      }
      assertNonEmpty(path, "path");
      if (this.path !== path) {
        this.history.push(path);
      }
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     *
     * @returns {string | undefined}
     *   Stem.
     */
    get stem() {
      return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} stem
     *   Stem.
     * @returns {undefined}
     *   Nothing.
     */
    set stem(stem) {
      assertNonEmpty(stem, "stem");
      assertPart(stem, "stem");
      this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
    }
    // Normal prototypal methods.
    /**
     * Create a fatal message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `true` (error; file not usable)
     * and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * > 🪦 **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Never.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(causeOrReason, optionsOrParentOrPlace, origin) {
      const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
      message.fatal = true;
      throw message;
    }
    /**
     * Create an info message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `undefined` (info; change
     * likely not needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * > 🪦 **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(causeOrReason, optionsOrParentOrPlace, origin) {
      const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
      message.fatal = void 0;
      return message;
    }
    /**
     * Create a message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `false` (warning; change may be
     * needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * > 🪦 **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(causeOrReason, optionsOrParentOrPlace, origin) {
      const message = new VFileMessage(
        // @ts-expect-error: the overloads are fine.
        causeOrReason,
        optionsOrParentOrPlace,
        origin
      );
      if (this.path) {
        message.name = this.path + ":" + message.name;
        message.file = this.path;
      }
      message.fatal = false;
      this.messages.push(message);
      return message;
    }
    /**
     * Serialize the file.
     *
     * > **Note**: which encodings are supported depends on the engine.
     * > For info on Node.js, see:
     * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
     *
     * @param {string | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when it’s a `Uint8Array`
     *   (default: `'utf-8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(encoding) {
      if (this.value === void 0) {
        return "";
      }
      if (typeof this.value === "string") {
        return this.value;
      }
      const decoder = new TextDecoder(encoding || void 0);
      return decoder.decode(this.value);
    }
  };
  function assertPart(part, name2) {
    if (part && part.includes(minpath.sep)) {
      throw new Error(
        "`" + name2 + "` cannot be a path: did not expect `" + minpath.sep + "`"
      );
    }
  }
  function assertNonEmpty(part, name2) {
    if (!part) {
      throw new Error("`" + name2 + "` cannot be empty");
    }
  }
  function assertPath2(path, name2) {
    if (!path) {
      throw new Error("Setting `" + name2 + "` requires `path` to be set too");
    }
  }
  function isUint8Array(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }

  // node_modules/unified/lib/callable-instance.js
  var CallableInstance = (
    /**
     * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
     */
    /** @type {unknown} */
    /**
     * @this {Function}
     * @param {string | symbol} property
     * @returns {(...parameters: Array<unknown>) => unknown}
     */
    function(property) {
      const self2 = this;
      const constr = self2.constructor;
      const proto = (
        /** @type {Record<string | symbol, Function>} */
        // Prototypes do exist.
        // type-coverage:ignore-next-line
        constr.prototype
      );
      const value = proto[property];
      const apply = function() {
        return value.apply(apply, arguments);
      };
      Object.setPrototypeOf(apply, proto);
      return apply;
    }
  );

  // node_modules/unified/lib/index.js
  var own3 = {}.hasOwnProperty;
  var Processor = class extends CallableInstance {
    /**
     * Create a processor.
     */
    constructor() {
      super("copy");
      this.Compiler = void 0;
      this.Parser = void 0;
      this.attachers = [];
      this.compiler = void 0;
      this.freezeIndex = -1;
      this.frozen = void 0;
      this.namespace = {};
      this.parser = void 0;
      this.transformers = trough();
    }
    /**
     * Copy a processor.
     *
     * @deprecated
     *   This is a private internal method and should not be used.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   New *unfrozen* processor ({@linkcode Processor}) that is
     *   configured to work the same as its ancestor.
     *   When the descendant processor is configured in the future it does not
     *   affect the ancestral processor.
     */
    copy() {
      const destination = (
        /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
        new Processor()
      );
      let index4 = -1;
      while (++index4 < this.attachers.length) {
        const attacher = this.attachers[index4];
        destination.use(...attacher);
      }
      destination.data((0, import_extend.default)(true, {}, this.namespace));
      return destination;
    }
    /**
     * Configure the processor with info available to all plugins.
     * Information is stored in an object.
     *
     * Typically, options can be given to a specific plugin, but sometimes it
     * makes sense to have information shared with several plugins.
     * For example, a list of HTML elements that are self-closing, which is
     * needed during all phases.
     *
     * > **Note**: setting information cannot occur on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * > **Note**: to register custom data in TypeScript, augment the
     * > {@linkcode Data} interface.
     *
     * @example
     *   This example show how to get and set info:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   const processor = unified().data('alpha', 'bravo')
     *
     *   processor.data('alpha') // => 'bravo'
     *
     *   processor.data() // => {alpha: 'bravo'}
     *
     *   processor.data({charlie: 'delta'})
     *
     *   processor.data() // => {charlie: 'delta'}
     *   ```
     *
     * @template {keyof Data} Key
     *
     * @overload
     * @returns {Data}
     *
     * @overload
     * @param {Data} dataset
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Key} key
     * @returns {Data[Key]}
     *
     * @overload
     * @param {Key} key
     * @param {Data[Key]} value
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @param {Data | Key} [key]
     *   Key to get or set, or entire dataset to set, or nothing to get the
     *   entire dataset (optional).
     * @param {Data[Key]} [value]
     *   Value to set (optional).
     * @returns {unknown}
     *   The current processor when setting, the value at `key` when getting, or
     *   the entire dataset when getting without key.
     */
    data(key, value) {
      if (typeof key === "string") {
        if (arguments.length === 2) {
          assertUnfrozen("data", this.frozen);
          this.namespace[key] = value;
          return this;
        }
        return own3.call(this.namespace, key) && this.namespace[key] || void 0;
      }
      if (key) {
        assertUnfrozen("data", this.frozen);
        this.namespace = key;
        return this;
      }
      return this.namespace;
    }
    /**
     * Freeze a processor.
     *
     * Frozen processors are meant to be extended and not to be configured
     * directly.
     *
     * When a processor is frozen it cannot be unfrozen.
     * New processors working the same way can be created by calling the
     * processor.
     *
     * It’s possible to freeze processors explicitly by calling `.freeze()`.
     * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
     * `.stringify()`, `.process()`, or `.processSync()` are called.
     *
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   The current processor.
     */
    freeze() {
      if (this.frozen) {
        return this;
      }
      const self2 = (
        /** @type {Processor} */
        /** @type {unknown} */
        this
      );
      while (++this.freezeIndex < this.attachers.length) {
        const [attacher, ...options] = this.attachers[this.freezeIndex];
        if (options[0] === false) {
          continue;
        }
        if (options[0] === true) {
          options[0] = void 0;
        }
        const transformer = attacher.call(self2, ...options);
        if (typeof transformer === "function") {
          this.transformers.use(transformer);
        }
      }
      this.frozen = true;
      this.freezeIndex = Number.POSITIVE_INFINITY;
      return this;
    }
    /**
     * Parse text to a syntax tree.
     *
     * > **Note**: `parse` freezes the processor if not already *frozen*.
     *
     * > **Note**: `parse` performs the parse phase, not the run phase or other
     * > phases.
     *
     * @param {Compatible | undefined} [file]
     *   file to parse (optional); typically `string` or `VFile`; any value
     *   accepted as `x` in `new VFile(x)`.
     * @returns {ParseTree extends undefined ? Node : ParseTree}
     *   Syntax tree representing `file`.
     */
    parse(file) {
      this.freeze();
      const realFile = vfile(file);
      const parser = this.parser || this.Parser;
      assertParser("parse", parser);
      return parser(String(realFile), realFile);
    }
    /**
     * Process the given file as configured on the processor.
     *
     * > **Note**: `process` freezes the processor if not already *frozen*.
     *
     * > **Note**: `process` performs the parse, run, and stringify phases.
     *
     * @overload
     * @param {Compatible | undefined} file
     * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
     * @returns {undefined}
     *
     * @overload
     * @param {Compatible | undefined} [file]
     * @returns {Promise<VFileWithOutput<CompileResult>>}
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`]; any value accepted as
     *   `x` in `new VFile(x)`.
     * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
     *   Callback (optional).
     * @returns {Promise<VFile> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise a promise, rejected with a fatal error or resolved with the
     *   processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If you’re using a compiler that doesn’t serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    process(file, done) {
      const self2 = this;
      this.freeze();
      assertParser("process", this.parser || this.Parser);
      assertCompiler("process", this.compiler || this.Compiler);
      return done ? executor(void 0, done) : new Promise(executor);
      function executor(resolve3, reject) {
        const realFile = vfile(file);
        const parseTree = (
          /** @type {HeadTree extends undefined ? Node : HeadTree} */
          /** @type {unknown} */
          self2.parse(realFile)
        );
        self2.run(parseTree, realFile, function(error, tree, file2) {
          if (error || !tree || !file2) {
            return realDone(error);
          }
          const compileTree = (
            /** @type {CompileTree extends undefined ? Node : CompileTree} */
            /** @type {unknown} */
            tree
          );
          const compileResult = self2.stringify(compileTree, file2);
          if (looksLikeAValue(compileResult)) {
            file2.value = compileResult;
          } else {
            file2.result = compileResult;
          }
          realDone(
            error,
            /** @type {VFileWithOutput<CompileResult>} */
            file2
          );
        });
        function realDone(error, file2) {
          if (error || !file2) {
            reject(error);
          } else if (resolve3) {
            resolve3(file2);
          } else {
            ok(done, "`done` is defined if `resolve` is not");
            done(void 0, file2);
          }
        }
      }
    }
    /**
     * Process the given file as configured on the processor.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `processSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `processSync` performs the parse, run, and stringify phases.
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`; any value accepted as
     *   `x` in `new VFile(x)`.
     * @returns {VFileWithOutput<CompileResult>}
     *   The processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If you’re using a compiler that doesn’t serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    processSync(file) {
      let complete = false;
      let result;
      this.freeze();
      assertParser("processSync", this.parser || this.Parser);
      assertCompiler("processSync", this.compiler || this.Compiler);
      this.process(file, realDone);
      assertDone("processSync", "process", complete);
      ok(result, "we either bailed on an error or have a tree");
      return result;
      function realDone(error, file2) {
        complete = true;
        bail(error);
        result = file2;
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * > **Note**: `run` freezes the processor if not already *frozen*.
     *
     * > **Note**: `run` performs the run phase, not other phases.
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} file
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} [file]
     * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {(
     *   RunCallback<TailTree extends undefined ? Node : TailTree> |
     *   Compatible
     * )} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
     *   Callback (optional).
     * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise, a promise rejected with a fatal error or resolved with the
     *   transformed tree.
     */
    run(tree, file, done) {
      assertNode(tree);
      this.freeze();
      const transformers = this.transformers;
      if (!done && typeof file === "function") {
        done = file;
        file = void 0;
      }
      return done ? executor(void 0, done) : new Promise(executor);
      function executor(resolve3, reject) {
        ok(
          typeof file !== "function",
          "`file` can\u2019t be a `done` anymore, we checked"
        );
        const realFile = vfile(file);
        transformers.run(tree, realFile, realDone);
        function realDone(error, outputTree, file2) {
          const resultingTree = (
            /** @type {TailTree extends undefined ? Node : TailTree} */
            outputTree || tree
          );
          if (error) {
            reject(error);
          } else if (resolve3) {
            resolve3(resultingTree);
          } else {
            ok(done, "`done` is defined if `resolve` is not");
            done(void 0, resultingTree, file2);
          }
        }
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `runSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `runSync` performs the run phase, not other phases.
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {TailTree extends undefined ? Node : TailTree}
     *   Transformed tree.
     */
    runSync(tree, file) {
      let complete = false;
      let result;
      this.run(tree, file, realDone);
      assertDone("runSync", "run", complete);
      ok(result, "we either bailed on an error or have a tree");
      return result;
      function realDone(error, tree2) {
        bail(error);
        result = tree2;
        complete = true;
      }
    }
    /**
     * Compile a syntax tree.
     *
     * > **Note**: `stringify` freezes the processor if not already *frozen*.
     *
     * > **Note**: `stringify` performs the stringify phase, not the run phase
     * > or other phases.
     *
     * @param {CompileTree extends undefined ? Node : CompileTree} tree
     *   Tree to compile.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {CompileResult extends undefined ? Value : CompileResult}
     *   Textual representation of the tree (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most compilers
     *   > return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If you’re using a compiler that doesn’t serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    stringify(tree, file) {
      this.freeze();
      const realFile = vfile(file);
      const compiler2 = this.compiler || this.Compiler;
      assertCompiler("stringify", compiler2);
      assertNode(tree);
      return compiler2(tree, realFile);
    }
    /**
     * Configure the processor to use a plugin, a list of usable values, or a
     * preset.
     *
     * If the processor is already using a plugin, the previous plugin
     * configuration is changed based on the options that are passed in.
     * In other words, the plugin is not added a second time.
     *
     * > **Note**: `use` cannot be called on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * @example
     *   There are many ways to pass plugins to `.use()`.
     *   This example gives an overview:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   unified()
     *     // Plugin with options:
     *     .use(pluginA, {x: true, y: true})
     *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
     *     .use(pluginA, {y: false, z: true})
     *     // Plugins:
     *     .use([pluginB, pluginC])
     *     // Two plugins, the second with options:
     *     .use([pluginD, [pluginE, {}]])
     *     // Preset with plugins and settings:
     *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
     *     // Settings only:
     *     .use({settings: {position: false}})
     *   ```
     *
     * @template {Array<unknown>} [Parameters=[]]
     * @template {Node | string | undefined} [Input=undefined]
     * @template [Output=Input]
     *
     * @overload
     * @param {Preset | null | undefined} [preset]
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {PluggableList} list
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Plugin<Parameters, Input, Output>} plugin
     * @param {...(Parameters | [boolean])} parameters
     * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
     *
     * @param {PluggableList | Plugin | Preset | null | undefined} value
     *   Usable value.
     * @param {...unknown} parameters
     *   Parameters, when a plugin is given as a usable value.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   Current processor.
     */
    use(value, ...parameters) {
      const attachers = this.attachers;
      const namespace = this.namespace;
      assertUnfrozen("use", this.frozen);
      if (value === null || value === void 0) {
      } else if (typeof value === "function") {
        addPlugin(value, parameters);
      } else if (typeof value === "object") {
        if (Array.isArray(value)) {
          addList(value);
        } else {
          addPreset(value);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value + "`");
      }
      return this;
      function add(value2) {
        if (typeof value2 === "function") {
          addPlugin(value2, []);
        } else if (typeof value2 === "object") {
          if (Array.isArray(value2)) {
            const [plugin, ...parameters2] = (
              /** @type {PluginTuple<Array<unknown>>} */
              value2
            );
            addPlugin(plugin, parameters2);
          } else {
            addPreset(value2);
          }
        } else {
          throw new TypeError("Expected usable value, not `" + value2 + "`");
        }
      }
      function addPreset(result) {
        if (!("plugins" in result) && !("settings" in result)) {
          throw new Error(
            "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
          );
        }
        addList(result.plugins);
        if (result.settings) {
          namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
        }
      }
      function addList(plugins) {
        let index4 = -1;
        if (plugins === null || plugins === void 0) {
        } else if (Array.isArray(plugins)) {
          while (++index4 < plugins.length) {
            const thing = plugins[index4];
            add(thing);
          }
        } else {
          throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
        }
      }
      function addPlugin(plugin, parameters2) {
        let index4 = -1;
        let entryIndex = -1;
        while (++index4 < attachers.length) {
          if (attachers[index4][0] === plugin) {
            entryIndex = index4;
            break;
          }
        }
        if (entryIndex === -1) {
          attachers.push([plugin, ...parameters2]);
        } else if (parameters2.length > 0) {
          let [primary, ...rest] = parameters2;
          const currentPrimary = attachers[entryIndex][1];
          if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
            primary = (0, import_extend.default)(true, currentPrimary, primary);
          }
          attachers[entryIndex] = [plugin, primary, ...rest];
        }
      }
    }
  };
  var unified = new Processor().freeze();
  function assertParser(name2, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name2 + "` without `parser`");
    }
  }
  function assertCompiler(name2, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name2 + "` without `compiler`");
    }
  }
  function assertUnfrozen(name2, frozen) {
    if (frozen) {
      throw new Error(
        "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
    }
  }
  function assertNode(node3) {
    if (!isPlainObject(node3) || typeof node3.type !== "string") {
      throw new TypeError("Expected node, got `" + node3 + "`");
    }
  }
  function assertDone(name2, asyncName, complete) {
    if (!complete) {
      throw new Error(
        "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
      );
    }
  }
  function vfile(value) {
    return looksLikeAVFile(value) ? value : new VFile(value);
  }
  function looksLikeAVFile(value) {
    return Boolean(
      value && typeof value === "object" && "message" in value && "messages" in value
    );
  }
  function looksLikeAValue(value) {
    return typeof value === "string" || isUint8Array2(value);
  }
  function isUint8Array2(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }

  // node_modules/estree-walker/src/walker.js
  var WalkerBase = class {
    constructor() {
      this.should_skip = false;
      this.should_remove = false;
      this.replacement = null;
      this.context = {
        skip: () => this.should_skip = true,
        remove: () => this.should_remove = true,
        replace: (node3) => this.replacement = node3
      };
    }
    /**
     * @template {Node} Parent
     * @param {Parent | null | undefined} parent
     * @param {keyof Parent | null | undefined} prop
     * @param {number | null | undefined} index
     * @param {Node} node
     */
    replace(parent, prop, index4, node3) {
      if (parent && prop) {
        if (index4 != null) {
          parent[prop][index4] = node3;
        } else {
          parent[prop] = node3;
        }
      }
    }
    /**
     * @template {Node} Parent
     * @param {Parent | null | undefined} parent
     * @param {keyof Parent | null | undefined} prop
     * @param {number | null | undefined} index
     */
    remove(parent, prop, index4) {
      if (parent && prop) {
        if (index4 !== null && index4 !== void 0) {
          parent[prop].splice(index4, 1);
        } else {
          delete parent[prop];
        }
      }
    }
  };

  // node_modules/estree-walker/src/sync.js
  var SyncWalker = class extends WalkerBase {
    /**
     *
     * @param {SyncHandler} [enter]
     * @param {SyncHandler} [leave]
     */
    constructor(enter, leave) {
      super();
      this.should_skip = false;
      this.should_remove = false;
      this.replacement = null;
      this.context = {
        skip: () => this.should_skip = true,
        remove: () => this.should_remove = true,
        replace: (node3) => this.replacement = node3
      };
      this.enter = enter;
      this.leave = leave;
    }
    /**
     * @template {Node} Parent
     * @param {Node} node
     * @param {Parent | null} parent
     * @param {keyof Parent} [prop]
     * @param {number | null} [index]
     * @returns {Node | null}
     */
    visit(node3, parent, prop, index4) {
      if (node3) {
        if (this.enter) {
          const _should_skip = this.should_skip;
          const _should_remove = this.should_remove;
          const _replacement = this.replacement;
          this.should_skip = false;
          this.should_remove = false;
          this.replacement = null;
          this.enter.call(this.context, node3, parent, prop, index4);
          if (this.replacement) {
            node3 = this.replacement;
            this.replace(parent, prop, index4, node3);
          }
          if (this.should_remove) {
            this.remove(parent, prop, index4);
          }
          const skipped = this.should_skip;
          const removed = this.should_remove;
          this.should_skip = _should_skip;
          this.should_remove = _should_remove;
          this.replacement = _replacement;
          if (skipped)
            return node3;
          if (removed)
            return null;
        }
        let key;
        for (key in node3) {
          const value = node3[key];
          if (value && typeof value === "object") {
            if (Array.isArray(value)) {
              const nodes = (
                /** @type {Array<unknown>} */
                value
              );
              for (let i = 0; i < nodes.length; i += 1) {
                const item = nodes[i];
                if (isNode(item)) {
                  if (!this.visit(item, node3, key, i)) {
                    i--;
                  }
                }
              }
            } else if (isNode(value)) {
              this.visit(value, node3, key, null);
            }
          }
        }
        if (this.leave) {
          const _replacement = this.replacement;
          const _should_remove = this.should_remove;
          this.replacement = null;
          this.should_remove = false;
          this.leave.call(this.context, node3, parent, prop, index4);
          if (this.replacement) {
            node3 = this.replacement;
            this.replace(parent, prop, index4, node3);
          }
          if (this.should_remove) {
            this.remove(parent, prop, index4);
          }
          const removed = this.should_remove;
          this.replacement = _replacement;
          this.should_remove = _should_remove;
          if (removed)
            return null;
        }
      }
      return node3;
    }
  };
  function isNode(value) {
    return value !== null && typeof value === "object" && "type" in value && typeof value.type === "string";
  }

  // node_modules/estree-walker/src/index.js
  function walk(ast, { enter, leave }) {
    const instance = new SyncWalker(enter, leave);
    return instance.visit(ast, null);
  }

  // node_modules/is-reference/src/index.js
  function is_reference(node3, parent) {
    if (node3.type === "MemberExpression") {
      return !node3.computed && is_reference(node3.object, node3);
    }
    if (node3.type === "Identifier") {
      if (!parent)
        return true;
      switch (parent.type) {
        case "MemberExpression":
          return parent.computed || node3 === parent.object;
        case "MethodDefinition":
          return parent.computed;
        case "PropertyDefinition":
          return parent.computed || node3 === parent.value;
        case "Property":
          return parent.computed || node3 === parent.value;
        case "ExportSpecifier":
        case "ImportSpecifier":
          return node3 === parent.local;
        case "LabeledStatement":
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        default:
          return true;
      }
    }
    return false;
  }

  // node_modules/periscopic/src/index.js
  function analyze(expression) {
    const map4 = /* @__PURE__ */ new WeakMap();
    const globals = /* @__PURE__ */ new Map();
    const scope = new Scope3(null, false);
    const references = [];
    let current_scope = scope;
    walk(expression, {
      enter(node3, parent) {
        switch (node3.type) {
          case "Identifier":
            if (parent && is_reference(node3, parent)) {
              references.push([current_scope, node3]);
            }
            break;
          case "ImportDeclaration":
            node3.specifiers.forEach((specifier) => {
              current_scope.declarations.set(specifier.local.name, specifier);
            });
            break;
          case "FunctionExpression":
          case "FunctionDeclaration":
          case "ArrowFunctionExpression":
            if (node3.type === "FunctionDeclaration") {
              if (node3.id) {
                current_scope.declarations.set(node3.id.name, node3);
              }
              map4.set(node3, current_scope = new Scope3(current_scope, false));
            } else {
              map4.set(node3, current_scope = new Scope3(current_scope, false));
              if (node3.type === "FunctionExpression" && node3.id) {
                current_scope.declarations.set(node3.id.name, node3);
              }
            }
            node3.params.forEach((param) => {
              extract_names(param).forEach((name2) => {
                current_scope.declarations.set(name2, node3);
              });
            });
            break;
          case "ForStatement":
          case "ForInStatement":
          case "ForOfStatement":
            map4.set(node3, current_scope = new Scope3(current_scope, true));
            break;
          case "BlockStatement":
            map4.set(node3, current_scope = new Scope3(current_scope, true));
            break;
          case "ClassDeclaration":
          case "VariableDeclaration":
            current_scope.add_declaration(node3);
            break;
          case "CatchClause":
            map4.set(node3, current_scope = new Scope3(current_scope, true));
            if (node3.param) {
              extract_names(node3.param).forEach((name2) => {
                if (node3.param) {
                  current_scope.declarations.set(name2, node3.param);
                }
              });
            }
            break;
        }
      },
      leave(node3) {
        if (map4.has(node3) && current_scope !== null && current_scope.parent) {
          current_scope = current_scope.parent;
        }
      }
    });
    for (let i = references.length - 1; i >= 0; --i) {
      const [scope2, reference] = references[i];
      if (!scope2.references.has(reference.name)) {
        add_reference(scope2, reference.name);
      }
      if (!scope2.find_owner(reference.name)) {
        globals.set(reference.name, reference);
      }
    }
    return { map: map4, scope, globals };
  }
  function add_reference(scope, name2) {
    scope.references.add(name2);
    if (scope.parent)
      add_reference(scope.parent, name2);
  }
  var Scope3 = class {
    /**
     * @param {Scope | null} parent 
     * @param {boolean} block 
     */
    constructor(parent, block) {
      this.parent = parent;
      this.block = block;
      this.declarations = /* @__PURE__ */ new Map();
      this.initialised_declarations = /* @__PURE__ */ new Set();
      this.references = /* @__PURE__ */ new Set();
    }
    /**
     * @param {import('estree').VariableDeclaration | import('estree').ClassDeclaration} node
     */
    add_declaration(node3) {
      if (node3.type === "VariableDeclaration") {
        if (node3.kind === "var" && this.block && this.parent) {
          this.parent.add_declaration(node3);
        } else {
          const handle_declarator = (declarator) => {
            extract_names(declarator.id).forEach((name2) => {
              this.declarations.set(name2, node3);
              if (declarator.init)
                this.initialised_declarations.add(name2);
            });
            ;
          };
          node3.declarations.forEach(handle_declarator);
        }
      } else if (node3.id) {
        this.declarations.set(node3.id.name, node3);
      }
    }
    /**
     * @param {string} name
     * @returns {Scope | null}
     */
    find_owner(name2) {
      if (this.declarations.has(name2))
        return this;
      return this.parent && this.parent.find_owner(name2);
    }
    /**
     * @param {string} name
     * @returns {boolean}
     */
    has(name2) {
      return this.declarations.has(name2) || !!this.parent && this.parent.has(name2);
    }
  };
  function extract_names(param) {
    return extract_identifiers(param).map((node3) => node3.name);
  }
  function extract_identifiers(param, nodes = []) {
    switch (param.type) {
      case "Identifier":
        nodes.push(param);
        break;
      case "MemberExpression":
        let object = param;
        while (object.type === "MemberExpression") {
          object = /** @type {any} */
          object.object;
        }
        nodes.push(
          /** @type {any} */
          object
        );
        break;
      case "ObjectPattern":
        const handle_prop = (prop) => {
          if (prop.type === "RestElement") {
            extract_identifiers(prop.argument, nodes);
          } else {
            extract_identifiers(prop.value, nodes);
          }
        };
        param.properties.forEach(handle_prop);
        break;
      case "ArrayPattern":
        const handle_element = (element2) => {
          if (element2)
            extract_identifiers(element2, nodes);
        };
        param.elements.forEach((element2) => {
          if (element2) {
            handle_element(element2);
          }
        });
        break;
      case "RestElement":
        extract_identifiers(param.argument, nodes);
        break;
      case "AssignmentPattern":
        extract_identifiers(param.left, nodes);
        break;
    }
    return nodes;
  }

  // node_modules/@mdx-js/language-service/lib/mdast-utils.js
  function getPointOffset(point5) {
    return (
      /** @type {number} */
      point5.offset
    );
  }
  function getNodeStartOffset(node3) {
    return getPointOffset(
      /** @type {Position} */
      node3.position.start
    );
  }
  function getNodeEndOffset(node3) {
    return getPointOffset(
      /** @type {Position} */
      node3.position.end
    );
  }

  // node_modules/@mdx-js/language-service/lib/script-snapshot.js
  var ScriptSnapshot = class {
    /**
     * @param {string} text
     *   The text to wrap.
     */
    constructor(text4) {
      this.text = text4;
    }
    /**
     * Not implemented.
     *
     * @returns {undefined}
     */
    getChangeRange() {
    }
    /**
     * @returns {number}
     */
    getLength() {
      return this.text.length;
    }
    /**
     * @param {number} start
     * @param {number} end
     * @returns {string}
     */
    getText(start2, end) {
      return this.text.slice(start2, end);
    }
  };

  // node_modules/@mdx-js/language-service/lib/jsx-utils.js
  function isInjectableComponent(name2, scope) {
    if (!name2) {
      return false;
    }
    const char = name2.charAt(0);
    if (char !== char.toUpperCase()) {
      return false;
    }
    return !scope.includes(name2);
  }

  // node_modules/@mdx-js/language-service/lib/virtual-code.js
  var jsPrefix = (tsCheck, jsxImportSource) => `${tsCheck ? "// @ts-check\n" : ""}/* @jsxRuntime automatic
@jsxImportSource ${jsxImportSource} */
`;
  var layoutJsDoc = (propsName) => `
/** @typedef {MDXContentProps & { children: JSX.Element }} MDXLayoutProps */

/**
 * There is one special component: [MDX layout](https://mdxjs.com/docs/using-mdx/#layout).
 * If it is defined, it\u2019s used to wrap all content.
 * A layout can be defined from within MDX using a default export.
 *
 * @param {{readonly [K in keyof MDXLayoutProps]: MDXLayoutProps[K]}} ${propsName}
 *   The [props](https://mdxjs.com/docs/using-mdx/#props) that have been passed to the MDX component.
 *   In addition, the MDX layout receives the \`children\` prop, which contains the rendered MDX content.
 * @returns {JSX.Element}
 *   The MDX content wrapped in the layout.
 */`;
  var componentStart = (isAsync, variables) => `
/**
 * @internal
 *   **Do not use.** This function is generated by MDX for internal use.
 *
 * @param {{readonly [K in keyof MDXContentProps]: MDXContentProps[K]}} props
 *   The [props](https://mdxjs.com/docs/using-mdx/#props) that have been passed to the MDX component.
 */
${isAsync ? "async " : ""}function _createMdxContent(props) {
  /**
   * @internal
   *   **Do not use.** This variable is generated by MDX for internal use.
   */
  const _components = {
    // @ts-ignore
    .../** @type {0 extends 1 & MDXProvidedComponents ? {} : MDXProvidedComponents} */ ({}),
    ...props.components,
    /** The [props](https://mdxjs.com/docs/using-mdx/#props) that have been passed to the MDX component. */
    props${Array.from(variables, (name2) => ",\n    /** {@link " + name2 + "} */\n    " + name2).join("")}
  }
  _components
  return <>`;
  var componentEnd = `
  </>
}

/**
 * Render the MDX contents.
 *
 * @param {{readonly [K in keyof MDXContentProps]: MDXContentProps[K]}} props
 *   The [props](https://mdxjs.com/docs/using-mdx/#props) that have been passed to the MDX component.
 */
export default function MDXContent(props) {
  return <_createMdxContent {...props} />
}

// @ts-ignore
/** @typedef {(void extends Props ? {} : Props) & {components?: {}}} MDXContentProps */
`;
  var jsxIndent = "\n    ";
  var fallback = jsPrefix(false, "react") + componentStart(false, []) + componentEnd;
  function visit2(node3, onEnter, onExit) {
    onEnter(node3);
    if ("children" in node3) {
      for (const child of node3.children) {
        visit2(child, onEnter, onExit);
      }
    }
    onExit(node3);
  }
  function addOffset(mapping, source, generated, startOffset, endOffset, includeNewline) {
    if (startOffset === endOffset) {
      return generated;
    }
    if (includeNewline) {
      const LF = 10;
      const CR = 13;
      const charCode = source.charCodeAt(endOffset);
      if (charCode === LF) {
        endOffset += 1;
      } else if (charCode === CR && source.charCodeAt(endOffset + 1) === LF) {
        endOffset += 2;
      }
    }
    const length = endOffset - startOffset;
    const previousSourceOffset = mapping.sourceOffsets.at(-1);
    const previousGeneratedOffset = mapping.generatedOffsets.at(-1);
    const previousLength = mapping.lengths.at(-1);
    if (previousSourceOffset !== void 0 && previousGeneratedOffset !== void 0 && previousLength !== void 0 && previousSourceOffset + previousLength === startOffset && previousGeneratedOffset + previousLength === generated.length) {
      mapping.lengths[mapping.lengths.length - 1] += length;
    } else {
      mapping.sourceOffsets.push(startOffset);
      mapping.generatedOffsets.push(generated.length);
      mapping.lengths.push(length);
    }
    return generated + source.slice(startOffset, endOffset);
  }
  function getPropsName(node3) {
    const { declaration } = node3;
    const { type } = declaration;
    if (type !== "ArrowFunctionExpression" && type !== "FunctionDeclaration" && type !== "FunctionExpression") {
      return;
    }
    if (declaration.params.length === 1) {
      const parameter = declaration.params[0];
      if (parameter.type === "Identifier") {
        return parameter.name;
      }
    }
    return "props";
  }
  function processExports(mdx, node3, mapping, esm) {
    const start2 = node3.position?.start?.offset;
    const end = node3.position?.end?.offset;
    if (start2 === void 0 || end === void 0) {
      return esm;
    }
    const body = node3.data?.estree?.body;
    if (!body?.length) {
      return addOffset(mapping, mdx, esm, start2, end, true);
    }
    for (const child of body) {
      if (child.type === "ExportDefaultDeclaration") {
        const propsName = getPropsName(child);
        if (propsName) {
          esm += layoutJsDoc(propsName);
        }
        esm = addOffset(
          mapping,
          mdx,
          esm + "\nconst MDXLayout = ",
          child.declaration.start,
          child.end,
          true
        );
        continue;
      }
      if (child.type === "ExportNamedDeclaration" && child.source) {
        const { specifiers } = child;
        for (let index4 = 0; index4 < specifiers.length; index4++) {
          const specifier = specifiers[index4];
          if (specifier.local.name === "default") {
            esm = addOffset(mapping, mdx, esm, start2, specifier.start);
            const nextPosition = index4 === specifiers.length - 1 ? specifier.end : mdx.indexOf(",", specifier.end) + 1;
            return addOffset(mapping, mdx, esm, nextPosition, end, true) + "\nimport {" + specifier.exported.name + " as MDXLayout} from " + JSON.stringify(child.source.value) + "\n";
          }
        }
      }
      esm = addOffset(mapping, mdx, esm, child.start, child.end, true);
    }
    return esm + "\n";
  }
  function getEmbeddedCodes(mdx, ast, checkMdx, jsxImportSource) {
    const jsMappings = [];
    const esmMapping = {
      sourceOffsets: [],
      generatedOffsets: [],
      lengths: [],
      data: {
        completion: true,
        format: true,
        navigation: true,
        semantic: true,
        structure: true,
        verification: true
      }
    };
    const jsxMapping = {
      sourceOffsets: [],
      generatedOffsets: [],
      lengths: [],
      data: {
        completion: true,
        format: false,
        navigation: true,
        semantic: true,
        structure: true,
        verification: true
      }
    };
    const markdownMapping = {
      sourceOffsets: [],
      generatedOffsets: [],
      lengths: [],
      data: {
        completion: true,
        format: false,
        navigation: true,
        semantic: true,
        structure: true,
        verification: true
      }
    };
    const virtualCodes = [];
    let hasAwait = false;
    let esm = jsPrefix(checkMdx, jsxImportSource);
    let jsx = "";
    let markdown = "";
    let nextMarkdownSourceStart = 0;
    const esmProgram = {
      type: "Program",
      sourceType: "module",
      start: 0,
      end: 0,
      body: []
    };
    for (const child of ast.children) {
      if (child.type !== "mdxjsEsm") {
        continue;
      }
      const estree = child.data?.estree;
      if (estree) {
        esmProgram.body.push(...estree.body);
      }
    }
    const variables = [...analyze(esmProgram).scope.declarations.keys()].sort();
    function updateMarkdownFromOffsets(startOffset, endOffset) {
      if (nextMarkdownSourceStart !== startOffset) {
        const slice = mdx.slice(nextMarkdownSourceStart, startOffset);
        for (const match of slice.matchAll(/^[\t ]*(.*\r?\n?)/gm)) {
          const [line, lineContent] = match;
          if (line.length === 0) {
            continue;
          }
          const lineEnd = nextMarkdownSourceStart + match.index + line.length;
          let lineStart = lineEnd - lineContent.length;
          if (match.index === 0 && nextMarkdownSourceStart !== 0 && mdx[lineStart - 1] !== "\n") {
            lineStart = nextMarkdownSourceStart + match.index;
          }
          markdown = addOffset(markdownMapping, mdx, markdown, lineStart, lineEnd);
        }
        if (startOffset !== endOffset) {
          markdown += "<!---->";
        }
      }
      nextMarkdownSourceStart = endOffset;
    }
    function updateMarkdownFromNode(node3) {
      const startOffset = getNodeStartOffset(node3);
      const endOffset = getNodeEndOffset(node3);
      updateMarkdownFromOffsets(startOffset, endOffset);
    }
    function processJsxExpression(program, lastIndex) {
      let newIndex = lastIndex;
      let functionNesting = 0;
      walk(program, {
        enter(node3) {
          switch (node3.type) {
            case "JSXIdentifier": {
              if (!isInjectableComponent(node3.name, variables)) {
                return;
              }
              jsx = addOffset(jsxMapping, mdx, jsx, newIndex, node3.start) + "_components.";
              newIndex = node3.start;
              break;
            }
            case "ArrowFunctionExpression":
            case "FunctionDeclaration":
            case "FunctionExpression": {
              functionNesting++;
              break;
            }
            case "AwaitExpression": {
              if (!functionNesting) {
                hasAwait = true;
              }
              break;
            }
            case "ForOfStatement": {
              if (!functionNesting) {
                hasAwait ||= node3.await;
              }
              break;
            }
            default:
          }
        },
        leave(node3) {
          switch (node3.type) {
            case "ArrowFunctionExpression":
            case "FunctionDeclaration":
            case "FunctionExpression": {
              functionNesting--;
              break;
            }
            default:
          }
        }
      });
      return newIndex;
    }
    visit2(
      ast,
      (node3) => {
        const start2 = node3.position?.start?.offset;
        let end = node3.position?.end?.offset;
        if (start2 === void 0 || end === void 0) {
          return;
        }
        switch (node3.type) {
          case "toml":
          case "yaml": {
            const frontmatterWithFences = mdx.slice(start2, end);
            const frontmatterStart = frontmatterWithFences.indexOf(node3.value);
            virtualCodes.push({
              id: node3.type,
              languageId: node3.type,
              mappings: [
                {
                  sourceOffsets: [frontmatterStart],
                  generatedOffsets: [0],
                  lengths: [node3.value.length],
                  data: {
                    completion: true,
                    format: true,
                    navigation: true,
                    semantic: true,
                    structure: true,
                    verification: true
                  }
                }
              ],
              snapshot: new ScriptSnapshot(node3.value)
            });
            break;
          }
          case "mdxjsEsm": {
            updateMarkdownFromNode(node3);
            esm = processExports(mdx, node3, esmMapping, esm);
            break;
          }
          case "mdxJsxFlowElement":
          case "mdxJsxTextElement": {
            if (node3.children.length > 0) {
              end = mdx.lastIndexOf(">", getNodeStartOffset(node3.children[0]) - 1) + 1;
            }
            updateMarkdownFromOffsets(start2, end);
            let lastIndex = start2 + 1;
            jsx = addOffset(jsxMapping, mdx, jsx + jsxIndent, start2, lastIndex);
            if (isInjectableComponent(node3.name, variables)) {
              jsx += "_components.";
            }
            if (node3.name) {
              jsx = addOffset(
                jsxMapping,
                mdx,
                jsx,
                lastIndex,
                lastIndex + node3.name.length
              );
              lastIndex += node3.name.length;
            }
            for (const attribute of node3.attributes) {
              if (typeof attribute.value !== "object") {
                continue;
              }
              const program = attribute.value?.data?.estree;
              if (program) {
                lastIndex = processJsxExpression(program, lastIndex);
              }
            }
            jsx = addOffset(jsxMapping, mdx, jsx, lastIndex, end);
            break;
          }
          case "mdxFlowExpression":
          case "mdxTextExpression": {
            updateMarkdownFromNode(node3);
            const program = node3.data?.estree;
            jsx += jsxIndent;
            if (program?.body.length) {
              const newIndex = processJsxExpression(program, start2);
              jsx = addOffset(jsxMapping, mdx, jsx, newIndex, end);
            } else {
              jsx = addOffset(jsxMapping, mdx, jsx, start2, start2 + 1);
              jsx = addOffset(jsxMapping, mdx, jsx, end - 1, end);
              esm = addOffset(esmMapping, mdx, esm, start2 + 1, end - 1) + "\n";
            }
            break;
          }
          case "root": {
            break;
          }
          case "text": {
            jsx += jsxIndent + "{''}";
            break;
          }
          default: {
            jsx += jsxIndent + "<>";
            break;
          }
        }
      },
      (node3) => {
        switch (node3.type) {
          case "mdxJsxFlowElement":
          case "mdxJsxTextElement": {
            const child = node3.children?.at(-1);
            if (child) {
              const start2 = mdx.indexOf("<", getNodeEndOffset(child) - 1);
              const end = getNodeEndOffset(node3);
              updateMarkdownFromOffsets(start2, end);
              if (isInjectableComponent(node3.name, variables)) {
                const closingStart = start2 + 2;
                jsx = addOffset(
                  jsxMapping,
                  mdx,
                  addOffset(
                    jsxMapping,
                    mdx,
                    jsx + jsxIndent,
                    start2,
                    closingStart
                  ) + "_components.",
                  closingStart,
                  end
                );
              } else {
                jsx = addOffset(jsxMapping, mdx, jsx + jsxIndent, start2, end);
              }
            }
            break;
          }
          case "mdxTextExpression":
          case "mdxjsEsm":
          case "mdxFlowExpression":
          case "root":
          case "text":
          case "toml":
          case "yaml": {
            break;
          }
          default: {
            jsx += jsxIndent + "</>";
            break;
          }
        }
      }
    );
    updateMarkdownFromOffsets(mdx.length, mdx.length);
    esm += componentStart(hasAwait, variables);
    for (let i = 0; i < jsxMapping.generatedOffsets.length; i++) {
      jsxMapping.generatedOffsets[i] += esm.length;
    }
    esm += jsx + componentEnd;
    if (esmMapping.sourceOffsets.length > 0) {
      jsMappings.push(esmMapping);
    }
    if (jsxMapping.sourceOffsets.length > 0) {
      jsMappings.push(jsxMapping);
    }
    virtualCodes.unshift(
      {
        id: "jsx",
        languageId: "javascriptreact",
        mappings: jsMappings,
        snapshot: new ScriptSnapshot(esm)
      },
      {
        id: "md",
        languageId: "markdown",
        mappings: [markdownMapping],
        snapshot: new ScriptSnapshot(markdown)
      }
    );
    return virtualCodes;
  }
  var VirtualMdxCode = class {
    #processor;
    #checkMdx;
    #jsxImportSource;
    /**
     * The mdast of the document, but only if it’s valid.
     *
     * @type {Root | undefined}
     */
    ast;
    /**
     * The virtual files embedded in the MDX file.
     *
     * @type {VirtualCode[]}
     */
    embeddedCodes = [];
    /**
     * The error that was throw while parsing.
     *
     * @type {VFileMessage | undefined}
     */
    error;
    /**
     * The file ID.
     *
     * @type {'mdx'}
     */
    id = "mdx";
    /**
     * The language ID.
     *
     * @type {'mdx'}
     */
    languageId = "mdx";
    /**
     * The code mappings of the MDX file. There is always only one mapping.
     *
     * @type {CodeMapping[]}
     */
    mappings = [];
    /**
     * @param {IScriptSnapshot} snapshot
     *   The original TypeScript snapshot.
     * @param {Processor<Root>} processor
     *   The unified processor to use for parsing.
     * @param {boolean} checkMdx
     *   If true, insert a `@check-js` comment into the virtual JavaScript code.
     * @param {string} jsxImportSource
     *   The JSX import source to use in the embedded JavaScript file.
     */
    constructor(snapshot, processor, checkMdx, jsxImportSource) {
      this.#processor = processor;
      this.#checkMdx = checkMdx;
      this.#jsxImportSource = jsxImportSource;
      this.snapshot = snapshot;
      const length = snapshot.getLength();
      this.mappings[0] = {
        sourceOffsets: [0],
        generatedOffsets: [0],
        lengths: [length],
        data: {
          completion: true,
          format: true,
          navigation: true,
          semantic: true,
          structure: true,
          verification: true
        }
      };
      const mdx = snapshot.getText(0, length);
      try {
        const ast = this.#processor.parse(mdx);
        this.embeddedCodes = getEmbeddedCodes(
          mdx,
          ast,
          this.#checkMdx,
          this.#jsxImportSource
        );
        this.ast = ast;
        this.error = void 0;
      } catch (error) {
        this.error = /** @type {VFileMessage} */
        error;
        this.ast = void 0;
        this.embeddedCodes = [
          {
            id: "jsx",
            languageId: "javascriptreact",
            mappings: [],
            snapshot: new ScriptSnapshot(fallback)
          },
          {
            id: "md",
            languageId: "markdown",
            mappings: [],
            snapshot: new ScriptSnapshot(mdx)
          }
        ];
      }
    }
  };

  // node_modules/@mdx-js/language-service/lib/language-plugin.js
  function createMdxLanguagePlugin(plugins, checkMdx = false, jsxImportSource = "react") {
    const processor = unified().use(remarkParse).use(remarkMdx);
    if (plugins) {
      processor.use(plugins);
    }
    processor.freeze();
    return {
      getLanguageId(fileNameOrUri) {
        if (String(fileNameOrUri).endsWith(".mdx")) {
          return "mdx";
        }
      },
      createVirtualCode(fileNameOrUri, languageId, snapshot) {
        if (languageId === "mdx") {
          return new VirtualMdxCode(
            snapshot,
            processor,
            checkMdx,
            jsxImportSource
          );
        }
      },
      typescript: {
        extraFileExtensions: [
          { extension: "mdx", isMixedContent: true, scriptKind: 7 }
        ],
        getServiceScript(root2) {
          return {
            code: root2.embeddedCodes[0],
            extension: ".jsx",
            scriptKind: 2
          };
        },
        resolveLanguageServiceHost(host) {
          return {
            ...host,
            getCompilationSettings: () => ({
              ...host.getCompilationSettings(),
              // Always allow JS for type checking.
              allowJs: true
            })
          };
        }
      }
    };
  }

  // node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js
  var exports = {};
  var _dewExec = false;
  var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
  function dew() {
    if (_dewExec)
      return exports;
    _dewExec = true;
    var process3 = exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this || _global, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this || _global, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process3.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      (this || _global).fun = fun;
      (this || _global).array = array;
    }
    Item.prototype.run = function() {
      (this || _global).fun.apply(null, (this || _global).array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop() {
    }
    process3.on = noop;
    process3.addListener = noop;
    process3.once = noop;
    process3.off = noop;
    process3.removeListener = noop;
    process3.removeAllListeners = noop;
    process3.emit = noop;
    process3.prependListener = noop;
    process3.prependOnceListener = noop;
    process3.listeners = function(name2) {
      return [];
    };
    process3.binding = function(name2) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
    return exports;
  }
  var process2 = dew();
  process2.platform = "browser";
  process2.addListener;
  process2.argv;
  process2.binding;
  process2.browser;
  process2.chdir;
  process2.cwd;
  process2.emit;
  process2.env;
  process2.listeners;
  process2.nextTick;
  process2.off;
  process2.on;
  process2.once;
  process2.prependListener;
  process2.prependOnceListener;
  process2.removeAllListeners;
  process2.removeListener;
  process2.title;
  process2.umask;
  process2.version;
  process2.versions;

  // node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
  var exports$1 = {};
  var _dewExec2 = false;
  function dew2() {
    if (_dewExec2)
      return exports$1;
    _dewExec2 = true;
    var process$1 = process2;
    function assertPath3(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code2;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code2 = path.charCodeAt(i);
        else if (code2 === 47)
          break;
        else
          code2 = 47;
        if (code2 === 47) {
          if (lastSlash === i - 1 || dots === 1)
            ;
          else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code2 === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format3(sep3, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep3 + base;
    }
    var posix3 = {
      // path.resolve([from ...], to)
      resolve: function resolve3() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd3;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd3 === void 0)
              cwd3 = process$1.cwd();
            path = cwd3;
          }
          assertPath3(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize4(path) {
        assertPath3(path);
        if (path.length === 0)
          return ".";
        var isAbsolute2 = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute2);
        if (path.length === 0 && !isAbsolute2)
          path = ".";
        if (path.length > 0 && trailingSeparator)
          path += "/";
        if (isAbsolute2)
          return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute2(path) {
        assertPath3(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join4() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath3(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix3.normalize(joined);
      },
      relative: function relative3(from, to) {
        assertPath3(from);
        assertPath3(to);
        if (from === to)
          return "";
        from = posix3.resolve(from);
        to = posix3.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong2(path) {
        return path;
      },
      dirname: function dirname4(path) {
        assertPath3(path);
        if (path.length === 0)
          return ".";
        var code2 = path.charCodeAt(0);
        var hasRoot = code2 === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code2 = path.charCodeAt(i);
          if (code2 === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path.slice(0, end);
      },
      basename: function basename4(path, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath3(path);
        var start2 = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code2 = path.charCodeAt(i);
            if (code2 === 47) {
              if (!matchedSlash) {
                start2 = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code2 === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start2 === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path.length;
          return path.slice(start2, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start2 = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1)
            return "";
          return path.slice(start2, end);
        }
      },
      extname: function extname4(path) {
        assertPath3(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code2 = path.charCodeAt(i);
          if (code2 === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code2 === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format2(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format3("/", pathObject);
      },
      parse: function parse5(path) {
        assertPath3(path);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path.length === 0)
          return ret;
        var code2 = path.charCodeAt(0);
        var isAbsolute2 = code2 === 47;
        var start2;
        if (isAbsolute2) {
          ret.root = "/";
          start2 = 1;
        } else {
          start2 = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start2; --i) {
          code2 = path.charCodeAt(i);
          if (code2 === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code2 === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute2)
              ret.base = ret.name = path.slice(1, end);
            else
              ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute2) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute2)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix3.posix = posix3;
    exports$1 = posix3;
    return exports$1;
  }
  var exports2 = dew2();

  // node-modules-polyfills:path
  var _makeLong = exports2._makeLong;
  var basename3 = exports2.basename;
  var delimiter = exports2.delimiter;
  var dirname3 = exports2.dirname;
  var extname3 = exports2.extname;
  var format = exports2.format;
  var isAbsolute = exports2.isAbsolute;
  var join2 = exports2.join;
  var normalize3 = exports2.normalize;
  var parse4 = exports2.parse;
  var posix2 = exports2.posix;
  var relative2 = exports2.relative;
  var resolve2 = exports2.resolve;
  var sep2 = exports2.sep;
  var win322 = exports2.win32;

  // IMPORT_PATH_MODIFIER:node:path/posix
  var posix_default = posix2;

  // node_modules/zwitch/index.js
  var own4 = {}.hasOwnProperty;
  function zwitch(key, options) {
    const settings = options || {};
    function one3(value, ...parameters) {
      let fn = one3.invalid;
      const handlers = one3.handlers;
      if (value && own4.call(value, key)) {
        const id = String(value[key]);
        fn = own4.call(handlers, id) ? handlers[id] : one3.unknown;
      }
      if (fn) {
        return fn.call(this, value, ...parameters);
      }
    }
    one3.handlers = settings.handlers || {};
    one3.invalid = settings.invalid;
    one3.unknown = settings.unknown;
    return one3;
  }

  // node_modules/mdast-util-to-markdown/lib/configure.js
  var own5 = {}.hasOwnProperty;
  function configure2(base, extension2) {
    let index4 = -1;
    let key;
    if (extension2.extensions) {
      while (++index4 < extension2.extensions.length) {
        configure2(base, extension2.extensions[index4]);
      }
    }
    for (key in extension2) {
      if (own5.call(extension2, key)) {
        switch (key) {
          case "extensions": {
            break;
          }
          case "unsafe": {
            list2(base[key], extension2[key]);
            break;
          }
          case "join": {
            list2(base[key], extension2[key]);
            break;
          }
          case "handlers": {
            map(base[key], extension2[key]);
            break;
          }
          default: {
            base.options[key] = extension2[key];
          }
        }
      }
    }
    return base;
  }
  function list2(left, right) {
    if (right) {
      left.push(...right);
    }
  }
  function map(left, right) {
    if (right) {
      Object.assign(left, right);
    }
  }

  // node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
  function blockquote(node3, _, state, info) {
    const exit2 = state.enter("blockquote");
    const tracker = state.createTracker(info);
    tracker.move("> ");
    tracker.shift(2);
    const value = state.indentLines(
      state.containerFlow(node3, tracker.current()),
      map2
    );
    exit2();
    return value;
  }
  function map2(line, _, blank) {
    return ">" + (blank ? "" : " ") + line;
  }

  // node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
  function patternInScope(stack, pattern) {
    return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
  }
  function listInScope(stack, list4, none) {
    if (typeof list4 === "string") {
      list4 = [list4];
    }
    if (!list4 || list4.length === 0) {
      return none;
    }
    let index4 = -1;
    while (++index4 < list4.length) {
      if (stack.includes(list4[index4])) {
        return true;
      }
    }
    return false;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/break.js
  function hardBreak(_, _1, state, info) {
    let index4 = -1;
    while (++index4 < state.unsafe.length) {
      if (state.unsafe[index4].character === "\n" && patternInScope(state.stack, state.unsafe[index4])) {
        return /[ \t]/.test(info.before) ? "" : " ";
      }
    }
    return "\\\n";
  }

  // node_modules/longest-streak/index.js
  function longestStreak(value, substring) {
    const source = String(value);
    let index4 = source.indexOf(substring);
    let expected = index4;
    let count = 0;
    let max = 0;
    if (typeof substring !== "string") {
      throw new TypeError("Expected substring");
    }
    while (index4 !== -1) {
      if (index4 === expected) {
        if (++count > max) {
          max = count;
        }
      } else {
        count = 1;
      }
      expected = index4 + substring.length;
      index4 = source.indexOf(substring, expected);
    }
    return max;
  }

  // node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
  function formatCodeAsIndented(node3, state) {
    return Boolean(
      state.options.fences === false && node3.value && // If there’s no info…
      !node3.lang && // And there’s a non-whitespace character…
      /[^ \r\n]/.test(node3.value) && // And the value doesn’t start or end in a blank…
      !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node3.value)
    );
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-fence.js
  function checkFence(state) {
    const marker = state.options.fence || "`";
    if (marker !== "`" && marker !== "~") {
      throw new Error(
        "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
      );
    }
    return marker;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/code.js
  function code(node3, _, state, info) {
    const marker = checkFence(state);
    const raw = node3.value || "";
    const suffix = marker === "`" ? "GraveAccent" : "Tilde";
    if (formatCodeAsIndented(node3, state)) {
      const exit3 = state.enter("codeIndented");
      const value2 = state.indentLines(raw, map3);
      exit3();
      return value2;
    }
    const tracker = state.createTracker(info);
    const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
    const exit2 = state.enter("codeFenced");
    let value = tracker.move(sequence);
    if (node3.lang) {
      const subexit = state.enter(`codeFencedLang${suffix}`);
      value += tracker.move(
        state.safe(node3.lang, {
          before: value,
          after: " ",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    if (node3.lang && node3.meta) {
      const subexit = state.enter(`codeFencedMeta${suffix}`);
      value += tracker.move(" ");
      value += tracker.move(
        state.safe(node3.meta, {
          before: value,
          after: "\n",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    value += tracker.move("\n");
    if (raw) {
      value += tracker.move(raw + "\n");
    }
    value += tracker.move(sequence);
    exit2();
    return value;
  }
  function map3(line, _, blank) {
    return (blank ? "" : "    ") + line;
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-quote.js
  function checkQuote(state) {
    const marker = state.options.quote || '"';
    if (marker !== '"' && marker !== "'") {
      throw new Error(
        "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
      );
    }
    return marker;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/definition.js
  function definition2(node3, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit2 = state.enter("definition");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    value += tracker.move(
      state.safe(state.associationId(node3), {
        before: value,
        after: "]",
        ...tracker.current()
      })
    );
    value += tracker.move("]: ");
    subexit();
    if (
      // If there’s no url, or…
      !node3.url || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node3.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node3.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node3.url, {
          before: value,
          after: node3.title ? " " : "\n",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node3.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node3.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    exit2();
    return value;
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
  function checkEmphasis(state) {
    const marker = state.options.emphasis || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
      );
    }
    return marker;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
  emphasis.peek = emphasisPeek;
  function emphasis(node3, _, state, info) {
    const marker = checkEmphasis(state);
    const exit2 = state.enter("emphasis");
    const tracker = state.createTracker(info);
    let value = tracker.move(marker);
    value += tracker.move(
      state.containerPhrasing(node3, {
        before: value,
        after: marker,
        ...tracker.current()
      })
    );
    value += tracker.move(marker);
    exit2();
    return value;
  }
  function emphasisPeek(_, _1, state) {
    return state.options.emphasis || "*";
  }

  // node_modules/unist-util-is/lib/index.js
  var convert = (
    // Note: overloads in JSDoc can’t yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    function(test) {
      if (test === null || test === void 0) {
        return ok2;
      }
      if (typeof test === "function") {
        return castFactory(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
      }
      if (typeof test === "string") {
        return typeFactory(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory(tests) {
    const checks = [];
    let index4 = -1;
    while (++index4 < tests.length) {
      checks[index4] = convert(tests[index4]);
    }
    return castFactory(any);
    function any(...parameters) {
      let index5 = -1;
      while (++index5 < checks.length) {
        if (checks[index5].apply(this, parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory(check) {
    const checkAsRecord = (
      /** @type {Record<string, unknown>} */
      check
    );
    return castFactory(all3);
    function all3(node3) {
      const nodeAsRecord = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        node3
      );
      let key;
      for (key in check) {
        if (nodeAsRecord[key] !== checkAsRecord[key])
          return false;
      }
      return true;
    }
  }
  function typeFactory(check) {
    return castFactory(type);
    function type(node3) {
      return node3 && node3.type === check;
    }
  }
  function castFactory(testFunction) {
    return check;
    function check(value, index4, parent) {
      return Boolean(
        looksLikeANode(value) && testFunction.call(
          this,
          value,
          typeof index4 === "number" ? index4 : void 0,
          parent || void 0
        )
      );
    }
  }
  function ok2() {
    return true;
  }
  function looksLikeANode(value) {
    return value !== null && typeof value === "object" && "type" in value;
  }

  // node_modules/unist-util-visit-parents/lib/color.js
  function color2(d) {
    return d;
  }

  // node_modules/unist-util-visit-parents/lib/index.js
  var empty3 = [];
  var CONTINUE2 = true;
  var EXIT2 = false;
  var SKIP2 = "skip";
  function visitParents(tree, test, visitor, reverse) {
    let check;
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
    } else {
      check = test;
    }
    const is2 = convert(check);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node3, index4, parents) {
      const value = (
        /** @type {Record<string, unknown>} */
        node3 && typeof node3 === "object" ? node3 : {}
      );
      if (typeof value.type === "string") {
        const name2 = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit4, "name", {
          value: "node (" + color2(node3.type + (name2 ? "<" + name2 + ">" : "")) + ")"
        });
      }
      return visit4;
      function visit4() {
        let result = empty3;
        let subresult;
        let offset2;
        let grandparents;
        if (!test || is2(node3, index4, parents[parents.length - 1] || void 0)) {
          result = toResult2(visitor(node3, parents));
          if (result[0] === EXIT2) {
            return result;
          }
        }
        if ("children" in node3 && node3.children) {
          const nodeAsParent = (
            /** @type {UnistParent} */
            node3
          );
          if (nodeAsParent.children && result[0] !== SKIP2) {
            offset2 = (reverse ? nodeAsParent.children.length : -1) + step;
            grandparents = parents.concat(nodeAsParent);
            while (offset2 > -1 && offset2 < nodeAsParent.children.length) {
              const child = nodeAsParent.children[offset2];
              subresult = factory(child, offset2, grandparents)();
              if (subresult[0] === EXIT2) {
                return subresult;
              }
              offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
            }
          }
        }
        return result;
      }
    }
  }
  function toResult2(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE2, value];
    }
    return value === null || value === void 0 ? empty3 : [value];
  }

  // node_modules/mdast-util-to-markdown/node_modules/unist-util-visit/lib/index.js
  function visit3(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
    let reverse;
    let test;
    let visitor;
    if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
      test = void 0;
      visitor = testOrVisitor;
      reverse = visitorOrReverse;
    } else {
      test = testOrVisitor;
      visitor = visitorOrReverse;
      reverse = maybeReverse;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node3, parents) {
      const parent = parents[parents.length - 1];
      const index4 = parent ? parent.children.indexOf(node3) : void 0;
      return visitor(node3, index4, parent);
    }
  }

  // node_modules/mdast-util-to-markdown/node_modules/mdast-util-to-string/lib/index.js
  var emptyOptions4 = {};
  function toString3(value, options) {
    const settings = options || emptyOptions4;
    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
    return one2(value, includeImageAlt, includeHtml);
  }
  function one2(value, includeImageAlt, includeHtml) {
    if (node2(value)) {
      if ("value" in value) {
        return value.type === "html" && !includeHtml ? "" : value.value;
      }
      if (includeImageAlt && "alt" in value && value.alt) {
        return value.alt;
      }
      if ("children" in value) {
        return all2(value.children, includeImageAlt, includeHtml);
      }
    }
    if (Array.isArray(value)) {
      return all2(value, includeImageAlt, includeHtml);
    }
    return "";
  }
  function all2(values, includeImageAlt, includeHtml) {
    const result = [];
    let index4 = -1;
    while (++index4 < values.length) {
      result[index4] = one2(values[index4], includeImageAlt, includeHtml);
    }
    return result.join("");
  }
  function node2(value) {
    return Boolean(value && typeof value === "object");
  }

  // node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
  function formatHeadingAsSetext(node3, state) {
    let literalWithBreak = false;
    visit3(node3, function(node4) {
      if ("value" in node4 && /\r?\n|\r/.test(node4.value) || node4.type === "break") {
        literalWithBreak = true;
        return EXIT2;
      }
    });
    return Boolean(
      (!node3.depth || node3.depth < 3) && toString3(node3) && (state.options.setext || literalWithBreak)
    );
  }

  // node_modules/mdast-util-to-markdown/lib/handle/heading.js
  function heading(node3, _, state, info) {
    const rank = Math.max(Math.min(6, node3.depth || 1), 1);
    const tracker = state.createTracker(info);
    if (formatHeadingAsSetext(node3, state)) {
      const exit3 = state.enter("headingSetext");
      const subexit2 = state.enter("phrasing");
      const value2 = state.containerPhrasing(node3, {
        ...tracker.current(),
        before: "\n",
        after: "\n"
      });
      subexit2();
      exit3();
      return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
        // The whole size…
        value2.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)…
        (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
      );
    }
    const sequence = "#".repeat(rank);
    const exit2 = state.enter("headingAtx");
    const subexit = state.enter("phrasing");
    tracker.move(sequence + " ");
    let value = state.containerPhrasing(node3, {
      before: "# ",
      after: "\n",
      ...tracker.current()
    });
    if (/^[\t ]/.test(value)) {
      value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
    }
    value = value ? sequence + " " + value : sequence;
    if (state.options.closeAtx) {
      value += " " + sequence;
    }
    subexit();
    exit2();
    return value;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/html.js
  html.peek = htmlPeek;
  function html(node3) {
    return node3.value || "";
  }
  function htmlPeek() {
    return "<";
  }

  // node_modules/mdast-util-to-markdown/lib/handle/image.js
  image.peek = imagePeek;
  function image(node3, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit2 = state.enter("image");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    value += tracker.move(
      state.safe(node3.alt, { before: value, after: "]", ...tracker.current() })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If there’s no url but there is a title…
      !node3.url && node3.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node3.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node3.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node3.url, {
          before: value,
          after: node3.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node3.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node3.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit2();
    return value;
  }
  function imagePeek() {
    return "!";
  }

  // node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
  imageReference.peek = imageReferencePeek;
  function imageReference(node3, _, state, info) {
    const type = node3.referenceType;
    const exit2 = state.enter("imageReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    const alt = state.safe(node3.alt, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(alt + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node3), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit2();
    if (type === "full" || !alt || alt !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function imageReferencePeek() {
    return "!";
  }

  // node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
  inlineCode.peek = inlineCodePeek;
  function inlineCode(node3, _, state) {
    let value = node3.value || "";
    let sequence = "`";
    let index4 = -1;
    while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
      sequence += "`";
    }
    if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
      value = " " + value + " ";
    }
    while (++index4 < state.unsafe.length) {
      const pattern = state.unsafe[index4];
      const expression = state.compilePattern(pattern);
      let match;
      if (!pattern.atBreak)
        continue;
      while (match = expression.exec(value)) {
        let position4 = match.index;
        if (value.charCodeAt(position4) === 10 && value.charCodeAt(position4 - 1) === 13) {
          position4--;
        }
        value = value.slice(0, position4) + " " + value.slice(match.index + 1);
      }
    }
    return sequence + value + sequence;
  }
  function inlineCodePeek() {
    return "`";
  }

  // node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
  function formatLinkAsAutolink(node3, state) {
    const raw = toString3(node3);
    return Boolean(
      !state.options.resourceLink && // If there’s a url…
      node3.url && // And there’s a no title…
      !node3.title && // And the content of `node` is a single text node…
      node3.children && node3.children.length === 1 && node3.children[0].type === "text" && // And if the url is the same as the content…
      (raw === node3.url || "mailto:" + raw === node3.url) && // And that starts w/ a protocol…
      /^[a-z][a-z+.-]+:/i.test(node3.url) && // And that doesn’t contain ASCII control codes (character escapes and
      // references don’t work), space, or angle brackets…
      !/[\0- <>\u007F]/.test(node3.url)
    );
  }

  // node_modules/mdast-util-to-markdown/lib/handle/link.js
  link.peek = linkPeek;
  function link(node3, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const tracker = state.createTracker(info);
    let exit2;
    let subexit;
    if (formatLinkAsAutolink(node3, state)) {
      const stack = state.stack;
      state.stack = [];
      exit2 = state.enter("autolink");
      let value2 = tracker.move("<");
      value2 += tracker.move(
        state.containerPhrasing(node3, {
          before: value2,
          after: ">",
          ...tracker.current()
        })
      );
      value2 += tracker.move(">");
      exit2();
      state.stack = stack;
      return value2;
    }
    exit2 = state.enter("link");
    subexit = state.enter("label");
    let value = tracker.move("[");
    value += tracker.move(
      state.containerPhrasing(node3, {
        before: value,
        after: "](",
        ...tracker.current()
      })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If there’s no url but there is a title…
      !node3.url && node3.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node3.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node3.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node3.url, {
          before: value,
          after: node3.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node3.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node3.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit2();
    return value;
  }
  function linkPeek(node3, _, state) {
    return formatLinkAsAutolink(node3, state) ? "<" : "[";
  }

  // node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
  linkReference.peek = linkReferencePeek;
  function linkReference(node3, _, state, info) {
    const type = node3.referenceType;
    const exit2 = state.enter("linkReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    const text4 = state.containerPhrasing(node3, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(text4 + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node3), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit2();
    if (type === "full" || !text4 || text4 !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function linkReferencePeek() {
    return "[";
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
  function checkBullet(state) {
    const marker = state.options.bullet || "*";
    if (marker !== "*" && marker !== "+" && marker !== "-") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    }
    return marker;
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
  function checkBulletOther(state) {
    const bullet = checkBullet(state);
    const bulletOther = state.options.bulletOther;
    if (!bulletOther) {
      return bullet === "*" ? "-" : "*";
    }
    if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
      throw new Error(
        "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    }
    if (bulletOther === bullet) {
      throw new Error(
        "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
      );
    }
    return bulletOther;
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
  function checkBulletOrdered(state) {
    const marker = state.options.bulletOrdered || ".";
    if (marker !== "." && marker !== ")") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    }
    return marker;
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-rule.js
  function checkRule(state) {
    const marker = state.options.rule || "*";
    if (marker !== "*" && marker !== "-" && marker !== "_") {
      throw new Error(
        "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    }
    return marker;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/list.js
  function list3(node3, parent, state, info) {
    const exit2 = state.enter("list");
    const bulletCurrent = state.bulletCurrent;
    let bullet = node3.ordered ? checkBulletOrdered(state) : checkBullet(state);
    const bulletOther = node3.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
    let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
    if (!node3.ordered) {
      const firstListItem = node3.children ? node3.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (bullet === "*" || bullet === "-") && // Empty first list item:
        firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
        state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
        state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
      ) {
        useDifferentMarker = true;
      }
      if (checkRule(state) === bullet && firstListItem) {
        let index4 = -1;
        while (++index4 < node3.children.length) {
          const item = node3.children[index4];
          if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
            useDifferentMarker = true;
            break;
          }
        }
      }
    }
    if (useDifferentMarker) {
      bullet = bulletOther;
    }
    state.bulletCurrent = bullet;
    const value = state.containerFlow(node3, info);
    state.bulletLastUsed = bullet;
    state.bulletCurrent = bulletCurrent;
    exit2();
    return value;
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
  function checkListItemIndent(state) {
    const style = state.options.listItemIndent || "one";
    if (style !== "tab" && style !== "one" && style !== "mixed") {
      throw new Error(
        "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    }
    return style;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/list-item.js
  function listItem(node3, parent, state, info) {
    const listItemIndent = checkListItemIndent(state);
    let bullet = state.bulletCurrent || checkBullet(state);
    if (parent && parent.type === "list" && parent.ordered) {
      bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node3)) + bullet;
    }
    let size = bullet.length + 1;
    if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node3.spread)) {
      size = Math.ceil(size / 4) * 4;
    }
    const tracker = state.createTracker(info);
    tracker.move(bullet + " ".repeat(size - bullet.length));
    tracker.shift(size);
    const exit2 = state.enter("listItem");
    const value = state.indentLines(
      state.containerFlow(node3, tracker.current()),
      map4
    );
    exit2();
    return value;
    function map4(line, index4, blank) {
      if (index4) {
        return (blank ? "" : " ".repeat(size)) + line;
      }
      return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
    }
  }

  // node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
  function paragraph(node3, _, state, info) {
    const exit2 = state.enter("paragraph");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node3, info);
    subexit();
    exit2();
    return value;
  }

  // node_modules/mdast-util-phrasing/lib/index.js
  var phrasing = (
    /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
    convert([
      "break",
      "delete",
      "emphasis",
      // To do: next major: removed since footnotes were added to GFM.
      "footnote",
      "footnoteReference",
      "image",
      "imageReference",
      "inlineCode",
      // Enabled by `mdast-util-math`:
      "inlineMath",
      "link",
      "linkReference",
      // Enabled by `mdast-util-mdx`:
      "mdxJsxTextElement",
      // Enabled by `mdast-util-mdx`:
      "mdxTextExpression",
      "strong",
      "text",
      // Enabled by `mdast-util-directive`:
      "textDirective"
    ])
  );

  // node_modules/mdast-util-to-markdown/lib/handle/root.js
  function root(node3, _, state, info) {
    const hasPhrasing = node3.children.some(function(d) {
      return phrasing(d);
    });
    const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
    return fn.call(state, node3, info);
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-strong.js
  function checkStrong(state) {
    const marker = state.options.strong || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
      );
    }
    return marker;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/strong.js
  strong.peek = strongPeek;
  function strong(node3, _, state, info) {
    const marker = checkStrong(state);
    const exit2 = state.enter("strong");
    const tracker = state.createTracker(info);
    let value = tracker.move(marker + marker);
    value += tracker.move(
      state.containerPhrasing(node3, {
        before: value,
        after: marker,
        ...tracker.current()
      })
    );
    value += tracker.move(marker + marker);
    exit2();
    return value;
  }
  function strongPeek(_, _1, state) {
    return state.options.strong || "*";
  }

  // node_modules/mdast-util-to-markdown/lib/handle/text.js
  function text3(node3, _, state, info) {
    return state.safe(node3.value, info);
  }

  // node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
  function checkRuleRepetition(state) {
    const repetition = state.options.ruleRepetition || 3;
    if (repetition < 3) {
      throw new Error(
        "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
      );
    }
    return repetition;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
  function thematicBreak2(_, _1, state) {
    const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
    return state.options.ruleSpaces ? value.slice(0, -1) : value;
  }

  // node_modules/mdast-util-to-markdown/lib/handle/index.js
  var handle = {
    blockquote,
    break: hardBreak,
    code,
    definition: definition2,
    emphasis,
    hardBreak,
    heading,
    html,
    image,
    imageReference,
    inlineCode,
    link,
    linkReference,
    list: list3,
    listItem,
    paragraph,
    root,
    strong,
    text: text3,
    thematicBreak: thematicBreak2
  };

  // node_modules/mdast-util-to-markdown/lib/join.js
  var join3 = [joinDefaults];
  function joinDefaults(left, right, parent, state) {
    if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
      return false;
    }
    if ("spread" in parent && typeof parent.spread === "boolean") {
      if (left.type === "paragraph" && // Two paragraphs.
      (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
      right.type === "heading" && formatHeadingAsSetext(right, state))) {
        return;
      }
      return parent.spread ? 1 : 0;
    }
  }

  // node_modules/mdast-util-to-markdown/lib/unsafe.js
  var fullPhrasingSpans = [
    "autolink",
    "destinationLiteral",
    "destinationRaw",
    "reference",
    "titleQuote",
    "titleApostrophe"
  ];
  var unsafe = [
    { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
    {
      character: "	",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    {
      character: "\r",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    {
      character: "\n",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
    {
      character: " ",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    // An exclamation mark can start an image, if it is followed by a link or
    // a link reference.
    {
      character: "!",
      after: "\\[",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans
    },
    // A quote can break out of a title.
    { character: '"', inConstruct: "titleQuote" },
    // A number sign could start an ATX heading if it starts a line.
    { atBreak: true, character: "#" },
    { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
    // Dollar sign and percentage are not used in markdown.
    // An ampersand could start a character reference.
    { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
    // An apostrophe can break out of a title.
    { character: "'", inConstruct: "titleApostrophe" },
    // A left paren could break out of a destination raw.
    { character: "(", inConstruct: "destinationRaw" },
    // A left paren followed by `]` could make something into a link or image.
    {
      before: "\\]",
      character: "(",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans
    },
    // A right paren could start a list item or break out of a destination
    // raw.
    { atBreak: true, before: "\\d+", character: ")" },
    { character: ")", inConstruct: "destinationRaw" },
    // An asterisk can start thematic breaks, list items, emphasis, strong.
    { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
    { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    // A plus sign could start a list item.
    { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
    // A dash can start thematic breaks, list items, and setext heading
    // underlines.
    { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
    // A dot could start a list item.
    { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
    // Slash, colon, and semicolon are not used in markdown for constructs.
    // A less than can start html (flow or text) or an autolink.
    // HTML could start with an exclamation mark (declaration, cdata, comment),
    // slash (closing tag), question mark (instruction), or a letter (tag).
    // An autolink also starts with a letter.
    // Finally, it could break out of a destination literal.
    { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
    {
      character: "<",
      after: "[!/?A-Za-z]",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans
    },
    { character: "<", inConstruct: "destinationLiteral" },
    // An equals to can start setext heading underlines.
    { atBreak: true, character: "=" },
    // A greater than can start block quotes and it can break out of a
    // destination literal.
    { atBreak: true, character: ">" },
    { character: ">", inConstruct: "destinationLiteral" },
    // Question mark and at sign are not used in markdown for constructs.
    // A left bracket can start definitions, references, labels,
    { atBreak: true, character: "[" },
    { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    { character: "[", inConstruct: ["label", "reference"] },
    // A backslash can start an escape (when followed by punctuation) or a
    // hard break (when followed by an eol).
    // Note: typical escapes are handled in `safe`!
    { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
    // A right bracket can exit labels.
    { character: "]", inConstruct: ["label", "reference"] },
    // Caret is not used in markdown for constructs.
    // An underscore can start emphasis, strong, or a thematic break.
    { atBreak: true, character: "_" },
    { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    // A grave accent can start code (fenced or text), or it can break out of
    // a grave accent code fence.
    { atBreak: true, character: "`" },
    {
      character: "`",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
    },
    { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    // Left brace, vertical bar, right brace are not used in markdown for
    // constructs.
    // A tilde can start code (fenced).
    { atBreak: true, character: "~" }
  ];

  // node_modules/mdast-util-to-markdown/node_modules/micromark-util-decode-numeric-character-reference/index.js
  function decodeNumericCharacterReference2(value, base) {
    const code2 = Number.parseInt(value, base);
    if (
      // C0 except for HT, LF, FF, CR, space.
      code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
      code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
      code2 > 55295 && code2 < 57344 || // Noncharacters.
      code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
      (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
      // Out of range
      code2 > 1114111
    ) {
      return "\uFFFD";
    }
    return String.fromCodePoint(code2);
  }

  // node_modules/mdast-util-to-markdown/node_modules/micromark-util-decode-string/index.js
  var characterEscapeOrReference2 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function decodeString2(value) {
    return value.replace(characterEscapeOrReference2, decode3);
  }
  function decode3($0, $1, $2) {
    if ($1) {
      return $1;
    }
    const head = $2.charCodeAt(0);
    if (head === 35) {
      const head2 = $2.charCodeAt(1);
      const hex = head2 === 120 || head2 === 88;
      return decodeNumericCharacterReference2($2.slice(hex ? 2 : 1), hex ? 16 : 10);
    }
    return decodeNamedCharacterReference($2) || $0;
  }

  // node_modules/mdast-util-to-markdown/lib/util/association.js
  function association(node3) {
    if (node3.label || !node3.identifier) {
      return node3.label || "";
    }
    return decodeString2(node3.identifier);
  }

  // node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js
  function compilePattern(pattern) {
    if (!pattern._compiled) {
      const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
      pattern._compiled = new RegExp(
        (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
        "g"
      );
    }
    return pattern._compiled;
  }

  // node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
  function containerPhrasing(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const results = [];
    let index4 = -1;
    let before = info.before;
    indexStack.push(-1);
    let tracker = state.createTracker(info);
    while (++index4 < children.length) {
      const child = children[index4];
      let after;
      indexStack[indexStack.length - 1] = index4;
      if (index4 + 1 < children.length) {
        let handle2 = state.handle.handlers[children[index4 + 1].type];
        if (handle2 && handle2.peek)
          handle2 = handle2.peek;
        after = handle2 ? handle2(children[index4 + 1], parent, state, {
          before: "",
          after: "",
          ...tracker.current()
        }).charAt(0) : "";
      } else {
        after = info.after;
      }
      if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
        results[results.length - 1] = results[results.length - 1].replace(
          /(\r?\n|\r)$/,
          " "
        );
        before = " ";
        tracker = state.createTracker(info);
        tracker.move(results.join(""));
      }
      results.push(
        tracker.move(
          state.handle(child, parent, state, {
            ...tracker.current(),
            before,
            after
          })
        )
      );
      before = results[results.length - 1].slice(-1);
    }
    indexStack.pop();
    return results.join("");
  }

  // node_modules/mdast-util-to-markdown/lib/util/container-flow.js
  function containerFlow2(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const tracker = state.createTracker(info);
    const results = [];
    let index4 = -1;
    indexStack.push(-1);
    while (++index4 < children.length) {
      const child = children[index4];
      indexStack[indexStack.length - 1] = index4;
      results.push(
        tracker.move(
          state.handle(child, parent, state, {
            before: "\n",
            after: "\n",
            ...tracker.current()
          })
        )
      );
      if (child.type !== "list") {
        state.bulletLastUsed = void 0;
      }
      if (index4 < children.length - 1) {
        results.push(
          tracker.move(between(child, children[index4 + 1], parent, state))
        );
      }
    }
    indexStack.pop();
    return results.join("");
  }
  function between(left, right, parent, state) {
    let index4 = state.join.length;
    while (index4--) {
      const result = state.join[index4](left, right, parent, state);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }

  // node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
  var eol = /\r?\n|\r/g;
  function indentLines(value, map4) {
    const result = [];
    let start2 = 0;
    let line = 0;
    let match;
    while (match = eol.exec(value)) {
      one3(value.slice(start2, match.index));
      result.push(match[0]);
      start2 = match.index + match[0].length;
      line++;
    }
    one3(value.slice(start2));
    return result.join("");
    function one3(value2) {
      result.push(map4(value2, line, !value2));
    }
  }

  // node_modules/mdast-util-to-markdown/lib/util/safe.js
  function safe(state, input, config) {
    const value = (config.before || "") + (input || "") + (config.after || "");
    const positions = [];
    const result = [];
    const infos = {};
    let index4 = -1;
    while (++index4 < state.unsafe.length) {
      const pattern = state.unsafe[index4];
      if (!patternInScope(state.stack, pattern)) {
        continue;
      }
      const expression = state.compilePattern(pattern);
      let match;
      while (match = expression.exec(value)) {
        const before = "before" in pattern || Boolean(pattern.atBreak);
        const after = "after" in pattern;
        const position4 = match.index + (before ? match[1].length : 0);
        if (positions.includes(position4)) {
          if (infos[position4].before && !before) {
            infos[position4].before = false;
          }
          if (infos[position4].after && !after) {
            infos[position4].after = false;
          }
        } else {
          positions.push(position4);
          infos[position4] = { before, after };
        }
      }
    }
    positions.sort(numerical);
    let start2 = config.before ? config.before.length : 0;
    const end = value.length - (config.after ? config.after.length : 0);
    index4 = -1;
    while (++index4 < positions.length) {
      const position4 = positions[index4];
      if (position4 < start2 || position4 >= end) {
        continue;
      }
      if (position4 + 1 < end && positions[index4 + 1] === position4 + 1 && infos[position4].after && !infos[position4 + 1].before && !infos[position4 + 1].after || positions[index4 - 1] === position4 - 1 && infos[position4].before && !infos[position4 - 1].before && !infos[position4 - 1].after) {
        continue;
      }
      if (start2 !== position4) {
        result.push(escapeBackslashes(value.slice(start2, position4), "\\"));
      }
      start2 = position4;
      if (/[!-/:-@[-`{-~]/.test(value.charAt(position4)) && (!config.encode || !config.encode.includes(value.charAt(position4)))) {
        result.push("\\");
      } else {
        result.push(
          "&#x" + value.charCodeAt(position4).toString(16).toUpperCase() + ";"
        );
        start2++;
      }
    }
    result.push(escapeBackslashes(value.slice(start2, end), config.after));
    return result.join("");
  }
  function numerical(a, b) {
    return a - b;
  }
  function escapeBackslashes(value, after) {
    const expression = /\\(?=[!-/:-@[-`{-~])/g;
    const positions = [];
    const results = [];
    const whole = value + after;
    let index4 = -1;
    let start2 = 0;
    let match;
    while (match = expression.exec(whole)) {
      positions.push(match.index);
    }
    while (++index4 < positions.length) {
      if (start2 !== positions[index4]) {
        results.push(value.slice(start2, positions[index4]));
      }
      results.push("\\");
      start2 = positions[index4];
    }
    results.push(value.slice(start2));
    return results.join("");
  }

  // node_modules/mdast-util-to-markdown/lib/util/track.js
  function track(config) {
    const options = config || {};
    const now = options.now || {};
    let lineShift = options.lineShift || 0;
    let line = now.line || 1;
    let column = now.column || 1;
    return { move, current: current2, shift };
    function current2() {
      return { now: { line, column }, lineShift };
    }
    function shift(value) {
      lineShift += value;
    }
    function move(input) {
      const value = input || "";
      const chunks = value.split(/\r?\n|\r/g);
      const tail = chunks[chunks.length - 1];
      line += chunks.length - 1;
      column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
      return value;
    }
  }

  // node_modules/mdast-util-to-markdown/lib/index.js
  function toMarkdown(tree, options = {}) {
    const state = {
      enter,
      indentLines,
      associationId: association,
      containerPhrasing: containerPhrasingBound,
      containerFlow: containerFlowBound,
      createTracker: track,
      compilePattern,
      safe: safeBound,
      stack: [],
      unsafe: [...unsafe],
      join: [...join3],
      // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
      // here.
      handlers: { ...handle },
      options: {},
      indexStack: [],
      // @ts-expect-error: add `handle` in a second.
      handle: void 0
    };
    configure2(state, options);
    if (state.options.tightDefinitions) {
      state.join.push(joinDefinition);
    }
    state.handle = zwitch("type", {
      invalid,
      unknown,
      handlers: state.handlers
    });
    let result = state.handle(tree, void 0, state, {
      before: "\n",
      after: "\n",
      now: { line: 1, column: 1 },
      lineShift: 0
    });
    if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
      result += "\n";
    }
    return result;
    function enter(name2) {
      state.stack.push(name2);
      return exit2;
      function exit2() {
        state.stack.pop();
      }
    }
  }
  function invalid(value) {
    throw new Error("Cannot handle value `" + value + "`, expected node");
  }
  function unknown(value) {
    const node3 = (
      /** @type {Nodes} */
      value
    );
    throw new Error("Cannot handle unknown node `" + node3.type + "`");
  }
  function joinDefinition(left, right) {
    if (left.type === "definition" && left.type === right.type) {
      return 0;
    }
  }
  function containerPhrasingBound(parent, info) {
    return containerPhrasing(parent, this, info);
  }
  function containerFlowBound(parent, info) {
    return containerFlow2(parent, this, info);
  }
  function safeBound(value, config) {
    return safe(this, value, config);
  }

  // node_modules/unist-util-lsp/lib/index.js
  function fromPlace(place) {
    if ("line" in place && "column" in place) {
      return {
        start: fromPoint(place),
        end: fromPoint(place)
      };
    }
    return fromPosition(place);
  }
  function fromPoint(point5) {
    return {
      character: point5.column ? point5.column - 1 : 0,
      line: point5.line ? point5.line - 1 : 0
    };
  }
  function fromPosition(unistPosition) {
    let end = unistPosition.end;
    if (!end || end.line == null || end.column == null) {
      end = unistPosition.start;
    }
    return {
      start: fromPoint(unistPosition.start),
      end: fromPoint(end)
    };
  }

  // node_modules/@mdx-js/language-service/lib/commands.js
  function createSyntaxToggle(context, type, separator) {
    return ({ range, uri }) => {
      const parsedUri = URI2.parse(uri);
      const sourceScript = context.language.scripts.get(parsedUri);
      const root2 = sourceScript?.generated?.root;
      if (!(root2 instanceof VirtualMdxCode)) {
        return;
      }
      const ast = root2.ast;
      if (!ast) {
        return;
      }
      const doc = context.documents.get(parsedUri, root2.languageId, root2.snapshot);
      const selectionStart = doc.offsetAt(range.start);
      const selectionEnd = doc.offsetAt(range.end);
      const edits = [];
      visitParents(ast, "text", (node3, ancestors) => {
        const nodeStart = getNodeStartOffset(node3);
        const nodeEnd = getNodeEndOffset(node3);
        if (selectionStart < nodeStart) {
          return;
        }
        if (selectionEnd > nodeEnd) {
          return;
        }
        const matchingAncestor = ancestors.find(
          (ancestor) => ancestor.type === type
        );
        if (matchingAncestor) {
          const ancestorStart = getNodeStartOffset(matchingAncestor);
          const ancestorEnd = getNodeEndOffset(matchingAncestor);
          const firstChildStart = getNodeStartOffset(matchingAncestor.children[0]);
          const lastChildEnd = getNodeEndOffset(
            /** @type {Nodes} */
            matchingAncestor.children.at(-1)
          );
          edits.push(
            {
              newText: "",
              range: {
                start: doc.positionAt(ancestorStart),
                end: doc.positionAt(firstChildStart)
              }
            },
            {
              newText: "",
              range: {
                start: doc.positionAt(lastChildEnd),
                end: doc.positionAt(ancestorEnd)
              }
            }
          );
        } else {
          const valueOffset = getNodeStartOffset(node3);
          let insertStart = valueOffset;
          let insertEnd = getNodeEndOffset(node3);
          for (const match of node3.value.matchAll(/\b/g)) {
            if (match.index === void 0) {
              continue;
            }
            const matchOffset = valueOffset + match.index;
            if (matchOffset <= selectionStart) {
              insertStart = matchOffset;
              continue;
            }
            if (matchOffset >= selectionEnd) {
              insertEnd = matchOffset;
              break;
            }
          }
          const startPosition = doc.positionAt(insertStart);
          const endPosition = doc.positionAt(insertEnd);
          edits.push(
            {
              newText: separator,
              range: { start: startPosition, end: startPosition }
            },
            {
              newText: separator,
              range: { start: endPosition, end: endPosition }
            }
          );
        }
      });
      if (edits) {
        return edits;
      }
    };
  }

  // node_modules/@mdx-js/language-service/lib/service-plugin.js
  var imageExtensions = /* @__PURE__ */ new Set([
    ".bmp",
    ".gif",
    ".ico",
    ".jpe",
    ".jpeg",
    ".jpg",
    ".png",
    ".psd",
    ".svg",
    ".tga",
    ".tif",
    ".tiff",
    ".webp"
  ]);
  function createMdxServicePlugin() {
    return {
      name: "mdx",
      capabilities: {
        diagnosticProvider: {}
      },
      create(context) {
        return {
          provide: {
            mdxCommands() {
              return {
                toggleDelete: createSyntaxToggle(context, "delete", "~"),
                toggleEmphasis: createSyntaxToggle(context, "emphasis", "_"),
                toggleInlineCode: createSyntaxToggle(context, "inlineCode", "`"),
                toggleStrong: createSyntaxToggle(context, "strong", "**")
              };
            }
          },
          async provideDocumentDropEdits(document5, position4, dataTransfer) {
            const documentUri = URI2.parse(document5.uri);
            let textItem;
            let uriListItem;
            for (const [mime, item] of dataTransfer) {
              if (mime === "text/plain") {
                textItem = item;
                continue;
              }
              if (mime === "text/uri-list") {
                uriListItem = item;
                continue;
              }
              if (!mime.startsWith("image/")) {
                continue;
              }
              const file = item.asFile();
              if (!file) {
                continue;
              }
              return {
                insertText: toMarkdown({ type: "image", url: file.name }).trim(),
                insertTextFormat: 1,
                createDataTransferFile: [
                  {
                    kind: "create",
                    uri: String(Utils.joinPath(documentUri, "..", file.name)),
                    contentsMimeType: mime,
                    options: {
                      ignoreIfExists: true
                    }
                  }
                ]
              };
            }
            if (uriListItem) {
              const value = await uriListItem.asString();
              const uris = value.split(/\r?\n/);
              const content3 = [];
              for (const line of uris) {
                try {
                  const uri = URI2.parse(line, true);
                  const value2 = uri.scheme === documentUri.scheme ? posix_default.relative(posix_default.dirname(documentUri.path), uri.path) : line;
                  content3.push(
                    toMarkdown(
                      imageExtensions.has(posix_default.extname(uri.path)) ? { type: "image", url: value2 } : { type: "text", value: value2 }
                    ).trim()
                  );
                } catch {
                  continue;
                }
              }
              return {
                insertText: content3.join(" "),
                insertTextFormat: 1
              };
            }
            if (textItem) {
              const string3 = await textItem.asString();
              return {
                insertText: string3,
                insertTextFormat: 1
              };
            }
          },
          provideSemanticDiagnostics(document5) {
            const decoded = context.decodeEmbeddedDocumentUri(
              URI2.parse(document5.uri)
            );
            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
            if (!(virtualCode instanceof VirtualMdxCode)) {
              return;
            }
            const error = virtualCode.error;
            if (error) {
              return [
                {
                  message: error.message,
                  code: error.source ? error.source + ":" + error.ruleId : error.ruleId,
                  codeDescription: {
                    href: error.url || "https://mdxjs.com/docs/troubleshooting-mdx/"
                  },
                  range: error.place ? fromPlace(error.place) : {
                    start: { line: 0, character: 0 },
                    end: { line: 0, character: 0 }
                  },
                  severity: 1,
                  source: "MDX"
                }
              ];
            }
          }
        };
      }
    };
  }

  // src/worker/mdx.worker.js
  var ts;
  var locale;
  self.onmessage = async (msg) => {
    if (msg.data?.event === "init") {
      locale = msg.data.tsLocale;
      ts = await importTsFromCdn(msg.data.tsVersion);
      self.postMessage("initted");
      return;
    }
    initialize((ctx, { tsconfig, dependencies }) => {
      const { options: compilerOptions } = ts.convertCompilerOptionsFromJson(
        tsconfig?.compilerOptions || {},
        ""
      );
      const asFileName = (uri) => uri.path;
      const asUri = (fileName) => URI2.file(fileName);
      const tsServicePlugins = (0, import_volar_service_typescript.create)(ts);
      return createTypeScriptWorkerService({
        env: {
          workspaceFolders: [URI2.file("/")],
          fs: (0, import_jsdelivr.createNpmFileSystem)(
            (uri) => {
              if (uri.scheme === "file") {
                if (uri.path === "/node_modules") {
                  return "";
                } else if (uri.path.startsWith("/node_modules/")) {
                  return uri.path.slice("/node_modules/".length);
                }
              }
            },
            (pkgName) => dependencies[pkgName],
            (path, content3) => {
              ctx.host.onFetchCdnFile(
                asUri("/node_modules/" + path).toString(),
                content3
              );
            }
          )
        },
        workerContext: ctx,
        uriConverter: {
          asFileName,
          asUri
        },
        typescript: ts,
        compilerOptions,
        languagePlugins: [
          createMdxLanguagePlugin()
        ],
        languageServicePlugins: [
          ...tsServicePlugins,
          createMdxServicePlugin()
        ],
        setup({ project }) {
          console.log(project);
        }
      });
    });
  };
  async function importTsFromCdn(tsVersion = "5.5.3") {
    const _module = globalThis.module;
    globalThis.module = { exports: {} };
    const tsUrl = `https://cdn.jsdelivr.net/npm/typescript@${tsVersion}/lib/typescript.js`;
    await import(tsUrl);
    const ts2 = globalThis.module.exports;
    globalThis.module = _module;
    return ts2;
  }
})();
/*! Bundled license information:

he/he.js:
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)
*/
//# sourceMappingURL=mdx.worker.js.map
